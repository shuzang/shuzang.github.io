<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>数据结构与算法 - 标签 - Shuzang's Blog</title><link>https://shuzang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>数据结构与算法 - 标签 - Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>liuyang8443@qq.com (Shuzang)</managingEditor><webMaster>liuyang8443@qq.com (Shuzang)</webMaster><lastBuildDate>Fri, 18 Sep 2020 20:37:00 +0800</lastBuildDate><atom:link href="https://shuzang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>算法-时间复杂度和空间复杂度</title><link>https://shuzang.github.io/2020/algorithm-time-and-space-complexity/</link><pubDate>Fri, 18 Sep 2020 20:37:00 +0800</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-time-and-space-complexity/</guid><description>&lt;p>时间和空间复杂度的分析是编制程序的一个基本能力，不过平时基本都是脑子里简单的估计，本篇文章打算回忆一下大 O 表示法和具体的时间复杂度的推导过程。&lt;/p></description></item><item><title>算法-字符串类问题</title><link>https://shuzang.github.io/2020/algorithm-stings/</link><pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-stings/</guid><description>做 Leetcode 每日一题的时候遇到了子串判断类的问题，想起一直没仔细的去看过 KMP 等字符串常用的算法，所以这里学习一下。 1. 重复的子字符串 这就是今天遇到的题目</description></item><item><title>算法-背包问题</title><link>https://shuzang.github.io/2020/algorithm-knapsack-problem/</link><pubDate>Thu, 06 Aug 2020 10:22:00 +0800</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-knapsack-problem/</guid><description>&lt;p>奇安信的笔试遇到了完全背包问题，结果写的时候按 0-1 背包写的贪心，最后没 AC，因此本篇对所有的背包问题做一次整理。&lt;/p></description></item><item><title>算法-分支限界</title><link>https://shuzang.github.io/2020/algorithm-branch-and-bound/</link><pubDate>Thu, 23 Jul 2020 10:07:00 +0800</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-branch-and-bound/</guid><description>&lt;p>分支限界和回溯都是有效搜索解空间树的方法，不同的是，分支限界使用广度优先或最小耗费/最大效益优先的方式。&lt;/p></description></item><item><title>算法-回溯</title><link>https://shuzang.github.io/2020/algorithm-backtracking/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-backtracking/</guid><description>在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Bra</description></item><item><title>算法-贪心</title><link>https://shuzang.github.io/2020/algorithm-greedu/</link><pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-greedu/</guid><description>&lt;p>贪心是一种策略，是一种总是寻求当前最优的策略。因为贪心只关心局部的最优，因此不是总能得到全局的最优解，所以我们选择贪心解决问题时必须保证状态的独立性，即当前最优值只与当前状态有关，不会影响以后的状态。&lt;/p></description></item><item><title>算法-动态规划</title><link>https://shuzang.github.io/2020/algorithm-dynamic-programming/</link><pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-dynamic-programming/</guid><description>&lt;p>动态规划策略通常用于求解最优化问题。在这类问题中，可能会有许多可行解，每个解对应一个值，我们希望找到具有最优值的那个解，也就是最优解。当题目中涉及「最大」「最小」等词时，很有可能就是这类问题，要考虑是否可用动态规划求解。&lt;/p></description></item><item><title>算法-分治</title><link>https://shuzang.github.io/2020/algorithm-divide-and-conquer/</link><pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-divide-and-conquer/</guid><description>分治，字面意思就是分而治之，意思就是把一个复杂的问题分成两个或更多个相同或相似的子问题，解决子问题后再进行合并。典型的如归并排序和快排，都是</description></item><item><title>算法-递归</title><link>https://shuzang.github.io/2020/algorithm-recursive/</link><pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-recursive/</guid><description><![CDATA[<p>首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。</p>
<ol>
<li>递归是一种编程技巧，一种解决问题的思维方式；</li>
<li>分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）；</li>
<li>贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。</li>
</ol>]]></description></item><item><title>算法-排序</title><link>https://shuzang.github.io/2020/algorithm-sort/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><author>Shuzang</author><guid>https://shuzang.github.io/2020/algorithm-sort/</guid><description>排序算法分为内部排序（待排序记录存放在内存中进行的排序过程）和外部排序（由于待排序记录数量大，以致内存一次不能容纳全部记录，在排序过程中需要</description></item></channel></rss>