<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Golang语法基础7-函数 - Shuzang's Blog</title><meta name=Description content="书藏的个人博客，记录学习，记录生活"><meta property="og:title" content="Golang语法基础7-函数"><meta property="og:description" content="1. 函数声明与定义 Go中有三种类型的函数： 普通的带有名字的函数 匿名函数 方法（Methods，在结构体部分介绍） 普通函数声明的基本格式为 1 func functionName(param1 type1,"><meta property="og:type" content="article"><meta property="og:url" content="https://shuzang.github.io/2019/golang-syntax-7-function/"><meta property="og:image" content="https://shuzang.github.io/logo.png"><meta property="article:published_time" content="2019-11-25T00:00:00+00:00"><meta property="article:modified_time" content="2020-06-16T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shuzang.github.io/logo.png"><meta name=twitter:title content="Golang语法基础7-函数"><meta name=twitter:description content="1. 函数声明与定义 Go中有三种类型的函数： 普通的带有名字的函数 匿名函数 方法（Methods，在结构体部分介绍） 普通函数声明的基本格式为 1 func functionName(param1 type1,"><meta name=application-name content="Shuzang's Blog"><meta name=apple-mobile-web-app-title content="Shuzang's Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://shuzang.github.io/2019/golang-syntax-7-function/><link rel=prev href=https://shuzang.github.io/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/><link rel=next href=https://shuzang.github.io/2019/articles-about-blockchain/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang语法基础7-函数","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2019\/golang-syntax-7-function\/"},"image":["https:\/\/shuzang.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"Go语法","wordcount":3919,"url":"https:\/\/shuzang.github.io\/2019\/golang-syntax-7-function\/","datePublished":"2019-11-25T00:00:00+00:00","dateModified":"2020-06-16T00:00:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/shuzang.github.io\/images\/avatar.png"},"author":{"@type":"Person","name":"Shuzang"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Shuzang's Blog">Shuzang's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=https://github.com/shuzang title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item language" title=选择语言>简体中文<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select id=language-select-desktop onchange="location=this.value;"><option value=/2019/golang-syntax-7-function/ selected>简体中文</option></select>
</a><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shuzang's Blog">Shuzang's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>所有文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/about/>关于</a><a class=menu-item href=https://github.com/shuzang title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a><a href=javascript:void(0); class=menu-item title=选择语言>简体中文<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select onchange="location=this.value;"><option value=/2019/golang-syntax-7-function/ selected>简体中文</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Golang语法基础7-函数</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>Shuzang</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/><i class="far fa-folder fa-fw"></i>Golang学习之路</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2019-11-25>2019-11-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3919 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 8 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-函数声明与定义>1. 函数声明与定义</a></li><li><a href=#2-函数调用>2. 函数调用</a></li><li><a href=#3-函数参数与返回值>3. 函数参数与返回值</a><ul><li><a href=#31-参数传递类型>3.1 参数传递类型</a></li><li><a href=#32-命名参数>3.2 命名参数</a></li><li><a href=#33-空白符>3.3 空白符</a></li><li><a href=#34-变长参数>3.4 变长参数</a></li><li><a href=#35-函数作为参数>3.5 函数作为参数</a></li></ul></li><li><a href=#4-内置函数>4. 内置函数</a></li><li><a href=#5-匿名函数与闭包>5. 匿名函数与闭包</a></li><li><a href=#6-defer和追踪>6. defer和追踪</a></li><li><a href=#7-编写规范>7. 编写规范</a></li></ul></nav></div></div><div class=content id=content><h2 id=1-函数声明与定义>1. 函数声明与定义</h2><p>Go中有三种类型的函数：</p><ol><li>普通的带有名字的函数</li><li>匿名函数</li><li>方法（Methods，在结构体部分介绍）</li></ol><p>普通函数声明的基本格式为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>functionName</span><span class=p>(</span><span class=nx>param1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>param2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>ret2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>定义就需要添加大括号和函数体</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>functionName</span><span class=p>(</span><span class=nx>param1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>param2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>ret2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>{</span>
    <span class=o>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>两个括号中分别为参数列表和返回值列表，参数个数和返回值个数允许为0。左大括号必须与声明语句在同一行，流程控制部分已经见过这个规定，这是编译器强制规定。</p><p>当函数执行到代码块最后一行，也就是最后一个<code>}</code>之前，或者执行到<code>return</code>语句的时候就会退出。</p><p>main函数是每个程序必须包含的，一般来说是启动后第一个执行的函数，但如果有init()函数会先执行该函数。</p><p>main函数既没有参数，也没有返回值，如果添加了两者中任一者，都会引发构建错误。main函数一旦返回就表示程序已成功执行并立即退出。同样，init()函数也没有返回值</p><h2 id=2-函数调用>2. 函数调用</h2><p>同一个包内，可以直接使用函数名调用该函数，不同包内，需要添加包名，如下所示</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>pack1</span><span class=p>.</span><span class=nf>functionName</span><span class=p>(</span><span class=nx>arg1</span><span class=p>,</span> <span class=nx>arg2</span><span class=p>,</span> <span class=o>...</span><span class=p>,</span> <span class=nx>argn</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p><code>pack1</code>是包名，<code>functionName</code>是该包中的一个函数，括号里是传入的实参。一个简单的调用其它函数的例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In main before calling greeting&#34;</span><span class=p>)</span>
    <span class=nf>greeting</span><span class=p>(</span><span class=p>)</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In main after calling greeting&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>greeting</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In greeting: Hi!!!!!&#34;</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>In</span> <span class=nx>main</span> <span class=nx>before</span> <span class=nx>calling</span> <span class=nx>greeting</span>
<span class=nx>In</span> <span class=nx>greeting</span><span class=p>:</span> <span class=nx>Hi</span><span class=p>!</span><span class=p>!</span><span class=p>!</span><span class=p>!</span><span class=p>!</span>
<span class=nx>In</span> <span class=nx>main</span> <span class=nx>after</span> <span class=nx>calling</span> <span class=nx>greeting</span>
</code></pre></td></tr></table></div></div><p>Go中不允许函数重载</p><h2 id=3-函数参数与返回值>3. 函数参数与返回值</h2><p>除了mian()和init()函数外，其它函数都可以拥有参数和返回值。而且任意一个有返回值的函数都必须以<code>return</code>或<code>panic</code>语句结尾，<code>return</code>可以返回多个值，多值返回是Go的一大特性。</p><h3 id=31-参数传递类型>3.1 参数传递类型</h3><p>Go中的参数传递类型有两种：按值传递和按引用传递。</p><p>Go默认使用按值传递来传递参数，也就是传递参数的副本，因此参数在函数中被更改后不会影响原值。如果希望函数运行的同时改变原变量的值，应该添加取地址符&，传递变量的指针，也就是按引用传递，按引用传递时，传入的是指针的副本，但指向的值依然是原变量。</p><p>函数调用时，切片、映射、接口、通道这些引用类型默认使用按引用传递</p><p>几乎在任何情况下，按引用传递的消耗都比按值传递小</p><p>按引用传递可以直接修改外部变量的值，因此被修改的变量不再需要使用<code>return</code>返回</p><h3 id=32-命名参数>3.2 命名参数</h3><p>函数定义时，形参一般都有名字，不过也可以定义没有形参名的函数，只有形参类型，比如<code>func f(int, int, float64)</code>，返回值同样如此。只有类型的返回值称为非命名返回值，有名字的返回值称为命名返回值。一个例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>var</span> <span class=nx>num</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>10</span>
<span class=kd>var</span> <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=kt>int</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=p>=</span> <span class=nf>getX2AndX3</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
    <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span>
    <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=p>=</span> <span class=nf>getX2AndX3_2</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
    <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;num = %d, 2x num = %d, 3x num = %d\n&#34;</span><span class=p>,</span> <span class=nx>num</span><span class=p>,</span> <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>getX2AndX3</span><span class=p>(</span><span class=nx>input</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>input</span><span class=p>,</span> <span class=mi>3</span> <span class=o>*</span> <span class=nx>input</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>getX2AndX3_2</span><span class=p>(</span><span class=nx>input</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>x2</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>x3</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>x2</span> <span class=p>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>input</span>
    <span class=nx>x3</span> <span class=p>=</span> <span class=mi>3</span> <span class=o>*</span> <span class=nx>input</span>
    <span class=c1>// return x2, x3
</span><span class=c1></span>    <span class=k>return</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>num</span> <span class=p>=</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>2</span><span class=nx>x</span> <span class=nx>num</span> <span class=p>=</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>3</span><span class=nx>x</span> <span class=nx>num</span> <span class=p>=</span> <span class=mi>30</span>    
<span class=nx>num</span> <span class=p>=</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>2</span><span class=nx>x</span> <span class=nx>num</span> <span class=p>=</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>3</span><span class=nx>x</span> <span class=nx>num</span> <span class=p>=</span> <span class=mi>30</span> 
</code></pre></td></tr></table></div></div><p>命名返回值会被初始化为相应类型的零值，返回时只需要一条简单的不带参数的return语句（带参数也不会出错）。</p><p>当需要返回多个非命名返回值时，需要使用括号包围，如<code>(int, int)</code>，但对命名返回值，即使只有一个返回值，也要用括号包围。</p><h3 id=33-空白符>3.3 空白符</h3><p>空白符<code>_</code>用来匹配不需要的返回值，然后丢弃掉，之前已经介绍过。</p><h3 id=34-变长参数>3.4 变长参数</h3><p>如果函数最后一个参数是<code>...type</code>的形式，那么函数就可以处理一个变长的参数，这个长度可以是0，这样的函数称为变参函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>myFunc</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>arg</span> <span class=o>...</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>变长参数的本质是一个切片，如下例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>Greeting</span><span class=p>(</span><span class=nx>prefix</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>who</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span>
<span class=nf>Greeting</span><span class=p>(</span><span class=s>&#34;hello:&#34;</span><span class=p>,</span> <span class=s>&#34;Joe&#34;</span><span class=p>,</span> <span class=s>&#34;Anna&#34;</span><span class=p>,</span> <span class=s>&#34;Eileen&#34;</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>变量<code>who</code>的值为 <code>[]string{"Joe", "Anna", "Eileen"}</code></p><p>如果参数本身就存在一个切片类型中，比如切片<code>slice1</code>，则可以通过<code>slice1...</code>的形式传递参数，之前的切片部分使用append函数时已经这样使用过</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>x</span> <span class=o>:=</span> <span class=nf>min</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The minimum is: %d\n&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
	<span class=nx>slice</span> <span class=o>:=</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>7</span><span class=p>,</span><span class=mi>9</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>1</span><span class=p>}</span>
	<span class=nx>x</span> <span class=p>=</span> <span class=nf>min</span><span class=p>(</span><span class=nx>slice</span><span class=o>...</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The minimum in the slice is: %d&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>min</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>==</span><span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span>
	<span class=p>}</span>
	<span class=nx>min</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>v</span> <span class=p>&lt;</span> <span class=nx>min</span> <span class=p>{</span>
			<span class=nx>min</span> <span class=p>=</span> <span class=nx>v</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>min</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>The</span> <span class=nx>minimum</span> <span class=nx>is</span><span class=p>:</span> <span class=mi>0</span>
<span class=nx>The</span> <span class=nx>minimum</span> <span class=nx>in</span> <span class=nx>the</span> <span class=nx>slice</span> <span class=nx>is</span><span class=p>:</span> <span class=mi>1</span>
</code></pre></td></tr></table></div></div><p>一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>F1</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>F2</span><span class=p>(</span><span class=nx>s</span><span class=o>...</span><span class=p>)</span>
	<span class=nf>F3</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>F2</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
<span class=kd>func</span> <span class=nf>F3</span><span class=p>(</span><span class=nx>s</span> <span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=35-函数作为参数>3.5 函数作为参数</h3><p>函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，只要函数返回值个数、返回值类型和返回值顺序同调用函数的形参列表定义相同，称之为回调。下面是一个将函数作为参数的简单例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
	<span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>callback</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nx>Add</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The sum of %d and %d is: %d\n&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>a</span><span class=o>+</span><span class=nx>b</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>callback</span><span class=p>(</span><span class=nx>y</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>f</span><span class=p>(</span><span class=nx>y</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=c1>// this becomes Add(1, 2)
</span><span class=c1></span><span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>The</span> <span class=nx>sum</span> <span class=nx>of</span> <span class=mi>1</span> <span class=nx>and</span> <span class=mi>2</span> <span class=nx>is</span><span class=p>:</span> <span class=mi>3</span>
</code></pre></td></tr></table></div></div><h2 id=4-内置函数>4. 内置函数</h2><p>Go语言拥有一些不需要导入就可以使用的内置函数，之前已经接触过一些，比如len, cap, append，以下是内置函数列表</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td>new、make</td><td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作</td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数，在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real imag</td><td>用于创建和操作复数</td></tr></tbody></table><h2 id=5-匿名函数与闭包>5. 匿名函数与闭包</h2><p>匿名函数是类似 <code>func(x, y int) int { return x + y }</code> 这样没有名字的函数。</p><p>匿名函数可以被直接调用，下面是一个计算从 1 到 1 百万整数的总和的匿名函数。表示参数列表的第一对括号必须紧挨着关键字 <code>func</code>，因为匿名函数没有名称。花括号 <code>{}</code> 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>sum</span> <span class=o>:=</span> <span class=mi>0</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=mf>1e6</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>sum</span> <span class=o>+=</span> <span class=nx>i</span>
	<span class=p>}</span>
<span class=p>}</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>另外，匿名函数可以像其它函数一样接受参数，下例展示了如何传递参数到匿名函数中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>u</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
	<span class=err>…</span>
<span class=p>}</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>还应该知道的，匿名函数可以被赋值给某个变量，如<code>fplus := func(x, y int) int { return x + y }</code>，这样函数的地址就保存到了变量中，之后可以通过变量名对函数进行调用：<code>fplus(3, 4)</code></p><p>所谓闭包就是函数及其引用环境的组合，这么说比较难理解，举个例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
        <span class=nx>i</span><span class=o>++</span>
        <span class=k>return</span> <span class=nx>i</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>在这里例子里，返回值是一个函数，这个函数本身没有定义变量，而是引用了它所在环境的变量 i，这就形成了一个闭包。从这里可以看出，闭包与匿名函数息息相关，因为匿名函数被用作函数返回值非常合适。下面是一个完整的例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>f</span> <span class=p>=</span> <span class=nf>Adder</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>,</span> <span class=s>&#34; - &#34;</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=p>,</span> <span class=s>&#34; - &#34;</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>300</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Adder</span><span class=p>(</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>x</span> <span class=kt>int</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>delta</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
		<span class=nx>x</span> <span class=o>+=</span> <span class=nx>delta</span>
		<span class=k>return</span> <span class=nx>x</span>
	<span class=p>}</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=mi>1</span> <span class=o>-</span> <span class=mi>21</span> <span class=o>-</span> <span class=mi>321</span>
</code></pre></td></tr></table></div></div><p>从这里例子中我们注意到 x 的值是不断累加的，这也就意味着闭包函数其实会保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 这里可以理解为函数被赋值给 f 之后，其实将整个闭包包括环境都赋值给了 f，变量 f 的生存周期内，其值是不变的，所以结果才会累积。</p><p>这种返回值为另一个函数的函数的形式也被称之为工厂函数，在需要创建一系列相似的函数的时候非常有用。下面的函数演示了如何动态返回追加后缀的函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=nx>suffix</span> <span class=kt>string</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
		<span class=k>if</span> <span class=p>!</span><span class=nx>strings</span><span class=p>.</span><span class=nf>HasSuffix</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>suffix</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>name</span> <span class=o>+</span> <span class=nx>suffix</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=nx>name</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>现在可以生成如下函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>addBmp</span> <span class=o>:=</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=s>&#34;.bmp&#34;</span><span class=p>)</span>
<span class=nx>addJpeg</span> <span class=o>:=</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=s>&#34;.jpeg&#34;</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>然后调用它们</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nf>addBmp</span><span class=p>(</span><span class=s>&#34;file&#34;</span><span class=p>)</span> <span class=c1>// returns: file.bmp
</span><span class=c1></span><span class=nf>addJpeg</span><span class=p>(</span><span class=s>&#34;file&#34;</span><span class=p>)</span> <span class=c1>// returns: file.jpeg
</span></code></pre></td></tr></table></div></div><h2 id=6-defer和追踪>6. defer和追踪</h2><p>关键字 defer 是 Go 中一个非常有用的特性，作用是将某个语句或函数推迟到函数返回之前执行。准确的说，defer 的执行时机有三种：</p><ol><li>包含 defer 语句的函数返回前</li><li>包含 defer 语句的函数执行到末尾</li><li>所在的 goroutine 发生 panic 时</li></ol><p>一个例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Fourth&#34;</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;First&#34;</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Third&#34;</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>First</span>
<span class=nx>Third</span>
<span class=nx>Fourth</span>
</code></pre></td></tr></table></div></div><p>defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，如下例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span>
<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Deferred print:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
<span class=nx>i</span><span class=o>++</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Normal print:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=nx>Normal</span> <span class=nx>print</span><span class=p>:</span> <span class=mi>2</span>
<span class=nx>Deferred</span> <span class=nx>print</span><span class=p>:</span> <span class=mi>1</span>
</code></pre></td></tr></table></div></div><p>但与匿名函数结合起来后，变量的值在函数运行时才会确定</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f1</span><span class=p>(</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=mi>1</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span><span class=o>++</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=mi>2</span>
    <span class=k>return</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nf>f1</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=mi>3</span>
</code></pre></td></tr></table></div></div><p>上例中出现了 return 语句，defer 与 return 的执行顺序比较复杂，这里要先理解两件事</p><ol><li>defer 函数执行时机是外层函数设置返回值之后，即将返回之前</li><li>return xxx 操作并不是原子的</li></ol><p>下面的例子中， return 0 实际上可以拆分为 r = 0; return 两条语句，因此输出是1不是0</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f1</span><span class=p>(</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span><span class=o>++</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span> <span class=mi>0</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>f1</span><span class=p>(</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>来一个更复杂的例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>x</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>triple</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span> <span class=o>+=</span> <span class=nx>x</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>triple</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=mi>9</span>
</code></pre></td></tr></table></div></div><p>上面的例子实际上等价于</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>triple</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
    <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span> <span class=o>+=</span> <span class=nx>x</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>多个 defer 同时使用时，以逆序执行，即后进先出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
	<span class=p>}</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=mi>4</span> <span class=mi>3</span> <span class=mi>2</span> <span class=mi>1</span> <span class=mi>0</span>
</code></pre></td></tr></table></div></div><p>defer 关键字一般用于释放某些已分配的资源或在函数执行完进行一些收尾工作，比如</p><ol><li><p>关闭文件流</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//open a file
</span><span class=c1></span><span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>解锁一个加锁的资源</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>(</span><span class=p>)</span>
<span class=k>defer</span> <span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>打印最终报告</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nf>printHeader</span><span class=p>(</span><span class=p>)</span>
<span class=k>defer</span> <span class=nf>printFooter</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>关闭数据库链接</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//open a database connection
</span><span class=c1></span><span class=k>defer</span> <span class=nf>disconnectFromDB</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li></ol><h2 id=7-编写规范>7. 编写规范</h2><p>Go是编译型的语言，因此函数的编写顺序无关紧要，但鉴于可读性的需求，最好遵循一定的编程规范，我这里采用的是Uber开源在github的编码规范，有两条主要规则</p><ol><li><p>函数应按粗略的调用顺序排序</p></li><li><p>同一文件中的函数应按接收者排序，意即可被外部访问的函数（参考可见性规则）应放在前面，普通工具函数放在后面。另外，在类型定义（结构体、接口等）后，可被外部访问的函数前，可能会出现类似于<code>newXYZ()</code>这样的新建某个类型的函数。一个简单的例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>something</span> <span class=kd>struct</span><span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
   
<span class=kd>func</span> <span class=nf>newSomething</span><span class=p>(</span><span class=p>)</span> <span class=o>*</span><span class=nx>something</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>something</span><span class=p>{</span><span class=p>}</span>
<span class=p>}</span>
   
<span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>something</span><span class=p>)</span> <span class=nf>Cost</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nf>calcCost</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>weights</span><span class=p>)</span>
<span class=p>}</span>
   
<span class=kd>func</span> <span class=nf>calcCost</span><span class=p>(</span><span class=nx>n</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span><span class=o>...</span><span class=p>}</span>
</code></pre></td></tr></table></div></div></li></ol><p>最后，main函数放在所有函数的最后。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2020-06-16</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/2019/golang-syntax-7-function/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://shuzang.github.io/2019/golang-syntax-7-function/ data-title=Golang语法基础7-函数 data-hashtags=Go语法><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://shuzang.github.io/2019/golang-syntax-7-function/ data-hashtag=Go语法><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://shuzang.github.io/2019/golang-syntax-7-function/ data-title=Golang语法基础7-函数><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://shuzang.github.io/2019/golang-syntax-7-function/ data-title=Golang语法基础7-函数><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://shuzang.github.io/2019/golang-syntax-7-function/ data-title=Golang语法基础7-函数><i class="fab fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/go%E8%AF%AD%E6%B3%95/>Go语法</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/ class=prev rel=prev title=医药健康3-医保及就医><i class="fas fa-angle-left fa-fw"></i>医药健康3-医保及就医</a>
<a href=/2019/articles-about-blockchain/ class=next rel=next title=区块链方向有参考价值的文章收集>区块链方向有参考价值的文章收集<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.63.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Shuzang</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.8/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>