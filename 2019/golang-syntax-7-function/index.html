<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Golang语法基础7-函数 | Shuzang's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="书藏的个人博客，包括Golang、数据结构、算法的学习记录，各类生活技能的学习，每周五发布一期自己的生活周刊"><link rel=prev href=https://shuzang.github.io/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/><link rel=next href=https://shuzang.github.io/2019/articles-about-blockchain/><link rel=canonical href=https://shuzang.github.io/2019/golang-syntax-7-function/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang语法基础7-函数"><meta name=twitter:description content="1. 函数声明与定义 Go中有三种类型的函数： 普通的带有名字的函数 匿名函数 方法（Methods，在结构体部分介绍） 普通函数声明的基本格式为 1 func functionName(param1 type1,"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang语法基础7-函数","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2019\/golang-syntax-7-function\/"},"image":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Go语法","wordcount":3919,"url":"https:\/\/shuzang.github.io\/2019\/golang-syntax-7-function\/","datePublished":"2019-11-25T00:00:00\x2b00:00","dateModified":"2020-06-16T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"shuzang","logo":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://shuzang.github.io>Shuzang's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">Golang语法基础7-函数</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2019-11-25>2019-11-25</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 3919 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://shuzang.github.io/categories/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/>Golang学习之路</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1-函数声明与定义>1. 函数声明与定义</a></li><li><a href=#2-函数调用>2. 函数调用</a></li><li><a href=#3-函数参数与返回值>3. 函数参数与返回值</a><ul><li><a href=#31-参数传递类型>3.1 参数传递类型</a></li><li><a href=#32-命名参数>3.2 命名参数</a></li><li><a href=#33-空白符>3.3 空白符</a></li><li><a href=#34-变长参数>3.4 变长参数</a></li><li><a href=#35-函数作为参数>3.5 函数作为参数</a></li></ul></li><li><a href=#4-内置函数>4. 内置函数</a></li><li><a href=#5-匿名函数与闭包>5. 匿名函数与闭包</a></li><li><a href=#6-defer和追踪>6. defer和追踪</a></li><li><a href=#7-编写规范>7. 编写规范</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#1-函数声明与定义>1. 函数声明与定义</a></li><li><a href=#2-函数调用>2. 函数调用</a></li><li><a href=#3-函数参数与返回值>3. 函数参数与返回值</a><ul><li><a href=#31-参数传递类型>3.1 参数传递类型</a></li><li><a href=#32-命名参数>3.2 命名参数</a></li><li><a href=#33-空白符>3.3 空白符</a></li><li><a href=#34-变长参数>3.4 变长参数</a></li><li><a href=#35-函数作为参数>3.5 函数作为参数</a></li></ul></li><li><a href=#4-内置函数>4. 内置函数</a></li><li><a href=#5-匿名函数与闭包>5. 匿名函数与闭包</a></li><li><a href=#6-defer和追踪>6. defer和追踪</a></li><li><a href=#7-编写规范>7. 编写规范</a></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=1-函数声明与定义></a><h2>1. 函数声明与定义</h2><p>Go中有三种类型的函数：</p><ol><li>普通的带有名字的函数</li><li>匿名函数</li><li>方法（Methods，在结构体部分介绍）</li></ol><p>普通函数声明的基本格式为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>functionName</span><span class=p>(</span><span class=nx>param1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>param2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>ret2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>定义就需要添加大括号和函数体</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>functionName</span><span class=p>(</span><span class=nx>param1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>param2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret1</span> <span class=nx>type1</span><span class=p>,</span> <span class=nx>ret2</span> <span class=nx>type2</span><span class=p>,</span><span class=o>...</span><span class=p>)</span> <span class=p>{</span>
    <span class=o>...</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>两个括号中分别为参数列表和返回值列表，参数个数和返回值个数允许为0。左大括号必须与声明语句在同一行，流程控制部分已经见过这个规定，这是编译器强制规定。</p><p>当函数执行到代码块最后一行，也就是最后一个<code>}</code>之前，或者执行到<code>return</code>语句的时候就会退出。</p><p>main函数是每个程序必须包含的，一般来说是启动后第一个执行的函数，但如果有init()函数会先执行该函数。</p><p>main函数既没有参数，也没有返回值，如果添加了两者中任一者，都会引发构建错误。main函数一旦返回就表示程序已成功执行并立即退出。同样，init()函数也没有返回值</p><a class=post-dummy-target id=2-函数调用></a><h2>2. 函数调用</h2><p>同一个包内，可以直接使用函数名调用该函数，不同包内，需要添加包名，如下所示</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>pack1</span><span class=p>.</span><span class=nf>functionName</span><span class=p>(</span><span class=nx>arg1</span><span class=p>,</span> <span class=nx>arg2</span><span class=p>,</span> <span class=o>...</span><span class=p>,</span> <span class=nx>argn</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p><code>pack1</code>是包名，<code>functionName</code>是该包中的一个函数，括号里是传入的实参。一个简单的调用其它函数的例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In main before calling greeting&#34;</span><span class=p>)</span>
    <span class=nf>greeting</span><span class=p>(</span><span class=p>)</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In main after calling greeting&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>greeting</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nb>println</span><span class=p>(</span><span class=s>&#34;In greeting: Hi!!!!!&#34;</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>In</span> <span class=nx>main</span> <span class=nx>before</span> <span class=nx>calling</span> <span class=nx>greeting</span>
<span class=nx>In</span> <span class=nx>greeting</span><span class=p>:</span> <span class=nx>Hi</span><span class=p>!</span><span class=p>!</span><span class=p>!</span><span class=p>!</span><span class=p>!</span>
<span class=nx>In</span> <span class=nx>main</span> <span class=nx>after</span> <span class=nx>calling</span> <span class=nx>greeting</span>
</code></pre></td></tr></table></div></div><p>Go中不允许函数重载</p><a class=post-dummy-target id=3-函数参数与返回值></a><h2>3. 函数参数与返回值</h2><p>除了mian()和init()函数外，其它函数都可以拥有参数和返回值。而且任意一个有返回值的函数都必须以<code>return</code>或<code>panic</code>语句结尾，<code>return</code>可以返回多个值，多值返回是Go的一大特性。</p><a class=post-dummy-target id=31-参数传递类型></a><h3>3.1 参数传递类型</h3><p>Go中的参数传递类型有两种：按值传递和按引用传递。</p><p>Go默认使用按值传递来传递参数，也就是传递参数的副本，因此参数在函数中被更改后不会影响原值。如果希望函数运行的同时改变原变量的值，应该添加取地址符&，传递变量的指针，也就是按引用传递，按引用传递时，传入的是指针的副本，但指向的值依然是原变量。</p><p>函数调用时，切片、映射、接口、通道这些引用类型默认使用按引用传递</p><p>几乎在任何情况下，按引用传递的消耗都比按值传递小</p><p>按引用传递可以直接修改外部变量的值，因此被修改的变量不再需要使用<code>return</code>返回</p><a class=post-dummy-target id=32-命名参数></a><h3>3.2 命名参数</h3><p>函数定义时，形参一般都有名字，不过也可以定义没有形参名的函数，只有形参类型，比如<code>func f(int, int, float64)</code>，返回值同样如此。只有类型的返回值称为非命名返回值，有名字的返回值称为命名返回值。一个例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>var</span> <span class=nx>num</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>10</span>
<span class=kd>var</span> <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=kt>int</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=p>=</span> <span class=nf>getX2AndX3</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
    <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span>
    <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span> <span class=p>=</span> <span class=nf>getX2AndX3_2</span><span class=p>(</span><span class=nx>num</span><span class=p>)</span>
    <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>PrintValues</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;num = %d, 2x num = %d, 3x num = %d\n&#34;</span><span class=p>,</span> <span class=nx>num</span><span class=p>,</span> <span class=nx>numx2</span><span class=p>,</span> <span class=nx>numx3</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>getX2AndX3</span><span class=p>(</span><span class=nx>input</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>input</span><span class=p>,</span> <span class=mi>3</span> <span class=o>*</span> <span class=nx>input</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>getX2AndX3_2</span><span class=p>(</span><span class=nx>input</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>x2</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>x3</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>x2</span> <span class=p>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>input</span>
    <span class=nx>x3</span> <span class=p>=</span> <span class=mi>3</span> <span class=o>*</span> <span class=nx>input</span>
    <span class=c1>// return x2, x3
</span><span class=c1></span>    <span class=k>return</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>num</span> <span class=p>=</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>2</span><span class=nx>x</span> <span class=nx>num</span> <span class=p>=</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>3</span><span class=nx>x</span> <span class=nx>num</span> <span class=p>=</span> <span class=mi>30</span>    
<span class=nx>num</span> <span class=p>=</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>2</span><span class=nx>x</span> <span class=nx>num</span> <span class=p>=</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>3</span><span class=nx>x</span> <span class=nx>num</span> <span class=p>=</span> <span class=mi>30</span> 
</code></pre></td></tr></table></div></div><p>命名返回值会被初始化为相应类型的零值，返回时只需要一条简单的不带参数的return语句（带参数也不会出错）。</p><p>当需要返回多个非命名返回值时，需要使用括号包围，如<code>(int, int)</code>，但对命名返回值，即使只有一个返回值，也要用括号包围。</p><a class=post-dummy-target id=33-空白符></a><h3>3.3 空白符</h3><p>空白符<code>_</code>用来匹配不需要的返回值，然后丢弃掉，之前已经介绍过。</p><a class=post-dummy-target id=34-变长参数></a><h3>3.4 变长参数</h3><p>如果函数最后一个参数是<code>...type</code>的形式，那么函数就可以处理一个变长的参数，这个长度可以是0，这样的函数称为变参函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>myFunc</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>arg</span> <span class=o>...</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>变长参数的本质是一个切片，如下例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>Greeting</span><span class=p>(</span><span class=nx>prefix</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>who</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span>
<span class=nf>Greeting</span><span class=p>(</span><span class=s>&#34;hello:&#34;</span><span class=p>,</span> <span class=s>&#34;Joe&#34;</span><span class=p>,</span> <span class=s>&#34;Anna&#34;</span><span class=p>,</span> <span class=s>&#34;Eileen&#34;</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>变量<code>who</code>的值为 <code>[]string{"Joe", "Anna", "Eileen"}</code></p><p>如果参数本身就存在一个切片类型中，比如切片<code>slice1</code>，则可以通过<code>slice1...</code>的形式传递参数，之前的切片部分使用append函数时已经这样使用过</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>x</span> <span class=o>:=</span> <span class=nf>min</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The minimum is: %d\n&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
	<span class=nx>slice</span> <span class=o>:=</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>7</span><span class=p>,</span><span class=mi>9</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>1</span><span class=p>}</span>
	<span class=nx>x</span> <span class=p>=</span> <span class=nf>min</span><span class=p>(</span><span class=nx>slice</span><span class=o>...</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The minimum in the slice is: %d&#34;</span><span class=p>,</span> <span class=nx>x</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>min</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>==</span><span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span>
	<span class=p>}</span>
	<span class=nx>min</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>v</span> <span class=p>&lt;</span> <span class=nx>min</span> <span class=p>{</span>
			<span class=nx>min</span> <span class=p>=</span> <span class=nx>v</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>min</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>The</span> <span class=nx>minimum</span> <span class=nx>is</span><span class=p>:</span> <span class=mi>0</span>
<span class=nx>The</span> <span class=nx>minimum</span> <span class=nx>in</span> <span class=nx>the</span> <span class=nx>slice</span> <span class=nx>is</span><span class=p>:</span> <span class=mi>1</span>
</code></pre></td></tr></table></div></div><p>一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>F1</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>F2</span><span class=p>(</span><span class=nx>s</span><span class=o>...</span><span class=p>)</span>
	<span class=nf>F3</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>F2</span><span class=p>(</span><span class=nx>s</span> <span class=o>...</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
<span class=kd>func</span> <span class=nf>F3</span><span class=p>(</span><span class=nx>s</span> <span class=p>[</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=35-函数作为参数></a><h3>3.5 函数作为参数</h3><p>函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，只要函数返回值个数、返回值类型和返回值顺序同调用函数的形参列表定义相同，称之为回调。下面是一个将函数作为参数的简单例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>
	<span class=s>&#34;fmt&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>callback</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nx>Add</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;The sum of %d and %d is: %d\n&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>a</span><span class=o>+</span><span class=nx>b</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>callback</span><span class=p>(</span><span class=nx>y</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>f</span><span class=p>(</span><span class=nx>y</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=c1>// this becomes Add(1, 2)
</span><span class=c1></span><span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>The</span> <span class=nx>sum</span> <span class=nx>of</span> <span class=mi>1</span> <span class=nx>and</span> <span class=mi>2</span> <span class=nx>is</span><span class=p>:</span> <span class=mi>3</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=4-内置函数></a><h2>4. 内置函数</h2><p>Go语言拥有一些不需要导入就可以使用的内置函数，之前已经接触过一些，比如len, cap, append，以下是内置函数列表</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td>new、make</td><td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作</td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数，在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real imag</td><td>用于创建和操作复数</td></tr></tbody></table><a class=post-dummy-target id=5-匿名函数与闭包></a><h2>5. 匿名函数与闭包</h2><p>匿名函数是类似 <code>func(x, y int) int { return x + y }</code> 这样没有名字的函数。</p><p>匿名函数可以被直接调用，下面是一个计算从 1 到 1 百万整数的总和的匿名函数。表示参数列表的第一对括号必须紧挨着关键字 <code>func</code>，因为匿名函数没有名称。花括号 <code>{}</code> 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>sum</span> <span class=o>:=</span> <span class=mi>0</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=mf>1e6</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>sum</span> <span class=o>+=</span> <span class=nx>i</span>
	<span class=p>}</span>
<span class=p>}</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>另外，匿名函数可以像其它函数一样接受参数，下例展示了如何传递参数到匿名函数中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>u</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
	<span class=err>…</span>
<span class=p>}</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>还应该知道的，匿名函数可以被赋值给某个变量，如<code>fplus := func(x, y int) int { return x + y }</code>，这样函数的地址就保存到了变量中，之后可以通过变量名对函数进行调用：<code>fplus(3, 4)</code></p><p>所谓闭包就是函数及其引用环境的组合，这么说比较难理解，举个例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
        <span class=nx>i</span><span class=o>++</span>
        <span class=k>return</span> <span class=nx>i</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>在这里例子里，返回值是一个函数，这个函数本身没有定义变量，而是引用了它所在环境的变量 i，这就形成了一个闭包。从这里可以看出，闭包与匿名函数息息相关，因为匿名函数被用作函数返回值非常合适。下面是一个完整的例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>f</span> <span class=p>=</span> <span class=nf>Adder</span><span class=p>(</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>,</span> <span class=s>&#34; - &#34;</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=p>,</span> <span class=s>&#34; - &#34;</span><span class=p>)</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nf>f</span><span class=p>(</span><span class=mi>300</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Adder</span><span class=p>(</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>x</span> <span class=kt>int</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>delta</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
		<span class=nx>x</span> <span class=o>+=</span> <span class=nx>delta</span>
		<span class=k>return</span> <span class=nx>x</span>
	<span class=p>}</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=mi>1</span> <span class=o>-</span> <span class=mi>21</span> <span class=o>-</span> <span class=mi>321</span>
</code></pre></td></tr></table></div></div><p>从这里例子中我们注意到 x 的值是不断累加的，这也就意味着闭包函数其实会保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 这里可以理解为函数被赋值给 f 之后，其实将整个闭包包括环境都赋值给了 f，变量 f 的生存周期内，其值是不变的，所以结果才会累积。</p><p>这种返回值为另一个函数的函数的形式也被称之为工厂函数，在需要创建一系列相似的函数的时候非常有用。下面的函数演示了如何动态返回追加后缀的函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=nx>suffix</span> <span class=kt>string</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
		<span class=k>if</span> <span class=p>!</span><span class=nx>strings</span><span class=p>.</span><span class=nf>HasSuffix</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>suffix</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>name</span> <span class=o>+</span> <span class=nx>suffix</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=nx>name</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>现在可以生成如下函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>addBmp</span> <span class=o>:=</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=s>&#34;.bmp&#34;</span><span class=p>)</span>
<span class=nx>addJpeg</span> <span class=o>:=</span> <span class=nf>MakeAddSuffix</span><span class=p>(</span><span class=s>&#34;.jpeg&#34;</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>然后调用它们</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nf>addBmp</span><span class=p>(</span><span class=s>&#34;file&#34;</span><span class=p>)</span> <span class=c1>// returns: file.bmp
</span><span class=c1></span><span class=nf>addJpeg</span><span class=p>(</span><span class=s>&#34;file&#34;</span><span class=p>)</span> <span class=c1>// returns: file.jpeg
</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=6-defer和追踪></a><h2>6. defer和追踪</h2><p>关键字 defer 是 Go 中一个非常有用的特性，作用是将某个语句或函数推迟到函数返回之前执行。准确的说，defer 的执行时机有三种：</p><ol><li>包含 defer 语句的函数返回前</li><li>包含 defer 语句的函数执行到末尾</li><li>所在的 goroutine 发生 panic 时</li></ol><p>一个例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Fourth&#34;</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;First&#34;</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Third&#34;</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=nx>First</span>
<span class=nx>Third</span>
<span class=nx>Fourth</span>
</code></pre></td></tr></table></div></div><p>defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，如下例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span>
<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Deferred print:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
<span class=nx>i</span><span class=o>++</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Normal print:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=nx>Normal</span> <span class=nx>print</span><span class=p>:</span> <span class=mi>2</span>
<span class=nx>Deferred</span> <span class=nx>print</span><span class=p>:</span> <span class=mi>1</span>
</code></pre></td></tr></table></div></div><p>但与匿名函数结合起来后，变量的值在函数运行时才会确定</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f1</span><span class=p>(</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=mi>1</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span><span class=o>++</span>
        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=mi>2</span>
    <span class=k>return</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nf>f1</span><span class=p>(</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=mi>3</span>
</code></pre></td></tr></table></div></div><p>上例中出现了 return 语句，defer 与 return 的执行顺序比较复杂，这里要先理解两件事</p><ol><li>defer 函数执行时机是外层函数设置返回值之后，即将返回之前</li><li>return xxx 操作并不是原子的</li></ol><p>下面的例子中， return 0 实际上可以拆分为 r = 0; return 两条语句，因此输出是1不是0</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f1</span><span class=p>(</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span><span class=o>++</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span> <span class=mi>0</span>
<span class=p>}</span>
<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>f1</span><span class=p>(</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>来一个更复杂的例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>x</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>triple</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span> <span class=o>+=</span> <span class=nx>x</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>triple</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span>
<span class=c1>// Output:
</span><span class=c1></span><span class=mi>9</span>
</code></pre></td></tr></table></div></div><p>上面的例子实际上等价于</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>triple</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>r</span> <span class=p>=</span> <span class=nf>double</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
    <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>r</span> <span class=o>+=</span> <span class=nx>x</span>
    <span class=p>}</span><span class=p>(</span><span class=p>)</span>
    <span class=k>return</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>多个 defer 同时使用时，以逆序执行，即后进先出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>f</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
	<span class=p>}</span>
<span class=p>}</span>
<span class=c1>//Output:
</span><span class=c1></span><span class=mi>4</span> <span class=mi>3</span> <span class=mi>2</span> <span class=mi>1</span> <span class=mi>0</span>
</code></pre></td></tr></table></div></div><p>defer 关键字一般用于释放某些已分配的资源或在函数执行完进行一些收尾工作，比如</p><ol><li><p>关闭文件流</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//open a file
</span><span class=c1></span><span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>解锁一个加锁的资源</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>(</span><span class=p>)</span>
<span class=k>defer</span> <span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>打印最终报告</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nf>printHeader</span><span class=p>(</span><span class=p>)</span>
<span class=k>defer</span> <span class=nf>printFooter</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li><li><p>关闭数据库链接</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//open a database connection
</span><span class=c1></span><span class=k>defer</span> <span class=nf>disconnectFromDB</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div></li></ol><a class=post-dummy-target id=7-编写规范></a><h2>7. 编写规范</h2><p>Go是编译型的语言，因此函数的编写顺序无关紧要，但鉴于可读性的需求，最好遵循一定的编程规范，我这里采用的是Uber开源在github的编码规范，有两条主要规则</p><ol><li><p>函数应按粗略的调用顺序排序</p></li><li><p>同一文件中的函数应按接收者排序，意即可被外部访问的函数（参考可见性规则）应放在前面，普通工具函数放在后面。另外，在类型定义（结构体、接口等）后，可被外部访问的函数前，可能会出现类似于<code>newXYZ()</code>这样的新建某个类型的函数。一个简单的例子如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>something</span> <span class=kd>struct</span><span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
   
<span class=kd>func</span> <span class=nf>newSomething</span><span class=p>(</span><span class=p>)</span> <span class=o>*</span><span class=nx>something</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>something</span><span class=p>{</span><span class=p>}</span>
<span class=p>}</span>
   
<span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>something</span><span class=p>)</span> <span class=nf>Cost</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nf>calcCost</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>weights</span><span class=p>)</span>
<span class=p>}</span>
   
<span class=kd>func</span> <span class=nf>calcCost</span><span class=p>(</span><span class=nx>n</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span><span class=o>...</span><span class=p>}</span>
</code></pre></td></tr></table></div></div></li></ol><p>最后，main函数放在所有函数的最后。</p></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>shuzang</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2020-06-16</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fshuzang.github.io%2f2019%2fgolang-syntax-7-function%2f&text=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%807-%e5%87%bd%e6%95%b0&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fshuzang.github.io%2f2019%2fgolang-syntax-7-function%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fshuzang.github.io%2f2019%2fgolang-syntax-7-function%2f&title=Golang%e8%af%ad%e6%b3%95%e5%9f%ba%e7%a1%807-%e5%87%bd%e6%95%b0" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://shuzang.github.io/tags/go%E8%AF%AD%E6%B3%95/><i class="fas fa-tag fa-fw"></i>&nbsp;Go语法</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://shuzang.github.io>Home</a></span></section></div><div class=post-nav><a href=https://shuzang.github.io/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/ class=prev rel=prev title=医药健康5-医保及就医><i class="fas fa-angle-left fa-fw"></i>医药健康5-医保及就医</a>
<a href=https://shuzang.github.io/2019/articles-about-blockchain/ class=next rel=next title=区块链方向有参考价值的文章收集>区块链方向有参考价值的文章收集<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shuzang.github.io/about/ target=_blank>shuzang</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-209130979-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>