[{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第十三期月刊，2022 年 05月。 ","date":"2022-05-31","objectID":"/2022/life-monthly-13/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 13 期 (202205)","uri":"/2022/life-monthly-13/"},{"categories":["日程及周刊"],"content":"新闻 本月忘记录了 ","date":"2022-05-31","objectID":"/2022/life-monthly-13/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 13 期 (202205)","uri":"/2022/life-monthly-13/"},{"categories":["日程及周刊"],"content":"生活 04.30-05.03，在介休游玩 05.04，给娟姐修电脑，发现阿澜·卢的新书 05.06，手锯到货，成果改造床头 05.08，更换洗漱杯，晚上和吉策、刘家懿在宿舍吃火锅 05.13，带双合成的点心回家 05.14，电动车上牌申请提交，带老妈和弟弟吃烤鱼 05.16，前往榆次完成医保归属地更改，社保卡发卡行更换到中行 05.21，农行卡注销，电动车低价卖出 05.25，和胡静文、夏福良、吉策去众德天和拍照，和吉策逛超市 05.26，和吉策逛街，玩滑板（学会滑行了） 05.27，和吉策去双合成换粽子 05.28，飞书的物品电子化表格整理，和吉策逛街，晚饭烤串+可乐，快乐到飞起 05.29，给高中朋友送上生日祝福，和吉策逛街，练习滑板，深夜大哭 05.30，和吉策玩滑板，半路上主楼改新闻稿 05.31，和吉策散步到太坊社区附近，发现一段宽敞干净的马路和一段废弃铁路线 ","date":"2022-05-31","objectID":"/2022/life-monthly-13/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 13 期 (202205)","uri":"/2022/life-monthly-13/"},{"categories":["日程及周刊"],"content":"观影 05.12-05.14，纪录片《性别的秘密》，一共三集，讲述了性别差异的六大区域：情绪认知、同理心、交流、基本认知、竞争以及大脑解剖结构，论据不太充分，但观点很有意思。 05.21，电影《神奇动物·邓布利多之谜》，这剧情就离谱，还有德普叔哪里去了 05.25，美剧《月光骑士》E01-E02，不是很好看，放弃。 05.28，电影《月球陨落》，中规中矩，三星到四星之间。 05.28-05.31，综艺《90婚介所》S01、S02，先看的第二季，后看的第一季，发现第二季好磕，第一季有用，了解这么人的看法真的很有用 05.29，电影《扬名立万》，确实有《利刃出鞘》的影子，但走出了自己的路，是个好电影而且导演好像在掺私货啊 ","date":"2022-05-31","objectID":"/2022/life-monthly-13/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 13 期 (202205)","uri":"/2022/life-monthly-13/"},{"categories":["日程及周刊"],"content":"阅读 1、《如何阅读一本书》，作者是莫提默·艾德勒和查尔斯·范多伦，已读完。 2、乐嘉的《写给单身的你》，第二次阅读 3、以色列作家伊利亚金·奇斯列夫的《单身社会》，正在阅读中，观点很有参考意义，尤其是对问题“婚姻能否缓解孤独终老的状态”的解析 ","date":"2022-05-31","objectID":"/2022/life-monthly-13/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 13 期 (202205)","uri":"/2022/life-monthly-13/"},{"categories":["日程及周刊"],"content":"收藏 【职业】验房师 【游戏】模拟飞行 【书籍】《赤脚医生手册》、《民兵训练手册》、《军地两用人才之友》，号称三大神书，能在核战后迅速恢复文明 【知识】兽面瓦当纹样 【网站】有籍 【商品】得力文件柜黑色五层 【网站】WodeABC.com ","date":"2022-05-31","objectID":"/2022/life-monthly-13/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 13 期 (202205)","uri":"/2022/life-monthly-13/"},{"categories":["日程及周刊"],"content":"思考 做月刊是一个很棒的事情，能发现自己这个月其实做了很多事，也过得很开心 长大后，有时候明明那么悲伤，但哭都不会哭了，需要学习一下 和吉策、刘家懿吃火锅的时候聊过去，意识到自己性格的一个缺陷，就是总喜欢自己想当然，但其实只要两个人在一起了，就是两个人的事，所担心的任何事情一定要摊开来说清楚，能接受则好，不能接受则分，而不是自己觉得为对方好，啥也不说就分开 要学会自己做决定，不要完全听别人安排，这样可以减少大量工作量 爱不爱自己是别人的事，不要为此而担心 对自己的每件物品了解多一点，能不能重拾热爱 ","date":"2022-05-31","objectID":"/2022/life-monthly-13/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 13 期 (202205)","uri":"/2022/life-monthly-13/"},{"categories":["日程及周刊"],"content":"Check List 对账 月刊完成 ","date":"2022-05-31","objectID":"/2022/life-monthly-13/:7:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 13 期 (202205)","uri":"/2022/life-monthly-13/"},{"categories":["平日里的白日梦"],"content":"伊利亚金·奇斯列夫的《单身社会》，中信出版社出版于2021年3月，总计10.2万字，讨论的内容包括：我们为什么不再憧憬婚姻，婚姻能否缓解孤独终老的状态，催婚的社会压力和单身歧视，独居人群如何获得社会安全感等。 ","date":"2022-05-30","objectID":"/2022/happy-singlehood/:0:0","tags":["读书笔记"],"title":"单身社会（未完成）","uri":"/2022/happy-singlehood/"},{"categories":["平日里的白日梦"],"content":"我们为什么不再憧憬婚姻 各种迹象都表明，各地晚婚、独居或选择单身的人数都在逐渐提升，不仅在发达国家如此，在中东等保守或超保守的社会也显现了类似的趋势。作者认为根本原因在于传统家庭在照顾个人方面曾扮演的不可或缺的角色，正在被蓬勃发展的国家及市场力量取代，主要原因被作者归结为八类，依次介绍如下。 一是人口变化。世界各国的生育率急剧下降，这带来如下影响，第一，如果生育的子女较少，就可以更晚结婚，不必追赶生育年龄；第二，孩子少，离婚的负担就小，甚至根本不必结婚，单亲照顾较少的孩子更轻松；第三，在小家庭中成长的人未来更有可能建立小家庭。预期寿命的提高同样导致单身人数增加，主要体现在许多老年人独自生活的时间延长，同时独居老人使年轻人的负担增加，又可能使年轻人延后结婚。最后，性别比失衡也会使潜在伴侣人数减少。 二是女性的社会角色变化。女性受教育水平的提高使得女性婚育年龄提高，社会对单身女性的看法也变得不那么严苛，鼓舞了更多女性选择单身的生活方式，另外，医学及科技的进步使得女性不必为了把握生育年龄早早进入婚姻。 三是在离婚兴盛的年代回避风险。在个人主义的社会中，人们习惯计算各种人生大事的利与弊，然而研究发现，婚姻只能暂时提升快乐感，大概结婚两年之后，快乐感通常就会降回婚前水准，但对于离婚，幸福感在正式离婚之前就开始下降，离婚期间幸福感降至谷底，虽然之后会逐渐回升，但不会恢复到基准水平。由于离婚会危及个人幸福，而婚姻带来的好处不足以弥补，人们倾向于干脆不结婚或延后结婚。但更讽刺的是，晚婚的人更容易离婚，证据显示，结婚年龄在32岁以上的伴侣，每晚一年结婚，离婚率约增加5%。 四是经济因素。经济弱势者即便肯定婚姻价值，也不太相信自己有能力维持财务稳定，进而维系婚姻。而经济稳定或富有的人也不见得离开单身，消费主义的兴起使得人们更关心自己的利益，因此偏离传统价值观，转而思考婚姻是否于己有利，许多人更想成为拥有个人品味的独立消费者，对通过两性交往或婚姻关系获得财务保障已渐失兴趣。资本主义促使人们思考并比较不同生活方式的价值，同时，资本主义体系所带来的财富让人们有能力依循自己的价值观生活，而现代人通常选择独立而非婚姻，更注重隐私而非家庭生活。最后，市场也更欢迎单身人士，因为比起家庭单位中的个人，单身人士能消费更多资源，这也导致市场在不断调整以迎合单身人士的需求，甚至鼓励单身，行成一个循环，媒体也正在调整舆论方向，单身人士逐渐成为广告的目标对象。 受教育程度也会影响结婚率。一方面，受教育程度越高，进入婚姻市场时间越短，另一方面，受教育程度较高的族群可能更重视职业生涯，另外，受教育程度较高的个人拥有独立与个人主义等价值观，进而较少有结婚成家的压力。最后，高等教育程度与高收入具有关联性，社会经济地位较高者能够负担独自生活的开销，进而影响了他们的关系模式。 五是宗教变迁。 六是大众文化、媒体及社群网络的发展。媒体上逐渐出现不需要另一半也可过的很好的单身人士，大众文化的赞同也使得年轻人对于选择单身生活更有自信。现代的通信方式也让用户接触到不一样的生活方式，挑战着传统及婚姻制度。人们一旦看见其他互动方式能满足自己的情感需求，他们会重新思考亲密关系及家庭状态。 七是都市化。都市的房屋价格升高，而家庭通常需要较大的空间，因此都市环境变得不利于家庭生活。另外，都市提供大量小型公寓，可以容纳越来越多的独居人士，而这样的过程循环不断。此外，在乡村到城市的大规模人口流动中，比起本地人，外来者对移居地的人际交往圈并不熟悉，同时又远离家族强加的婚姻义务，因此有更高的概率独自生活。 八是国际移民。 ","date":"2022-05-30","objectID":"/2022/happy-singlehood/:1:0","tags":["读书笔记"],"title":"单身社会（未完成）","uri":"/2022/happy-singlehood/"},{"categories":["我所热爱的生活啊"],"content":"本篇是对恋爱、婚姻和生育问题的思考。 很长一段时间，我都在坚称自己是不婚主义者，但其实我心里一直明白，我还是想要恋爱，可以接受结婚，只是不想生育，但这种想法是如何产生的，不反感结婚的我为什么声称自己不婚，又一直没有踏入恋爱关系，很多事需要仔细的梳理一下。 ","date":"2022-05-29","objectID":"/2022/about-love-and-marriage/:0:0","tags":["杂谈"],"title":"关于恋爱与婚姻（未写完）","uri":"/2022/about-love-and-marriage/"},{"categories":["我所热爱的生活啊"],"content":"恋爱观 Q：是否想恋爱？ A：想 Q：喜欢什么样的人？ A：第一印象不反感，性格安静内敛，有矛盾的第一反应是通过沟通解决，喜欢看电影，喜欢旅游，最好喜欢健身，愿意学习新东西，愿意共同承担生活中的开心和不开心。但这种事情哪有那么绝对呢，曾经有人第一次见面完全没感觉，但随着相处却越来越喜欢，恋爱真的是不讲道理的，感觉来了所有条件都不是问题，只是具有以上特质的人喜欢的概率大一点罢了，这也是为什么不太想回答这种问题，因为没那么绝对。 Q：之前为什么不愿意步入亲密关系，而且声称自己不婚？ A：首先是恋爱需要更多的开销，学生阶段还需要父母给生活费，不想给父母更重的负担；其次是保持着遇一人就是终生的朴素价值观，但又不清楚自己究竟想和什么样的人在一起；然后是不想花父母的钱自己又短时间买不起房子付不起彩礼，想着即使恋爱了也无法走入婚姻，干脆不要耽误别人；还有是性格内向且被动，不会去主动认识更多的人，而且恐惧竞争，一旦有人同时喜欢一个女生，就不想争了，主动退出；最后是担心自己不够好，也不帅，喜欢的人不会喜欢自己。 Q：现在的观念是否发生了转变，发生了哪些转变？ A：确实发生了转变。一是已经步入工作，有了独立的经济来源，这样就会相对比较愿意去投入；二是逐渐明白恋爱和结婚真的是两件事，因为害怕走不到一起所以第一步也不迈出，实在是再可笑不过的想法了；三是觉得，前面的时光里我已经因为害怕错过了很多人，现在如果有机会，我绝对不要继续错过，我更想去直接的表达自己的喜欢，另外就是，是不是喜欢我是对方的事，不应该是我担心的问题，我暂时不可能为了一个人去改变自己的人生目标和态度，而且靠勉强自己获得的喜欢我并不想要，只有喜欢当下优缺点并存的我，才是我想要的恋爱。 Q：是否愿意相亲？ A：不愿意，我想要恋爱，但我并不渴望婚姻，而且目前还是比较享受单身生活的。 Q：有没有非常希望有女朋友的时刻？ A：有。看到美好的事物、遇到快乐的事情想有人分享，生病或身体不舒服的时候想有人陪伴，晚上从噩梦中惊醒的时候也喜欢身边有人。 Q：从之前的关系中有收获什么经验吗？ A：遇到任何问题，一定要充分的沟通，而不是自己去猜测，然后抱着为对方好的心态去做某事，这也是为什么喜欢什么样的人里面有一条描述是“有矛盾的第一反应是通过沟通解决” ","date":"2022-05-29","objectID":"/2022/about-love-and-marriage/:1:0","tags":["杂谈"],"title":"关于恋爱与婚姻（未写完）","uri":"/2022/about-love-and-marriage/"},{"categories":["我所热爱的生活啊"],"content":"婚姻观 Q：是否想结婚？ A：可以接受，可以接受的意思是如果在一起了，为了让喜欢的人放心，可以结婚。 结婚担心什么？ 引入另一个家庭的复杂人际关系； 结婚成本过高（房价和彩礼），会掏空父母口袋 不结婚的担心？ ‌婚姻和幸福没有必然联系 ‌单身和孤独也没有必然联系 ‌单身和婚姻都只是一种选择 催婚和社会舆论是单身要面对的两座大山 人生最重要的使命是清楚自己要什么，并靠自己努力去获得，绝不是把自己人生的希望寄托在另一半身上 《出租什么都不做的人》E08，委托人说，好想有个人来关注我的人生，这就是他想结婚的动力 想恋爱、结婚的理由有 有时候想找个人分享美好的事情 有时候一个人很难坚持，比如突发疾病等 自己所承受的来自父母的压力，父母所承受的社会舆论压力 ","date":"2022-05-29","objectID":"/2022/about-love-and-marriage/:2:0","tags":["杂谈"],"title":"关于恋爱与婚姻（未写完）","uri":"/2022/about-love-and-marriage/"},{"categories":["我所热爱的生活啊"],"content":"生育观 是否想生育？否 不想生育的原因？ 教育成本太高； 会影响整个人生选择，减少大量个人时间，简单说就是从小到大按一个模板走过来，还没做自己想做的事，一旦结婚和生育后会被拖入永无止境的泥潭； 对世界悲观，长大后发现世界不一样，而且认为世界会越来越坏，既然自己活的痛苦，为什么还要下一代来感受同样的痛苦 ","date":"2022-05-29","objectID":"/2022/about-love-and-marriage/:3:0","tags":["杂谈"],"title":"关于恋爱与婚姻（未写完）","uri":"/2022/about-love-and-marriage/"},{"categories":["我所热爱的生活啊"],"content":"如何回应一些问题 有对象了吗？ 给你介绍一个对象怎么样？ 为什么不想结婚？ ","date":"2022-05-29","objectID":"/2022/about-love-and-marriage/:4:0","tags":["杂谈"],"title":"关于恋爱与婚姻（未写完）","uri":"/2022/about-love-and-marriage/"},{"categories":["我所热爱的生活啊"],"content":"五一市内出游计划：绵山和张壁古堡，都在介休市，绵山算是鼎鼎大名，山西的旅游宣传片里经常有，张壁古堡主要是前段时间从《航拍中国》纪录片里了解的。这次的预算在 2000 元，游览 2-3 天。 ","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:0:0","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"旅行策划 ","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:1:0","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"A. 景点了解 了解要去的景点算是做攻略很重要的一部分，主要是为了避免确定路线、安排行程，以及不会错过值得游览的景点，导致回来后有所遗憾。大部分的资料来自于景区官网的介绍，可以辅以网上的各种攻略补充。 张壁古堡 张壁古堡，4A级景区，全国文物保护单位，位于介休东南十公里的绵山北麓，是古时候介休去往绵山的必经之地，也是著名古代军事要塞雀鼠谷的重要堡垒之一，因此，虽然面积只有0.12平方公里，却因为地理位置险要，成为了兵家必争之地。 游览张壁古堡应重点体会其军事堡垒的特征和各类设施的完善性。据网上描述，古堡三面临沟，一面靠山，整个地势南高北低，西高东低，易守难攻。北门瓮城城门指向800米外一座小山丘“照壁”，而南门指向照壁上象征北斗七星的七颗槐树，这是我们应该注意的。我们所看到的城堡，始建于北朝十六国的后赵时期，距今已有1600多年。现存堡墙全长约1.1千米，高5到7米。堡墙夯土层厚度在9到17厘米之间。因历代经过补修，堡四周夯土层的厚度是有所不同的。据古堡现存的道光年间《重修仪仗补修彩绘碑记》中记载，堡墙原先高4丈，宽7尺，顶部可供兵马来回行走。据专家介绍，距今约4600-4000年的龙山文化时期，先民们已经开始使用夯土技术。汉代的夯筑土层厚约15公分，唐代至明代约30公分。这里的堡墙夯土层厚度是15公分左右。依据堡墙夯土层的厚度，和最新的研究成果推测，堡墙始建年代是早于隋唐的，应该是在坞壁盛行的北朝十六国时期。因此入城门前先看堡墙。 现在，为了出入便利，人们多走南门，因此游览应由南门入，古堡南门为石砌，堡门上有一座石雕龙头，象征龙首；门外有九条红石铺路，象征龙须；进入城堡，是一条连接南北两个堡门的交通主干道，这条长约300米的街道以石板铺地，象征龙身；清朝时，堡中居民出于协调风水和兴盛文运的考虑，由堡外花费人力财力运入石材，将街道中央的青石板挖起，铺设了三列平行的红色长石条，一直从南门延伸到北门，它象征龙脊。整条街道并不呈直线，而是S形，据说，街道两侧原先各有一座水塘，后来由于修建学校填平了其中之一，而它们与S形街道构成了一幅道家的阴阳太极图。这条龙街与各个街巷相交也都是构成丁字型结构，据说是为了巷战。 张壁古堡的地上，是易守难攻的防御体系，地下则是纵横交错的地道，长达5000米，距今已有1380余年的历史，是国内罕见的古代地下军事遗址。地道分高中低三层，高层地道距离地面仅仅1米，中层大约有8-10米，而底层地道距地面竟达到20米。要想出入这3层地道，就必须经过一处特定的交叉口才可到达另一层地道。如此设计，让走在暗道里的人，如进入了一个遥远而陌生的迷宫一样不知所措。随着逐渐深入，地道内的陷阱、通讯道、探望孔、伏击道、逃跑口、排水口等一一呈现。 除了颇具规模的军事堡垒，众多的宗教庙宇也是张壁的一个亮点，因此也是我们关注的第二个方面，张壁内现存16座祠庙，真武殿、空王殿、三大士殿、二郎庙、可罕庙、关帝庙等林林总总于南北两门附近，且大多建于城上。按下面游览图上的景点顺序，我们逐个介绍 关帝庙：建于明末清初，当时只是在南门外建了一座小庙。康熙四十八年，也就是公元1709年,在原址重建正殿，距今已有三百多年的历史。关帝庙是根据张壁村南高北低的地形、随山就势而修建的。按老百姓的说法，之所以之样做，一是要借助关老爷的神威，拦挡绵山山林的煞气；二是让庙宇山门正对堡门，好让大名鼎鼎的关老爷时时刻刻看护着全村，保佑这里的百姓吉祥如意，平平安安。牌文记载，立碑者为曹洞正宗十七代弟子。佛教禅宗创立于江西丰洞山，后有弟子本寂在吉水的曹山传禅，因此后世其这一支为曹洞宗。由此看来，张壁关帝庙具有佛教的色彩，应当是正宗的禅宗寺庙。进入正殿，正中供奉的是关羽关老爷。旁边扶刀站立的是周仓，抱印的关羽的义子关平。殿内壁画绘于康熙五十年，即1711年，与现存殿宇同时期完成，工笔细腻，用二十五幅连环画的形式介绍了关羽的生平故事。这些壁画是由纯天然颜料绘制的，耐久性强，不易脱色，加之张壁村地处黄土高原，相对湿度较低，虽然历经三百多年时间，色彩依然艳丽，色质依然清晰，堪称同时期壁画之佳作。 泥包铁神像：关帝庙的东院有三眼窑洞，建于清康熙五十年，也就是1709年。从前曾有砖砌的供台，供台上曾有精致的竹编神龛，神龛中供奉有三尊站立的千手观音。文革时拆除供台，拆除作业时,发现了后墙上的木梁。因为古堡的地道出入口很多，怀疑这也是个地道口，便撬开一块砖，想看个究竟。惊讶地发现，里面是居然安放一尊神像。这尊塑像的内胎是铁铸，处面则先包一层泥，再进行了彩绘。彩绘精美细腻，造像神态安祥，栩栩如生。神像的服饰似佛似道又似儒，十分罕见。这尊塑像面世以来，引起了许多专家学者的关注。关于他的来历众说纷纭，显得扑朔迷离。 可罕庙：可罕王庙建在村东侧黄土高台上，南北五十七米，东西二十八米，南缘凸出堡墙之外，是张壁村的最高点。可见庙内所供人物在张壁人心目中的地位至高无上。可罕庙东西北三面墙高达三丈。那一个个垛口是张壁古堡当年作为军事壁垒设防御敌的标志，森然威严，俨然是堡中之堡。庙院分为三个高度，东西两侧是厢房，北面两米多高的月台上是正殿和钟鼓楼。 魁星楼：魁星是主管功名科举的神，我国很多地方都建有“魁星楼”或“魁星阁”，且都是建在巽位上。道家学说认为，巽位有一种莫名的光亮，魁星楼建在巽位，昭示前途光明。奎宿和壁宿两组星团紧紧相邻，星宿学中有“奎壁联辉”之说，若奎壁两宿同时发出强烈光芒，就预示着会有圣人出世。魁星楼为二层挑角阁楼，六方攒尖顶，葫芦形宝刹，灰瓦脊兽，高10.5米，石台基高0.6米，二层为砖灰结构，门阶向北。一层供奉的就是魁星。魁星是主管功名科举的。过去的读书人在魁星楼拜魁星，祈求在科举中金榜题名，二层供奉的是文昌君，也就是文曲星。也有传说魁星和文昌君原本就是同一位神，魁星是文昌君下凡。 三大士殿：三大士殿建于康熙三十一年，也就是1692年。殿中原先供奉文殊、普贤、观音三位菩萨，殿宇的木质结构为元代保留下的。元代时，三教合一这个名词开始屡次出现，宗教相融达到了鼎盛时期。在雀替上雕有半龙半象也是在建筑上宗教的一种融合。三大士殿最珍贵的是墙上的壁画。这里的壁画，在文革破四旧的时候，被老百姓用涂麦秸泥的方式保护起来，只露着一小块可以看得真切。从暴露出来的部分，我们可以看到，遗存壁画的内容中有达摩东渡的故事。壁画的色泽虽然历经三百年依旧很艳丽，画的技法也很高超，俗话说“民间有高手，高手在民间”，这话一点不假。 真武殿：真武庙重修于清嘉庆十三年（1808年），距今已有203年。按道家学说，二十八星宿分为四象，即东青龙、西白虎、南朱雀、北玄武，北方属水，其色玄，故称玄武。真武是司水之神，以灵龟为盾、玄蛇为剑。真武龟蛇交缠，为阴阳交感、演化万物的象征，又被称为司命之神。张壁人在北堡门之上修建了真武庙，目的是为了留锁风水，藏风聚气，保佑堡中百姓安康、风调雨顺。 空王行祠：空王殿是为供奉唐贞观年间于绵山抱腹寺成佛的空王佛田志超所建。这座空王行祠建于明万历41年，即公元1613年，距今400年。建空王行祠之前已有了空王寺，寺中有僧人。至于旧的空王寺建在哪里，建于何年，存在了多少年，都已无法考证。空王殿顶的琉璃，历经400多年，依然光彩夺目。屋脊一龙一凤和脊角的螭吻活灵活现，精美绝伦，是难得的艺术珍品。空王殿顶正中有3个葫芦宝瓶为狮瓶风水楼，护佑平安之意。空王殿前的琉璃碑名叫《宽贤发愿碑》。碑文记载的是万历三十三年三月二十三日（1602年），空王行祠僧人宽贤发愿修缮殿宇的事。对面檐下那块琉璃碑是《创建空王行祠碑记》，记载了空王佛的传说故事，是现存世上关于空王佛田志超成佛事迹最为完整的记录。这两块琉璃碑高二百五十厘米，宽六十八厘米，分为碑首，碑身，碑座三个部分。碑额的螭首为黄色，二龙戏珠，栩栩如生。碑身是珍贵的孔雀蓝色，碑文用黑釉书写。碑座是瓜皮条釉。这两块琉璃碑，都是通体烧造，所采用的也都是孔雀兰色，这是国内绝无仅有的两通琉璃碑，堪称稀世之宝。 二郎庙：张壁人为了收住风水，不使外泄，在北门洞之上修建了真武殿，真武殿是第一道拦截风水的建筑，古朴的张壁人还是担心风水外泄，所以在此增加堡墙高度，本地方言中“郎”与“拦”谐言。殿内供奉的是三眼二郎神杨戬。旁边是他的哮天犬，墙上以屏风画形式彩绘《二十四孝》图。 张壁古堡号称星象村，是第三个看点，但网上没有介绍，因此要在星象文化展厅看一下。此外，还有一些小景点需要关注： 龙鹤福：古代建筑有房必有门，有门必有壁，张嘉会堂的照壁是个福字，整个字似字又似画，左边是龙，右边是鹤，龙是古代对权利的象征，表达了主人望子成龙,希望后人飞黄腾达的意思。整个字由三种手法写成，狂草开头、行书过径，楷书结尾。“福”字图形外围是用砖雕竹节, 竹节有节节高升之意,共用44节寓意事事如意；内圆用砖66块,寓意六六大顺,福字共用16块方砖拼成,寓意石榴，多子多孙；福字以外的空间共用砖24块，对应农家二十四节气，16、24、44、66相加之和为150，写作壹佰伍零,寓意一本万利，财源广进。将这么多象征吉祥如意的数字巧妙地结合在一起，堪称民俗文化中的奇迹，可见主人和设计制造者的匠心独运。 槐抱柳：1000年的古槐，根部，长出一株两人合抱的巨柳，挺拔向上，似在古槐怀中，故名槐抱柳。 多个历史时期的遗留，地上明堡，地下暗道，星象村的奇特布局，机关密布，诡秘奇绝，成就了张壁古堡“明堡暗道双城子，堡垣庙院博物村”的美名，也有”古庙神佛异，明堡暗道奇“的说法。 绵山 绵山，5A级旅游景区，入口在介休，但实际跨介休、灵石、沁源三市县地界，最高海拔 2560 米，是太岳山的一条支脉。 绵山最富盛名之处是它是清明（寒食）节的起源地，是当年介子推携","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:1:1","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"B. 行程 结合火车车次，公交运行时间、景区大致游览时间等信息，确定行程。 首先，火车4月30日上午10点到介休，在火车站附近乘301路到张壁古堡，约11点，游览约3小时，主要关注如下景点： 古照壁和七星槐 堡墙不同年代的夯土 堡外三面临沟，一面靠山的地形； 南门的龙头，南门到北门象征龙身和龙脊的石板路； 南门到北门的街道是弯的。 龙街与周围街道的丁字型结构 三层地道及它们间的交叉口 地道内的各类设施，如陷阱、通讯道、探望孔、伏击道、逃跑口、排水口，注意和在武乡和沁县看到的地道的差别 关帝庙关羽像，左右周仓和关平像，殿内壁画。 关帝庙东院的泥包铁神像，是不是似佛似道又似儒 可罕王庙整体 魁星楼 龙鹤福 槐抱柳 三大士殿的壁画 真武殿 空王行祠的琉璃顶和琉璃碑 二郎庙 下午2点左右结束游览，乘301路返回介休，入住订好的酒店，稍作休息，然后在介休城里逛一逛，和朋友约个饭，第二天早上乘7点的第一班公交（302路）到绵山，到达时约8点，景区内的行程如下： 从景区入口乘大巴到最后一站水涛沟，约九点； 从水涛沟入口走到终点水帘洞来回约3小时，因此只走到龙马瀑就返回，这一段主要观赏瀑布，感受安静的环境，约1.5小时，10点半结束； 放弃古藤谷，返回水涛沟入口后乘缆车上山到介公岭，主要感受感受清明文化，凭吊先贤，下山途中会经过介公墓和介公庙，下山后到达栖贤谷，体验镂空台阶，全程约共2小时，12点半结束，途中吃午饭（自带）； 从栖贤谷坐车到正果寺，步行去云峰寺，体验悬空栈道，参观包骨真身像，共1.5小时，2点结束，这里是航拍中国取景地，是旅行重点； 从云峰寺坐车到朱家凹（远观、粗看），再坐车到一斗泉（泉水本身），接着看天桥（云雾缭绕、栈道），约1小时，3点结束； 从天桥坐车返回大罗宫（感受宏伟壮观），1小时，4点结束； 从大罗宫坐车回龙脊岭（长城、营帐），1小时，5点结束； 从龙脊岭坐车回景区出口，1小时，赶6点末班公交。 公交终点站为火车站，乘7点左右的火车离开介休。 ","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:1:2","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"C. 行李 短途旅行，且只有两天，只带一个背包，内有： 衣物：长裤一件、卫衣一件，均为备用； 洗护用品：牙刷套装、洗面奶、乳液、防晒、卫生纸； 电子产品：手机、备用手机、充电头和充电线、充电宝、自拍杆、耳机； 其它：钱包、眼镜、备用眼镜、各种证件、零食、雨伞； ","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:1:3","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"旅行期间 ","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:2:0","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"Day1 张壁古堡 4月30日起了个大早，充满期待的洗漱、收拾，然后还是在那家有猫的沙县小吃完成了早饭。火车9:59到介休，出站时遇到车站工作人员用担架抬了一个人出去，也不知道出了什么事，由于是市内出行，只验了两码就顺利的出了站，但接下来预料之外的事情发生了，本来打算乘火车站附近的301路公交前往张壁古堡，但火车站前面正在修路，封堵了一侧道路，瞬间有点不确定公交有没有停运。在公交站牌附近逗留了很久，没有等到公交，问周围的人也并不清楚，于是打算走到前一站看一看，结果走到一半要等的公交过去了，疯狂追逐没追上，但也因此确认了这趟公交处于运行状态，于是心一狠，走了三站路到了没有修路的公交站点，终于坐上了车，但此时已经11:37了。在这个过程中深刻的体会到了人生地不熟这句话的含义，当然，更重要的一个经验是，如果遇到修路，且无法从周围获得准确信息的情况下，务必不要原地死等。 在张壁古堡附近有一个张壁新村，大部分居民都已经搬到了这里，因此很多人在这里下车，但实际上往前还有一个站点，离古堡更近，我和司机确认后了解到了这一点。门票已经提前在网上买好了，12点的时候终于迈入了景区的大门，当进入景区的时候其实是有点懵的，因为按照原计划是先看到古照壁和七星槐，然后看堡墙，最后到南门，进入南门后进关帝庙，但没想到一进景区就是南门，找了好半天才找到堡墙，原来就是南门旁边一段平平无奇的夯土层，而且关帝庙在南门外正对面，不在南门内，遂决定先入关帝庙。 张壁古堡虽然源自隋唐，但堡内其实大部分是明清建筑，关帝庙自不例外，庙内有正殿一间，偏殿两间，正殿内一尊关羽像，左边是扶刀站立的周仓，右边是抱印的关平，殿内的光线比较阴暗，而塑像又比较逼真，再加上游人稀少，盯久了还有点毛骨悚然的感觉。之前查资料的时候有看到说殿内壁画水平很高，所以特别注意了一下，但由于光线昏暗，只有拿着手机开夜景模式才能看清楚，当当时并不明白壁画描绘的是什么故事，直到回到家才从资料中发现描述的是关羽的生平，偏殿供奉的是何人并不清楚，但也有很棒的壁画，而且光线比较好，肉眼就可以看清楚，壁画绘制了很多普通劳动者和神仙，依然无法辨识剧情。正殿前面相连的有一个亭子，抬头可以看到横梁上写了很多字，但没看清写的什么，亭子前有个小石桌，桌前蹲坐的石猴很有意思。 关帝庙的东院是三眼窑洞，只有中间的一眼窑洞开放，泥包铁神像也正在这里，隔着玻璃，我们可以看到神像外面皲裂的泥土和残留的彩绘，从盘坐的大腿处还能看到里面的铁胎，之前看资料留意到对这尊神像的描述是服饰容貌似佛似道又似儒，但仔细看其实并没看出什么，但服饰确实和平时见到的其它塑像有很大不同。当我在神像前逗留的时候，忽然听到身后有小鸟的叫声，转身后惊讶的发现窑洞顶上竟然住了一窝小燕子，也不知道千百年的神像有这一窝小燕子陪伴有没有变得没那么孤独。 出窑洞右转上台阶，就可以到南门上面的堡墙上，古堡的大部分宗教建筑实际上都在南北堡门上面，在南堡门上面的正是魁星楼、西方圣境殿和可罕庙。魁星楼是一座二层小楼，以此命名的楼阁在很多地方都能见到，主要是祈求功名用的。张壁古堡的魁星楼不大，但是外形很有趣，底下是四方的砖墙，中间是两层挑角的阁楼，顶上是葫芦形宝刹，乍一想八竿子打不着，看起来却很好看。小楼一层供奉魁星，二层供奉文曲星，最难得的是，二层竟然是开放的，但空间比较小，需要弯腰才能从楼梯上去，而且踩上去有吱呀的声音，要小心行走。 从魁星楼回转，南门正上面是西方圣境殿，这一处建筑做攻略的时候并没注意到，但实际观看的时候比较震撼，殿内四墙是密密麻麻的罗汉和菩萨浮雕，正中一尊如来，非常有视觉冲击力。殿前有个琉璃古灯杆，很是漂亮，这里也是古堡的最美观景点之一。圣境殿再往前是古校军场，有很多我们在影视剧中看到的古代军事设施，但不知道是真的古代遗留还是现代仿造，同时在这里又发现了石猴，不知道是不是有什么特别含义。 从古校军场折返，途径西方圣经殿，到魁星楼下面即是可罕王祠，可罕王祠本身是明清建筑，但它对面的古戏台却是元代建筑，这点要注意，另外，可罕王祠正殿塑像背后两幅壁画很有意思，左边是凤凰，但却是人面，右边则是蓝孔雀，真的是勾起了我的好奇心，可惜没人解释。可罕王祠供奉何人其实并没有定论，但此处的介绍却显然指向李世民。王祠是古堡的最高点，三面都有超出堡墙的部分，同时有很多垛口，此时的军事风格才浓郁了起来，然而从靠近城内的一处垛口向下望去，下面的民居正在翻修，那崭新的木头和灰砖，但却复古的建筑风格，会让人不经怀疑这座古堡中的古建筑究竟还剩多少。 古堡最为出名的是地道，地道的入口也在可罕王祠院内，由于疫情游客非常少，但我下地道的时候旁边正好有一家人，估计是本地人或者来过不止一次，得知我一个人来的后，提醒我说下去之后手机没有信号，一定不要乱跑，跟着指示牌走。我嘴上感谢，心里却不以为意，心想就凭我的方向感和空间想象力，等会儿拍张地道地图还不是手到擒来，下去后一定要都走一遍。没想到下去后走了有一段时间真的就迷失了方向，幸亏还没有走进岔道，要不然就真的出不来了，地道里有点阴凉，再加上只有我一人行走，心里是有点害怕的，心里想着我要是真的迷失在里面了要多久才能有人发现，而且这时候孤独感特别严重，心里又想着要是有个一起出来玩的人就好了。 辨认不清方向后，我也就直接放弃了挣扎，安安静静跟随指示牌前行，地道内几乎可以直立通行，所以走起来也不算费劲，沿路看到了马槽、指挥所、伏击窑、士兵窑、水井、俘虏洞等各种各样的军事设施，因为之前去过地道战时期挖的那种地道，所以一开始其实还不以为意，但等到见到的设施种类越来越多，通道越来越复杂，并且空气流通丝毫不成问题，我才意识到了此处地道的高明之处，心里开始对千年前的古人升起敬佩之心。沿着指示牌一直走到将军窑附近的时候，会有一个临时的出口，可以从这里看到古堡四周的一条沟，而最终的出口是古堡的另一条沟，所以在这里全程可以感受张壁古堡作为一座军事堡垒的原因。另外，资料中说古堡的地道分高中低三层，要想出入这3层地道，就必须经过一处特定的交叉口才可到达另一层地道，我在地道中走了许久，感觉自己一直在第一层，不知下面两层是否未开放，另外，出口附近有很多塑像，不知道是古代遗留还是现代建造。 按游览图上的标识，出口附近有一个地道滑道，也不知是游人比较少还是正在修缮，反正滑道暂未开放。接下来，跟着地道出口附近的“前往下一个景点”的指示牌，登上台阶穿过一座座院落，就可以回到古堡的主干道，途中会经过一处布满爬山虎的墙壁，盈盈绿意会为一直以来满眼的土灰色增添一点乐趣，之后还会经过有名的龙鹤福，不过如果不看介绍，这里就是很普通的一处墙壁。 回到主干道后继续向前走，不久就到了槐抱柳，树前的石碑上写着“国槐，树龄1000年”，给人的震撼非常大，书上挂满了祈福的红条，配合春天那满树的新芽，给古树增添了很多色彩，这时候回想起《家族的形式》里面大介假期骑行到山里的时候，学着老年人怀抱古树感受宁静，于是也有股抱一下古树的冲动，可惜周围有人，自己又不够社牛，最终没付诸行动。 槐抱柳的旁边是兴隆寺，这是一个之前查资料的时候没有注意过的地方，入门是一个悬空的弥勒，两侧有四大天王，这时候想起来之前看过的书里提到，中国的寺庙一般从前往后几种不同类型的建筑依次排列，最开始是山门和天王殿，山门里是哼哈二将，天王殿里是四大天王，给人一个下马威，顺利的过了天王殿，一般就是供奉殿，正面的大雄宝殿里面是佛祖如来和十八罗汉等，两侧的偏殿和厢房可能会有弥勒、观音、药食等，再往后则是修行类建筑，是寺众起居的地方，比如禅堂、念佛堂，如果后面还有建筑，则一般是藏经阁。兴隆寺的布局也基本是这个样子，只是由于地方比较小，所有建筑并不是在一条中轴线上，而且只有天王殿、供奉殿和修行类建筑三类，但还是令人大开眼界，主要是现实和刚学到的东西能对应起来，就感到非常开心，所以就不禁想，旅行其实也会受到自身知识储备的影响，自己知道的越多，就能从所游览的地方看到更多的东西， 而不是匆匆一瞥而过，只留下打卡的身影。兴隆寺正殿的院子里还有四个形态各异的小沙弥，非常可爱，忍不住留了个影。 从兴隆寺出来走上主干道，一眼就可以看到北门顶上的真武殿，实际上，空王行祠、真武殿和三大士殿是排列在一起的三座建筑，从右侧拾台阶而上，首先看到的就是空王行祠。空王行祠的琉璃屋顶和门前两侧的孔雀蓝琉璃碑在来之前就充满了期待，屋顶果然很漂亮，但琉璃碑的蓝却不是我想象中那种晶莹剔透的蓝，略有失望。位居正中的真武殿据说是为了留锁风水，保佑堡中百姓安康、风调雨顺，但我注意到的只有门口台阶前的抱鼓小狮，真武殿前是另一处最佳观景点，从近处开满粉色花朵的古树，到不远处苍翠的槐抱柳，再到远方天际线的绵山，构成了一幅层次分明的风景画。真武殿再往前是三大士殿，殿中供奉文殊、普贤、观音三位菩萨，而且这里的壁画据称很有名，可惜我进去的时候四面墙壁均被黄色丝绸遮盖，什么都看不到。从三大士殿折返，经过真武殿和空王行祠，往旁边稍撇一眼可以看到一座小庙，正是吕祖祠，吕祖祠门口有一座袖珍小楼，叫做祈雨楼。这座3米左右的小楼有三层，卯榫结构，雕刻非常精细，上面的小兽栩栩如生，最重要的是，这座小楼是宋金时期的文物，其历史其实要比周围几座明清殿宇要早几百年。 吕祖阁旁边有一段小台阶，下去后就是二郎庙的院子里，这里已经有些游人在歇息，因为正殿封闭没开，我在院子里看了看这里的古戏台随即离开。从二郎庙出去随即就能看到古堡的北门，询问了一下工作人员，得知无法从北门外的道路离开，只能原路返回，于是从龙尾到龙头重新完整走了一次，这时候才发现一路上果然全是丁字路口，又一个被忽略的有意思的设计。 出景区后已经大概14:30了，为了全心中的念想，专门去找了一下古照壁和七","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:2:1","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"Day1 介休城区 回到介休后先在酒店办了入住，稍休息了一会儿，又按捺不住自己的心，打算出去逛一逛，感受一下介休城的烟火气，于是在地图上规划了一条简单的步行路线。一切的开始总是有趣的，我哼着小调，迈着轻快的步伐走向了附近的街巷，此时我惊讶的发现，我走的这条街竟然是从高到底不断往下的，开心的不得了，而且不一会儿我就发现了一个很有意思的景象，同一个路口的东西两边，就好像是一天的不同时刻一样，然后在另一处，又发现马路两边的两栋建筑好像两个不同的时代，果然非常有趣。 当然，这一路上还发现了很多奇奇怪怪的事物，天桥、十字路口、路边的公交，无一不透露这一种特别的美感，也许，发现这些东西也是旅行的快乐之一。 走过上面图片里的奇怪十字路口后，你会误打误撞进入介休城里的古迹之路，一路上从后土庙、老爷庙、城隍庙，一直到终点压轴的袄神楼，每个地方都风采各异，其中给人映像最深的是后土庙和城隍庙那漂亮的屋顶和令人叹为观止的袄神楼的复杂结构。 走到袄神楼的时候才发现自己不知不觉走了那么远，身体的疲劳就像慢了一拍似的才反应了过来，于是急匆匆的去赶最后一班公交回去，正是上面图中那种可爱的小公交。晚上和介休的朋友吃了顿饭，早早回去休息等待第二天的旅程。 ","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:2:2","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"Day2 绵山 早上6:48退房出酒店门口，正好遇上首班公交，开心的不得了，7:37到达景区，7:52景区大巴发车，8:20的时候到了最后一站水涛沟，比预想的要早了很多，来之前总担心一天没法走完绵山景区，现在安心不少。 水涛沟的对外介绍里将这里的景观描述为“十里画廊，叠瀑大观。一条湍流不息的十里水系，大小瀑布近百处，一层层重叠而下，仿佛将光鲜的银丝绸缎不停抖动，形成层层叠叠的瀑布波段。但我其实并没有信，因为景区的夸大宣传简直再寻常不过了，没想到到了现场后发现这段描述竟然是写实，整条水系在平缓处清澈见底，潺潺流动，遇到落差则呈现出奔放的一面，流速瞬间变快，争着抢着往下跳去，然后在岩石上击打出一阵阵水花，水的颜色也变成了乳白，白的透亮，你的脑海里不由自主就会浮现出“甘甜清冽”这个词来，忍不住想去喝一口。 水涛沟的小瀑布有趣之处还在于每一处由于落差不同，水花碰撞的石头形状不同，导致瀑布呈现各种各异的姿态，一路往上，欣赏这种万千的姿态也是一件乐事。另外，十里水系湍流不息的含义还在于从起点到终点，你眼中的瀑布永远不会消失，短则两三米，长则数十米，总会看到下一处瀑布，当然，溪水流动的声音和瀑布水花飞溅的声音也就会时时萦绕在你的耳朵里。 大家说从水涛沟入口走到终点水帘洞来回约3小时，因此原计划打算只走到五龙瀑就返回，但没想到天有不测风云，五龙瀑由于山洪堵塞断流，景区工作人员正在清理，看了看时间，发现还早，于是心一狠走到了终点的水帘洞，水帘洞的瀑布并没有想象中大，但水流很急，我又没有当年孙大圣的勇气，因此没能进入瀑布后面的洞内，只好遗憾而去。返程的速度要快一点，只花了半个小时，10点就回到了出口，比半路返回的计划还提前了半小时。 从下车的地方买票乘缆车上了介公岭，这段路线很有意思，从缆车起点只能看到一对柱子和一个小山尖，你心里会不禁疑惑就这么点距离还需要坐缆车吗，但当翻过那个小山尖，眼前就是从远到近密密麻麻的吊箱，视野从极小到极大，会给人一种很大的冲击力，同时入眼的是满山初春时节那种充满生命力的翠绿色，脚下还有掩映在树木间的房屋院落，氛围感一下子就有了，会让人觉得不虚此行。不过，吊箱本身时不时晃动一下，还发出吱吱呀呀的声音，一路上都在担心会不会掉下去，这是自前一天在张壁古堡地道后第二次希望身边有个人，但脑子里又不禁想到，如果真的是两个人坐缆车，这种情况下会不会产生吊桥效应，总之就是一直胡思乱想，然后期盼着赶紧到达山顶。 到达山顶后沿着唯一的小道一路向前就可以达到介公墓，介公墓比较荒凉，四周布满了各种碑石和石像，其中两只石猪形象比较有意思，去的朋友可以注意一下。简单拜祭后开始下山，下山后要注意看指示牌，没有走错路的情况下，在半山腰可以找到介神庙。介神庙是我国最大的石窟祠，整体位于山体内，远观非常震撼，同时在这里你会初步体会到在峭壁边行走的感觉，整个绵山大部分景点都是这样修在山间的，这种路之后会有更多。 从介神庙返回继续下山，走很久会到栖贤谷的终点，是的，由于我们是下山，会先到终点，然后逆着往回走。如果是普通的景点，这倒也无所谓，但栖贤谷是一道蜿蜒而上、九曲一线天的狭谷，两边怪石嶙峋，少有草木，落脚之处唯有嵌入山体的铁质脚踏和偶尔可见的悬梯，有些路段还有水流飞溅，导致悬梯打滑，这种路线即使是从下往上攀登都很困难，何论从上往下，这也是我第一次后悔选择下山路线。但整条路线走完，得见真正的栖贤谷建筑的时候，你会恍惚间有种见到世外隐居之地的感觉，所以也不能说是毫无益处。 我在栖贤谷休息了好一会儿，一方面是感受在世外桃源隐居的感觉，一方面也恢复一下体力，随后就乘景区大巴到了下一个景点，正果寺。这一次依然选择了乘电梯上山，然后慢慢下山的路线，也是第二次后悔。 正果寺本身除了佛道共存的几尊包骨真身像，以及旁边灵应塔的幽暗地宫，并无太多值得关注之处，但从正果寺到云峰寺的路上，可谓是步步惊心。事实上，我乘电梯上去的时候售票的阿姨就提醒，如果恐高的话，就再坐电梯下去，不要步行下山，但我就想先看看有多可怕，结果走了很久才到云峰寺的顶上，而且当我发现自己必须从一段峭壁间的栈道下山的时候，已经陷入了进退两难的囧境，因为回去也还要走好久。我的腿有点软，于是坐在山顶的台阶上吹着风先吃了点东西补充能量，然后鼓起勇气拽着铁索一级一级的往下挪，就这样走完了全程。但你知道吧，绵山就爱搞这些柳暗花明又一村的东西，介公岭的缆车是，栖贤谷的悬梯是，云峰寺也是。你还没有从回望云峰栈道的惊恐中缓过神来，耳朵里就已经传来了云峰寺山间那铃铛的清响。看过《航拍中国》第三季山西篇的人大概还记得，工人从山顶悬吊下来，一晃一晃，最终将铃铛挂在山间的场景，而此时，我终于亲耳听到了它们的声音。 我在云峰寺的山腰坐了很久，这一天正好大风，那些铃铛的清响一刻不停，彷佛把我带到了它们当初悬挂的现场，同时我也录了好几段视频，只为了留住这些声音。此时云峰寺的庙宇，甚至空王古佛的包骨真身像都已经不重要了，我来这里就是为了这一幕，而我亦得偿所愿。下山的时候在第一级台阶前还遇到一尊很有喜感的石像，不知是龙生九子中的哪一位，但非常喜欢。 此行最大的心愿完成后，随后的旅程似乎变得有些轻快起来，我和一起乘大巴的一家子、一对情侣一起游览了一斗泉，然而因为找不到路，只有我和那一家人一路向上走到了天桥，那对情侣则和我们失散，原路返回重新从天桥景区的起点网上爬。在大罗宫又遇到了当初在介神庙向我问路的中年夫妻，这次他们没有半途而费，完完整整走完了大罗宫的六层。朱家凹和蜂房泉被我跳过，返回起点的龙头寺后，再无游览的兴致，于是乘车返回，出景区的时候连四点都还没到，但此行已再无遗憾。 ","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:2:3","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["我所热爱的生活啊"],"content":"旅行总结 04.30 上午到达介休，05.01 晚上从介休离开，两天时间，累计花费450左右，比预想少了很多。游览了两处景点一个城市，行走了接近35公里，看到很多好玩的东西，也有了很多新奇的体验，缓解了我最近不太好的心情，总体非常满意。 ","date":"2022-05-04","objectID":"/2022/mianshan-scenic-area-and-zhangbi-castle/:3:0","tags":["旅行记录"],"title":"绵山及张壁古堡","uri":"/2022/mianshan-scenic-area-and-zhangbi-castle/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第十二期月刊，2022 年 04 月。 ","date":"2022-04-29","objectID":"/2022/life-monthly-12/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 12 期 (202204)","uri":"/2022/life-monthly-12/"},{"categories":["日程及周刊"],"content":"新闻 1、4月14日，大秦铁路翠屏山线有货运火车脱轨 央视新闻4月14日消息，当日13时左右，在大秦铁路翠屏山站（位于天津市蓟州区）停放的货车车辆发生溜逸，与运行中的货物列车相撞造成17辆货车脱线，其中11辆坠落铁路桥下，导致大秦铁路中断行车，无人员伤亡。链接 【评论】很久没看到火车出事的新闻了，瞬间有点震惊。 2、4月19日，一条抹香鲸在宁波海域搁浅 4月19日上午8时许，浙江省象山县石浦镇半边山海域，渔民发现一条体长超过10米的抹香鲸搁浅。当地渔政和水生野生动物救助中心的人员立刻赶往现场。4月20日，经过长达20小时接力救援，在渔政船的牵引和护航下，在浙江宁波象山海域搁浅的抹香鲸终于成功放回大海。链接 【评论】为什么我每次都对这种新闻没有抵抗力 ","date":"2022-04-29","objectID":"/2022/life-monthly-12/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 12 期 (202204)","uri":"/2022/life-monthly-12/"},{"categories":["日程及周刊"],"content":"生活 04.03，闲逛的一天 午饭尝试了家家利附近的砂锅香菇鸡肉面，很棒； 电影院看电影《神秘海域》 发现一家唐狮，进去看了看无帽卫衣； 路边看到糖葫芦，买了个猕猴桃夹心的 到双合成店里兑换了蛋糕券 南山南路发现一家书吧 到盛大驾校报名处询问考驾照的相关信息 晚饭点了一份很贵的鸡公煲，带回去吃结果包装裂了，毁了机械键盘和一身最爱的衣服，清理了一晚上，破坏了一天的好心情 04.04，晾干的键盘恢复使用了，衣服也洗干净了，有点开心，都救回来了 04.05，最终还是不敢手洗那件贼贵的羊绒衫，送去了洗衣店，晚上和夏福良、刘家懿斗地主，单位就剩我们仨 04.06，去政务大厅取核准批复，意外发现一条新的去金谷广场的路，近了很多 04.14，因清徐物流园疫情爆发，开始在宿舍隔离 04.16，宿舍点外卖吃烧烤，真香 04.18，早饭吃了三块蝴蝶酥，不是很喜欢，但是君乐宝酸奶很棒，下次还可以买 04.19，做完《原神》容彩祭活动，为什么有点疲惫了，做的时候并没有很开心 04.21，解封，开始上班 04.22，和吉策聊天 04.24，阳光花园的水煮肉片麻辣烫店（卖的是麻辣烫，店名是水煮肉片），鸡肉和牛肉锅底都很好吃，撑到走不动路 04.25，又是闲逛的一个周末，逛了之前注意到的一家袜子专卖店，买了最爱的酸奶和果冻 04.28，刚产生的好感被掐死，谁知道人家有对象呢，心里有点堵 ","date":"2022-04-29","objectID":"/2022/life-monthly-12/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 12 期 (202204)","uri":"/2022/life-monthly-12/"},{"categories":["日程及周刊"],"content":"观影 04.03，电影院观影《神秘海域》，好莱坞流水线水准，没有惊喜，但可以看。 04.04-04.10，日剧《不能结婚的男人》，停留在收藏夹很久，之前尝试过，但第一集都没看完，这一次终于看完了，看宽叔和医生的终极对线太开心了 04.09，宿舍观影《狙击手》，有谁能想到，班长是《我不是药神》里的黄毛呢 04.16-04.17，国产短剧《念念无明》，逻辑自洽的高甜优秀国产剧集，被B站安利而来，也不知道是营销还是自来水，但是确实吸引到我了。不过，隔了这么久重新开始看国产剧，结果看的是一部狗粮剧，这说明了什么呢，更离谱的是我在豆瓣找了半天没找到同时出现男女主正脸的剧照。 04.16，宿舍观影《亚当计划》，也是很早关注的一部片子，但没有惊喜，瑞安·雷诺兹当主演的电影看之前都能想到是什么风格，我就不该抱太大期望。 04.20-04.21，《航拍中国》S03的山西篇和山东篇，前者是疫情期间只能在省内活动，看一下有哪些可去的地方，后者是去年去过的地方，回忆一下。 ","date":"2022-04-29","objectID":"/2022/life-monthly-12/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 12 期 (202204)","uri":"/2022/life-monthly-12/"},{"categories":["日程及周刊"],"content":"阅读 1、《如何阅读一本书》，作者是莫提默·艾德勒和查尔斯·范多伦，按这本书里教的方法看它自己，但还没看完 2、张克群的《中国古建筑小讲》，为了出去玩的时候能看懂建筑选的书，写的很有意思，五一去介休实践一下 ","date":"2022-04-29","objectID":"/2022/life-monthly-12/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 12 期 (202204)","uri":"/2022/life-monthly-12/"},{"categories":["日程及周刊"],"content":"收藏 【知识】村中开己纸模，惊叹绝伦，想不到纸模能做到这种地步 【软件】pangu.js，可以在中英文中间加空格，是想了很久的东西 【书籍】《赤脚医生手册》、《民兵训练手册》、《军地两用人才之友》，号称三大神书，能在核战后迅速恢复文明 【软件】caxa cad电子图板，看CAD的线路图太好用了 【知识】豆瓣公墓小组，很有意思的小组 【知识】jeff，健身大神，B站有视频，介绍健身时会讲解涉及的肌肉 【知识】胃寒可以喝姜糖茶 ","date":"2022-04-29","objectID":"/2022/life-monthly-12/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 12 期 (202204)","uri":"/2022/life-monthly-12/"},{"categories":["日程及周刊"],"content":"思考 可以用什么替代可乐呢 重要的不是事情做多快，而是在其中感受整个过程，同样，极简并不是目的，目的是享受生活 如果躺着感觉是在浪费时间，那么就起来好了 生命中的每一霎瞬间，都是向永恒借来的片羽 ","date":"2022-04-29","objectID":"/2022/life-monthly-12/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 12 期 (202204)","uri":"/2022/life-monthly-12/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 对账 月刊完成 ","date":"2022-04-29","objectID":"/2022/life-monthly-12/:7:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 12 期 (202204)","uri":"/2022/life-monthly-12/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第十一期月刊，2022 年 03 月。 ","date":"2022-03-31","objectID":"/2022/life-monthly-11/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 11 期 (202203)","uri":"/2022/life-monthly-11/"},{"categories":["日程及周刊"],"content":"新闻 1、东航飞机坠毁 3月21日，东方航空公司MU5735航班在广西梧州藤县坠毁，机上载有乘客123人、机组人员9人，全部遇难。 ","date":"2022-03-31","objectID":"/2022/life-monthly-11/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 11 期 (202203)","uri":"/2022/life-monthly-11/"},{"categories":["日程及周刊"],"content":"生活 03.03，拔掉两颗智齿 03.12，在一家新开的店（H\u0026G）买了一件衬衫和一条裤子，都是夏天穿的 03.16，整理家里的旧衣物捐赠，一共60kg，都给了白鲸鱼 03.18，洗牙，第一次且选了最便宜的，有点酸痛 03.20，太谷解封，返回单位 03.22，工资卡更换，第一次办了工商银行的卡，特地选了一张卡面是小老虎的 03.26，拍摄证件照、购买打折半袖、终于换掉了一直想换的洗漱包，午饭和吉策一起吃的炮仗面，晚饭一起吃的麻辣拌 03.27，成功重装并运行了ERP系统，以后不用去办公室查投资了，完善和吉策沿箕城街向西，然后进入南山南路，至杨老太烧饼，晚饭后返回 03.29，晚上和吉策散步至农大返回 03.30，晚上和吉策散步至农大返回 03.31，晚上和吉策沿铁路线散步至杨老太烧饼，沿27号的路线相反方向返回 ","date":"2022-03-31","objectID":"/2022/life-monthly-11/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 11 期 (202203)","uri":"/2022/life-monthly-11/"},{"categories":["日程及周刊"],"content":"观影 03.07，电影《游戏之夜》，一般。 03.09，阿根廷电影《极盗行动》，根据真实事件改编，很棒。 03.10-0314，美剧《上载新生》S01和S02，设定很棒，但剧情有点扯 03.13，电影《蜘蛛侠：英雄无归》，三代蜘蛛侠同框这个宣传卖点总算不是噱头，很棒。 03.18-03.27，纪录片《新人生七年》，一个人的成长会受多少影响，不同环境的人又会有怎样的人生轨迹，这部纪录片给我的映像非常深刻，最重要的是七年更新一次，怕不是有生之年系列 03.27，电影《雄狮少年》，看得出导演想表达一些东西，但又遮遮掩掩不敢说，只敢点一下，还有，很难理解当初说这部动画辱华的人的脑子 03.30-03.31，纪录片《航拍中国》S01E01-E03，整体很好，画质比较差，而且说实话，没太用心看 ","date":"2022-03-31","objectID":"/2022/life-monthly-11/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 11 期 (202203)","uri":"/2022/life-monthly-11/"},{"categories":["日程及周刊"],"content":"收藏 【软件】obs studio和bandicam，两个视频录制软件 【商品】挂在窗外的蔬菜种植袋，《上载新生》S01E08里女主家里出现的，很有趣的东西 【软件】皓宸CAD看图王，看CAD图纸很方便 【商品】粘毛器 【软件】travelboast，旅行地图 ","date":"2022-03-31","objectID":"/2022/life-monthly-11/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 11 期 (202203)","uri":"/2022/life-monthly-11/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 对账 月刊完成 ","date":"2022-03-31","objectID":"/2022/life-monthly-11/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 11 期 (202203)","uri":"/2022/life-monthly-11/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第十期月刊，2022 年 02 月。 ","date":"2022-02-28","objectID":"/2022/life-monthly-10/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 10 期 (202202)","uri":"/2022/life-monthly-10/"},{"categories":["日程及周刊"],"content":"新闻 1、北京冬奥会圆满闭幕 从2月4号到2月20日，北京冬奥会持续了17天，吸引了无数人的注意，也让非常多的冰雪项目和运动员为人熟知，2月20日晚，北京冬奥会闭幕式圆满完成，标志着这一盛事走向了结束。 2、俄乌战争爆发 2月24日俄罗斯总统普京决定在顿巴斯地区进行特别军事行动，同日俄乌战争开始，这一场战争牵动了整个世界的人的注意力，在后疫情时代，这场战争可能会对未来产生深远的影响。 ","date":"2022-02-28","objectID":"/2022/life-monthly-10/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 10 期 (202202)","uri":"/2022/life-monthly-10/"},{"categories":["日程及周刊"],"content":"生活 02.01，新年到 02.05，高中同学聚会 02.06，年假结束，返回单位，街上很多店还没有开 02.12，前往平遥游览平遥古城 02.20，太谷区疫情爆发，隔离在家。 ","date":"2022-02-28","objectID":"/2022/life-monthly-10/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 10 期 (202202)","uri":"/2022/life-monthly-10/"},{"categories":["日程及周刊"],"content":"观影 02.02，在家观看电影《长津湖》，02.07在电影院观看《长津湖之水门桥》，对先辈致以诚挚的敬意 02.17，电视剧《开端》E13-E15，大结局啦。 02.22—02.23，纪录片《约翰威尔逊的十万个怎么做》，一个纯粹的未经美化的生活，一个普通人对世界的思考和各种矛盾的挣扎 02.23—02.24，日剧《三年A班：从现在起，大家都是人质》，关于网络时代社会问题的剧，很棒。 02.27，动漫电影《寻龙传说》，很一般的迪士尼动画。 ","date":"2022-02-28","objectID":"/2022/life-monthly-10/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 10 期 (202202)","uri":"/2022/life-monthly-10/"},{"categories":["日程及周刊"],"content":"收藏 【软件】竹白，用于创建newsletter ","date":"2022-02-28","objectID":"/2022/life-monthly-10/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 10 期 (202202)","uri":"/2022/life-monthly-10/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 照片备份 录音整理 浏览器书签备份 对账 月刊完成 ","date":"2022-02-28","objectID":"/2022/life-monthly-10/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 10 期 (202202)","uri":"/2022/life-monthly-10/"},{"categories":["国网的咸鱼生活"],"content":"应工作需要，收集整理和理解电缆的种类、型号和结构。 ","date":"2022-02-26","objectID":"/2022/detailed-cable-model/:0:0","tags":["国网"],"title":"电缆型号详解","uri":"/2022/detailed-cable-model/"},{"categories":["国网的咸鱼生活"],"content":"1. 电缆的种类 电缆从基本结构上分，主要有三部分组成：一是导电线芯，用于传输电能；二是绝缘层，保证电能沿导电线芯传输，在电气上使导电体与外界隔离；三是保护层，起保护密封作用，使绝缘层不受外界潮气浸入，不受外界损伤，保持绝缘性能。 电力电缆有多种分类方法，如 按电压等级分类：电缆都是按一定电压等级制造的，电压等级依次为：0.5、1、3、6、10、20、35、60、110、220、330kV。 按导电线芯截面积分类：我国电力电缆导电线芯标称截面系列为：2.5、4、6、10、16、25、35、50、70、95、120、150、185、240、300、400、500、625、800mm2，共19种。 按导电线芯数分类：电力电缆导电线芯数有单芯、二芯、三芯、四芯、五芯。单芯电缆通常用于传送单相交流电、直流电。二芯电缆多用于传送单相交流电或直流电。三芯电缆主要用于三相交流电网中，在35kV及以下的各种电缆线路中得到广泛的应用。四芯电缆多用于低压配电线路、中性点接地的三相四线制系统（四芯电缆的第四芯截面积通常为主线芯截面积的40%～60%）。只有电压等级为1kV的电缆才有二芯和四芯。 按绝缘材料分类：分为塑料绝缘电缆、橡皮绝缘电缆、阻燃聚氯乙烯绝缘电缆和油浸纸绝缘电力电缆。 ","date":"2022-02-26","objectID":"/2022/detailed-cable-model/:1:0","tags":["国网"],"title":"电缆型号详解","uri":"/2022/detailed-cable-model/"},{"categories":["国网的咸鱼生活"],"content":"2. 电缆的组成 ","date":"2022-02-26","objectID":"/2022/detailed-cable-model/:2:0","tags":["国网"],"title":"电缆型号详解","uri":"/2022/detailed-cable-model/"},{"categories":["国网的咸鱼生活"],"content":"导体 电缆的导体通常用导电性好、有一定韧性、一定强度的高纯度铜或铝制成。较小截面（16mm2以下）的导体由单根导线制成，较大截面（16mm2及以上）的导体由多根导线分数层绞合制成，绞合时相邻两层扭绞方向相反。 ","date":"2022-02-26","objectID":"/2022/detailed-cable-model/:2:1","tags":["国网"],"title":"电缆型号详解","uri":"/2022/detailed-cable-model/"},{"categories":["国网的咸鱼生活"],"content":"绝缘层 电缆的绝缘层用来使多芯导体间及导体与护套间相互隔离，并保证一定的电气耐压强度。它应有一定的耐热性能和稳定的绝缘质量。 绝缘层的材料主要有油浸电缆纸、塑料和橡胶三种，现将三种电缆绝缘层的结构及特点分述如下。 塑料绝缘：塑料绝缘主要有聚氯乙烯绝缘和交联聚乙烯绝缘两种，电缆绝缘层分别由热塑性塑料挤包制成和由添加交联剂的热塑性聚乙烯塑料挤包后交联制成。这种绝缘电气性能及耐水性能良好，能抗酸、碱，防腐蚀，它还具有允许工作温度高、机械性能好、可制造高电压电缆等优点。 橡胶绝缘：橡胶绝缘电力电缆的绝缘层为丁苯橡胶或人工合成橡胶（乙丙橡胶、丁基橡胶）。这种电缆突出的优点是柔软，可挠性好，特别适用于移动性的用电和供电的装置。但是橡胶绝缘遇到油类时会很快损坏；在高电压作用下，容易受电晕作用产生龟裂。因此这种电缆一般用于10kV及以下电压等级，人工合成的乙丙橡胶绝缘电缆可用到35kV电压级。 油浸纸绝缘：油浸纸绝缘由电缆纸与浸渍剂组合而成。普通油浸纸绝缘电缆纸的厚度为0.08、0.12、0.17mm三种；浸渍剂用低压电缆油和松香混合而成，称谓黏性浸渍电缆油。 ","date":"2022-02-26","objectID":"/2022/detailed-cable-model/:2:2","tags":["国网"],"title":"电缆型号详解","uri":"/2022/detailed-cable-model/"},{"categories":["国网的咸鱼生活"],"content":"电缆护层 为了使电缆绝缘不受损伤，并满足各种使用条件和环境的要求，在电缆绝缘层外包覆有保护层，叫做电缆护层。电缆护层分为内护层和外护层。 内护层是包覆在电缆绝缘上的保护覆盖层，用以防止绝缘层受潮、机械损伤以及光和化学侵蚀性媒质等的作用，同时还可以流过短路电流。内护层有金属的铅护套、平铝护套、皱纹铝护套、铜护套、综合护套，以及非金属的塑料护套、橡胶护套等。金属护套多用于油浸纸绝缘电缆和110kV及以上的交联聚乙烯绝缘电力电缆；塑料护套（特别是聚氯乙烯护套）可用于各种塑料绝缘电缆，如聚氯乙烯绝缘电缆和35kV及以下交联聚乙烯绝缘电缆的内护层为聚氯乙烯护套或聚乙烯护套；橡胶护套一般多用于橡胶绝缘电缆。 外护层是包覆在电缆护套（内护层）外面的保护覆盖层，主要起机械加强和防腐蚀作用。常用电缆有内护层为金属护层的外护层和内护层为塑料护套的外护层。金属护套的外护层一般由衬垫层、铠装层和外被层三部分组成。衬垫层位于金属护套与铠装层之间，起铠装衬垫和金属护层防腐蚀作用。铠装层为金属带或金属丝，主要起机械保护作用，金属丝可承受拉力。外被层在铠装层外，对金属铠装起防腐蚀作用。衬垫层及外被层由沥青、聚氯乙烯带、浸渍纸、聚氯乙烯或聚乙烯护套等材料组成。根据各种电缆使用的环境和条件不同，其外护层的组成结构也各异。内护层为塑料护套的外护层的结构有两种。一种是无外护层而仅有聚氯乙烯（PVC）或聚乙烯护套；另一种是铠装层外还挤包了PVC套或聚乙烯套，其厚度与内护套相同。传统的PVC外护套因PVC的工作温度较低，对于运行温度高且有护层绝缘要求的高压交联聚乙烯（XLPE）电缆已不太适合，所以现采用高密度聚乙烯（HDPE）或低密度聚乙烯（LLDPE）作外护层已很普遍，但无阻燃性，明敷设时要考虑防火措施或采用阻燃型电缆。使用HDPE作外护层可提高护层的绝缘水平，外护套与皱纹金属套间应有黏结剂。 ","date":"2022-02-26","objectID":"/2022/detailed-cable-model/:2:3","tags":["国网"],"title":"电缆型号详解","uri":"/2022/detailed-cable-model/"},{"categories":["国网的咸鱼生活"],"content":"3. 电缆的型号 用汉语拼音第一个或前两个字母的大写表示导体材料、绝缘种类、内护层材料和结构特点。如用 Z 代表纸（zhi）；L代表铝（lv）；ZR代表阻燃（zuran）；NH代表耐火（naihuo）。常用各种代号含义如下表 导体材料 绝缘种类 内护层 铠装层 外被层 T：铜 V：聚氯乙烯 V：聚氯乙烯护套 0：无 0：无 TR：软铜导体 X：橡胶 Y：聚乙烯护套 2：双钢管 1：纤维外被 L：铝 Y：聚乙烯 L：铝护套 3：细钢丝 2：聚氯乙烯 YJ：交联聚乙烯 Q：铅护套 4：粗钢丝 3：聚乙烯 Z：纸 H：橡胶护套 F：氯丁橡胶护套 敷设电缆用型号-额定电压-规格-国家标准编号。其中，型号按电缆结构排列，一般依下列次序：绝缘材料 导体材料 内护层 外护层，外护层用两位数字表示，第一位数表示铠装，第二位数表示外被。型号后再加上说明额定电压、芯数和标称截面积的阿拉伯数字。举例如下，第1、2种为设计方案常见电缆型号 YJV32-1 3×150表示铜芯、交联聚乙烯绝缘、细钢丝铠装、聚氯乙烯护套、额定电压1kV、三芯、标称截面积为150mm2的电力电缆。 ZC-YJV22-3*400，阻燃C类、铜芯、交联聚乙烯绝缘、聚氯乙烯护套，3芯，标称截面400mm2 VV42—10 3×50表示铜芯、聚氯乙烯绝缘、粗钢丝铠装、聚氯乙烯护套、额定电压10kV、三芯、标称截面积为50mm2的电力电缆。 ZLQ02—10 3×70表示铝芯、纸绝缘、铅护套、无铠装、聚氯乙烯护套、额定电压10kV、三芯、标称截面积为70mm2的电力电缆。 架空电缆以 JK 开头，表示方法为：型号-额定电压 芯数×标称截面 国家标准编号，架空电缆的导体材料中除上表外，还常见铝合金（LH）和钢芯加强铝芯（LG），设计方案种几种常见架空电缆型号解释如下 JKLGYJ-240，钢芯加强铝芯交联聚乙烯绝缘架空电缆，标称截面 240mm2 JKLYJ-70，铝芯交联聚乙烯绝缘架空电缆，标称截面70mm2 在关于旧线路的描述中常涉及裸导线，其表示方法如下：铜用字母“T”表示；铝用“L”表示；钢用“G”表示；硬型材料用“Y”表示；软型材料用“R”表示；绞合电线用“J”表示；界面用数字表示；单线线径用“Ф”表示。其中裸绞线是将多根圆单线绞合在一起的绞合线，这种导线较软并有足够的强度、架空电力线、电缆芯线大都采用绞合线，其股数和单股直径的表示方法是将股数和直径写在一起，如7×2.11表示7股直径为2.11mm的单线交合而成。架空线路中常用的绞线有LJ型硬铝绞线，LGJ钢芯铝绞线及TJ型硬铜绞线。LJ和TJ主要用于低压及高压架空输电，LGJ主要用于提高拉力强度的架空输电线路。设计方案中常见型号如下 LGJ-95：钢芯铝绞线，后面的数字是标称截面 参考： 额定电压1 kV及以下架空绝缘电缆：国家标准|GB/T 12527-2008 额定电压10kV架空绝缘电缆：国家标准|GB/T 14049-2008 陈蕾. 电缆图表手册（第二版）[M]. 中国水利水电出版社. 2014-01. ","date":"2022-02-26","objectID":"/2022/detailed-cable-model/:3:0","tags":["国网"],"title":"电缆型号详解","uri":"/2022/detailed-cable-model/"},{"categories":["我所热爱的生活啊"],"content":"「独立」是个多么有诱惑力的词啊，即使现在提起来也依然抑制不住的心潮澎湃。穷人家却从小被父母告知“不需要关心其它事情，只要专心学习就好”的朋友应该最能理解这种渴望，一方面由于经济窘迫体谅父母所以啥也不敢买，只能不断压抑自己的渴望，内心却无比憧憬着能经济独立，另一方面又由于父母太过关爱导致生活技能极度匮乏，所以心里同时还期望着生活上能独当一面。 有些人在上大学后水阔凭鱼跃，敢闯敢试从此成为一个独立的人，另外一些像我一样的人，由于怯懦的性子，手里死死攥住已有的那点可怜的东西，一直不敢展翅高飞，虽然年龄上早已步入成人，精神却永远困在了父母身边。但，人总是要成长的吧，一旦有了念头，行动就不远了。之前我从衣物开始迈出了个人独立计划的第一步，也是在我派写文章的开始，后来又完成了《安全感提升》系列文章，现在，终于将目光指向了个人独立的另一个重要方面：疾病和医药。 文中没加引用，但文末有参考文献，大部分知识来自于国家药品监督管理局等权威网站和相关教科书。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:0:0","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"常见疾病了解 小时候觉得妈妈很厉害，一看就知道我生了什么病该吃什么药，家里总是备着满满一抽屉的药，这一度让我在大学时都感觉自己是个废物，因为连自己是不是感冒了都分辨不出来，更别说吃什么药了。后来才意识到，这种事要么是久病成医，要么需要自己主动去学习，所以去看了不少的资料。 当时想的是，就从平时经常听到的开始了解吧，像什么感冒、发烧、肚子痛啦，还有什么糖尿病、高血压、高血脂等等，头脑风暴列了一个类似于下面词云图一样的单子。后来想了想，把这些疾病分了两类，一类是感冒、发烧这种，算是给自己考虑，需要了解一下症状和用药，另一类是高血压、糖尿病这种，是给父母老人考虑，了解一下大致症状和严重性就行。 高血压这类疾病随后再做知识储备，但其它的常见疾病，比如感冒，一年怎么说也要有几回，学了这点东西，再自个儿买几次药，也就大致熟悉了。写到这里就突然想到，父母当初估计就是这么过来的，甚至他们都省去了主动学习的过程，直接就是久病成医，每次记下医生开的药，多来几次就熟了，而医学生的学习也是先抱着课本学一大堆的基础知识，看大量的案例，实习的时候再经历一些，最后在行医过程中不断增长经验，所以对自己莫名有了点信心，不至于拿着药不敢用。但还是要提一句，我自己在这上面付出的精力必然不如专业的人，所以各位学医和学药的朋友如果看到不对的地方，请及时指出来，免得给其它朋友造成误导。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:1:0","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"感冒 感冒算是最最常见的疾病了，一旦我们有个头疼脑热、打冷颤、流鼻涕之类的症状，一般就会说感冒了，但是感冒有很多类型，比如我们平常经常听到的风寒感冒、风热感冒、流行性感冒（流感）等，这些又怎么辨别呢？ 通过阅读资料我们知道，风寒感冒和风热感冒是中医的说法，类似的还有暑湿感冒和气虚感冒，流感则是西医的说法，是一种病毒引起的急性呼吸道传染病。但是，出于某种不可知的力量，大家生活里还是习惯把这三者混在一起来归类，只要遇到感冒，就会不自觉的想，”这是风寒、风热，还是流感啊“，也没啥不行。 流感是传染病，这是大家熟知的，甭管咳嗽、打喷嚏，都能传染给别人，且传染性非常强，尤其是冬春季，只要身边有一个人得了流感，很快身边就会出现一堆得了流感的人。但季节不是流感的标签，咳嗽打喷嚏也不是流感的专利，那总不能通过有没有感染身边的人来判断吧，所以我们要注意下面几件事，如果有，大概率是流感。 起病是不是比较急，突然发热，且高至38~41℃； 全身酸痛，明显乏力，食欲下降； 轻度的呼吸道症状，如咽痛或持续性咳嗽，有时伴有眼干眼痛。 流感和风热对我自己而言有些难以区分，因为风热感冒的症状有些和它有点像，书上说风热感冒发热较重，微恶风寒，鼻塞流黄浊涕，头痛，目涨，咽痛，或有咳嗽。我个人更愿意从体温和身体情况两个方面来区分，如果突然高烧、全身乏力，则判断为流感，如果发烧没那么重，全身也不是很酸痛乏力，症状较轻，则认为是风热。当然了，这个显得有点武断，在生活中，如果症状比较轻，比如就是很单纯的流个鼻涕、打个喷嚏，没人想着吃药和看医生，但如果发了高烧，则会感觉去诊所看医生买药，所以其实自己的判断主要起个辅助作用，最后还是看药店或诊所值班医生的判断。相比之下，风寒感冒就显得格格不入了，各种症状都比较特立独行，一眼就能看出来，比如人家另外两种感冒发热重，它不发热或发热很轻，人家流黄浊涕，它流清涕，人家舌苔黄腻，它舌苔薄白，所以这里不多介绍它，就像听话的孩子得到的关注总是最少。 如果得了流感，你大概率是被传染的，但如果是普通感冒，一般是受凉、着雨、过度疲劳，从而抵抗力下降而导致的，因为普通感冒虽然也有可能传染，但传染的概率真的很低很低。所以盲生你这里发现华点了吗，如果有人提醒你”别着凉了，万一感冒了咋办“，这里提到的感冒不是流感，而是普通感冒，你们说我这么大个人了，以前咋就不知道这个呢！ 普通感冒没有特效的治疗药，这是一个很热的冷知识。得了普通感冒，只要注意休息、多喝水，常开窗透透气，一般5～7天左右即可自愈，但为了减轻症状，缩短病程，也可以选用一些对症治疗的药物。比如头痛、头晕、全身肌肉酸痛，可选用解热镇痛药：对乙酰氨基酚、阿司匹林、布洛芬等；鼻塞、流清鼻涕都遵照医嘱用药。还有一些复方制剂，比如风寒感冒颗粒、感冒清热颗粒、正柴胡饮颗粒等主治风寒感冒，清热解毒口服液、小柴胡颗粒等主治风热感冒。但这么多的药，就算明明白白写在这里了，一些大佬在文章或视频里信誓旦旦的保证过，我还是不敢乱用，所以除了对乙酰氨基酚和布洛芬这种应急的退烧止痛药，剩下的还是安心听医生的话吧，也不急于一时，最多就是耽搁一个晚上。 流感在出现症状的早期有相对特效的抗病毒药，据研究显示，流感发生后24小时内服用奥司他韦的患者，病程会减短30%~40%，病情会减轻25%，而服药时间超过48小时，则对病情的改善作用较小，所以家里或许可以常备一盒磷酸奥司他韦颗粒。另外，什么双黄连、板蓝根、连花清瘟胶囊等中药或复方制剂，都可改善流感症状，促进流感恢复，但这些都用的时候买就行，不需要事先储备。 最后，小时候可能父母经常给吃阿奇霉素，但抗生素只对细菌有杀灭或抑制作用，对感冒病毒无能为力。感冒一开始就服用抗生素，不但对治疗无益，还会引起药物不良反应和细菌耐药性的产生，使用抗生素一定要听从医生建议。至于书籍和视频里经常提到的流感患者应停止工作和学习，在家中隔离，充分休息的同时也可避免流感传播，这个就不强调了，因为在现有国情下，这句话无异于空谈，还是平时多锻炼增强抵抗力，患病时积极戴口罩防止感染他人比较靠谱和有可行性。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:1:1","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"上火 中国人的生活简直离不了上火两个字，吃个火锅会上火，不吃蔬菜会上火，熬夜上火，压力大也会上火，彷佛做啥都能和上火扯上关系。与之相对的，各种下火的食物就备受人们喜爱，绿豆汤、冬瓜汤、苦瓜、梨、柚子，犹记得小时候上火妈妈总是买几瓶梨罐头，现在变了，每次都买几颗柚子，我感觉自己的水果喜好都是我妈培养起来的。 上火当然也是中医的说法，辨识上火的典型症状包括口唇起泡、口腔溃疡、牙龈肿痛、口燥咽干、流鼻血、眼睛发红等，尤其是口腔溃疡和牙龈肿痛，就和应激反射一样，一旦出现这两种症状就知道自己该吃柚子了，有趣的紧。 我们给简单的归个类的话，上火多是由精神紧张、过度疲劳、辛热药食等所诱发的。而从现代医学的角度看，某种说法提到，上火既包括了一些亚健康的状态，也包含了头面部某些器官皮肤粘膜的炎症，如复发性口腔溃疡，慢性牙龈炎等，这种说法还是挺让人信服的。因此，根据诱发的原因，上火后一般建议清淡饮食、多喝水、忌食辛辣油腻刺激性食物、避免熬夜等，但口唇起泡、口腔溃疡和牙龈肿痛有时候是真的很难受，所以为了缓解症状，一般也需要对症用药。 口唇起泡学名叫口腔单纯性疱疹，是由1型单纯疱疹病毒所引发的皮肤粘膜病。根据 WHO 的数据，全球有 37 亿 50 岁以下的人（67%）罹患1型单纯疱疹病毒感染，且这种病毒感染会持续终身，所以那些没有受到感染的朋友是真的让人羡慕啊。 口唇起泡如果不管的话可以自愈，但像我这种管不住手的会忍不住去抠，所以最好还是用一点药缩短病程比较好，一般可以服用阿昔洛韦等抗病毒药物治疗，但这些药属于处方药，需要医生来开。 口腔溃疡是一种反复发作的圆形或椭圆形口腔粘膜溃疡，且相比于口唇起泡更难受，吃饭的时候灼痛非常明显，严重影响日常生活。所以虽然口腔溃疡也有自限性，可以不治而愈，但我相信没人想硬生生撑着。在家的时候我妈一般是拿一点维生素C或维生素B2磨成粉末外敷到溃疡面，但这东西吧，我现在都怀疑是它真的起了作用还是溃疡自愈了，所以后来改用了诊所医生推荐的冰硼散，有时候也会吃一点西瓜霜。写这篇文章的时候查到有人说康复新液很好用，但不知真假，而如果你用了，希望你不要因为好奇去查它的成分 。 关于某些事物为什么会导致上火（口腔溃疡），在一个知乎答主那里我找到了答案： 物理刺激：烧烤、油炸食物表现更脆、更硬，会在不经意间划伤口腔细胞。 化学刺激：辛辣食物、菠萝、荔枝等食用的同时会给口腔细胞很大压力。 生物刺激：高盐、高糖食物，破坏口腔中的离子平衡和酸碱平衡。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:1:2","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"肠胃疾病 根据前瞻产业研究院的统计，我国非处方药市场上，除了感冒药，就属胃肠用药占比最高，联系现实生活也确实如此，恶心、呕吐、反酸、烧心、食欲不振、腹胀、腹痛、腹泻等等，一年里总遇的着几次，但由于不同的疾病可能有一些相同的症状，因此主要还是依赖于医生的判断，我们能准备的是一些缓解突发症状的药物。 首先是如何向其他人（主要是医生）描述自己疼痛的位置和类型。如果以肚脐眼为中心，将整个腹部划分为一个九宫格，那么就可以用方位词来准确的描述疼痛的位置，如下图，最中间的格子，也就是肚脐眼周围是肠道疼痛，中上和左上都包含胃，可能是胃疼，中下可能是生殖系统，右下则可能是阑尾疼。至于疼痛的类型，我们经常接触到的有胀痛、钝痛和绞痛，胀痛是那种内部被撑大了的痛，钝痛类似于拿拳头面顶在胳膊或大腿的肉上那种感觉，至于绞痛，是最难受的一种，感觉是肚子里的东西被人像拧毛巾一样狠狠拧了一下，只要经历过，永远都忘不掉那种感觉。 一些简单的症状或病症我们通常会自己做一定的处理，比如消化不良。如果我们到了饭点还是有点腹胀，感觉肚子是饱着的，不太想吃饭，并且持续了很多天，那一般就是有点消化不良了，小时候父母可能会给吃一点健胃消食片或者大山楂丸，这个传统我一直保持了下来，但最近几次药店的医生给推荐乳酸菌素片，说是平时没事儿也可以当零食吃，用来调节肠道菌群，目前还没看到效果。 对于我自己而言，便秘的时候很少，腹泻的时候很多。腹泻的症状大家都很清楚，主要是排便次数增加和粪便呈稀水样，是由于某些物质无法被吸收进血液而大量存在于肠腔内时，使过量水分滞留于粪便造成的。以前每次遇到腹痛腹泻来一套的时候，一般是直接使用诺氟沙星胶囊，通常能起作用，但现在明白了，诺氟沙星等药物只适用于肠道感染所致的腹泻，而且还是非处方药，要是以后还像这样不论原因直接用药，迟早要出事，所以现在常备的是蒙脱石散，而且腹泻只是一种症状，明确病因很重要，蒙脱石散暂时起作用的情况下，还是会到诊所或药店做进一步的诊治。 肚子受凉在生活中几乎和上火一样普遍，最常见的情况是，晚上睡觉硬生生被痛醒，然后连续排几次稀便，需要捂好久等到肚子暖和了才会好一点。那么肚子受凉到底是一个什么过程呢，主要是肚脐附近的腹壁比较薄，一旦因保护不好着了凉，就可引起胃肠道平滑肌的收缩，使胃肠的蠕动加速。所以肚子受凉的疼痛是一种肠道痉挛的疼痛，一般位于肚脐眼周围，发病的时候偶尔还能清楚的感受到肠子的蠕动。大家最熟悉的方法就是喝点温热的姜糖水，拿个暖水袋捂捂肚子，但这个适用于只有腹痛的情况，如果配合有拉肚子，还是应当参考上面腹泻的部分。 最后，胃炎和消化道溃疡也是很多人常有的疾病，主要表现在上腹或左上腹的疼痛以及肚子的一种烧灼感，有这个病的人自然知道用什么药，比如常备铝碳酸镁片和奥美拉唑肠溶胶囊，如果以前没有遇到过这种情况，则听从医生的吩咐即可。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:1:3","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"过敏与中暑 过敏这件事儿吧，有的人深受困扰，有的人却从来没遇过，比如我，不过也有可能我遇到过，但当时没意识到那是过敏，所以一切从学习过敏的症状开始。 耳熟能详的几种过敏情况包括花粉过敏、海鲜过敏和荨麻疹。其中，花粉过敏的主要症状为鼻塞或眼睛发痒，打喷嚏、 流涕 、流眼泪，记得山本文绪在《然后，我就一个人了》这本书中提到自己对花粉过敏，每到春夏花粉飘扬的季节，就必须关好门窗，戴着口罩出门，由此而印象深刻。好在我没有这种情况，唯一有的是有时候从室内到室外遇到强烈的太阳光就鼻子发痒连打几个喷嚏，难道是强太阳光过敏？赶紧查了查，好险没有这种过敏情况，而且现在科学还没法解释这种情况。至于海鲜过敏，主要症状是皮肤瘙痒、发红、水肿，提到这个相信很多人都对《爱情公寓》里面张伟的龙虾过敏症状记忆犹新，那通红肿胀的大嘴唇，让人不寒而栗，不过看了一些图片，发现现实的海鲜过敏好像一般没有这么严重，仔细想了想，自己吃了不少海鲜，没产生过过敏症状。最后，荨麻疹表现为风团和瘙痒，找了找图片，发现这个自己好像有过，只不过当时以为是蚊子咬的，还在疑惑为什么有传染性，挠一挠发痒的地方，要是手再碰一下其它地方的皮肤，其它地方也会起疙瘩然后发痒，也没想过为什么这个疙瘩和平时蚊子咬的疙瘩不一样，只是因为没几天就自己消散了，所以没注意，进一步了解到重症荨麻疹可能会出现呼吸困难，进而危及到生命后，就开始常备氯雷他定，不过后来再没发作过，所以没有用过药。 中暑也是大家熟知的情况了，但我映像里的中暑还停留在军训的时候一群人在炎炎的烈日下，突然有一个人昏倒了，然后赶紧被抬到阴凉处，掐人中，醒来后赶紧喂几瓶藿香正气水的场景。经过主动学习后，我了解到昏迷已经是相当严重的中暑情况了，而且不应当掐人中，而是在转移到阴凉处后及时给中暑者降温，比如松开衣领，用湿毛巾冷敷头部，以及用酒精擦拭皮肤等，严重的要及时送往医院。至于平时，只要出现轻微的头晕、头痛、耳鸣、眼花、口渴、浑身无力及行走不稳，就已经算先兆中暑了，如果还有面色潮红、胸闷、皮肤干热，或有面色苍白、恶心、呕吐、大汗，那就属于轻度中暑，这两种情况出现时都应当及时离开高温环境，选择阴凉通风处休息，喝一些带盐分的饮料，涂抹清凉油、风油精，或服用藿香正气水等，如果没有缓解，也要及时前往诊所或医院治疗。 当然，在高温天最好是事先就做好防中暑的准备，如太阳镜、遮阳伞、防晒衣等，长时间在户外准备好防暑药品如藿香正气水，补充电解质的饮料如脉动。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:1:4","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"一些外伤 按理说外伤应该放在急救部分，但下面的医药箱部分要准备一些相关的外用器具，所以这里简单介绍。 首先是擦伤、割伤或划伤等伤口不大的情况。先用碘伏棉签对伤口进行清洁和消毒，以前在家里的时候还用过紫药水、红药水或酒精等消毒清创，但这两年在网上找资料就基本都是推荐碘伏棉签的了。碘伏棉签的要点在于将碘伏和棉签合二为一，不必再单独储备，另外，为了防止买一大包开封后受到污染，最好应当购买独立包装的碘伏棉签。消毒完成后同样使用独立包装的纱布片和医用胶带包扎，创口贴虽然好用，但我每次买到的创口贴透气性都不是很好，所以依然储备，但不是很常用。另外要注意的是，如果自己没法处理干净伤口，比如有些脏东西用棉签怎么都擦不掉，还是及时前往诊所比较好，如果伤口比较深，要在做完消毒止血后及时去医院处理，并在24小时内打破伤风针。 烫伤是另外一种居家常见的情况，可能是打翻了盛着开水的杯子，也可能是蒸汽烫伤，更有可能是没注意赤手去端滚烫的锅或碗，无论哪种情况，都有可能引起皮肤烫伤。如果只是皮肤红肿疼痛，连水泡都没有，那么可以在水龙头下用冷水持续冲洗烫伤的部位，或者将烫伤处置于冷水中浸泡，直到脱离冷源后疼痛显著减轻为止，最后再用万花油或烫伤膏涂于烫伤部位。但如果起了水泡，疼痛难忍，这时候就不要勉强自己了，迅速到诊所或医院治疗，并且注意不要弄破水泡，等医生处理。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:1:5","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"药品的贮存 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:2:0","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"放哪里 这一节原本的标题是“医药箱”，但转头想了想，药品的贮藏为什么要用医药箱呢，看到的所有文章里大佬们都在介绍医药箱里要放些什么，但少有人解释药品贮藏要满足什么样的条件，为什么要用医药箱。这个问题搞得我心痒痒，毕竟我家里一直用的是一整个抽屉来存放药品，而我自己在学校的时候用的是简单的塑料袋。 我在江苏省药学会编著的《社区居民安全合理用药读本》里找到了一些说明：“空气中易变质的药品应装在干燥密闭容器中保存；易氧化的药品应密闭在棕色玻璃瓶中置阴凉避光处；易吸潮的药品应装在密封容器中储于干燥处；易风化的药品应装在封口的容器内置阴凉处；外用药于内服药分开存储。”但实际实施的时候才发现这段话毫无可实践性，我怎么知道哪个药已变质，哪个药又易氧化呢！但往下又看到书中提到：“为使药品在有效期内符合药品质量标准，药品在说明书中都规定有贮存与保管的要求。“，随便找了个药翻了翻说明书，果然有贮藏一栏。 但现在问题又来了，我要每个药都看一下说明书的贮藏条件，然后分门别类合理存放吗？恐怕我们并不想付出这种精力，最好是找到最常出现的术语，只要能满足大部分条件即可，于是有了下面的表。对着这些名词解释仔细思考之后，发现医药箱还真是最合适的选择。 名称解释遮光指用不透光的容器包装，例如棕色容器或黑纸包裹的无色透明、半透明容器密闭指将容器密闭，以防止尘土及异物进入密封指将容器密封以防止风化、吸潮、挥发或异物进入阴凉处指不超过20℃凉暗处指避光且不超过20℃冷处指2~10℃常温指10~30℃ 网上不同的医药箱对选择困难症来说是个挑战，但外观的选择其实并不重要，因为每个人有自己的偏好，尺寸才是最关键的，虽然每个商品标注了什么规格适合几人使用，但就像我，买了适合1~2人的药箱还是装不下多少东西，这件事可能和备药的策略也有关，我们将在下一小节详细讨论。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:2:1","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"放什么 家用药箱里放什么这个问题各个平台都有大量的回答，尤其是上面这篇少数派最近的文章在我看来就写的极其完美，非常喜欢，所以我参照学会的知识和这篇文章准备了下面的药品。 解热镇痛：复方对乙酰氨基酚片，小儿退热贴 感冒咳嗽：板蓝根颗粒、999抗病毒口服液、莲花清瘟胶囊、蜜炼川贝枇杷膏 肠胃：乳酸菌素片、健胃消食片、铝碳酸镁咀嚼片、蒙脱石散、诺氟沙星胶囊 口腔溃疡：冰硼散 过敏和中暑：氯雷他定胶囊、藿香正气胶囊 其它：独立包装的碘伏棉签、纱布、医用胶带、创口贴 然后，药箱放不下了……有人说你这看着也不像按前面的介绍买的药啊，而且也不是按刚刚介绍的那篇文章买的。是的，确实不是，所以我这里就简单介绍一下我买药时候的挣扎。首先，对于一个从小吃着扑热息痛长大从来没有碰过布洛芬的人来说，真正购买的时候还是会对对乙酰氨基酚下手；其次，买感冒药的时候，如果你已经知道了风热、风寒、流感这么多分类，然后眼看着板蓝根、抗病毒口服液、莲花清瘟胶囊这一堆耳熟能详各有侧重的药物，你是否能坚定的只买一个复方氨酚烷胺片；最后，如果你每次拉肚子都是吃了诺氟沙星就好了，那么你是否能坚定的只买一份蒙脱石散等到下次发病临时找医生诊治。所以最后就到了医药箱完全放不下的程度，甚至堪堪只能放下治感冒的那几种药。 我当然可以换一个更大的医药箱，但我感觉问题的关键不在于此，因为在替我妈整理家里放药抽屉的过程种，我逐渐意识到，药箱其实是一个家庭生活的痕迹。药箱里不仅仅是常见病和多发病的用药，还有相当一部分需要根据家庭成员的组成和健康情况来调整，哪里有一个万能的清单呢，所以，就让时间来决定吧，过个几年，说不定我的药箱就顺人心意了呢，到时候再扔不用的药物或者换更大的药箱，都有了更合理的解释。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:2:2","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"怎么管理 于我自己而言，因为前段时间把所有电子化记录从 Notion 迁移到了飞书，现在使用飞书管理药品，例子如下 同时还基于飞书的自动化流程做了一个自动标记过期的功能，设置如下，这样过期的时候我能及时收到提醒，记录内容也会自动做相应变更。 这两天山西疫情，我被隔离在家，想着整理一下家里放药的抽屉，顺便和我妈聊聊她储备药品的思路。结果发现抽屉里放着大量的过期药品，最早的失效时间甚至可以追溯到 2014 年，在我想一股脑扔掉的同时，我妈提出了她的看法。她说：“过期的药只是药效弱了点，又不是不能用，万一遇个突发情况，就像你二舅上次，大晚上的找不到一颗药，咋办？”我竟无言以对，所以我在网上查了查过期药到底为什么不能吃，然后看到有科普说过期药不仅仅是有效成分含量降低，其中的化学成分也有可能改变，毒性增加，对人体造成伤害。于是，我和我妈开始据理力争，但最终依然只能和她达成一个折衷的处理办法：我尽快给她买回来新药，然后再把她的过期药给扔掉。而过期药到底属于什么垃圾，我现在已经完全没有精力思考了。 [1] 国家药品监督管理局. 科普 | 流感还是普通感冒？治疗用药大不同！. 2019-01-18 [2] 徐俊本, 陈凯章. 常见病中成药实用速查宝典[M]. 中国中医药出版社，2014-04， [3] 世界卫生组织. 单纯疱疹病毒 (who.int). 2020-05-01. [4] 知乎. 「上火」到底是什么原因？现代医学怎么解释「上火」？. 2019-07-04. [5] 知乎. 肚子这里痛千万别忍着！学会自查，分分钟能自救！. 2019-03-07. [6] 刘成玉. 诊断学（第4版）[M]. 人民卫生出版社. 2019-01. [7] 江苏省药学会编著. 社区居民安全合理用药读本[M]. 江苏凤凰科技出版社. 2015-09. ","date":"2022-02-25","objectID":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/:2:3","tags":["生活技能"],"title":"医药健康1-常见疾病及医药箱","uri":"/2022/medicine-and-health-1-common-diseases-and-medical-kit/"},{"categories":["我所热爱的生活啊"],"content":"上一篇总结了常见病，这一篇总结常听说的疾病。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:0:0","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"1. 中老年常见病 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:1:0","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"高血压 高血压是最常见的心血管疾病，主要表现为体循环动脉压增高，病因有遗传、肥胖、吸烟、酗酒、缺乏运动、精神压力大，高盐饮食等。长期高血压，还是多种心血管疾病的重要危险因素，并影响重要器官如心，脑，肾的功能，最终导致这些器官的功能衰竭。 要预防高血压，就要多吃水果蔬菜，坚持锻炼，舒缓身心，避免压力过大。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:1:1","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"高血脂 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:1:2","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"痛风 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:1:3","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"糖尿病 糖尿病是一种比较常见的内分泌代谢性疾病。发病原因主要是由于胰岛素分泌不足。多见于40岁以上喜食甜食而肥胖的病人，城市多于农村，常有家族史，故与遗传有关。少数病人与病毒感染和自身免疫反应有关。主要表现为烦渴、多饮、多尿、多食、乏力、消瘦等症状。糖尿病常伴发高血压、冠心病、高脂血症等，严重时危及生命。因糖尿病的发生和饮食有关，饮食控制的好坏直接影响着治疗的效果，要选择低血糖的食物。再就是配合运动，注意调摄情志，再适当的配合中药治疗会取得良好的治疗效果。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:1:4","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"中风 中风是中医学对急性脑血管疾病的统称。它是以猝然昏倒，不省人事，伴发口角歪斜、语言不利而出现半身不遂为主要症状的一类脑血液循环障碍性疾病。由于中风发病率高、死亡率高、致残率高、复发率高以及并发症多的特点，所以医学界把它同冠心病、癌症并列为威胁人类健康的三大疾病之一。预防中风的重要性已经引起国内外医学界的重视，医学家们正从各个方面探索中风的预防措施。因发病急骤，症见多端，病情变化迅速，与风之善行数变特点相似，故名中风、卒中。本病常留有后遗症，发病年龄也趋向年轻化，因此，是威胁人类生命和生活质量的重大疾患。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:1:5","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"冠心病 冠状动脉粥样硬化性心脏病是指冠状动脉粥样硬化使血管狭窄或阻塞，导致心肌缺血缺氧或者坏死，称为冠心病，冠心病的范围可能更广泛，还包括冠脉炎症，栓塞，痉挛等因素导致管腔狭窄或者闭塞，临床中，常分为稳定性冠心病和急性冠状动脉综合征。易感人群为四十岁以上男性，绝经后妇女，脑力劳动，腹型肥胖，高血压，高血脂，糖尿病患者。患者注意多饮水，少食多餐，食用低脂肪、低热量食物。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:1:6","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"老年痴呆 所谓的老年痴呆症，又称阿尔茨海默病，是发生在老年期及老年前期的一种原发性退行性脑病，指的是一种持续性高级神经功能活动障碍，即在没有意识障碍的状态下，记忆、思维、分析判断，视空间辨认、情绪等方面的障碍。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:1:7","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"2. 常见职业病 包括颈椎病、腰椎病、干眼、失眠、紧张性头痛、鼠标手等，对于本职业的职业病应严加注意和预防。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:2:0","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"3. 常见传染病 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:3:0","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"病毒性肝炎 肝炎是肝脏的炎症。最常见的是病毒造成的肝炎，此外还有自身免疫造成的。酗酒也可以导致肝炎。肝炎分急性和慢性肝炎。由病毒造成的肝炎按照其病毒系列不同分为甲型肝炎、乙型肝炎、丙型肝炎、丁型肝炎、戊型肝炎和庚型肝炎共六种类型病毒性肝炎。 肝炎的早期症状及表现，如：食欲减退，消化功能差，进食后腹胀，没有饥饿感；厌吃油腻食物等。 肝炎暂无有效预防措施，早发现早诊断是本病防治的关键。脂肪肝是引起肝炎的重要原因，近年来明显增多的肝脏病，常与肥胖症、糖尿病共存。要远离脂肪肝，应从调节饮食入手。控制脂肪饮食当然是必需的。预防脂肪肝还要提倡运动，运动可以消耗掉体内多余的脂肪。 乙肝最为常见，可通过母婴、血液和性传播，但不会经消化道和呼吸道传播，因此日常学习、工作、生活接触等不会感染。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:3:1","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"水痘 水痘(varicella)是由水痘-带状疱疹病毒引起的原发感染，是以较轻的全身症状和皮肤粘膜上分批出现的斑疹，丘疹，水疱和痂疹为特征的急性传染性皮肤病。多见于儿童，具有高度的传染性，易造成小区域的流行，愈后可获终身免疫。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:3:2","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"结核病 结核病是由结核分枝杆菌引起的慢性传染病，可侵及许多脏器，以肺部受累形成肺结核(pulrnonary tuberculosis)最为常见，排菌患者为其重要的传染源。人类主要通过吸入带菌飞沫(结核病人咳嗽、打喷嚏时散发)而感染。入侵呼吸道的结核菌被肺泡巨噬细胞吞噬。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:3:3","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"4 其它 包括艾滋病、各种癌症、白血病等人们常听到或遇到的疾病。应掌握各种疾病的主要症状、发病原因、是否传染以及如何预防。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:4:0","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"食物中毒 食物中毒是由于进食被细菌污染的食物引起的急性中毒性疾病，常见原因有 生熟交叉感染：熟食品被生的食品原料污染，或被与生的食品原料接触过的表面（如手、操作台、容器等）污染。 食品贮存不当：如熟食品在10℃~60℃的温度条件下存放时间应小于2小时，易腐原料、半成品食品在不适合的温度下长时间贮存也容易引起变质。 食品未烧熟煮透：如食品烧制时间不足、烹调前未彻底解冻等原因，使食品加工时中心部位的温度未达到70℃。另外，经长时间贮存的食品食用前未彻底再加热，及进食未经加热处理的生食品也是细菌性食物中毒的常见原因。 带菌的动物如家畜、家禽及其蛋品、鱼类及野生动物为主要传染源，患者带菌时间较短，作为传染源意义不大。人群普遍易感，病后无明显免疫力。 食堂吃饭的地方常暴起发病，与食入同一污染食物有关，潜伏期短，常于进食后数小时发病，各细菌引起的食物中毒症状基本相似，主要表现为腹痛、恶心、呕吐等肠胃类症状，吐泻严重者可能出现脱水、酸中毒，甚至休克，部分患者有畏寒、发热、头昏头痛、乏力等全身中毒症状。 多数食物中毒的毒素会在短期排出体外，症状轻者卧床休息、清淡饮食直到病情好转即可，可适量引用盐糖水补充电解质。高热可物理降温，吐泻腹痛可使用相关药物，腹部放热水袋缓解，过敏时使用抗过敏药物，脱水、休克应抢救。肉毒杆菌食物中毒症状较重，头痛头晕、全省软弱无力，还会出现神经麻痹症状如复视、瞳孔散大等，应及时入院治疗。 应禁止使用病死家畜。已变质的肉及腐败、变质的食物坚决不食；少食海鲜及生冷食物；食物要煮熟煮透，生熟食应分刀、分砧板处理、分容器储藏。尽量避免剩饭剩菜，剩余的饭、菜、粥等应冷藏，以防变质，解冻食用时解冻应彻底，加热保证中心温度达70℃。消灭苍蝇、鼠类、蟑螂、蚊类及其滋生地，防止食品被污染。罐头变质如顶部膨胀，食品的色、香、味变化，或食品呈乳酸样酸臭时，禁止食用。 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:4:1","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"艾滋病 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:4:2","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"癌症 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:4:3","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"白血病 ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:4:4","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["我所热爱的生活啊"],"content":"参考 [1] 知乎-小悠Little的回答-家庭药箱需常备哪些药品和工具 [2] 上火到底是什么原因？现代医学怎么解释「上火」？ - 知乎 (zhihu.com) [3] 康震，常见疾病谱用药：速查速用手册，化学工业出版社，2014.05. ","date":"2022-02-25","objectID":"/2022/medicine-and-health-2-frequently-heard-diseases/:5:0","tags":["生活技能"],"title":"医药健康2-常听说的疾病","uri":"/2022/medicine-and-health-2-frequently-heard-diseases/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第九期月刊，2022 年 01 月。 ","date":"2022-01-31","objectID":"/2022/life-monthly-9/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 9 期 (202201)","uri":"/2022/life-monthly-9/"},{"categories":["日程及周刊"],"content":"新闻 1、汤加火山剧烈喷发 1月15日，南太平洋岛国汤加的洪阿哈阿帕伊岛的一个海下火山发生剧烈喷发，往大气层喷射了19千米高的火山灰和蒸汽，形成一个巨大的蘑菇云。该火山引发了越洋海啸，整个汤加与外界断开了联系，汤加首都受到灾难性影响。日本连续发布海啸警报，这是日本自2016年11月以来首次发布海啸警报。新西兰、美国、加拿大、汤加周边的斐济、萨摩亚也发布了不同级别的海啸警报。 ","date":"2022-01-31","objectID":"/2022/life-monthly-9/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 9 期 (202201)","uri":"/2022/life-monthly-9/"},{"categories":["日程及周刊"],"content":"生活 01.01，换笔记本，开启新一年的子弹笔记 01.02， 尝试游戏《古墓丽影9》 一家人前往武乡逛街买衣服 01.03， 尝试游戏《古墓丽影·崛起》，各方面都比9好 备份2021年照片，腾讯云COS存储调整 01.04，8个配网工程核准文件准备，联网直报流程捋通 01.05，明星与胡村所培训，雍和家园小区情况摸查 01.06，打疫苗加强针 01.07，GIS绘图培训 01.08，药品储备 01.12，完成文章《12306如何取消学生身份》 01.13，明星所二次培训 01.15，所有账号手机号更改 01.18，奶奶病故，请假回家，持续到 01.22 上午 01.23，和老爸弟弟超市购物，岗位工作梳理 01.24，更新MIUI13，内网新闻完成 01.25，1月党建工作完成 01.26-01.27，教安质和财务完成绩效系统 01.28，整理办公室柜子里的物品 01.29，管理创新填报 01.30，回家 01.31，除夕，挂灯笼，看晚会 ","date":"2022-01-31","objectID":"/2022/life-monthly-9/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 9 期 (202201)","uri":"/2022/life-monthly-9/"},{"categories":["日程及周刊"],"content":"观影 01.09，电源《独自生活的人们》，大爱。 01.22 — 01.31，电视剧《开端》E01-E12。《长安十二时辰》后第一次再看国产剧，非常棒。 ","date":"2022-01-31","objectID":"/2022/life-monthly-9/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 9 期 (202201)","uri":"/2022/life-monthly-9/"},{"categories":["日程及周刊"],"content":"思考 1、极简的本质是珍视已有的事物，因此，极简理念下的购物，不是购物流程极简，而是用心挑选每个物品，保证每个都是最爱。 2、不是所有想法都需要完成，要学会抓重点，不然时间永远不够。以写文章为例，各种点子很多，但不必每个都写，可以每年限定写的数量。 3、有些事做一次可以受益很久，如修复某个东西，有些事则是周期性的额，永远做不完，比如清洁，因此要学会用自动化的手段节省周期性工作需要的时间。 ","date":"2022-01-31","objectID":"/2022/life-monthly-9/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 9 期 (202201)","uri":"/2022/life-monthly-9/"},{"categories":["日程及周刊"],"content":"收藏 【小技巧】过年大扫除用玻璃水擦窗户不会冻 【小技巧】牛皮纸袋可以用来收纳 【概念】注册电气工程师 【课程】哈佛积极心理学公开课 ","date":"2022-01-31","objectID":"/2022/life-monthly-9/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 9 期 (202201)","uri":"/2022/life-monthly-9/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 照片备份 QQ和微信聊天记录备份 录音整理 浏览器书签备份 对账 月刊完成 ","date":"2022-01-31","objectID":"/2022/life-monthly-9/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 9 期 (202201)","uri":"/2022/life-monthly-9/"},{"categories":["我所热爱的生活啊"],"content":"每次买东西纠结个半天，最后买回来还不一定合心意，所以打算梳理一下购物的流程，希望能提供一些参考，给以后的购物节省一些时间，同时减小冲动消费的概率。 ","date":"2022-01-04","objectID":"/2022/shopping-process/:0:0","tags":["生活技能"],"title":"购物流程","uri":"/2022/shopping-process/"},{"categories":["我所热爱的生活啊"],"content":"想买东西的时刻 把几个电商平台的购物历史浏览了一遍之后，根据当初买东西的出发点，分成了以下几种不同的情况。 已有同类物品。此时又分为三种子情况，第一种是原物品用完了或到期了，常见于有保质期的化妆品、药物以及各类日常消耗品（牙刷、卫生纸等）；第二种是原物品损坏，必须换，或者半损坏，用着很不舒服；第三种则是原物品不喜欢，可能是日积月累看腻了，也可能是本来就不喜欢，勉勉强强用到现在。 没有同类物品。此时分为两种子情况，第一种是由于生活中遇到的各种问题诞生的需求，第二种则是来自各种文章视频或者来自身边朋友的安利，或者是单纯的凑单需求。 拿最近两个月买的东西举个例子 物品名 一级分类 二级说明 小米10s手机壳 已有 原物品不喜欢 免打孔吹风机置物架 没有 浴室储物架杂乱诞生的收纳需求 Keep手环b2腕带 已有 原物品损坏 双耳泡面碗+筷勺套装 没有 周末吃饭没有餐具诞生的需求 药箱 没有 药品和医疗器械储备存放诞生的需求 羽绒服 已有 原物品半损坏 折叠裤架 没有 被安利 哑铃 没有 室内健身需求 手账本 已有 原物品用完了 无痕衣架 已有 原物品不喜欢 ","date":"2022-01-04","objectID":"/2022/shopping-process/:1:0","tags":["生活技能"],"title":"购物流程","uri":"/2022/shopping-process/"},{"categories":["我所热爱的生活啊"],"content":"购物冲动自评 做到理性消费的核心是诞生了购买欲后做一个自评，自评的核心有两点，一是买这个物品有没有必要，二是需不需要立即买。 关于购买的必要性，其实评价维度很多，已有的物品用完了、到期了、损坏了，这些都毫无疑问需要马上购买，但储备的物品还有一半突然遇到打折了，比如卫生纸，或者物品半损坏，比如插排出现了电流声，这个时候就会有一点纠结。更进一步的，遇到物品不喜欢的情况，比如以前买的衣服，因为没法和其它衣服搭配，变得不喜欢了，或者买手机送的手机壳，虽然可以使用，但就是不喜欢，这时候是否买一个新的来替换，纠结程度就更多一点。这两种情况我一般是看当月的预算是否还足够，以及与之同时的是否有其它购买需求，如果预算足够且没有其它购买需求的话，一般就买了。 另外，生活中诞生的需求，也需要区分是真需求还是伪需求。我的办法有两个，一个是判断买回来是立即投入使用，还是作为储备，另一个是了解完商品情况及分析了自己的需要后，判断是否能满足自己的需要。比如，免打孔吹风机置物架是买回来马上就用且立马就能使得浴室空间焕然一新的，双耳泡面碗+筷勺套装则是立马就解决了周末吃饭问题的，但用来洗内裤袜子的小洗衣机，经过了解后就发现完全属于鸡肋，没法完全满足需求，因此就不必购买。 ","date":"2022-01-04","objectID":"/2022/shopping-process/:2:0","tags":["生活技能"],"title":"购物流程","uri":"/2022/shopping-process/"},{"categories":["我所热爱的生活啊"],"content":"了解商品情况 线下还是线上 有空的话线下逛一圈，看看有没有想要的样式以及多少钱 网上样式较多，但是没法上手看，很多方面只能买回来才能看到，退换成本较高 去哪儿翻评测或找咨询 B站各专业细分方向的评测，普通人的开箱、使用体验 知乎的购买建议，仅供参考 小红书的购买建议，仅供参考 同类比较， 这个产品有几种不同样式，每种的优缺点是啥 确定产品样式后自己翻各个平台全网比价 确定商品后全网比价，以及查询商品历史价格 主要看样式喜不喜欢，功能能不能满足自己需要，注意不需要为多余的功能付额外的钱 问清楚客服自己不清楚的事项 网购能不能搞价？ 买回来能不能退 注意买退货保险 注意会员权限中的免费退换货 注意退换货的条件 退不了的咋处理 二手回血，心里要想着卖了还能回点血，不卖血本无归 送人 扔掉 如何做金钱和时间的平衡，什么价位的东西值得付出什么样的时间和精力 一个几块钱的东西挑个一星期，不值得，这个价位可以定到10块、20块，根据自己经济情况看 每个月做预算，超出预算的部分可以下个月买 想买的东西记录到表格 ","date":"2022-01-04","objectID":"/2022/shopping-process/:3:0","tags":["生活技能"],"title":"购物流程","uri":"/2022/shopping-process/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第八期月刊，2021 年 12 月。 ","date":"2021-12-31","objectID":"/2021/life-monthly-8/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 8 期 (202112)","uri":"/2021/life-monthly-8/"},{"categories":["日程及周刊"],"content":"生活 12.01，定岗，发展建设部报道 12.02 胡村所有事务结束，包括学习总结、核查问题汇总报给所长、退出工作群 《薪酬和晋升》文章完成并发表 12.03，发展部工作熟悉，晚上部门聚餐，认识了部门所有人 12.05，发现家家利超市旁边地下有个美食城，但尝试后发现又贵又不好吃，晚上又在沙县小吃点了「拌面+蒸饺」的经典搭配 12.07，U盘注册到内网，学习区域负荷月报和请示的办理 12.11，买的新手机（小米10s）到货，一边心疼钱一边开心的用 12.12，完成文章《电费与停电报修》 12.14，专业技术资格（助理工程师）认定材料准备与提交 12.15，英大保险的钱划转到保和堂 12.17，买太谷卷卷，回家 12.18，上午在湖畔里售楼处领橙子，中午一家人聚餐、改善伙食，下午和老妈逛街 12.19，坐车到高铁站被坑，好气啊 12.25，一大早坐公交去榆次办医保，冻得鼻涕都出来了，可惜人家周六不上班，于是在旁边万达逛了一圈 ","date":"2021-12-31","objectID":"/2021/life-monthly-8/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 8 期 (202112)","uri":"/2021/life-monthly-8/"},{"categories":["日程及周刊"],"content":"工作 小白和胡村的核准办理 上善和太谷北的入统办理 十四五规划报告梳理，和厂家交流完善 根主任去北汪，见识杆塔选址的确定过程 低压线路图绘制的流程梳理、和厂家交涉、单位对面小南街实地调研 小白、北汪、候城、水秀、阳邑、范村六个所的低压线路图绘制培训 主题党日活动的新闻报道 接手的发展部业务整理成电子版教程 网上电网：一些系统里配变的垃圾数据报宫文宇 准备给市局的上善工程的请示 办理白塔区低压台区改造等八个2022年配网工程的核准 ","date":"2021-12-31","objectID":"/2021/life-monthly-8/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 8 期 (202112)","uri":"/2021/life-monthly-8/"},{"categories":["日程及周刊"],"content":"观影 12.02，日剧《出租什么都不做的人》追完，应该算很喜欢的一部剧。 12.04，电影《毒液2》，不喜欢。 12.07-12.23，美剧《鹰眼》S01，比起漫威其它的故事，更喜欢这一部，可能是身为凡人的鹰眼更接地气吧，也可能是女主太有意思 12.11，电影《古董局中局》，虽然有逻辑漏洞，但还是很喜欢。 12.12，电影《一周不死，全额退款》，超棒的冷幽默电影，强烈的推荐。 12.12，电影《你丫闭嘴》，比较老的片子了，不能说不好，但是不合我口味。 ","date":"2021-12-31","objectID":"/2021/life-monthly-8/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 8 期 (202112)","uri":"/2021/life-monthly-8/"},{"categories":["日程及周刊"],"content":"思考 不读书就是睁眼瞎，读书只为不做愚人。 ","date":"2021-12-31","objectID":"/2021/life-monthly-8/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 8 期 (202112)","uri":"/2021/life-monthly-8/"},{"categories":["日程及周刊"],"content":"收藏 【汽车】哈弗越野车 ","date":"2021-12-31","objectID":"/2021/life-monthly-8/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 8 期 (202112)","uri":"/2021/life-monthly-8/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 照片备份 QQ和微信聊天记录备份 录音整理 浏览器书签备份 对账 月刊完成 ","date":"2021-12-31","objectID":"/2021/life-monthly-8/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 8 期 (202112)","uri":"/2021/life-monthly-8/"},{"categories":["日程及周刊"],"content":"2021 年末总结和 2022 新年计划。 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:0:0","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"大事记 硕士毕业。学生生涯到此结束，感谢我的导师和同学们。 入职工作。迈入了人生的下一个阶段，希望越来越好。 少数派写作。找到了喜欢做的事，从默默在自己的博客更新文章进步到了在平台上同步更新。这一年一共更新了 14 篇文章，基本达成了每月一篇的目标，到目前为止写作了 10 万字，获得了 41 万次阅读量，下一年继续努力。 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:1:0","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"书影音 2021 年看过了 79 部电影和剧集，读了 11 本书（很多没看完的或者没想起来记到豆瓣的），基本达成了每周一部电影和每月一本书的目标。下表列出了 2021 年看过的所有书影音，其中「最爱」一行的是推荐看的，另外两行不推荐，至于年度最爱，电影颁给《我和厄尔以及将死的女孩》，剧集颁给《家族的形式》，书籍颁给《日本世相系列：饱食穷民》 电影 剧集 书籍 最爱 《一周不死，全额退款》 《我和厄尔以及将死的女孩》 《白蛇2：青蛇劫起》 《缩小人生》 《彼得兔2：逃跑计划》 《垫底辣妹》 《王牌保镖》 《地球上的星星》 《阳光姐妹淘》 《特工绍特》 《心花路放》 《夺宝奇兵》 《哥斯拉大战金刚》 《人之怒》 《你好，李焕英》 《恶人传》 《天地大冲撞》 《末日病毒》 《出租什么都不做的人》【日剧】 《紧急呼救：孤星》第一季【美剧】 《完美星球》【纪录片】 《比宇宙更遥远的地方》【动漫】 《我是遗物整理师》【韩剧》 《爱，死亡和机器人》第二季【动漫】 《神盾局特工》第一季【美剧】 《神盾局特工》第二季【美剧】 《神盾局特工》第三季【美剧】 《神盾局特工》第四季【美剧】 《旺达幻视》【美剧】 《钱断情始》【日剧】 《逃避虽可耻但有用》【日剧】 《家族的形式》【日剧】 《致肥元凶》 《日本世相系列：饱食穷民》 《日本世相系列：妻子们的思秋期》 《从前有幅画》 《亲密关系：通往灵魂的桥梁》 《行为上瘾》 《本能减脂》 《施瓦辛格健身全书》 《睡眠革命》 一般 《古董局中局》 《失控玩家》 《皮皮鲁与鲁西西之罐头小人》 《红色通缉令》 《峰爆》 《神偷军团》 《沙丘》 《环形使者》 《X特遣队：全员集结》 《魔警》 《极限特工2》 《黑寡妇》 《你眼中的世界》 《猎杀T34》 《人潮汹涌》 《幸运钥匙》 《新神榜：哪吒重生》 《热气球飞行家》 《刺杀小说家》 《幻体：续命游戏》 《熊出没：狂野大陆》 《心灵奇旅》 《逃避虽可耻但有用：新春特别篇》 《洛基》第一季【美剧】 《七个世界，一个星球》【纪录片】 《猎鹰与冬兵》【美剧】 《拳愿阿修罗》【动漫】 《浮生一日》 《写给单身的你》 《网络小说类型专题研究》 不喜欢 《你丫闭嘴》 《毒液2》 《尚气与十环传奇》 《007：无暇赴死》 《丛林奇航》 《王牌保镖2》 《极限特工3：终极回归》 《明日之战》 《瞒天计划》 《活死人军团》 《速度与激情9》 《特种空勤团：红色通缉令》 《真·三国无双》【讨厌】 《征途》【讨厌】 《侍神令》 《扎克施耐德版正义联盟》 《猫和老鼠真人版》【讨厌】 《神盾局特工》第五季 《当时这样说就好了》 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:2:0","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"旅行 因为疫情没有去太多地方，全年值得拿出来说的只有三次。一次是年初在家的时候（2月21日），和老爸老妈去走马岭和漳河源头，一次是五一的时候去秦皇植物园和北戴河黄金海岸沙雕乐园，最后一次是毕业旅行，去了山东的济南、曲阜和泰安，三次都玩的很开心。入职之后基本是在城区逛，没去过太远的地方，希望明年可以去更多的地方玩。 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:3:0","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"时间都去哪儿啦 三月份，也就是刚过年那会儿，主要在看一系列关于上瘾的资料，包括各种书籍、纪录片和论文，目的是解决网络小说成瘾的问题，最后还写了两篇文章，但这部分工作可以称得上失败，因为现在依然没有脱离魔爪，但相比之前，投入其中的时间有明显减少，所以也不能说徒劳无功。而且后来其实想通了，就把它当作一个爱好好了，偶尔看看，只要不影响工作学习就好。 四月份，在看各种健身的书籍和资料，着力于构建一个完善的健身理论体系，使自己不至于一头雾水的跟着软件里的教程随便练。这一部分工作没有一个好的结果主要是越学越觉得要看的东西多，甚至萌生了进修一个该方向的学位的想法，或者去参加一下健身教练的培训，最后实在无法建立完整的体系，最终搁置。从 Keep 的健身记录来看的话，2021 年累计运动时间 8079 分钟，几乎是 2020 年的三倍，当然，这和今年换了 Keep 手环，把平常的行走也统计进来有很大关系，如果只看健身的话，今年只有 1814 分钟，而去年为 2648 分钟，跑步今年有 145 公里，去年则是 46 公里，总体来看今年和去年相差不大，2022 年需要继续努力。如果看体重的话，元旦将近的现在，体重直逼 75 公斤，BMI 也直线上升，主要是因为从 9 月入职开始健身就搁置了，2022 年需要抓紧恢复锻炼了。 五、六月份在忙着毕业答辩，答辩完了和同学各种聚餐、出去玩，这段时间也投入了大量的时间玩游戏，主要是《死亡搁浅》、《刺客信条：英灵殿》以及《原神》，其中《原神》一直玩到现在，日耕不辍。 六月底和七月初策划并进行了毕业旅行。而七月份在家度过学生时代最后一个暑假的时候，主要是在看婚姻和恋爱的各种书籍和文献，打算从学术上理解这个东西，做出最理性的决策，很可惜最后还是半途而废，这份工作留到了以后。 八月份精力投入在完成《安全感提升》系列文章上，包括《灾害》、《独居》、《出行》三篇以及一篇未发表的《未来》，但这些文章提到的内容更多的是一种预案，是我如果遇到这些情况怎么办，而且里面提到的很多东西都有待攒了一些钱之后慢慢进行。 九月入职，忙着熟悉新环境，没工夫做其它的事情，这段时间有两个选题，包括《入职一周我做了些什么》、《职工宿舍改造计划》，但都因为各种原因鸽掉了，其中《入职一周我做了些什么》一度改成《入职一个月我做了些什么》、《入职三个月我做了些什么》，但大家也可以看到，都年末了，文章还是没成稿。 十月在基层供电所学习，时间稍微多一点，完成了一篇选题板里放了很久的《内向者破壁》。 十一月、十二月开始忙起来，同时按照原定计划开始熟悉工作上的各种业务，以及薪酬、晋升通道、企业组织架构等等内容，一些可以发出来的写成了文章，一些不能发出来的业务总结留在了本地。但以目前来看，不熟悉的内容还很多，尤其是供电所学习结束后，到了定好的岗位，又是大量新的业务需要熟悉，到现在也没整理完成。 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:4:0","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"收支 2021 年共收入 25061.96 元，支出 18053.44 元。从折线图看，以 9 月入职为分界点，9月之前基本上是支出大于收入的状态，但从 9 月入职开始，收入开始大于支出。 从分类支出看，饮食类（包括三餐、外出聚餐、买菜、水果）共花费 4306.42 元，占总支出的 23.86%；数码产品（包括实物电子设备和游戏、会员、订阅等虚拟支付）共花费 3211.80 元，占总支出的 17.79%；各种日用品（牙刷等消耗品、手机壳这类小物件等）共花费 2611.74 元，占总支出的 14.47%；交通类支出 1675.33 元，主要是回家的往返支出和旅行的S支出；买衣服花费 1118.89 元，占比 6.2%；给家人买东西花了 2302.00 元，占比 12.75%；生活日常（理发、话费、快递等）共花费 1057.96 元，占比 5.86%；其它花费一共占比 9.8% 。 毕业旅行单独拿出来提一下，一共 4 天，共花费 1666.66 元。 展望 2022 年，预计各种花费如下 饮食类中，周末日常花费全年约 2100，零食水果全年约 1200，聚餐及其它设置预算 700，三项总计 4000 元。 数码产品参考 2021 年的支出，设置预算 3000 元。 日用品分类中，牙刷、牙膏、洗面奶、柔肤水、防晒霜、洗发水、护发素、洗衣液等消耗品更换周期比较固定，全年约 800，其它购物支出设置预算 2000。 交通类中，每月回家至少 1 次，往返约 150，全年 1800，其它出行设置预算 1000 元。 衣物类中，内裤、袜子、T恤、毛巾等更换周期比较固定，全年约 400 元，其它不定期需更换的衣服，或非常想买的衣服共设置预算 2000 元。 生活日常中，话费 46×12=552，理发 20×12=240，加上其它零碎支出，设置预算1500 元 给家人买东西设置预算 5000 此外，2022 年计划考驾照，设置预算 4000；没有大病的情况下，体检、买药、洗牙等医疗方面的花费设置预算 2000；旅行单项中设置预算 5000。由于 2021 年学习支出比较少，2022 年计划增加学习类支出，预算为 5000，主要用在购买书籍、课程和考试报名上。 综上，2022 年预计花费 34500 元，预计收入 64800，因此2022 年结余估计在 30000 左右。但考虑 2021 年2025 年的中期计划，结余最好是在 40000 到 50000 之间，中间这个缺口就需要通过其它途径来补了，因此 2022 年还需要单列一个副业发展的计划。 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:5:0","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"下年计划 2022 年预计的大事有两件：国培和考驾照。下面则介绍各方面的分类计划 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:6:0","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"工作 熟悉本地电网的总体运行情况，学会配网规划、负荷预测等电网规划的方法，能够独立完成电网规划报告【1-2月】； 和大家配合完成全区范围内的低压线路图重绘工作【1-6月】； 完成省培和国培【3-6月】； 深入理解奖惩细节和薪档积分规则，规则范围内尽量提升收入，目前包括 写内网新闻报道【全年】 考取软件工程师的证书【7-11月】 发表论文，为评定高级职称做储备【7-12月】 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:6:1","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"生活 以下大部分已经养成习惯，2022 年继续保持，娱乐类的内容不做强制要求，因为本意是放松，不应反而成为负担，如果是计划养成的习惯，会在后面备注 每周六换洗衣物（周三额外换洗一次内衣） 每周六晚上一部电影 每月出游一次，全年两次远距离旅行，好好看看这个世界（视疫情发展而定） 每周五晚和家人通话，但每月回家的那一次周末除外 坚持健身，阶段性目标依然和以前一样 子弹笔记的记录格式规范化 坚持记账，同时完善记账的标签体系，发挥其在下一年度收支中的指导性作用 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:6:2","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"学习 考驾照【3-10月】 发展其它收入，可选包括写稿、当Up主等，考虑考取编辑证、整理师证等证书【全年】 梳理 2021 年完成的《安全感提升》系列文章，开始实践其中的预算，预存各类应付意外情况的资金和物资，完善应对各种情况的预案【7-12月】 开始学习经济学课程，了解股票、国债、基金等内容，准备投资【7-12月】 学习沟通技巧、人际关系处理原则和一些心理学知识，思考如何在不违背自身原则的情况下与世界和谐相处【3-4月】 思考恋爱、婚姻、生育等问题，如果做出了不婚或则丁克的决定，如何应对社会舆论压力，如何应对周围人的压力【5-6月】 致用类书籍的阅读范围为以上几方面，其它书籍凭兴趣，全年阅读量在 30~50本 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:6:3","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["日程及周刊"],"content":"健康【专项计划】 生活中常见疾病及用药【1-3月】 家庭小药箱应该放哪些东西（少数派，丁香医生都有相关文章）【1-3月】 常见外伤的处理和一些急救知识（急救培训）【3-6月】 医保转移 定期体检，应体检的条目，体检单如何看，定期进行牙科检查（包括洗牙），每年做一次验光和眼部检查【3-6月】 医院看病的流程，医保缴纳与报销方法，拨打 120 的注意事项【3-6月】 ","date":"2021-12-31","objectID":"/2021/end-of-2021-summary/:6:4","tags":["日程"],"title":"2021年末总结和2022新年计划","uri":"/2021/end-of-2021-summary/"},{"categories":["国网的咸鱼生活"],"content":"入职后先在供电所学习了两个月，现在学习结束做一个总结，算是画一个句号。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:0:0","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"1. 基本情况 供电所的名字和位置就省略了，记录一下其它情况，各种数据可能不是最新的，这里只是提醒，到一个地方最后先掌握这些总体性的东西。 整个供电所有各类员工 24 人，其中所长 1 名，副所长 1 名，营业厅营销人员 3 名，台区经理 19 名，基本这就是一个供电所的人员构成。所有这些人负责 1 个乡镇、9个行政村、12047户居民、160个企业的工业生产和 4.2 万人生活用电供应、管理和服务以及电网检修、维护任务，注意，这段话里涉及的每一点在下面的业务介绍中都会提到。整个供电所管辖配变 384 台，其中公用台区 163 台，专变 221 台，总容量 124185KVA，10KV 线路 10 条，共计 113.958 KM，低压线路 207 条，共计 152.6KM。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:1:0","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"2. 业务介绍 所长和副所长主要做的事情就是上传下达和遇到事情拿主意，上级单位安排的每个任务由所长和副所长传达并划分和安排到每个人身上，并在全过程中监督执行，以及实时的将执行情况返回；同时，所有员工解决不了的问题，或者没法拿主意的事情，都需要所长和副所长拍板决策，和其它部门、单位外其它人员的沟通也由所长副所长完成。所以，通俗的讲，所长和副所长就是这个层级的管理岗位的典型代表。 营业厅的几名营销人员负责的工作如下 低压居民用电业务受理，包括新用电、过户、电表迁移、并户、分户等 低压非居民用电业务受理，比如各种商铺、企业的用电 电费查询、用电量查询、电费（业务费）收取、增值税发票开具等业务 计量表、铅封等物资的注册登记、保管、出库管理等 电表电量信息采集（电脑操作，不用出门） 以上相关业务涉及的各类纸质文件的管理以及电子化 台区经理其实就是我们平时说的农电工，他们负责 根据营业厅受理的低压居民或非居民业务前往现场进行实施，比如装表、接线等； 每月根据营业厅给出的欠费清单对自己所管辖区域的用户催缴电费 处理 10kV 线路和低压线路的突发故障，平时也需要进行巡视检查 完成临时安排的任务，比如检修或用电核查等 这里注意，供电所不受理高压（10KV以上）用电业务，由区/县公司负责（但对外声称是所有业务都受理的，受理后将业务转接到对应单位） 下面详细介绍各类业务的具体步骤。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:2:0","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"2.1 低压居民用电 总体来说，我们可以将低压居民用电的业务分为三个方面：业扩报装、电费交纳和停电保修。 A. 业扩报装 业扩报装包含的业务如下 新装、增容：通俗点说就是新盖房子要通电，或者原来的电不够用了，申请增加以下容量。这两者办理可以到营业厅柜台办理，也可以在「网上国网」发起申请，均需准备包括身份证、户口本、房产证等材料，主要目的是证明身份和对房屋的所有权。注意，按国网要求，从申请到装表接电不得超过 3 日，且计量装置（电表、表箱）及以上设备由国网公司出资，也就是电表不用用户花钱买，但电表入户的线、入户总开关、漏电保护器等需要用户自行委托电工完成。 移表：因修缮房屋或其它原因需要移动电能计量装置安装位置，通俗讲就是给电表挪个位置。 改类：同一受电装置内电力用途发生变化而引起用电电价类别改变，最常见的就是居民房屋改成商铺，需要将居民用电电价改商业电价，或者相反，最近的特殊情况是冬季取暖相应国家号召办理了煤改电，为了获取国家补贴的优惠电价，也需要办理这个业务。 销户：因客户停止用电，与供电公司终止供用电关系，但这种业务很少，一般用电的时候办理都很积极，但不用的时候真的少见有人专门办销户，尤其是现在装个电表不要钱了，更是如此。 更名或过户：因房屋转让或其它原因需要变更用户户名。 B. 电费交纳 电费交纳则主要分电费计算规则、交费渠道和其它注意事项三部分。 首先，居民用电实行阶梯电价，如下表所示，按每月用电量分为三档。第一档电量为 170kwh 及以下，执行基础电价 0.477元/千瓦时；第二档电量为 171~260千瓦时，电价在第一档基础上，每千瓦时加价 0.05 元；第三档电量为 261 千瓦时及以上，电价在第一档电价基础上，每千瓦时加价 0.3 元。 在统计及交费时，用电实际上都是以「户」为单位，正常情况下，一户就是一个房产证件对应的住宅，一户安装一个电表，这就是所谓的「一户一表」。但实际应用中各种情况比较多，比如多代同堂人数较多的家庭，各自经济独立，可能就会需要多个电表分开来计算，再比如安装了电动汽车充换电设施或响应国家号召安装了电采暖设备的，充换电设施合电采暖设备一般使用一个和家庭用电独立的电表，这时候一户也会有多个电表。这些一个住宅安装多个电表的情况，可以单独计费，也可以采用「合表计量」，此时采用上图中对应列的电价。 除了阶梯电价外，电费缴纳还有峰谷分时的区别，峰段指的是 8:00~22:00，谷段指的是22:00~次日8:00，峰段的电价要比不分时高，而谷段的电价要比不分时低，所以如果晚上用电比较多，可以申请执行峰谷电价。但不是所有用户都可以申请执行峰谷电价，只有下面三类可以： 直接向供电企业结算电费的「一户一表」居民用户（不含多户居民共用一块电表计量的用户）； 执行居民电价的非居民用户 执行居民电价的城乡居民住宅小区公共附属设施用电及电动汽车充换电设施用电 要注意，峰谷电价的执行周期为“年”，且不得少于一年，所以申请之前一定要想好，没办法中途反悔。另外，上述第二条提到了执行居民电价的非居民用户，这些用户包括：民政部门批准的社会福利机构；学校教学合学生生活用电；经县级及以上人民政府宗教事务部门登记的寺院、宫观、清真寺、教堂等宗教活动场所生活用电；城乡社区居委会（含村民委员会）的工作场所及其非经营公益服务设施；机关、部队、企事业单位集体宿舍合监狱监房的生活用电；利用可再生能源供热制冷项目运行用电；居民住宅小区公用附属设施。 供电公司每月电费的结算日期一般是每月 1 日零点，从这一天起 10 日内，电费违约金从逾期之日起计算至交纳日止，居民户每日按欠费总额的千分之一计算。结清欠费后，可以拨打停电通知单上的抄表员电话或“95598”联系复电，根据公司规定，费用结清后 24 小时内恢复供电。 如果发现用电量或电费突增或突减怎么办？在确定没有大功率电器设备影响的情况下，可以联系供电公司抄表人员进行现场核对，如果你觉得电表不准，可以向供电营业厅提出验表申请（也可以向其它有资质的计量检定机构申报校验）。如校验结论为合格，检测费用由客户承担；如不合格，由表计提供方承担，但能证明因对方使用、管理不善的除外。 C. 交费渠道 支付宝和微信是现在大家交电费最常使用的方式，除此之外各大银行的手机客户端也可以交费，然后是在营业厅的自助终端上交费和直接到柜台交费。但这里还有两种方式介绍给大家 一是银行代扣交费，可以选择到供电营业厅签署电费结算协议，按照用电量定期从银行卡种扣款 二是使用网上国网APP，这是国网自己的手机APP，使用这个软件的优势在于可以查询每个月、甚至每天的用电量，以及各种业务不必跑营业厅，可以直接在这上面提出申请。 D. 其它 业扩报装中提到的业务都需要准备一堆材料，但变更手机号则没有这么麻烦，可以在网上国网APP线上变更，也可以联系分管自己小区的电工，把变更后的手机号告诉他即可，营业厅收到电工的反馈后会直接在系统里更新联系方式。 电工师傅们出去装表接电的时候也跟出去见识过，所以也大概理解这个流程。首先，办理完用电申请后，由电工拿着电表去你家里安装，不能自己拿走电表，他们会从最近的低压线路上引出线接入电表，这些都是供电公司提供，但从电表入户的线和设备都应当用户自行准备和安装。电表通电后，电工师傅需要用一个掌机进行定位以及向系统提交基础信息，比如安装位置，从那个电杆接出来的等。另外，为了防止偷电或私自拆表箱，需要用铅封来封住电表和电表箱，铅封有两种，一种是红色长条，看起来像电阻，另一种是小铁片，需要配合铅丝使用。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:2:1","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"2.2 低压非居民用电 低压非居民用电，字面含义，就是低压条件下，除居民用电外的一切其它用电，最常见的是商铺用电。低压非居民用电的大致内容和低压居民用电相同，只在细节上有区别，但有一个最重要的不同：低压非居民用电要签署用电协议。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:2:2","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"2.3 数据召测 这里的数据指的是用电的相关数据，比如用了多少电，当前的实时电压电流等，但这些数据都在现场的采集终端里，需要把采集终端中存储得数据存入服务器，这就叫数据召测。这里值得一提的是，每个公用变压器负责一个区域，采集终端就在这个配变的箱子里，当然，这个箱子里还有一个总电表，用来统计该区域用电总信息。 一般来说，召测的数据有三种类型： 实时数据。即30分钟内的实时数据，可设置为5分钟、15分钟、或30分钟，只能召测一次 冻结数据。电能表拥有冻结功能，即在特定的时间把数据保存起来，召测冻结数据就是召测这些事先保存好的数据，有如下几种类型 整点冻结：存储整点时刻或半点时刻的有功总电能，可存储254个数据。 日冻结：存储每天零点时刻的电能量，可存储254天的数据。 月冻结：存储每月1日零点的总电能和各费率的电能数据，可存储24次。 定时冻结：按照约定的时间及间隔冻结电能量数据； 瞬时冻结：在非正常情况下，冻结当前的日历、时间、所有电能量和重要测量的数据；瞬时冻结量保存最后3次的数据。 事件数据。即电表或者终端发生事件时候的具体信息 系统会每天自动将冻结的数据存入数据库中，但存在失败的可能性，此时就需要人工进行补招，由于冻结的数据是历史数据，因此可以反复召测。 进行数据召测时使用的系统称为「电力用户用电信息采集系统」，网址为 20.38.194.7/eic，登录名为 hanf0497，密码为 Hanf0123@ 在左侧栏中选择「采集点」，主页面选择「首页—\u003e2020考核指标」，然后选择「日统计」，其中涉及的指标就是我们关心的内容，核心的指标有两个：电量采集成功率和曲线成功采集率。系统会在每天 8:30、14:00 和 20:00 分别刷新一次 T-1 日的以上指标数据，每天 22:00 刷新一次 T-2 日的指标数据，因此，上午进行补采后，下午查看指标会发现数据有所提升，同时补采成功的用户不会再次出现在失败列表里。这里值得注意的是，由于晚上 10:00 有一次刷新，对于 T-2 日的数据是有一次补救机会的。最后，「月统计」和「逐日统计」中的指标和「日统计」是相同的，周/月/季度的指标数据更新时间为每周/月/季度第 1 天的 8:30、14:00 和 20:00。 电量采集 电量采集成功率的算法在右下角的「算法解释」中有说明，包括日采集成功率和月采集成功率，月采集成功率为当月每日成功率的平均值，该类指标主要用来评价各单位各类用户每日电能示值类数据采集情况。以日采集成功率为例，算法如下，注意，由于专变用户归属区供电公司管辖，其权重已增加到公变用户 $$ 电量日采成功率 = 公变总表日成功率 \\times 0.7 \\ + \\ 低压用户日成功率 \\times 0.2 \\ + \\ 分布式电源用户日成功率 \\times 0.1 $$ 其中： $$ 公变总表日成功率 = (正向有功电能示值 \\ + \\ 反向有功电能示值)/2 \\ 低压用户日成功率 = (低压单相用户正向有功电能示值 \\ + \\ 低压三相用户正向有功电能示值)/2 \\ 分布式电源用户日成功率 = (正向有功电能示值 \\ + \\ 反向有功电能示值)/2 $$ 可以注意到，电量采集算法的核心就是正向有功电能示值，下面分别介绍公变、用户和光伏三种具体的电量采集过程。 对公变电量采集的过程如下 切换到公变页面； 供电单位选择「胡村供电所」，点击「查询」； 在出现的页面中寻找「正向有功电能示值」列 如果该列中数值为 100，跳过如下步骤，直接结束 如果小于 100，点击该数值 全选挑选页面中的所有结果，点击右下角的「添加至列表」，则所有待招测采集点将出现在侧栏（左）中； 在侧栏中选中第一个采集点，右键，选择「召测数据」； 在召测数据页面的左上角选择「考核表数据」，选中列表中的条目； 召测数据页面中间偏下的参数项选择「日冻结」； 在召测数据页面右侧列表中寻找「电能量对象—\u003e0010：日正向有功电能示值」，点击添加，该数据项将出现在页面中间的召测数据项列表中； 点击右上角的「召测」按钮； 依次召测侧栏中其它的采集点数据。 对普通用户电量采集的过程如下： 切换到普通用户界面 供电单位选择「胡村供电所」，点击「查询」； 在出现的页面中寻找「正向有功电能示值」列 如果该列中数值为 100，跳过如下步骤，直接结束 如果小于 100，点击该数值 全选挑选页面中的所有结果，点击右下角的「添加至列表」，则所有待招测采集点将出现在左侧列表中； 点击「失败数」一列对应的数字，在出现的页面中可以看到采集失败用户的测量点编号； 在侧栏中选择刚才点击的「失败数」对应行的采集点名称，右键，选择「召测数据」； 跳转的召测页面有两种情况 情况1：召测页面左上角存在「用户表数据」「考核表数据」等 3 个选项，此时选择用户表，并在用户表列表中根据测量点编号选择所有采集失败的用户，参数项选择「日冻结」，召测数据项选择「电能量对象—\u003e0010：日正向有功电能示值」，添加到召测数据项列表并点击召测； 情况2：召测页面上方出现「日冻结数据」「曲线数据」等多个选项，此时选择日冻结数据，然后选择「电表数据」，在出现的列表中根据测量点编号选择所有采集失败的用户，召测数据项选择「F1」，点击召测； 跳转回第 5 步，依次完成其它采集点的失败用户补招工作。 对光伏电量采集的过程如下： 切换到光伏界面； 供电单位选择「胡村供电所」，点击「查询」； 在出现的页面中寻找「正向有功电能示值」列 如果该列中数值为 100，跳过如下步骤，直接结束 如果小于 100，点击该数值 全选挑选页面中的所有结果，点击右下角的「添加至列表」，则所有待招测光伏用户将出现在左侧列表中； 在侧栏中选中第一个光伏用户，右键，选择「召测数据」； 在召测数据页面的左上角选择「用户表数据」，选中列表中唯一的条目； 参数项选择「日冻结」，召测数据项选择「电能量对象—\u003e0010：日正向有功电能示值」，添加到召测数据项列表并点击召测； 依次召测侧栏中其它的光伏用户。 注：召测数据面板下方可以选择重招当前选中项和重招当前失败项。 曲线采集 曲线采集成功率的算法同样在右下角的「算法解释」里，包括日采集成功率和月采集成功率，月采集成功率仍然是当月每日成功率的平均值。该类指标主要用来评价各单位各类用户每日电流、电压、功率类曲线数据采集情况，计算公式如下，专变用户权重已增加到公变用户 $$ 曲线日采成功率 = 公变总表日成功率 \\times 0.7 \\ + \\ HPLC用户日成功率 \\times 0.2 \\ + \\ 分布式电源用户日成功率 \\times 0.1 $$ 其中，公变总表日成功率的统计规则如下，HPLC和分布式电源用户日成功率的统计规则和它一致，另外，公变总表、分布式用户电能示值均包括反向曲线 $$ 公变总表日成功率 = 电能示值曲线 \\times 0.3 \\ + \\ 总有功功率 \\times 0.1 \\ + \\ 无功功率 \\times 0.1 \\ + \\ (A相电压曲线+B相电压曲线+C相电压曲线+A相电流曲线+B相电流曲线+C相电流曲线)/6 \\times 0.4 \\ + \\ 总功率因数曲线 \\times 0.1 $$ 可以注意到，曲线采集算法包括电能示值、有功功率、无功功率、功率因数和三相电流电压，这也是我们召测数据时选择数据项的标准，下面分别介绍公变、HPLC和光伏三种具体的曲线采集过程。 对公变曲线的采集过程如下 切换到公变页面； 供电单位选择「胡村供电所」，点击「查询」； 在「正向/反向有功电能示值」列外选择一个数值最小的列，点击该数值； 将出现的页面中的所有结果添加至侧栏； 在侧栏中选中第一个采集点，右键，选择「召测数据」； 在召测数据页面的左上角选择「考核表数据」，选中列表中的条目，参数项选择「分钟冻结」； 召测数据项选择曲线类对象中的前 5 个和后 2 个（如下所示），添加到召测数据项列表中并开始召测； 20000200：电压曲线 2001：电流曲线 2004：有功功率曲线 2005：无功功率曲线 200A：功率因数曲线 00100201：正向有功总示值 00200201：反向有功总示值 依次召测侧栏中其它的采集点。 对 HPLC 曲线采集的过程如下 切换到 HPLC 页面； 供电单位选择「胡村供电所」，点击「查询」； 在「正向/反向有功电能示值」列外选择一个数值最小的列，点击该数值； 将出现的页面中的所有结果添加至侧栏； 点击「失败数」一列对应的数字，在出现的页面中可以看到采集失败用户的测量点编号； 在侧栏中选择刚才点击的「失败数」对应行的采集点名称，右键，选择「召测数据」； 在召测数据页面选择「用户表数据」，根据测量点编号选中所有失败的用户； 参数项选择「分钟冻结」； 召测数据项选择曲线类对象中的前 5 个和后 2 个，添加到召测数据项列表中并开始召测； 依次召测侧栏中其它的采集点。 对光伏曲线采集的过程如下 切换到光伏界面； 供电单位选择「胡村供电所」，点击「查询」； 在「正向/反向有功电能示值」列外选择一个数值最小的列，点击该数值； 将出现的页面中的所有结果添加至侧栏； 在侧栏中选中第一个光伏用户，右键，选择「召测数据」； 跳转的召测页面有两种情况 情况1：选择「用户表数据」，参数项选择「分钟冻结」，召测数据项选择曲线类对象中的前 5 个和后 2 个，添加到召测数据项列表并点击召测； 情况2：选择「曲线数据」，选择「电表数据」，召测数据项选择 F101、F103、F81、F85、F105 以及 F89-F94，即电流、电压、无功功率、有功功率、功率因数和三相电流电压，然后点击召测 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:2:3","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"2.4 线损治理 在采集系统中可以查看各条线路或台区的线损，线损简单来讲，就是供电量与用电量的差值占供电量的比重，按要求，线损值不可高于 8%，否则为高损，需要及时处理，当然，也不可以为负损，这种情况是有可能出现的，一般是由于由自发电用户的存在，计算错误导致发电量反而小于用电量。 线损治理的办法目前不清楚。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:2:4","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"2.5 线路故障处理 电工师傅们除了装表接电、催缴电费，平时最主要的工作就是处理线路故障，比如电线断了或跳闸了或某个设备烧了等等，都会导致线路停电，停电后根据用户电话或调度部门通知，电工师傅就需要出去处理。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:2:5","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"3. 临时业务：巡线 如果说 2.5 所述的线路故障处理是停电后出去抢修，巡线就是平时的检查，主要目的是及时发现存在的问题，避免之后发生停电，这是一种预防性的工作。 巡线时一般由多人协作，只允许看，不允许登杆。检查的问题包括：电杆倾斜、鸟害、电线散股、开关烧毁、变压器缺油、直瓶破损、避雷器坏、树障等等，可能会拿着望远镜、红外测温相机、超声波探测仪等等设备，在巡线过程中需要把发现的所有问题记录下来，每个问题都拍个对应的照片。在巡视完成后整理出缺陷和隐患记录，等待下一次计划停电来消除这些问题。 一条线路除了主线可能会有很多支线，甚至支线的支线，主线或支线都可能几根、几十根、上百根电杆不等，所以巡线的时间非常不固定。 由于巡线工作在野外进行，因此春秋两季是最合适的时候，不仅气候适宜，少雨雪多晴天，更重要的是可以避开庄稼地里的农作物，不管是视野还是行进难度都大幅降低。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:3:0","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"4. 临时业务：核查 在供电所的时候正好碰上营销大普查，不过大家都叫做核查，对高压用户，主要是核对其公司位置、营业执照、身份信息、联系方式、各种设备的数值细节，还需要给现场的计量设备拍照片，低压非居民用户、低压居民用户、光伏用户主要是位置、身份信息、联系方式等。 核查过程中可以发现各种问题，包括 高压用户的变压器实际使用者和系统登记的人不一致的情况很普遍 高压用户没有营业执照的情况比较多 高压用户很多自己进行线路改接 低压用户系统中的名字和身份证上的名字对不上的情况很普遍，有些事登记失误，有些是因为当初登记的时候登记的就是小名，然后一直沿用 跟着师傅出去核查熟悉了很多东西，包括 各种线路、设备、计量装置辨识及所在位置 基层用电所出现的各种各样的情况，所以上面做计划时一定不能想当然，要实际去试行一段时间收集问题再说 熟悉了供电所所管辖范围内各行政区域，也就是各村子逛的比较熟 了解了不同的电工师傅有不同的性格，管理他们确实不容易 电工师傅在完成工作的过程中确实会出现各种问题，因为什么样的用户都有 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:4:0","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"5. 突发情况：五星供电所评选 学习期间正好评选五星供电所，因为补材料，学到了很多运检的东西，下面这张图是梳理出来的电工师傅平时工作需要写的资料 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:5:0","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"6. 基层存在的问题总结 电工师傅年龄结构不合理，多数年龄过大 师傅们年龄过大导致对各种新系统不熟悉，同时没有动力或能力去学习使用，数字化在基层起的作用不大 师傅们普遍学历较低，以经验解决问题比较多，各种数值参数等不理解也不理会 很少按各种规则制度执行，工作票、操作票、抢修票等从没开过，直接工作，而且很多情况下以抢代维，平常巡线检查比较少，只有出了问题才去处理 老人对各种数字化系统使用存在障碍，依然去营业厅交费 各种业务流程依然存在简化的可能，一个业务可能用户需要跑很多遍，很多地方 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:6:0","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["国网的咸鱼生活"],"content":"附录：名词解释 低压集抄：即自动集中抄表 台变：安装在某地的变压器，是特指在装、运行的某台变压器 台区：台变供电的区域范围 机井：利用动力机械驱动水泵提水的水井 10kv821…线 公变和专变：公变即公用变压器，由供电单位出资建设，产权也属于供电单位；专变即专用变压器，由用户出资建设，常见于各种制造工厂，产权属于用户。更多信息参考 专变与公变 - 知乎 (zhihu.com) 普通用户：使用电能表计量的普通用电用户，可能包括居民、商铺、公司等。 HPLC：宽带电力线载波，是智能电表中的一个模块，作用包括数据采集、远程监测、电能管理等。 光伏：指光伏发电，用户安装光伏系统所发电量可以并入电网系统。 分布式电源：光伏发电即分布式电源的一种，其它的还有如风能发电等。 终端：现场负责采集和存储用户用电信息数据的设备，并将数据上传给主站，通常位于变压器的柜子里。 ​ 注意，采集终端和我们平时说的电能表是两个设备，两者通过 RS485 接口相连，电能表更靠近用户，采集终端从用户的电能表采集到数据后，通过 GPRS 上传到后台服务器。 采集点：安装采集终端的位置。 计量装置：电能表、计量用互感器和二次连接线导线构成的总体叫做计量装置。 计量点：安装计量装置的位置，通常是我们所说的表箱。 计量点性质：有考核和结算两种，考核用于台区供电统计和考核，结算用于用户售电侧结算。 电能示值和电能量：电能示值就是电能表直接显示的数据，电能量是两个不同时刻电能示值的差值。 PT与CT https://www.zygsz.com/article-detail/BxydnG3N 电能表上标有PT和CT是什么意思_百度知道 (baidu.com) 有功和无功：电能可以用来转化各种能量。例如可以通过电磁炉转化为热能，通过电灯转化为光能，通过电机转化为机械能等，这些转换过程中消耗的电能称为有功电能。有些电器装置在做能量转化时得先建立相应的转化环境，例如变压器、电机等需要建立磁场才能进行能量转化，其它电器可能还需先建立电场才能进行转化，这种情况下所需的电能称为无功电能。有功总电量就是所实际消耗的电能，无功总电量就是无功量（功率因数）。 正向与反向：正向就是指电网向用户传输的电能，反向则是指用户向电网传输的电能。 有功功率：保持用电设备正常运行所需的电功率，也就是将电能转换为其他形式能量(机械能、光能、热能)的电功率。比如：5.5千瓦的电动机就是把5.5千瓦的电能转换为机械能，带动水泵抽水或脱粒机脱粒；各种照明设备将电能转换为光能，供人们生活和工作照明。 无功功率：用于电路内电场与磁场的交换，并用来在电气设备中建立和维持磁场的电功率。它不对外作功，而是转变为其他形式的能量。凡是有电磁线圈的电气设备，要建立磁场，就要消耗无功功率。比如40瓦的日光灯，除需40多瓦有功功率(镇流器也需消耗一部分有功功率)来发光外，还需80乏左右的无功功率供镇流器的线圈建立交变磁场用。由于它不对外做功，才被称之为“无功”。 功率因数：衡量电气设备效率高低的一个系数，功率因数低，一般说明无功功率大，设备的利用率较低，线路供电损失较大。 四象限：DL/T645-2007 将一个平面坐标系的横轴定义为无功功率，纵轴定义为有功功率。二个轴将平面划分为四个区域，左上角为Ⅰ象限，顺时针依次为Ⅱ象限、Ⅲ象限和Ⅳ象限；Ⅰ象限和Ⅱ象限无功定义为正向无功，Ⅲ象限和Ⅳ象限无功定义为反向无功； 供电系统向用户输送有功和无功电能时，电表在第I象限工作显示的有功和无功都是正值。这是最常见的一种方式也是大部分用户用的方式。 当供电系统向用户输送无功电能时，用户向系统反送有功电能时，电表在第II象限工作时显示有功为负值、无功为正值。这种发生在有些自发电用户在有功电能向网上送的情况。 当用户向供电系统反送有功电能和无功电能时，电表在第III象限工作时显示的有功和无功都是负值。这种情况通常发生在有些自发电的用户在内部没有负荷时出现和专业电厂一样的有功和无功向网上全部输送； 当供电系统向用户输送有功电量时，用户向系统反送无功电量时，电表在第IV象限工作时显示有功为正值，无功为负值；这种情况通常是该用户从网上获取有功电量，但是内部电容器等投多了，向网上输送电量。 ","date":"2021-12-05","objectID":"/2021/study-summary-of-power-supply-station/:7:0","tags":["国网"],"title":"供电所学习总结","uri":"/2021/study-summary-of-power-supply-station/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第七期月刊，2021 年 11 月。 ","date":"2021-11-30","objectID":"/2021/life-monthly-7/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 7 期 (202111)","uri":"/2021/life-monthly-7/"},{"categories":["日程及周刊"],"content":"时政 1、世界卫生组织：最新出现的新冠变种病毒是怎么回事？ 本月出现了新的新冠变种，传染力更强，目前不知道会产生多大影响。 ","date":"2021-11-30","objectID":"/2021/life-monthly-7/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 7 期 (202111)","uri":"/2021/life-monthly-7/"},{"categories":["日程及周刊"],"content":"生活 11.02，晚上和北辰青年的编辑聊天 11.04，10KV706南席线巡线 11.05，给弟弟高考报名 11.06 初雪 衣物和杂物整理 试用小柚子清洁剂，确实好用 11.09，《原神》胡桃池歪了琴，对生活失去了希望 11.11，尝试卖小笼包那家的炒饭，味道还行，但太油腻，馄饨则一点味道没有 11.14 运检材料补缺的思维梳理及流程图绘制 晚上吃烧烤 11.15，双十一买的东西陆续到达，宿舍改造按计划进行 11.18，舍友请吃麻辣烫 11.20 办理工作地移动新卡，注销旧卡 办理建行借记卡，储蓄用 超市购买零食 11.21，逛小米之家，最喜欢小米 11 青春版和红米 Note 11 Pro 11.25，回来比较晚，在火车站附近吃的饭，果然沙县小吃，永远的神 11.27，前一天晚上得知老爸回家了，早上很早起来去小米之家买了个红米 K40 当礼物，回家喽！晚上一家人打牌，和老妈的组合无敌！ 11.28，白天理了个发，晚上回单位，去张亮麻辣烫的店里吃，发现比外卖便宜将近 10 块 11.30，接到通知，被分配到发展建设部了，供电所的学习告一段落（内心OS：明明是发展建设部，为啥大家都称呼为发策） 11.03-11.14，五星供电所评选材料整理 11.17-11.22，上级检查后，五星供电所评选材料大修 11.01-11.07，《国网组织架构》文章 11.16-11.30，《国网薪酬体系及晋升通道》文章 11.23-11.30，高压核查（工作） ","date":"2021-11-30","objectID":"/2021/life-monthly-7/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 7 期 (202111)","uri":"/2021/life-monthly-7/"},{"categories":["日程及周刊"],"content":"观影 11.01，电影《神偷军团》。看预告片的时候很惊喜，以为是又一部《惊天魔盗团》，而且还是《活死人军团》外传，果断加入待看列表，等到看完才发现没有想象中那么好，唯一值得一提的是娜塔莉·伊曼纽尔饰演的女主很棒。 11.06，电影《峰爆》。情感和气氛很棒，但特效太假了、非常出戏，有的台词也比较尴尬，像强行表现主题一样，一句话评价：国产灾难片进步空间还很大。 11.08-11.11，美剧《紧急呼救：孤星》S01。看到最后几集才发现，第一季之前就看完了，实在是一件尴尬的事情。 11.13，电影《红色通缉令》。又是一部待看列表里待了好久的电影，看看这主演阵容：道恩·强森、瑞安·雷诺兹、盖尔·加朵 ，已经不需要有任何担心了，事实的确如此，而且看结尾这样子，是要出一个系列的趋势。 11.18，电影《007：无暇赴死》。要深度没深度，要感情没感情，要爽度没爽度，本月最佳烂片，海报都不想放了，就这样吧。 11.20，电影《尚气与十戒传奇》，烂片程度比 007 更胜一筹，从头到尾内心充满吐槽欲，然而看完逛豆瓣的时候发现华人群体的评价很高，非常有共情，看来自身经历对电影评价的影响确实很大。不放海报，没有好看的。 11.21，电影《皮皮鲁与鲁西西之罐头小人》。我们总是用着大人的思维看着小孩的童话，别用「这是拍给成年人的童话」自我安慰了，事实就是，我们再也回不去小时候了。最后，下面剧照中小女孩的虎牙超级谜之可爱！ 11.23-11.30，《出租什么都不做的人》E01-08。从待看列表里翻出来的日剧，很棒，虽然某些价值观不一致，但也正是由于这些不一致我们才会去思考一些问题。最后吐槽一句，男主和他老婆是相当没有夫妻相啊，相处也完全没有夫妻的感觉。 ","date":"2021-11-30","objectID":"/2021/life-monthly-7/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 7 期 (202111)","uri":"/2021/life-monthly-7/"},{"categories":["日程及周刊"],"content":"阅读 书籍《与内在小孩和解》读完，感觉需要再读一遍，想象心中有另一个被压抑的自己这个方法太棒了。 11.13，书籍《焦虑的人》读完，相当有意思的一本书，生活就是这么戏剧。 ","date":"2021-11-30","objectID":"/2021/life-monthly-7/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 7 期 (202111)","uri":"/2021/life-monthly-7/"},{"categories":["日程及周刊"],"content":"思考 1、我告诉你「我喜欢你」，并不是一定要和你在一起，而是希望今后的你，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。 ——摘自某部小说 2、生活是否有其它可能 ——观看日剧《出租什么都不做的人》的思考 3、为什么周末感觉不是自己的，因为时间都给了手机。 4、以前写过的每个字，都是给自己挖的坑，尤其是对这个领域理解更深的时候回去看。 5、好好想一想，帮别人的时候，做到什么程度比较好。 6、不要总想着欠了啥赶紧还清楚，天天想这些太累了，钱和人情皆如此。 7、注意自己想要什么，不要完全沉醉在工作里，要找时间做自己喜欢的事。 8、抽烟、喝酒、染发，这些都定义不了一个人，只有相处才能看清，所以不要太相信第一印象。 ——回忆自己接触过的人 ","date":"2021-11-30","objectID":"/2021/life-monthly-7/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 7 期 (202111)","uri":"/2021/life-monthly-7/"},{"categories":["日程及周刊"],"content":"收藏 【职业】旅行编辑 【技巧】每个月把想买的东西记在下个月月初的日历中 【软件】慢慢买，可以查商品历史价格 ","date":"2021-11-30","objectID":"/2021/life-monthly-7/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 7 期 (202111)","uri":"/2021/life-monthly-7/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 照片备份 QQ和微信聊天记录备份 录音整理 浏览器书签备份 对账 月刊完成 ","date":"2021-11-30","objectID":"/2021/life-monthly-7/:7:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 7 期 (202111)","uri":"/2021/life-monthly-7/"},{"categories":["国网的咸鱼生活"],"content":"入职培训的时候有关于晋升和薪酬的课程，但那时候时间紧、内容多，要说完全理解，也是自欺欺人。回来后在内外网找了很久，都没有找到相关的文件，直到最近才在内网的国网学堂看到相关的视频，所以这篇文章主要就根据这些视频以及当初课程拍的的照片，对薪酬组成和晋升通道两部分内容做一个梳理，从而确定要在哪方面付出多少努力，或者干脆维持现在的咸鱼生活。 TLDR（太长不看系列）： 普通员工的工资由岗位薪点工资（基本工资）、绩效工资、辅助工资组成； 福利体系覆盖比较全面，但绝大部分不能到手，而是保障性的，比如看病可以多次报销，和医保累加最高可报销到 95%； 员工的绩效考核分 A、B、C、D四个等级，可以影响工资、福利、评优、晋升等很多事，但所幸C、D等级没有比例限制； 由于薪酬改革，新员工入职 3 年才能拿满工资， ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:0:0","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"1. 薪酬体系 首先，国网实行的工资总额分级管理制度，即每一级公司（省、市、县等）员工的工资并不是总公司直接确定的，而是由上级单位发放一笔总的资金，然后由单位人资部门在这笔预算内确定大家的薪资以及给下级单位的工资总额，至于这笔钱是每个月发的多一点，分 12 个月发完，还是每个月少一点，年终给一大笔年终奖，都是各级单位决定。 国网总公司的工资总额也不是自己定的，而是在每年年初的时候，根据有关要求编制年度工资预算方案上报国资委，在国资委批复后，在这个批复的预算额度内，综合考虑经营效率、业绩考核结果、人员结构、人工成本水平和地区差异等，编制下达各省公司级单位的工资总额计划。当然，相似的，在中间层的各级单位拿到这笔预算后也要制定自己的下级单位的预算并发放。很大程度上，各单位的工资总额都和业绩考核的结果有关，而我们所谈到的各种福利，如交通补贴、通讯补贴、住房补贴、节日补助、午餐费补贴等，都是从工资总额这笔钱中支出的，而不能从其它的运营成本中支出。 最后，我们可能更关心的是自己薪酬的组成，不过这里有一点小小的差别，那就是各级单位的企业负责人和普通员工的薪酬是两种算法。负责人实行的是年薪制，根据公司业绩考核结果由上级主管单位确定和审批；而普通员工工资主要由三部分组成：基本工资（岗位薪点工资）、绩效工资、辅助工资，这三部分工资的比重根据工作属性、职位等因素略有差别，例如，辅助性岗位人员的基本工资占比略高，管理经营岗位人员绩效工资占比略高，一线生产辅助工资占比略高，整体比例约为4:5:1。 可能还有人关心企业负责人究竟包括哪些职位，这个暂时没找到资料（指官方文件《薪酬管理办法》），但根据其他省公开的资料，企业负责人一般包括董事长、董事（不含外部董事）；总经理、副总经理、总会计师、总经济师、总工程师；党委（党组）书记、党委（党组）副书记、纪委书记（纪检组长）。不过下面不关心这个，只分析普通员工的工资构成。 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:1:0","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"1.1 基本工资 普通员工的基本工资采用岗位薪点制度，所以一般称为岗位薪点工资，是以岗级为基础，依据绩效考核结果和能力素质评价确定薪档，用薪点数设置工资标准，用点值计算发放额度的工资单元。计算公式如下 $$ 岗位薪点工资=薪点数 \\times 点值 $$ 上面这段话初见很难理解，但只要耐心看完下面的内容，会发现这是最简练但最准确的描述。 首先，公式中的薪点数按照岗位薪点标准计算，该标准设立了 26 个岗级、56 个薪级，每个人都能对号入座，找到自己的位置。岗级是根据员工所从事的岗位的不同确定的，人资有个文件具体讲什么样的岗位是什么样的级别，但我在内网里没找到，所以只能根据培训的时候拍的照片自己绘制一个，可能不准确，仅供参考。 薪级是一个工资等级序列，整个国网的员工基本工资分了 56 个等级，薪级就是每个员工自己的基本工资在这个等级序列中的位置。每一个薪级有一个对应的薪点数，1薪为 500 点，56薪为 6000 点，各薪级之间不是等值增加，而是薪级越高，相邻两个薪级之间差值越大。 那么基本工资，也就是岗位薪点工资到底是怎么确定的呢？我们可以绘制如下表格，其中，行对应薪级，列对应岗级，每个岗级设置 6 个基本薪档，身处该岗位的员工的工资就在这 6 个薪档中浮动。这里可以简单解释以下薪档的含义，因为从图中可以看到薪档和薪级也是对应的，所以有人可能会有疑惑。简单的讲，薪级就是员工的薪点工资在公司整个薪点工资等级序列（56级）中的位置，而薪档就是员工的工资在所处岗位对应的 6 个薪级区间的位置，当我们谈到总体时，就用薪级这个术语，但当我们加了岗级这个限定词，通常就用薪档这个术语。需要注意的是，尽管每个岗位都只对应 6 个薪档，但各级各类人才和特殊贡献员工会多 6 个职业成长薪档，共计 12 个薪档区间。 新入职的员工被分配岗位之后，根据自己所在的公司级别和这个岗位就可以确定自己的岗级，同时根据《工资管理办法》中的薪档积分标准可以得到一个初始薪档（很可惜这个文件也找不到，所以上表也是根据照片粗略绘制的），按照上表找到该行对应的薪级，就可以确定个人的薪点数，最后再知道点值，就可以计算出自己的岗位薪点工资了。点值也不是一个定值，而是根据年度工资总额、岗位薪点工资比重和员工薪点总和等因素确定，具体公式如下 $$ 点值 = \\frac{单位年度工资总额 \\times 岗位薪点工资比重}{\\sum_{}员工薪点数 \\times 12} $$ 举个具体的薪点工资计算的例子，假设某个员工岗级为 12，薪档为 1 档，那么所在行对应的薪级就是 23，其薪点数为 1350，再假设点值以 2.8 计算，该员工的工资就是 1350×2.8=3780 元。 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:1:1","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"1.2 绩效工资 绩效大家都理解，就是根据根据每个人的工资业绩和贡献确定的工资部分，有两种形式：绩效考核奖和专项考核奖。前者和我们常说的 KPI 严格相关，可能会按月、季、年进行发放，后者则通常是对一些具有临时性、突发性重要任务的奖励。至于绩效工资占个人工资收入的比重，可能根据岗位层级和类别的不同而不同。 KPI 计算就不多说了，无非就是从上到下层层摊派指标，再由各级人资部门根据情况自行确定，当然，最重要的是，这方面的文件也没找到。不过这里可以介绍一下关于年度绩效考核的知识。 首先，各类员工年度绩效考核结果，分为 A、B、C、D四个等级。A 级占比原则上不超过 20%，如果所在单位的年度考核结果为 A，则员工中考核结果为 A 的比例可以适当提高，最高不超过 25%。C级和D级员工占比由各单位结合实际自主确定，但出现以下情形的， 考核结果直接评定为 C 级或 D 级，注意，这里划重点了，这就是红线： 违反党的纪律， 违反中央八项规定及其实施细则精神，违反国家《公职人员政务处分法》， 滥用职权、 以权谋私、 挥霍浪费、 损公肥私等， 造成不良影响的。 违反政治纪律， 无故不参加政治学习、 散布谣言、 弄虚作假、 违规信访、 泄露公司秘密、 扰乱企业正常秩序等， 造成不良影响的。 违反劳动纪律， 经常迟到、 早退、 旷工、 无正当理由不服从工作安排， 或在工作中消极懈怠、 推诿塞责， 不担当、 不作为等， 造成不良影响的。 违反安全生产规程， 岗位履责不到位， 工作失误、 失职和处置不当， 违章指挥、 违规操作等， 导致工作业绩与岗位标准存在差距的。 不注重专业技能学习， 造成专业知识、 技能水平、 解决问题能力不适应岗位工作要求的。 违反公司其他制度规定， 造成不良影响的。 各级领导人员， 年度考核评价结果为基本称职及以下的。 违反国家法律法规， 给公司造成不良影响的。 受到党内严重警告及以上处分的， 政务记过及以上处分的， 公司记过及以上纪律处分的， 直接评为 D 级。 为什么考核结果需要关心，下面可以介绍一些它所影响的方面。第一，它直接影响工资，员工的绩效工资除了受单位工资总额影响，就是受自己的绩效考核结果影响了，原则上，A 级员工与相同岗位层级员工平均绩效工资倍比不低于 1.15，C 级员工与相同岗位层级员工平均绩效工资倍比不高于 0.9。 连续 3 年绩效 A级的员工， 可由所在单位结合实际给予一次性特别奖励。 第二，它与评优评先有关，员工年度绩效考核结果未达到 B 级的， 不得推荐参加综合性先进评选，员工年度绩效考核结果为 A 级的， 优先推荐参加各类先进评选。 第三，它与福利保障有关，员工年度绩效考核结果为 A 级的， 可按本单位制度优先安排职工疗养和体检，企业年金的缴费分配也向年度绩效为 A 级的员工适度倾斜。 最后，它与岗位晋升有关，前面提到每个岗位对应 6 个薪档，薪档的晋升就需要累计积分，A、B、C、D 四个绩效考核等级，对应增加的积分就分别是 2分、1.5分、1分、0分，只有近 3 年绩效等级积分累计达到 4.5 分且上年绩效达到 B 级及以上的， 方可聘任更高层级岗位、 职务和职员职级， 上年考核评级为 C、 D 级的不得列为领导人员选拔培养对象； 近 3 年积分累计达到 5.5 分的， 优先聘任更高层级岗位、职务和职员职级； 连续 3 年绩效为 A 级的员工，可适当缩短职员职级晋升、 岗位晋升年限要求。 这也就是说，只有每年绩效考核评定在 B 级及以上，才有晋升的可能。同样，近 3 年绩效等级积分累计达到 4.5 分且上年绩效达到 B 级及以上的， 方可参加各类专家人才选拔； 近 3 年积分累计达到 5.5 分的， 优先评聘各类专家人才； 连续 3 年绩效为 A 级的员工， 可适当缩短评聘专家人才、职称和技能等级评定等方面的年限要求。各类专家人才年度绩效为 D 级的， 取消称号。 考核结果其实不止关系向上的通道，也关系向下。我们常提到国企和事业单位的稳定性，默认的一般是指没重大错误不会随意辞退员工，这个重大错误包括哪些可以查找《员工奖惩规定》，但其实一开始这个问题还和考核结果有关，即首次订立固定期限劳动合同的员工， 连续两个年度绩效等级均为 D级， 原则上用人单位不得与其续订劳动合同。除此之外，员工年度绩效为 D 级且上年度绩效为 C 级的，予以降岗； 年度绩效为 D 级且不能胜任岗位工作要求的， 或连续两年绩效为 D 级的，予以待岗；员工待岗期内未按规定参加待岗学习培训的，待岗期满考试不合格的，以及考试合格重新上岗后当年绩效仍为 D 级的， 应依法解除劳动合同。 不过也不需要太担心啦，前面已经提到 C 级和 D 级的比例各单位自行确定，也就是没有固定指标，所以一般也不会评到 D 这个等级，最多就是 C。 最后，柔性团队、 挂职锻炼、 人才帮扶、 人员借用等长期派出人员， 一般由派驻单位进行考核， 并按派出单位考核周期及时向其反馈考核结果，可以不占用派出单位的评级比例，这几种调动方式后面还会提到。 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:1:2","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"1.3 辅助工资 辅助性工资包括年功工资、加班工资、表彰奖励、五项福利性补贴、人才（专家补贴）津贴和其它津补贴，辅助工资总额原则上不超过工资总额的 15%。其中，年功工资实际上就是工龄工资，实行分段累进的计算方式，1-5 年为 10 元/工龄年，每 5 年为一工龄段，每工龄段依次增加 8元，封顶 50 元，一览表如下，当然，这部分可能各省略有不同。 关于加班工资，按国家法律规定，在日法定标准工作时间以外延长工作时间的，按照不低于劳动者本人小时工资标准的 150% 支付工资；休息日工作无法补休的，按照不低于日或小时工资标准的 200% 支付工资；法定休假日工作，按照不低于日或小时工资的 300% 支付工资。这个计算标准的话可以参考下面的公式，而且是按岗位薪点工资算的，不是总工资，最重要的是，和私企一样，国网的加班认定同样很难，日常或周六日加个班，大多是无偿。 $$ 加班工资=岗位薪点工资/21.75加班天数计发比例 $$ 表彰奖励是获得各类奖项后的一次性奖励，很好理解，五项福利性补贴则包括交通补贴、通讯补贴、住房补贴、午餐费补贴以及为员工发放的节日补贴等，住房补贴是没见到，不过可能指单位提供得免费宿舍，其它几项补贴的具体情况可参考下表，其中的节日补贴今年是一分没看到，不知道是不是和新入职有关。 人才（专家）津贴是指为吸引、留住和激励优秀人才而建立的津贴项目，包括一次奖励和年度履职考核奖，这部分暂时和我们没关系，先不管了。其他津补贴则是指依据国家有关政策规定设立的津补贴项目，主要包括下面的内容： 供暖费补贴：指根据国家和地方政策，在冬季几种供暖地区，企业按属地政策规定和标准负担的职工供暖费补贴。我所在的地市标准如下，一般在三季度实施，比如今年就是 10 月发放。 正高级职称人员 5600元/人 处级领导、副高级职称、高级技师人员 4480元/人 科级、中级职称、技师、高级工 3920元/人 其它人员 3360元/人 独生子女费补贴：考虑现在的情况，肯定是没了。 丧葬补助费：根据国家和地方政策规定，由企业按属地政策标准支付的职工因病或非因工死亡的丧葬补助费，不包括纳入社会保险统筹范围的各项丧葬费用。我所在的地方按照省级劳动保障部门下发的标准执行，补助费为 2000 元。 抚恤费：指职工因病或非因工死亡后供养直系亲属的抚恤费和救济费（生活困难补助）。按照省级劳动保障部门下发的标准执行。 职工一次性抚恤费为 3000 元 生活困难补助费标准：家居省辖市的，每人每月 140 元；家居县（县级市）、镇的，每人每月120元；家居农村的，每人每月100元。供养直系亲属，凡孤身一人生活的，可在上述标准基础上增加 20 元。 食堂经费：指企业根据国网公司总（分）部、省公司、直属单位管理规定和标准，负担的自办职工食堂经费补贴或未办职工食堂统一供应午餐支出，不包括未统一供餐而按月发放给职工的应纳入工资的午餐补助和内设食堂设备、设施的折旧、维修保养等费用。 福利机构经费：不清楚是啥。 医疗费：包括 职工供养直系亲属（独生子女）医疗补助。指企业对职工在国家规定范围内供养的直系亲属（独生子女），在社会保险及其它医疗保险外负担的符合相关政策规定的一定比例（金额）的医疗费用。 职工体检费。指企业统一组织的符合相关政策的职工健康体检支出，不过一般自己看不到这笔钱，而是由电力医院过来免费体检。 老工伤职工医疗费用。指企业负担的符合国家政策规定的未纳入工伤保险统筹老工伤职工的医疗费用。 职工疗养费 荣誉类疗养条件：荣获地市劳模、地市五一劳动奖章、地市公司劳模等荣誉称号的职工，可享受公司统一组织的荣誉类疗养 新入职员工、长病、长学、停职或待岗人员不参加当年组织的疗养。公司统一组织的荣誉类疗养最高不超过 6000元/人次，常规疗养最高不超过 4000元/人次 职工困难补助：指为保障困难职工家庭的基本生活，在按程序进行审核认定与公示基础上，负担的困难职工的一次性补助。职工符合下列条件之一的，可以向所在单位申请给予一次性困难补助： 本人或供养亲属因为突患重病、受伤而造成生活困难 遭受不可抗拒的自然灾害而造成生活上的困难 由于其他原因而造成生活上暂时的困难 探亲假路费：指企业根据国家和公司有关规定，负担的职工探亲假期间的往返交通费，包括职工探望配偶、未婚职工探望父母和已婚职工探望父母发生的往返交通费。但这笔钱判定要求比较高，比如必须外省，以及路程必须大于多少公里等。 离退休人员统筹外费用：指离退休人员的医疗费和按属地政策标准负担的离退休人员供暖费补贴、独生子女费、丧葬费补贴、抚恤费，以及离退休人员其它统筹外费用，不包括纳入社会保险统筹范围的离退休人员费用。 其实上述的 11 条里，能实际拿到手的也就供暖费补贴，其它的都见不到，而是属于一种保障性的东西，不过对于福利而言，就是这样，不能苛求太多。 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:1:3","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"1.4 六险二金 五险一金大家都很清楚，多出来的一险一金是补充医疗保险和企业年金 补充医疗保险 是根据职工工作性质、环境等因素，适当增加的医疗保险项目，用人单位和个人自愿参加，可以提高职工整体医疗保险水平，职工补充医疗保险按照缴纳基数的 5% 计提，全部由企业承担。而且职工补充医疗保险在基本医疗保险的基础上，扩大了报销范围（用药、病症等），同时可用于职工患大病，基本医保报销、大病医保报销后进行三度报销，报销比例为95%，这其实也算国企稳定性的一个方面，解决了每个人关心的看病问题。最后，每年度通过英大小程序，还会划入职工个人账户 1000-4000 元用于定点药店购药等，当然，凡是涉及范围的，灵活性就很大了。 企业年金，是指企业及其职工在依法参加基本养老保险的基础上，自愿建立的企业补充养老保险制度，是多层次养老保险体系的重要组成部分。企业年金缴纳由职工个人和企业共同承担，企业部分按照缴费基数的 8% 计提，个人部分计提额与职工工龄、上年度工资总额有关，约 2%。个人和企业缴纳的年金统一进入职工个人账户，并通过省公司基金投资运营实现资金的保值增值。企业年金的提取条件类似基本养老保险 正常办理退休手续后，可一次性领取企业年金； 出境定居人员，可一次性支付给本人； 职工死亡后，可一次性领取。 六险二金整体缴费比例表格如下 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:1:4","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"2. 工资理解深入 了解了工资组成之后，更进一步的，可以看一个实发工资的例子，然后了解一下提升工资的方法和降低工资的几种情况，最后再介绍一下休假的情况。 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:2:0","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"2.1 实发工资举例 国网新员工基本上三年及以上工资才能发满，具体规则如下，可以看到，前三年每个月基本只有 3000，属于吃土水平，连扣税的资格都没有，要是这时候已经办了房贷车贷，还是需要家里救济。 举个具体的例子，假设 2021 年 9 月入职，那么第一年和第二年的工资如下 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:2:1","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"2.2 工资提升与降低 工资提升的主要途径就是把握薪酬体系里可变的部分，包括如下几个方面，其中，我们重点介绍前两个，简要介绍第三个，剩下的几个见名知意，不多赘述。 岗位晋升；（岗位薪点工资） 参加援藏；（其它工作津补贴） 及时填报专项附加扣除（免税） 承担急难险重工作；（专项考核奖） 获得荣誉称号；（表彰奖励） 参加公司组织的各项活动；（月度奖） 通讯报道；（月度奖） 工资扣除则主要有如下三种情况 安全事故； 生产类或营销类投诉； 监察部下达的处罚决定（旷工、经济责任等违反《员工处罚条例》的行为） A. 岗位晋升 在理解了第一部分岗位薪点工资的组成之后，我们就能理解，只要提升了薪级，工资就能提升，且随着薪级变大，增长的幅度会越来越大，但具体来说又有两种情况。 第一种，在岗位未发生变化的情况下，通过提升薪档来提升薪级。以我所在的地区来说，累计满 4 分可晋升一个薪档，晋升后扣减已经用过的薪档积分，当本身已处于该岗位对应薪档区间的上限时（即 6 档），薪级就没法再晋升了，但积分还可以继续累计，等到岗级提升后，一次性进行计算。同时，在上一级岗位空缺的时候，优先聘用处于薪档区间上限的员工。 那么薪档积分的计算受哪些方面影响呢？按照薪档积分标准，主要包括如下方面 年度绩效。员工年度绩效考核等级会折算进积分系统，这一点上面已经提到过，具体标准如下图，且连续两年获得 A 级的员工，可奖励 0.5 分。 资质等级。包括员工学历、专业技术资格、注册类执业资格、技能等级、工龄五个方面积分值如下图所示，其中的专业技术资格、注册类执业资格和技能等级按照最高原则取分，不叠加计算。 专业成果。专业成果则按照员工人才称号、专利奖励、科技创新、管理创新、管理创新成果推广应用、职工技术创新、质量管理小组活动、专业竞赛考试、个人荣誉、员工流动积分十个方面进行积分。这里很容易理解，就是各种竞赛、专利、称号等进行积分奖励，由于细分条目过多，而且地市级奖项一般只有零点几分，也就国家级的万人计划这种等级，才一次性加分 5 分左右，所以这里不进行列举。 值得注意的是，积分的增加还有一种特殊的方式，即员工流动的积分奖励，计算方法为 基础积分×地区系数×时间系数=流动积分。其中，异地人才帮扶、劳务协作、挂职锻炼、人员借用等连续工作满一年的基础积分分别为1.3分、1.2分、1.1分、0.7分；对于地区系数，西藏一至四类藏区地区系数分别为 1.4、1.6、1.8、2.0，国家规定的艰苦边远地区一至六类地区系数分别为0.8、0.9、1.0、1.1、1.3、1.6，各单位内部欠发达一、二类地区系数为0.8、0.9，非艰苦边远和发达地区系数为 0.6；对于时间系数，异地连续工作满一年，时间系数为 1.0，超出一年或不足一年的，按照实际月份折算。 当然，薪档可提升就可降低，根据《员工奖惩管理办法》，对于受到警告、记过、记大过处分的员工，除扣减绩效工资外，在处分期内分别对应下调 1 至 3 薪档。 第二种情况，由于升职、降职或平级调动，岗级发生了变化。但岗级变化不一定意味着薪级变动，举个例子，某个员工本来是 12 岗 6 档，一次调整岗位升到了 13 岗，且它的积分累积未达到 4 分，那么这时他处于13 岗 4 档，两者对应的薪级是相同的。但处罚性降岗必然导致薪级降低，因为这种情况的降岗，薪档不得高于原薪档。最后，薪级薪档变动在岗位变动的次月执行，按新的薪级工资标准发放工资。 薪档积分评价按年度进行，评价周期为每年 4 月 1 日至次年 3 月 31 日。在此期间获取积分，积分累计满 4 分，晋升一个薪档，同时扣减相应积分。但对于1）年度绩效考核等级为 D 级的员工；2）当年受到记过、记大过、降级降职处分的员工；3）受到撤职、留用察看或者被撤销党内职务、留党察看、开除党籍处分的员工当年无法提高薪档。 更详细的积分说明参考晋中供电人（2015）15号 B. 东西人才帮扶 举个代表性的例子：援藏，且我们下面不考虑其它的事情，只考虑待遇问题。 帮扶期间，帮扶人员在原单位的工资、保险、福利等待遇不变，其绩效表现由受援单位考核，结果通知派援单位。一般，帮扶人员的月度绩效工资按派出单位同层级岗位平均标准水平发放，年度绩效工资按年度考核结果发放，同时，公司给予生活补助、通信补贴、一次性防寒装备、节假日慰问，期满给予帮扶人员流动积分等待遇。 生活补助和通信补贴没有找到相应资料，所以拿前两年驻村扶贫帮扶做参考。月度生活补助跨地市范围每人每天 60 元 ，年度生活补助按照每人每月 1200 元标准发放，依据扶贫单位或当地扶贫工作领导小组反馈的考核结果确定乘的系数，考核结果为优秀的，按 1200*驻村月数*1.2 发放，考核结果为优良和合格的，系数分别为 1.1 和 1.0，考核不合格不予发放。通信补贴按月发放，跨地市人员每月增发 200 元通信补贴。 帮扶人员严寒季节仍在当地工作，且连续 3 个月以上的，由派援单位发给一次性防寒装备费，从劳动保护费列支，派援期限一年以上的，标准为一类藏区 7000 元，二类藏区 8000 元，三类藏区 9000 元，四类藏区 10000 元。其它艰苦边远地区从一类到六类区分别从 3000 元递增到 8000 元，间隔为 1000 元。派援期限不足一年的，按实际派援月数除以 12 进行折算。 节假日慰问费从工会经费列支，由国网公司统一组织派驻的东西人才帮扶人员每人每年 5000 元，各单位自行组织选派的每人每年 3000 元。帮扶人员可以享受年休假，其中，帮扶人员在参与帮扶的次年，可以按国家政策有关规定，享受探亲假，探亲期间不享受生活补助费。 C. 专项附加扣除 等熬个几年，工资够得上扣税标准的时候，专项附加扣除就起的了作用了，相比工作的大家都很清楚这部分内容，这里简单记一下提醒自己 个税起征点为 60000元/年，5000元/月 员工在工作地名下没有住房时，可以使用「住房租赁」专项附加扣除，扣除额度为800元/月 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:2:2","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"2.3 休假 首先，最常见的病假和事假是扣工资的，但两者有一点不同 对于病假，只要有伤病证明，只扣除一部分工资，大部分依法发放 事假（员工因私事必须本人办理的）则一概不计发工资。 事假在两个工作日以内，由处室（班站批准），五个工作日以内，由部门、生产单位领导批准，超过五个工作日的，由单位人力资源部门批准。事假按天计算，不足一天也按一天计算，所以不要请半天假，请半天依然按一天算。每月员工请事假天数原则上不得超过 10 个工作日，年内事假累计天数原则上不得超过 30 个工作日。 其次，除国家法定节假日和公休日外，公司员工依法享受年休假、婚假、丧假、产假（护理假）、哺乳假、探亲假和路程假等假期。这些假期都不扣工资。 年休假：连续工作满 1 年以上的在岗职工，均可享受年休假，累计工作满 1 年不满 10 年的，年休假 5 天，累计工作满 10 年不满 20 年的，年休假 10 天，累计工作满 20 年的，年休假 15 天。注意，国家法定节假日、休息日、探亲假、婚丧假、产假、因工伤停工留薪期，不计入年休假天数。 婚假：依法办理结婚登记的夫妻，在国家规定婚假（3天）的基础上，增加假期 10 天，共计可休 13 天婚假。 丧假：员工的直系亲属（父母、配偶、子女）及岳父母或公婆身故的，可给予 3 天的丧假，其它亲属身故的，可给予 1 天的丧假。 产假（护理假）： 女员工正常生育的，休产假 98 天，难产或者实施剖宫产手术分娩的，增加产假 15 天，生育多胞胎的，每多生育 1 个婴儿，增加产假 15 天。 女员工合法生育子女的，在法定产假基础上增加产假 60 天，同时给予男方护理假 15 天，夫妻异地居住的，给予男方护理假 20 天。女员工参加孕前检查的，在法定产假的基础上增加产假 10 天。 女员工怀孕未满 4 个月流产的，享受 15 天产假，怀孕满 4 个月流产的，享受 42 天产假。 哺乳假：女员工生育孩子满 1 周岁前，单位无法给予哺乳时间和条件的，经协商，可以给予 3 个月到 6 个月的哺乳假。 探亲假：在公司系统连续工作满 1 年，且员工与父母双方均不在同一省内居住，或者与配偶不在同一城市内工作，且又不能在公休假日团聚的（指不能利用公休假日在家休息一夜或半个白天），可请求探望父母或配偶，需提供对方单位提供的夫妻两地分居证明。 路程假：员工休婚假因配偶在异地工作而需到外地结婚，休丧假因身故的直系亲属在外地而需到外地奔丧，以及休探亲假的，可根据路程远近和工作安排，给予 1-2 天的路程假。 其中，年休假、探亲假等假期应于当年 12 月底前休完，婚假应在结婚登记日起一年内休完，丧假应在直系亲属身故之日起五日内休完。未休完的假期过期不予补假，所有假期都要按公司规定履行请假手续，经批准后准予休假。 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:2:3","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"晋升通道 总体上看，晋升通道包括如下几种途径 干部序列 职员职级序列 专业技术资格 技能等级 工匠 四级四类人才 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:3:0","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"干部序列 普通员工——\u003e班组长/专工——\u003e副主任——\u003e主任——\u003e副总经理——\u003e总经理，这个序列很容易理解，但晋升相对较难 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:3:1","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"职员职级序列 普通员工——\u003e班组长/专工——\u003e五级职员——\u003e四级职员——\u003e三级职员等，是给干部序列升不上去的人另一种选择 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:3:2","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"专业技术资格 专业技术资格，即我们平常所说的职称。国网内部这一序列有五级，分别是员级、助理级、中级、副高级、正高级。 根据国网公司相关政策规定，理工类专业硕士入职当年认定助理工程师，助理工程师 2 年认定工程师，工程师 4 年后评定高级工程师，高级工程师 5 年后评定正高级工程师。如果是专业不对口的学历，需取得 2 门及以上大专层次专业对口的专业课程自学考试单科结业证书，或取得华北电力大学电气工程专业课程研修班结业证书可申报中级、副高级职称。这段话中涉及到了几个词，比如「认定」、「评定」，这些都属于职称取得的方式，且除了这两种外，根据申报专业、等级不同，职称取得方式还包括考试、评审、考评结合、考核认定、面试答辩和业绩积分等，下面简要介绍评审和考核认定的区别： 评审是指具备规定学历，达到专业技术工作年限，有一定专业技术工作水平、能力、业绩等，经个人申报，所在单位审核，国网人才评价中心（或委托单位）评定，即可取得相应职称的方式。 这种方式适用于大部分专业中、高级、正高级职称。 考核认定指具备规定学历、达到专业技术工作年限，有一定专业技术工作水平、能力、业绩等，经个人申报、所在单位考核，主管单位复核，即可直接取得相应职称的方式。一般适用于工程技术、政工专业的初、中级职称 有一个不太清楚的地方是，上面提到的「专业不对口的学历」，不知道是指学校学的专业还是公司内，因为在其它地方还看到一句话：职称根据专业学历、工作经历、现工作岗位、现职称确定，运检专业可认定助理工程师，评定工程师、高级工程师和正高级工程师。 另外，公司上下与职称管理相关的各机构所起作用如下 国网公司总部：职称工作体系、管理制度、信息平台、政策支持和服务指导、监督和考核 国网人才评价中心：制定发布年度职称申报规定、组织开展高级职称评定、受托开展中级职称评定、职称评定管理信息平台建设与维护、印发各级职称证书 省公司：高级职称申报，中级职称评定、认定，系统外职称确认，评审专家库建设。 申报者所在单位：初级职称认定，申报材料的初审，业绩鉴定以及单位评价 申报的流程如下 个人申报 资格审查 评审实施（面试答辩、网上评审、考试、业绩积分等方式） 公开审查（含举报问题核查与处理） 发文认证 资料归档 可参考的文件有： 《国家电网有限公司职称评定管理办法》（国家电网企管[2019]428号），2019年5月8日印发 《国网人才评价中心关于职称申报的规定》（人才评价[2021]27号） 《国网人才评价中心关于2020年度职称评定工作安排的通知》（人才评价[2021]28号），2021年5月14号印发 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:3:3","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"技能等级 技能等级评价的相关文件： 国家电网人资[2018]1130号，国家电网有限公司关于组织开展技能等级评价工作的通知 国家电网有限公司关于组织开展技能等级评价工作的通知 国家电网有限公司技能等级评价管理办法（征求意见稿） 技能等级评价申报条件 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:3:4","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"英才子计划 国网公司有英才计划，因此山西省公司有英才子计划，主要内容如下，但找不到具体文件，不清楚如何实施 双百菁英金字塔 高精尖培育 上挂下派 干部队伍整体优化 ","date":"2021-11-29","objectID":"/2021/state-grids-salary-system-and-promotion-channels/:3:5","tags":["国网"],"title":"国网的薪酬体系及晋升通道","uri":"/2021/state-grids-salary-system-and-promotion-channels/"},{"categories":["国网的咸鱼生活"],"content":"本文系转载，内容略作调整，原文地址 ","date":"2021-11-03","objectID":"/2021/grid-organization-structure-reproduced/:0:0","tags":["国网"],"title":"电网组织架构整理(转载)","uri":"/2021/grid-organization-structure-reproduced/"},{"categories":["国网的咸鱼生活"],"content":"1. 我国电力系统整体架构 我国电力系统的整体架构如上图所示。其中，电力配送主要由国家电网和南方电网集团负责，南方电网负责我国广东、广西、云南、贵州、海南五省的建设、运营电网的输配电业务。国家电网公司负责除南方电网管理区域以及内蒙古、陕西榆林等9市以外的全国26个省（市、区）的供电服务。其中内蒙古的呼和浩特、鄂尔多斯、巴彦淖尔市、乌海市、包头市、乌兰察布、阿拉善盟、薛家湾八个地区的供电业务独立属于内蒙古电力有限责任公司，陕西榆林地区属于陕西省（地方）电力有限责任公司负责。 我国的发电集团主要由五大发电集团承担，即中国华能集团公司、中国大唐集团公司、中国华电集团公司、中国国电集团公司、中国电力投资集团公司，五大发电集团主要以火电水电为主，其中火电占比普遍超过50%。三峡集团全称中国长江三峡集团有限公司，不属于上述五大发电集团，是和五大发电集团平级的国资委监管央企之一，除此之外，还有四小豪门：国投电力、国华电力、华润电力、中广核， 2011年，随着电网主辅分离改革，两大电力辅助集团中国电建和中国能建成立。中国电建由中国水利水电建设集团公司、中国水电工程顾问集团公司和国家电网公司、南方电网公司河北、吉林、上海等14个省(区、市)公司所属辅业单位重组而成。中国能建由中国葛洲坝集团公司、中国电力工程顾问集团公司和国家电网公司、南方电网公司北京、天津、山西等15个省(区、市)公司所属辅业单位重组而成。 ","date":"2021-11-03","objectID":"/2021/grid-organization-structure-reproduced/:1:0","tags":["国网"],"title":"电网组织架构整理(转载)","uri":"/2021/grid-organization-structure-reproduced/"},{"categories":["国网的咸鱼生活"],"content":"2. 国家电网 国家电网（简称国网）供电覆盖我国 26 个省（自治区、直辖市），供电范围占国土面积的 88%，供电人口超过 11 亿人。注册资本 8295 亿元，资产总额 4.1 万亿元，稳健运营在菲律宾、巴西、葡萄牙、澳大利亚、意大利、希腊、中国香港等国家和地区的资产（2019 年数据）。公司连续十五年、五个任期获评中央企业业绩考核 A 级企业，位居《财富》世界 500 强前列，是全球最大的公用事业企业（2019 年数据）。 2002 年，国务院下发《电力体制改革方案》(即俗称的电改 “五号文”)，提出了“厂网分开、主辅分离、输配分开、竞价上网” 的 16 字电改方针。在此背景下，2002 年，国务院决定在原国家电力公司部分企事业单位基础上组建国家电网公司。2015 年 3 月，中共中央、国务院 “关于进一步深化电力体制改革的若干意见” 通过中发［2015］9 号文正式下发（简称 9 号文）。理顺电价形成机制，通过市场竞争确定发、售电价，是此次电改的关键任务。2017 年，国务院实施中央企业公司制改制工作，公司由全民所有制企业整体改制为国有独资公司，名称变更为 “国家电网有限公司”，归属国资委管理。 ","date":"2021-11-03","objectID":"/2021/grid-organization-structure-reproduced/:2:0","tags":["国网"],"title":"电网组织架构整理(转载)","uri":"/2021/grid-organization-structure-reproduced/"},{"categories":["国网的咸鱼生活"],"content":"3. 国网组织架构 国网整体组织架构如下图所示，公司由总部和下属单位构成，其中其业务共分为电网业务、一路一带的对外业务、产业和金融 4 大板块。 其总部下属 29 个部门，并向 6 个地区分别派驻 6 个分部，分别为华北分部、华东分部、华中分部、东北分部、西北分部、和西南分部。总部下还包含有北京电力交易中心。总部 29 个部门具体如下： ","date":"2021-11-03","objectID":"/2021/grid-organization-structure-reproduced/:3:0","tags":["国网"],"title":"电网组织架构整理(转载)","uri":"/2021/grid-organization-structure-reproduced/"},{"categories":["国网的咸鱼生活"],"content":"3.1 电网业务 电网业务具体由 6 个大区分部和各省市国网集团分公司承担，如华东分部负责上海、江苏、浙江、安徽、福建四省一市供电服务，具体电网业务由分区下属省市公司如国网河南省电力公司、国网上海市电力公司及其下一级市区子公司承担。 各大区分部 各大区分部其实为总部的派驻机构，其职责可参考华中分部： 国家电网公司华中分部是国家电网公司在华中（覆盖湖北、河南、湖南、江西四省）设立的派出机构，在总部授权范围内，主要承担区域内电网调控运行、安全质量监督、电网规划及前期、审计监督等职责，对区域内省公司进行协调监督，确保公司的各项决策部署和重点工作在区域内有序推进和贯彻落实。其中华东分部负责上海、江苏、浙江、安徽、福建四省一市提供供电服务。华中分部负责湖北、河南、湖南、江西四省。西北分部西北陕西、甘肃、青海、宁夏、新疆区域。 各分部组织架构相似，参考华东分部组织架构如下： 省公司 以国网山西省电力有限公司为例，查看其组织架构。 国网山西省电力公司是国家电网有限公司的全资子公司，以电力生产、建设、调度、经营及电力规划研究等为主营业务，下设11个市供电公司、104个县级供电公司， 供电区域覆盖117个县(市、区)中的105个，供电面积13.55万平方公里，服务客户1349万户，拥有资产总额951亿元，全口径用工总量5.01万人，肩负着全省3700万人民电力供应的基本使命，承担着向京津唐、河北、江苏、湖北等地外送电力的重要任务。 国网山西省电力公司主要有本部、下至低级市县的供电分公司和业务支撑实施机构三部分组成，具体如下： 市公司 以国网晋中市供电公司为例。 国网晋中供电公司成立于1965年，是国网山西省电力公司直属大型一类供电企业，担负着山西电网南北联网和晋中11个县（市、区）的供电任务，服务用户135万户。现有从业人员5038人（其中，全民职工2552人、集体职工568人、农电工1818人，劳务派遣工100人），职能部门12个，业务支撑和实施机构16个，下辖11个县公司、109个供电所。 官网公布的架构图如下 县/区公司 以国网晋中市太谷区供电公司为例，主体构成为营销、运检、安监、调度四个主要职能部门，以及财务、发展建设和办公室三个辅助职能部门，下辖还包括 9 个乡镇供电所，一般是以行政区划划分。 ","date":"2021-11-03","objectID":"/2021/grid-organization-structure-reproduced/:3:1","tags":["国网"],"title":"电网组织架构整理(转载)","uri":"/2021/grid-organization-structure-reproduced/"},{"categories":["国网的咸鱼生活"],"content":"3.2 一路一带（对外） 国网的一路一带业务主要指对国外的投资和建设项目。 截至 2020 年 6 月，国家电网有限公司已成功投资运营巴西、菲律宾、葡萄牙、澳大利亚、意大利、希腊、阿曼和中国香港等八个国家和地区的骨干能源网，境外投资约 210 亿美元，管理境外资产约 650 亿美元。同时积极开发境外绿地输电项目，相续成功投资建设巴西美丽山 ±800 千伏特高压直流送出一期和二期项目、特里斯皮尔斯水电送出一期和二期项目等多个大型绿地输电特许权项目；采用 BOOT 模式投资建设巴基斯坦默蒂亚里 - 拉合尔 ±660 千伏直流输电项目。 国家电网有限公司在全球设立了 10 个办事处，主要负责加强与所在国家和地区的政府部门、经贸商会、电力企业、科研院所、国际组织及我国驻外机构等交流与合作；宣传公司战略目标；跟踪并推进投资并购、能源合作、工程承包、装备出口、技术咨询服务、金融合作等项目 ","date":"2021-11-03","objectID":"/2021/grid-organization-structure-reproduced/:3:2","tags":["国网"],"title":"电网组织架构整理(转载)","uri":"/2021/grid-organization-structure-reproduced/"},{"categories":["国网的咸鱼生活"],"content":"3.3 直属产业 国家电网有限公司直属产业作为公司业务的重要组成部分，是公司服务经济社会发展的重要力量，业务板块包括电工装备制造、信息通信与电子商务、节能与电能替代、境外投资与运营、工程总承包等。拥有 16 家产业公司、6 家上市公司。 其下属产业公司包括高端制造、互联网 +、节能环保、其他业务四个领域。 高端制造领域主要包括许继集团、南瑞集团、平高集团、山东电工电气、国网信通产业集团。 互联网 + 领域包括南瑞集团、国网信通产业集团、国网电动汽车公司、国网电商公司。 节能环保领域包括国网新源公司、国网节能公司、鲁能集团。 其他业务领域包括国网通航公司、鲁能集团、国网中兴公司、英大传媒、国网物资公司。 以下将对各公司进行分别介绍： 南瑞集团：南瑞集团本部位于江苏南京，是国际知名的智能成套装备及整体解决方案提供商。主要从事电力自动化及保护、电力信息通信、电力电子、智能化电气设备、发电及水利自动化设备、轨道交通及工业自动化设备、非晶合金变压器的研发、设计、制造、销售、工程服务与工程总承包业务。现有资产总额超 700 亿元，员工 1.7 万余人，在南京、北京、上海、天津、武汉、深圳等 20 多个地区建有研发和产业基地，2017 年，南瑞集团完成重大资产重组，实现集团核心业务资产整体上市。 许继集团：许继集团本部位于河南许昌，控股 1 家上市公司，下设 19 家子（分）公司，打造了许昌 1 个研发中心，北京、上海、西安、哈尔滨 4 个研发分中心，以及许昌、珠海、福州、厦门、济南、哈尔滨、成都等 7 个产业基地，在东南亚、南亚、非洲、独联体等区域十多个国家开展国际业务工作。公司提供高端能源和电力技术装备，为清洁能源生产、传输、配送以及高效使用提供全面的技术和服务支撑。公司聚焦于特高压、智能电网、新能源、电动汽车充换电、轨道交通及工业智能化五大核心业务，综合能源服务、智能制造、智能运检、先进储能等新兴业务，产品可广泛应用于电力系统各环节。 平高集团：平高集团本部位于河南平顶山，在北京、天津、上海、郑州、长沙、威海、廊坊、长春等地设有子公司，在波兰、印度、南非、老挝、巴基斯坦等国家和地区设有分公司与办事处。始建于 1970 年，经过近 50 年的发展，现已形成了以电力装备制造商和系统集成商为发展定位，以开关类为核心的电力装备研发制造和能源系统综合解决方案的主营业务布局。业务范围涵盖输配电设备研发、设计、制造、销售、检测、相关设备成套、服务与工程承包，并积极发展运维检修、GIL、电力储能、综合能源等新业务。 山东电工电气：本部位于山东济南，成立于 2012 年 5 月，是国家电网有限公司的直属产业单位，所属企业近 30 家，分布在山东、北京、重庆、江苏、浙江、安徽、陕西等省市。业务范围涵盖输变配电设备研发、设计、制造、销售、检测、设备成套、服务与工程总包，核心业务包括全系列变压器及零部件，高端铁塔、线缆。集团处于国内变压器行业领军地位、铁塔行业首位、4 家 1100 千伏组合电器生产企业行列，是国内最大的电工装备及整体解决方案供应商之一，致力于建设国际一流的电力装备制造商和系统服务商。 国网信通产业集团：本部位于北京，成立于 2014 年，注册资本金 50 亿元，拥有 1 个信通研究院、1 家上市公司、28 家分子公司，并设立华北、华东等 7 个客户代表处，员工九千余人，目前是中国能源行业主要的信息通信技术、产品及服务提供商。国网信通产业集团秉持 “互联 · 共享，让能源更智慧，让生活更美好” 的发展使命，打造了 “云 - 网 - 边 - 端 - 芯 - 智 - 链” 全产业链业务体系，全力支撑智能电网和能源互联网建设，服务经济社会发展。 国网电子商务有限公司（国网金融科技集团）：本部位于北京，是国家电网有限公司的全资子公司，成立于 2016 年 1 月。2018 年 7 月，根据国家电网有限公司党组决定，正式成立国网雄安金融科技集团有限公司，与国网电子商务有限公司按照 “两块牌子、一套人马” 运作，实行 “一体两翼” 管理模式。 国网电商公司（国网金融科技集团）主要业务包括电子商务和金融科技两大领域，以互联网信息技术为支撑，实现两大业务相互融合、协同发展。电子商务重点聚焦电费代收、企业 B2B 采购、工业互联网、清洁发展、光伏云网、电动汽车网销、商旅综合服务、“一带一路” 跨境电商、双创及分享经济等九个板块。 金融科技主要布局能源特色金融科技全业务，拓展供应链金融、电费金融、个人金融、大数据征信等业务，建设金融科技实验室，打造集能源、金融、数据交易于一体的线上综合服务平台，打通产融结合通道，助力实体经济发展，建成开放共享、互利共赢的金融科技生态圈。 国网新源控股有限公司：本部位于北京，成立于 2005 年 3 月，注册资本金 102.86 亿元，目前由国家电网公司持股 70%，中国长江三峡集团公司持股 30%，与国家电网公司 2011 年 9 月成立的全资子公司国网新源水电有限公司实施一体化管理模式，主要负责开发建设和经营管理抽水蓄能电站和常规水电站，承担着保障电网安全、稳定、经济、清洁运行的基本使命，是全球最大的调峰调频专业运营公司。 国网综合能源服务集团有限公司：成立于 2013 年 1 月，前身为国网节能服务有限公司，是国家电网公司全资子公司，资产总额 200 多亿元，是国家电网公司综合能源服务产业的龙头企业。主要从事国家积极倡导的节能环保与能源高效开发利用项目的投资、建设与运营，涵盖综合能源、生物质发电、新能源及储能、电网节能、电能替代等业务，是发挥电网企业资源优势，市场化运作、专业化管理、多元化发展的新兴市场化企业。 集团设 8 个职能部门、6 个业务中心和 4 个事业部，拥有 1 家上市公司，以及国能生物发电集团有限公司、国网（北京）综合能源规划设计研究院有限公司等 10 家分（子）公司，具备综合能源服务领域规划设计、系统集成、投资建设、运行维护、评估评价的全产业链能力，在综合能效提升、区域能源利用、县域综合能源、集中供冷供热、储能等方面技术优势较为突出。 鲁能集团：本部位于北京，成立于 2002 年 12 月，是国家电网公司全资子公司，核心业务聚焦地产、能源两大板块。主导产业商业产业、文旅产业、体育产业、健康产业、科技产业、美丽乡村、民生产业、绿色能源。其中国家电网的房产物业业务由鲁能集团和国网中兴公司承担，控股 1 家上市公司天津广宇发展股份有限公司，业务范围涵盖住宅产品开发、商业地产项目开发运营以及物业管理服务。 其他业务领域： 通用航空业务由国网通航公司承担，业务范围主要包括电网运维、勘测设计、应急救援、基建施工、科学试验、客货运输等。 传媒业务由英大传媒承担，以发展现代传媒为核心，为公司开展新闻宣传服务，业务范围主要包括报纸、图书、期刊、影视、数字化和品牌策划等。 物资服务业务由国网物资公司承担，业务范围主要包括集中招标代理、总部直管工程物资供应服务和物力集约化管理支撑服务等。 ","date":"2021-11-03","objectID":"/2021/grid-organization-structure-reproduced/:3:3","tags":["国网"],"title":"电网组织架构整理(转载)","uri":"/2021/grid-organization-structure-reproduced/"},{"categories":["国网的咸鱼生活"],"content":"3.4 金融业务 2010 年年底，国家电网成立了国网英大国际控股集团有限公司和国网英大国际集团。 目前，国网英大集团已发展为中国电力财务有限公司、英大泰和财产保险股份有限公司、英大泰和人寿保险股份有限公司、英大国际信托有限责任公司、英大证券有限责任公司、英大长安保险经纪有限公司、国网国际融资租赁有限公司、英大期货有限公司、英大保险资产管理有限公司、英大基金管理有限公司等 10 个专业金融单位，参股 23 家机构的金融控股集团。 国网英大国际控股集团有限公司（简称 “国网英大集团公司”）于 2010 年 12 月 20 日由原国网资产管理有限公司更名组建，作为国网英大国际集团核心企业，与集团控股金融单位建立以资本纽带为基础的母子公司法人治理关系，履行出资人职责并行使出资人权利，依法对控股金融单位及参股股权进行管理。 国网英大集团中国电力财务公司：中国电力财务有限公司（以下简称 “中国电财”）成立于 2000 年 1 月，是由中国银保监会监管的非银行金融机构，注册资本金 180 亿元，国家电网有限公司持股 51%，国网英大集团持股 49%。公司本部位于北京，拥有 25 家区域及省级分支机构。中国电财主要为国家电网有限公司成员单位及经中国银保监会核准的服务对象提供金融服务。中国电财服务地域广、业务范围全，注册资本金、资产规模、利润总额等多项指标在国内财务公司行业中均名列前茅。中国电财主要面向国家电网公司成员单位及经中国银监会核准的服务对象，开展结算业务、存款业务、贷款业务、投行业务和国际业务。2012 年，国家电网公司对中国电财的核心业务进行了界定，为资金结算、资金监控、资金备付、资金运作、融资等资金管理。 国网国际融资租赁有限公司：国网国际融资租赁有限公司成立于 2011 年 7 月，是经商务部批准设立的融资租赁公司，主要从事融资租赁业务，是国家电网有限公司全资企业。国网租赁公开市场主体评级 AAA，在行业内拥有较好的声誉和融资能力。2020 年 5 月，国网租赁注册资本为 80.76 亿元，居于行业前列。 英大泰和财产保险股份有限公司：成立时间于 2008 年 10 月 28 日，业务范围包括财产损失保险、责任保险、信用保险和保证保险、短期健康保险和意外伤害保险、上述业务的再保险业务、国家法律法规允许的保险资金运用业务、经中国保监会批准的其他业务。 英大长安保险经纪有限公司：英大长安保险经纪有限公司于 2001 年 6 月成立，现有 26 家分公司和 5 家控股子公司，是目前国内业务规模最大、组织服务体系地域覆盖最广、综合实力最强的保险经纪公司。业务涵盖保险经纪、保险公估、全面风险管理咨询、产权经纪等服务领域，业务涉及电力、化工、交通、煤炭、制造、运输、商业、传媒、教育等多个行业。 英大保险资产管理有限公司：英大保险资产管理有限公司（简称 “英大资产”）由英大人寿、英大财险和英大集团共同发起设立，于 2015 年 4 月 3 日开业，注册资本金为 2 亿元，注册地为北京市。提供专业、高效、全面的资产管理服务。目前已获得较为完备的投资和发行业务资质，受托管理保险资金超过 500 亿元，发行了多款保险资产管理产品和投资计划项目。 英大国际信托有限责任公司：英大国际信托有限责任公司成立于 1987 年 3 月，是经中国银行保险监督管理委员会批准设立的非银行金融机构。公司目前注册资本金为人民币 40.29 亿元，注册地为北京，股东单位包括国网英大股份有限公司（持股 73.49%）、中国南方电网有限责任公司（持股 25.00%）、济钢集团有限公司（持股 0.82%）、山东网瑞物产有限公司（持股 0.69%）。 英大证券有限责任公司：英大证券有限责任公司（以下简称 “公司”）成立于 1996 年，是国家电网有限公司（以下简称 “国家电网”）旗下的综合性证券公司，总部位于深圳市，注册资本 43.36 亿元。公司构建了面向全国的综合性金融服务平台，业务牌照齐全，服务网络健全，能满足广大客户全方位、多样化的证券相关金融服务需求。为支持金融业务发展、拓宽资本补充渠道，2020 年国家电网对金融资产进行了资产重组，重组后，国家电网通过上市公司国网英大股份有限公司（股票代码：600517）以及英大国际信托有限责任公司间接持有公司股权。 英大期货有限公司：英大期货有限公司（以下简称 “公司”）是一家经中国证监会批准、注册地在北京的全国性期货经营机构，成立于 1996 年 4 月，注册资本 5 亿元。公司控股股东英大证券有限责任公司是国网英大国际集团有限公司成员单位的重要组成部分，实际控制人为国家电网公司。公司现拥有博易大师、文华财经两套行情系统及恒生、CTP 和易盛三套交易系统。潍坊、大连、青岛、上海、济南、重庆、北京、郑州等多地设立分支机构 英大基金管理有限公司：英大基金管理有限公司（以下简称 “公司”）成立于 2012 年 8 月，是经中国证监会批准成立的全国性公募基金管理公司，业务范围涵盖基金募集、基金销售、特定客户资产管理、资产管理和中国证监会许可的其他业务。 公司注册资本金 3.16 亿元，其中，国网英大国际控股集团有限公司持股 67.7%，中国交通建设股份有限公司持股 22.8%，航天科工财务有限责任公司持股 9.5%，下设全资子公司北京英大资本管理有限公司，主要从事特定客户资产管理业务以及法律法规和中国证监会许可的其他业务。 主要参考一下文章 1、国家电网有限公司 官网 http://www.sgcc.com.cn/ 2020.7.12 2、北极星输配电网：一篇文章看懂新电改方案：改什么 怎么改 http://shupeidian.bjx.com.cn/html/20141209/571426-2.shtml 2020.7.13 3、北极星输配电网：我国电网体制改革的三级递进方案 http://shoudian.bjx.com.cn/html/20200713/1088251.shtml 2020.7.13 4、关于进一步深化电力体制改革的若干意见（中发〔2015〕9 号文）及配套文件 2015.03.15 ","date":"2021-11-03","objectID":"/2021/grid-organization-structure-reproduced/:3:4","tags":["国网"],"title":"电网组织架构整理(转载)","uri":"/2021/grid-organization-structure-reproduced/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第六期月刊，2021 年 10 月。 ","date":"2021-10-31","objectID":"/2021/life-monthly-6/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 6 期 (202110)","uri":"/2021/life-monthly-6/"},{"categories":["日程及周刊"],"content":"时政 1、山西洪涝致175万余人受灾 从10月2日20时至7日8时，山西省平均降水量达119.5毫米，全省有18个县（市、区）降水超过200毫米，有51个县（市、区）降水在100至200毫米之间，累计降水量最大为285.2毫米。全省11个市76个县（市、区）175.71万人受灾，紧急转移安置12.01万人，农作物受灾面积284.96万亩，倒塌房屋1.7万余间。 2、两周38次 美国“罢工潮”呈扩大之势 (cctv.com) 根据美国康奈尔大学的统计数据，今年全美已经发生各种规模的罢工181次；仅在10月前两周，就已经发生罢工38次。分析指出，罢工频发的背后原因之一，是美国严重的疫情下，经济一度停滞，致多行业工作积压严重。在经济重启后，工作量猛增以及人手短缺导致工作人员压力巨大。 3、高雄“城中城”大楼火灾 14日凌晨台湾高雄市盐埕区“城中城”大楼发生火灾，造成46人遇难、41人受伤。 ","date":"2021-10-31","objectID":"/2021/life-monthly-6/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 6 期 (202110)","uri":"/2021/life-monthly-6/"},{"categories":["日程及周刊"],"content":"生活 10.01，国庆回家，中午炸了一些骨肉相连和春卷，晚上老妈烧了一些烙饼 10.02，九月月刊制作完成，下午和老妈逛了逛金店 10.03， 原神2.2前瞻直播 博客添加 Google Analytics 分析 老妈找人给做了一块新床单，25/米 10.04， 电网业务数据召测部分电子化完成 中午吃炒擦面 《原神》冰本打到了花和羽毛的双暴 10.05 拍 2寸证件照 升级 Win11 Notion 向飞书迁移 10.06，《闲聊的话题与技巧》一文完成，《原神》逐月节任务完成 10.08， 核酸检测 得知社保转移推迟到 11 月 10.09, 太古小分队汇合前往榆次 出门前把水杯摔碎了 逛大学城，中午吃煮串，三人第一次聚餐 报到时下大雨，但住宿条件很不错，晚饭也可以 晚上组建班委，大家自我介绍，认住不少人 10.10 6:30 起床军训，又冷又累 素拓（两人三足团队版、蒙眼拼三角、从前往后传消息、击鼓颠球、协作毛笔写字）使大家关系迅速拉近 在学校里办了一个移动卡，18块套餐，198号段，但好像给多开了一个黄金超市权益 庆幸学校超市有自己看中的水杯，果断买下 10.11 《职业素养培训 》和《职业生涯规划》两门课 中午去销卡，因为归属地错了，但得知新卡要一个月后注销，但成功取消了黄金超市权益 10.12 上午《口才与演讲训练》课程 下午趣味运动会（两人三足小队版、羽毛球、跳大绳、球拍托球、拔河），友谊迅速加深 晚上提出要进行汇演，确定主题和形式 10.13 早上跑操取消 《安规解读》和《企业历史文化》两门课 《原神》2.2版本更新 10.14 早上下雨，跑操取消 上午是关于晋升通道和薪酬构成的介绍，下午有四个青年骨干的经历介绍，都很有用 新老员工篮球赛 把一起培训的小伙伴的微信都加上了 和海波一起试了试学校的食堂，被请了一杯奶茶 和小组成员逃离朗诵稿内容 填员工履历表 加班过 12 点，不开心 10.15 前往昔阳参观大寨 从 18:30 排练到 22:30 再次 12:00 后睡觉 10.16，关于沟通和心理健康的课程 10.17，参观变电站，虽然听不懂，但是大受震撼 10.18，正式演出，培训结束啦，晚上和大家聚餐，这几天虽然有点累，但还是很开心，认识好多小伙伴 10.19， 一觉睡到 9 点，坐公交回去，直接上班 晚上发现宿舍进行了暖气改造，但是一片狼藉，清理了很久 10.19-10.21，培训的照片整理 10.20-10.26，宿舍改造计划实施 10.20-10.30，每天出去进行核查（高压、光伏和三相表），周末依然在工作，晚上有时候加班 10.27，核查过程遇到老乡 10.28，加入北辰青年举办的线上三天高质量交友活动，很好玩 10.30，朝阳核查完成直接坐高铁回家，到家约 9 点，确认高铁+公交的时间小于开车 10.31，睡懒觉、玩原神 ","date":"2021-10-31","objectID":"/2021/life-monthly-6/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 6 期 (202110)","uri":"/2021/life-monthly-6/"},{"categories":["日程及周刊"],"content":"观影 美剧《紧急呼救·孤星》S01 E01-E02 电影《丛林奇航》，10.03 电影《沙丘》，10.23 电影《脱口秀大会第4季》，10.24，感悟是要多看看不同的人生，多尝试不同的东西 电影《我和厄尔以及将死的女孩》 ","date":"2021-10-31","objectID":"/2021/life-monthly-6/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 6 期 (202110)","uri":"/2021/life-monthly-6/"},{"categories":["日程及周刊"],"content":"思考 1、看美剧体会到的一个最最重要的东西，有什么事情一定要说出来，好好沟通 2、大家齐心协力做一件事的时候会很开心 ——入职培训感受记录 3、经历了入职培训后，有点期待类似的活动，比如北辰青年里经常提到的那些 4、不管想要什么，都要承担对应的责任，想要友情，就要扮演好朋友的角色，想要爱情，也要承担相应的责任 5、生育是个权衡问题，是把时间和精力留给探索世界，还是留给抚育后代 6、每个人都有一套自己的行为方式 ——陪不同的电工师傅核查有感 ","date":"2021-10-31","objectID":"/2021/life-monthly-6/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 6 期 (202110)","uri":"/2021/life-monthly-6/"},{"categories":["日程及周刊"],"content":"收藏 【概念】认知疗法 【概念】达克曲线 【软件】快连VPN，培训的时候海波推荐 【文章】从分子层面雕刻肌肉：新数学模型预测锻炼肌肉最优方式，健身福音 【游戏】Life Restart (syaro.io)，上个月大火的软件，但上月的月刊忘了收集 【网站】全国移动电话卡“一证通查” (caict.ac.cn) ","date":"2021-10-31","objectID":"/2021/life-monthly-6/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 6 期 (202110)","uri":"/2021/life-monthly-6/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 照片备份 QQ和微信聊天记录备份 录音整理 浏览器书签备份 对账 月刊完成 ","date":"2021-10-31","objectID":"/2021/life-monthly-6/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 6 期 (202110)","uri":"/2021/life-monthly-6/"},{"categories":["我所热爱的生活啊"],"content":"这个选题废了，改造前的照片没拍，文章没法写。 再依依不舍，还是离开学校，成为了社会人，本以为会从此开启独居生涯，没想到入职后被分配了一个两人宿舍。虽说是两人间，但房间非常小，而且家具都比较陈旧，各种小毛病很多，有了之前独居的经历后，这次就不想再「忍」了，就算住的时间不长，也要捯饬的像个家，何况，说不定要在这里住好多年。 开始改造之前，心里一直在想：我要是学过室内设计多好啊！哪像现在，根本无从下手，不仅仅是不知道怎么开始、怎么去做，连自己想要把房间改造成什么样子都不清楚。思考了好久之后，决定从解决现有的问题开始。 ","date":"2021-10-26","objectID":"/2021/dormitory-renovation-plan/:0:0","tags":["杂谈"],"title":"宿舍改造计划","uri":"/2021/dormitory-renovation-plan/"},{"categories":["我所热爱的生活啊"],"content":"1. 小问题修复 因为房子比较老，所以存在的小问题比较多，大致总结如下 窗帘吊环掉了一个，而且是最边上那个，所以窗帘总是耷拉下来，而且拉不严实 是双层的窗户，但是外层的窗户关不严，总是有条缝，里层的窗户拉的时候会发出刺耳的声音（铝合金） 窗户、浴室门、房间门上贴的木条已经脱离墙面，一碰就往外倒 床板不平 淋浴喷头的支架损坏，需要换新的 马桶进水阀和排水阀处于半损坏状态，勉强能用 浴室地漏盖板没了 ","date":"2021-10-26","objectID":"/2021/dormitory-renovation-plan/:1:0","tags":["杂谈"],"title":"宿舍改造计划","uri":"/2021/dormitory-renovation-plan/"},{"categories":["我所热爱的生活啊"],"content":"2. 房间改造 分析了一下自己的需求， 最重要的是健身，所以要在不大的房间中空出足够大的一块放瑜伽垫 其次是需要一个玩电脑或者写笔记的地方（办公桌+椅子） 挂衣帽的地方，救救孩子吧，现有的衣柜太小了，放不了两个人的衣服 放各种杂物的地方，如储备的日用品、工具箱、矿泉水、书包… 放鞋的地方 喝水，房间里虽然有饮水机，但不能用 放行李箱的地方 放一些小工具的地方，比如剪刀、挖耳勺、温度计、小镜子等 ","date":"2021-10-26","objectID":"/2021/dormitory-renovation-plan/:2:0","tags":["杂谈"],"title":"宿舍改造计划","uri":"/2021/dormitory-renovation-plan/"},{"categories":["我所热爱的生活啊"],"content":"3. 清洁 其实不是我傻了，最后才想起来做清洁，只是有点懒，以为上面的改造完成后，就可以掩盖这些问题，但，是我太天真的，你不动手，房间不会自己变干净。当然，这里指的都是一些顽固污渍，真正看不下去的那种，入职第一天就已经清洁过了这一次需要攻略的地方有 卫生间墙面 卫生间地面 洗手池 门窗的框 窗户滑槽 主房间地面 工具：拖把，小柚子清洁剂 ","date":"2021-10-26","objectID":"/2021/dormitory-renovation-plan/:3:0","tags":["杂谈"],"title":"宿舍改造计划","uri":"/2021/dormitory-renovation-plan/"},{"categories":["我所热爱的生活啊"],"content":"4. 后记 本次改造共花费： 还有一些改造想做但因为各种原因没有做 墙纸，墙太高了，没有梯子，只贴一半不好看 地板：太贵 床上用品统一风格：现在的虽然不好看，但是挺舒服 空调清理：没有梯子，够不着 门窗、床、柜子、桌椅用贴纸统一风格，太费事了，不想动 ","date":"2021-10-26","objectID":"/2021/dormitory-renovation-plan/:4:0","tags":["杂谈"],"title":"宿舍改造计划","uri":"/2021/dormitory-renovation-plan/"},{"categories":["我所热爱的生活啊"],"content":"「聊点什么」这个问题，简直是我永恒的恐惧，甭管熟人生人，见面陷入尴尬的沉默那是家常便饭，等到好不容易想出了话题，一开口又变了味儿，结果别人反而不知道该怎么搭这个话了，所以久而久之，我也就养成了多听多看少说话的风格，出门在外恨不得啥事儿都自己做，最好是不和人打交道才好。到了最近两年，「社恐」这个词流行起来，终于给自己找了个面子上看得过去的理由，心里的压力才小了一点。 读研究生的时候事情有了一点改变，虽然少言语的整体情况没变化，但和父母、老师、朋友聊天的时候却少了一份拘束，更加的轻松自在，想到当初连每周和父母通话都不知道说什么，全靠我妈问问题的情景，感觉应该把这些东西总结一下，说不定还能有进步。 注：本文部分技巧可能学自伊庭正康的《当时这样说就好了》，但这本书并不作推荐，有用的东西少，没用的或者说接受不了的东西多。 ","date":"2021-10-06","objectID":"/2021/topics-and-techniques-for-small-chat/:0:0","tags":["生活技能"],"title":"内向者破壁：闲聊的话题与技巧","uri":"/2021/topics-and-techniques-for-small-chat/"},{"categories":["我所热爱的生活啊"],"content":"1. 理念和技巧 尽管沉默寡言是常态，但还是有想说话的人和想说话的时候，因此最终的目标就是保证在这些想说话的时刻以及面对这些想说话的人的时候，能顺利的开启话题以及将话题延续下去。这两者中，前者的重点在于话题本身，后者的重点在于闲聊技巧，因此下面主要从这两个方向来思考。 首先，我们可以简单将可以聊的话题分四类：生活见闻分享、共同经历回忆或近况分享、社会热点讨论、共同兴趣讨论。 生活见闻，顾名思义，指生活中的所见所闻，比如天气、吃饭、走路的时候遇到的人或事等等，重点在于描述所见所闻以及分享自己的感受，一般是和非常熟悉的人闲聊的主要话题，比如父母、女朋友、舍友等，他们往往比较关心你的生活或者和你有共同的感受，能够给出正面的反馈，增强我们开口说话的信心。 共同经历回忆或近况分享是和久不相见的旧友闲聊的主要话题，话题的开启可能会以当前对朋友的视觉感受和过去的对比开始，但谈话过程中的主要话题是每个人近况的询问和介绍，以及由某一段描述或当前所见引发的对过去共同经历的回忆，最常见的一种聊天方式是过去和现在的对比，从这个意义上来说，凡是和我们有共同经历的人都可以开启这个话题，包括上一个话题类型中提到的父母、女朋友等。 社会热点和共同兴趣的讨论则可能发生在和任何人的交谈中，无论是已认识的人还是陌生人，只要对一个问题有认识，就可以产生交谈的基础。 为了融入圈子或找话题专门花时间去做某件自己不喜欢的事，我是觉得没有必要的，我看小说舍友打游戏，也不妨碍我们一起吐槽食堂饭菜难吃，刻意的去迎合别人难保不会迷失自己。 其次，对于话题的延续，最重要的是保持好奇心。好奇心是一切的基础，有好奇心才会发现生活里各种有趣无趣的事情和物品，天空的云、河边的柳絮、迟到了半小时到实验室的导师，以及食堂没尝试过的一道菜，有发现就有感受，有感受就可分享，这样，话题就来了。另外，有好奇心才会对别人的分享有积极的反应，舍友说“我们导师今天没来”，你说：“哦”，父母说“我今天买了件衣服”，你说：“哦”，这样不管谁都聊不下去。或许你可以这样想，我们常说一个人的生命是有限的，读书可以扩展我们有限的生命，难道了解别人不是吗，你在交谈的过程中就是在阅读另一个人的人生，相比于自己一个人，又多了无限的可能性。 就技巧而言，适当的回应是话题延续的关键。首先是表示接受，可以用“嗯嗯”、“是的”、“确实”等等，目的是让对方知道你在听，然后继续讲。其次是加速对话，可以用“结果怎么样”、”后来呢“、”你的意思是“等等，目的是在意识到对方讲的太详细的时候稍微加速一下，促使对方无意识地跳过这一部分内容。最后是提问，比如”为什么“、“怎么会那样“等，举个例子，对方介绍自己在某个餐馆吃了啥，你可以继续问味道怎么样、多少钱、口味重不重，最后以“听起来不错，我下次去试试”结束，但要注意不要把话题的中心强行转到自己身上，比如自己在哪儿吃过类似的，那边怎么怎么样，然后沉浸在自己的介绍里，这样聊天的另一方一般会比较不开心。所以要注意聊天的时候一定不要唱独角戏，单纯的倾听没有回应很容易冷场，只管自己说同样如此，因为这样对方只能很无聊的应和你。更好地做法是察觉到对方快无话可说的时候，再用自己的经历来接上话题。 最后，话题的延续也要掌握一个度的问题，不要背后议论别人不好的地方，也不要对别人不想谈的事情穷追猛打，更重要的是，不要「讲道理」，牢记闲聊不是辩论，是生活中一种轻松的对话，格外坚持自己的观点或者一定要指出对方言语中不对的地方，极有可能引起双方对立，最后大家都不开心，如果实在看法不一样或价值观不同，也要记得争论的时候对事不要对人。 ","date":"2021-10-06","objectID":"/2021/topics-and-techniques-for-small-chat/:1:0","tags":["生活技能"],"title":"内向者破壁：闲聊的话题与技巧","uri":"/2021/topics-and-techniques-for-small-chat/"},{"categories":["我所热爱的生活啊"],"content":"2. 有趣的示例 在举例子之前，我们先来把谈话的角色做一个分类。从空间距离的远近上看，不在身边的可以聊社会热点、分享自己最近的经历，对于在自己身边的，则四种话题都可以聊。从心灵距离的远近来看，从父母、恋人、兄弟姐妹，到好友/舍友、亲戚、普通朋友/同学、老师，最后到路人（比如出租车司机、食堂打饭大妈、卖煎饼果子的摊主等），话题的亲密度一定是递降的，因此闲聊的方式也会有所不同。下面主要就从这一方面来举例子，非常亲近的以父母为例，比较亲近的以好友/舍友为例，路人以出租车司机为例。 ","date":"2021-10-06","objectID":"/2021/topics-and-techniques-for-small-chat/:2:0","tags":["生活技能"],"title":"内向者破壁：闲聊的话题与技巧","uri":"/2021/topics-and-techniques-for-small-chat/"},{"categories":["我所热爱的生活啊"],"content":"2.1 父母 自离家上大学开始我每周和父母来一次视频电话，不过通话的时候多数情况是我妈在说，我在静静地听以及偶尔回答提问，毕竟，三点一线的生活我实在是不知道该说什么，我总不能和我妈说我今天做了什么实验或者看了什么番剧吧，这也太奇怪了。好在毕竟是和家人聊天，不管怎么样都不会尴尬，不过聊的多了我开始慢慢发现，我妈问的问题或者说提到的话题通常就那几个，这些话题我可以等我妈来问，也可以自己主动来说，而且主动说就显得气氛活跃一点，于是我开始了尝试。 首先是吃饭。吃饭真的是永恒的话题，我们的通话时间一般是晚上，所以一般打通之后我妈第一句话总是“晚上吃什么啦？”。其实我也很无奈，作为一个山西人，吃饭这个问题潜意识只有两个答案：米和面，所以百分之九十的情况我都是回答“米饭啊还能是什么”，有时候我也会失笑，然后和我妈说，“这个问题也太无聊了，我一般就这一个回答，也不用每次都问啊”。后来我意识到了，这个问题无聊不无聊一点都不重要，重要的是它可以引出其它的话题。就我自身而言，我除了说“我吃米饭了”，还可以描述或者吐槽一下菜品，比如“吃了个角瓜鸡蛋，但角瓜片切的有点大“、”吃了鱼香肉丝，感觉还没我自己在家做的好吃”等等，平常和同学吐槽的饭菜和食堂管理等种种问题，都可以和我妈说，兴致来了还可以引出体重问题，抱怨一下食堂的菜油和盐太重，比在家又重了好多斤啊什么的。这个时候还可以反问一句，你在家吃什么了，或者什么都不说，我妈就会自然而然接过话头，开始叮嘱我买点牛奶和水果吃、先吃饱再减肥等等。闲聊这种事情，脑子是没有记忆的，这周说完了，下周继续按这个流程来，一点突兀感都没有，所以完全不用担心每次谈一样的话题是不是无聊这种事情。 其次是天气。很多时候我妈会说，“我这边下雨了/下雪了，你那边天气怎么样啊？”，然后我就学会了主动提起这个话题，比如说“这边下了一场小雨”、“下了一场大雪”、“太阳太毒了”、“早晚温差有点大”、“有雾霾，没出门”等等，又或者”柳絮飘得到处都是“、“学校里的石榴结果子了”等等与季节有关的话题。多数情况下这种话题可以引出父母对穿衣的担心和叮嘱，“天气凉多穿点衣服”、“那件黄色的大衣在家还是在你那里”、“天气热了就记得换衣服，别这么大了不知冷热\"等，你就可以不断应和和点头，最后如果能反过来关心一下父母就皆大欢喜了，他们就非常开心。 最后是近况。做个实验、看个番这种话题当然和父母没得聊，但三点一线之外的事情可以随便提啊，整整一周的时间，只要善于发现，总不可能一点可以聊的事都没有，就算是和父母聊聊同学的八卦都没问题，他们对你身边一切人和事都保有兴趣，只是记得不要自己引火烧身，比如聊到同学找女朋友的事情。感兴趣的还可以尝试写日记或写子弹笔记，如果把每天的事情记下来，通话的时候话题就变得特别好找。 其实，刚开始每周打这个电话是因为担心我妈想我，结果后来感觉我爸有点小不开心，于是变成了多人视频聊天。事实证明，多一个人简直是聊天时间的大杀器，上面提到的所有话题，多一个人分享就会多出好多时间，再加上我妈谈到的多是周围的亲戚邻居的事情，但和我爸聊天就可以讨论时事和社会热点，一来二去，一两个小时就过去了，家庭会议圆满结束。 ","date":"2021-10-06","objectID":"/2021/topics-and-techniques-for-small-chat/:2:1","tags":["生活技能"],"title":"内向者破壁：闲聊的话题与技巧","uri":"/2021/topics-and-techniques-for-small-chat/"},{"categories":["我所热爱的生活啊"],"content":"2.2 好友 首先，如果好友在不同的城市，那么话题就需要建立在共同经历上，比如我和某位本科同学小A，常谈的话题就包括当初的同学、老师、学校的近况、其它同学的近况等等。同时，两人也会基于研究生这个共同的身份在某方面产生共鸣，比如做实验、写论文、吐槽导师等等，由于都玩《原神》，也会聊聊游戏，另外如果遇到时事热点也会激烈讨论，开心了可以分享，不开心了也可以分享，虽然不在一个地方，但是当下分享的近况和感受以后会成为共同的回忆，然后成为以后聊天的话题，这是一个正循环。 其次，如果是近在咫尺的好友，比如舍友或学校里关系好的同学，聊天的话题就更广。当然，总体来说还是所见所闻以及自己的感受，比如学习，某门课怎么样、带课老师怎么样、关于实验、关于复习、关于考试，学生在这方面有着天然的聊天基础，又非常容易唤起共鸣。饮食也是常见话题，从食堂好不好吃，哪个窗口好吃，哪个窗口不好吃，哪个窗口又倒闭了，哪个窗口又涨价了，一直到食堂管理问题，乃至哪家的外卖好吃、哪家的外卖便宜、哪里有优惠券可以用，如果是和一般人聊天吃饭的话题是入门，和舍友聊天这方面的话题就是深入了，而且永远聊不腻。年轻人少不了的是恋爱话题，虽然大家单身狗居多，但不妨碍都喜欢当狗头军师，因此对所见女生的考察与评论、如何挑礼物、如何制造偶遇、如何回复微信等等，制造了大量的话题，而如果身边有个扶不起的阿斗，简直就是个话题制造机，三年都不愁没得聊。至于其它的话题，比如一起旅行的经历、宿舍夜谈会分享自己的过往、对时事的评论等，虽然比较少，但也是相当重要的内容。大家的关系就是这么建立的，一起经历的越多，和对方分享的越多，最后越能敞开心扉，没有压力的随便聊。 ","date":"2021-10-06","objectID":"/2021/topics-and-techniques-for-small-chat/:2:2","tags":["生活技能"],"title":"内向者破壁：闲聊的话题与技巧","uri":"/2021/topics-and-techniques-for-small-chat/"},{"categories":["我所热爱的生活啊"],"content":"2.3 路人 路人实际上是最没有压力的，我一般这样想：反正就见这一次，或者反正他也不认识我，说错就说错咯，尴尬就尴尬咯，以后又不会再见。尤其是到一个新的城市旅游，更是肆无忌惮，打车的时候还可以顺口问司机几句当地哪里好玩，如果自己不想说话但司机是个话痨，那就用“嗯嗯”“是的”“确实啊”这样的话附和一下就好，完全不用有心理压力，反正大家只有几分钟的相处时间，七月份我一个人毕业旅行的时候就是这么一路莽了过去，现在想起来真是佩服那时候的自己啊。 有时候路人见面次数多了就变成了熟人，比如舍管阿姨、食堂大妈、便利店收银员，对于社恐而言可能熟了之后对方打招呼就会浑身不自在，然后就开始躲着舍管阿姨出入、换个窗口吃饭以及换家便利店买东西。但我后来觉得这也太委屈自己了，出入个宿舍还要偷偷摸摸的，喜欢吃的菜难道再也不吃了吗，买个东西还要走好远的路到另一家，相比打招呼，果然还是这样更痛苦。我就开始琢磨怎么应对别人打招呼，后来想，甭管怎样，见了人露个笑脸没问题吧，何况食堂阿姨还经常多给半勺菜呢，就这样久而久之，发现天也没塌地也没陷，世界还是那个世界，于是乎时间久了早上出门还能和舍管阿姨问声早上好，着急的时候舍管阿姨也会帮忙取一取外卖，这可比躲着人出入舒服多了。 ","date":"2021-10-06","objectID":"/2021/topics-and-techniques-for-small-chat/:2:3","tags":["生活技能"],"title":"内向者破壁：闲聊的话题与技巧","uri":"/2021/topics-and-techniques-for-small-chat/"},{"categories":["我所热爱的生活啊"],"content":"3. 话题终结术 前面提到的都是如何聊天，但如何结束聊天有时候也很有用。内向的人终结话题虽然是本能，但那太粗暴了，沉默对抗的结果是大家不欢而散，以及下次见到更加尴尬，所以还是需要一些终结话题的技巧。当然，在此之前，先来列举一些希望结束话题的场景： 涉及自己隐私，不想回答，比如亲戚、邻居或其它莫名其妙的人问工作、工资、婚姻、生育等等 涉及他人隐私，需要保守秘密 父母催婚 他人大量的负面情绪宣泄，或者反复说同一件事 一般产生纠结都是因为谈话的对方是熟人，不熟的人直接了当说明就好，就说因为什么自己不想回答，越敞亮大家越没心结。对于熟人，可以用话题转移大法，主动开启一个新话题，如果对方纠缠，那就找个借口暂时离开一下，回来后自然而然就进入了另一个话题，而且一般而言对方会明白你不想回答的。这种方法有时候对于父母没什么用，这时候就可以用左耳进右耳出大法了，只要自己心里坚定，父母唠叨两句没有关系啦。 负面情绪的宣泄其实也分情况，如果是经常性的，而且是只管自己说那种，可以仔细考虑这个朋友的性格，想想是不是结束这段朋友关系比较好，但如果是偶尔的情绪宣泄，你也许需要的不是话题终结术，而是静静的倾听和安慰，另外，切忌不要把话题转移到自己身上，用自己身上发生的更恶劣的事情来做比对，这并不会产生安慰效果，只会更不开心。 ","date":"2021-10-06","objectID":"/2021/topics-and-techniques-for-small-chat/:3:0","tags":["生活技能"],"title":"内向者破壁：闲聊的话题与技巧","uri":"/2021/topics-and-techniques-for-small-chat/"},{"categories":["我所热爱的生活啊"],"content":"后记 我认为造成我沉默寡言性格的原因其实很多，从小时候发现什么都不说可以挨父母更少的打，到成长过程中身边的朋友比较少，再到长大后发现这个世界是自己不喜欢的样子，内心不愿接受，但想改变这个世界却又无能为力，于是最终选择了沉默以对。有人会说这是逃避，我却更愿意认为这种方式是我捍卫自己内心世界的武器，所以我没想着彻底改变自己，变得外向啊、善于交谈啊什么的，只是想学一点沟通技巧，总结一点经验，能够和我爱的、我认同的以及爱我的人们相处的更好。 ","date":"2021-10-06","objectID":"/2021/topics-and-techniques-for-small-chat/:4:0","tags":["生活技能"],"title":"内向者破壁：闲聊的话题与技巧","uri":"/2021/topics-and-techniques-for-small-chat/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第五期月刊，2021 年 9 月。 ","date":"2021-09-30","objectID":"/2021/life-monthly-5/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 5 期 (202109)","uri":"/2021/life-monthly-5/"},{"categories":["日程及周刊"],"content":"时政 1、东京残奥会闭幕 9 月 5 日晚，第十六届夏季残疾人奥林匹克运动会在东京落下帷幕，在 12 天的赛程中，中国代表团参加了 20 个大项的比赛，获得了 96 金 60 银 51 铜共 207 枚奖牌，在金牌和奖牌榜上均遥遥领先，并连续第五次在残奥会上实现金牌、奖牌双第一。另外，残奥会旗在闭幕式上已移交到了巴黎市长伊达尔戈手中，第十七届夏季残疾人奥林匹克运动会将于 2024年08月28日-09月08日于巴黎举行。 2、全运会举办 9 月 15 日，第十四届全国运动会在陕西西安开幕，经历了 13 天的紧张比赛，最后在 9 月 27 日晚落下帷幕。整个赛事共有 12000 多名运动员参赛，在 35 个大项 410 个小项的争夺中，超12项世界纪录、创2项亚洲纪录、24项全国纪录。 3、神舟十二号载人飞船返回 9 月 17 日 13 时 34 分，神舟十二号载人飞船返回舱在东风着陆场成功着陆，执行飞行任务的航天员聂海胜、刘伯明、汤洪波安全顺利出舱，这意味着我国空间站阶段首次载人飞行任务取得圆满成功。 4、美“全平民”太空“旅行团”安全返回地球 9 月 18 日，美国太空探索技术公司(SpaceX)的「全平民」太空旅行团在绕行地球飞行约 3 天后，成功返回地球，降落在美国佛罗里达州附近。这里「全平民」的意思是所有乘客均为非专业宇航员，其中，本次的 4 名游客分别为美国支付服务商“Shift4支付”创始人兼首席执行官贾里德·艾萨克曼、数据工程师克里斯·塞姆布罗斯基、地球科学家莎恩·普罗克托和圣祖德儿童研究医院医师助理海莉·阿西诺。艾萨克曼为另外3名游客的相关支出买单，并希望借此为圣祖德儿童研究医院筹集资金。 当地时间2021年9月15日，美国佛州卡纳维拉尔角，送第一个全平民机组进入太空轨道，火箭发射升空。据报道，亿万富翁企业家艾萨克曼(Jared Isaacman)和其他三人搭乘SpaceX猎鹰火箭，进行为期三天的名为Inspiration4的任务。 5、东北三省拉闸限电 “连个通知都没有，（电）突然就停了”“红绿灯也停了，堵车很严重”“正在家上网课，时不时停电断网，没法上学了”…… 9 月末，「东北限电」的话题冲上热搜，东北地区的供电紧张问题引起全国关注，事实上，在全国范围内，此前广东、江苏等多个省份已相继采取“有序用电”等措施以应对供电紧张局面。而东北地区此番则是出现将限电措施由工业用电扩展到生活用电领域的情况，才进一步引发舆论争议。 外界认为“能耗双控”（控制能源消费总量、控制能源消耗强度）、电力供应紧张、电煤供给紧俏等因素是电荒的主要原因。其中，江苏、云南、浙江有“能耗双控”因素，政府要求企业停工限产，广东、湖南、安徽等地则主要是由于电力供应紧张，企业被迫错峰限电，此次东北限电与“能耗双控”无关，是电力供应短缺所致。在东北三省做出的回应中，风电骤减、水电减少、新能源发电不及预期、全国性煤炭紧缺、煤价高企、煤电价格倒挂等是主要原因。 ","date":"2021-09-30","objectID":"/2021/life-monthly-5/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 5 期 (202109)","uri":"/2021/life-monthly-5/"},{"categories":["日程及周刊"],"content":"生活 09.01，尝试录制《原神》游戏视频，但录制的视频画质不高，同时无法解决人声录入的问题，暂时搁置。 09.02，前往榆次签订劳动合同，领取介绍信。 09.06，前往太谷供电公司报到（老爸开车送） 和一同到单位的两个小伙伴初见面 添加单位大门的人脸识别，领取主楼的门禁卡 熟悉上下班时间、食堂开饭时间及就餐流程 分配宿舍，整理宿舍 09.07 上报工资卡号 开始背安全规范 发现食堂提供晚饭 帮办公室解决 IE 下电网系统运行的一些问题 去附近超市购置必需生活用品 09.08 解决网络问题（询问得知了单位 WIFI 密码） 晚上下班后向东散步一直到山西农大 09.09 老爸捎来一些生活用品（7号和老爸说的） 领中秋福利，两盒月饼 晚上下班后向北散步到金谷广场 09.11，向南散步，绕一圈回到单位 09.12，发现周六日中午食堂有饭 09.13，帮贺君姐查资料 09.14，安监部要求，完善中国志愿服务网信息 09.15， 安监部安排任务，前往阳光超市当志愿者 Notion 衣物整理部分调整，Notion life wiki 建立 09.16，安规考试结束 09.19，中秋放假回家 09.20， 《原神》在雷神池快结束的时候终于抽到了雷神 《原神》雷神瞳收集完成 中午在和苑酒家吃饭 下午回村里摘菜、打水 09.21，中秋节啦，和老妈一起做饭，晚上回到单位 09.22， 帮办公室扫描归档社保缴费证明和退伍军人的退役证 被分配到胡村供电所三个月 09.23， 上午前往胡村供电所 晚上乘 20 路公交回城，熟悉路线 从七五三道口骑青桔单车回单位，在单位门口锁车锁了 20 分钟，气炸了，多付两块钱，还错过了晚饭 09.24， 早上副所长开车捎到了所里 胡村所开会，开始普查工作 熟悉召测数据工作 晚上乘公交回单位，下雨，等 5 路等了半小时 09.25， 早上和武所长碰头，上午在单位一楼营销部召测数据 晚饭尝试在美团里找店铺，然后到线下店里吃饭，再一次确认堂食比外卖便宜 金谷昱看电影，看完出来发现下雨了，冒雨回单位 09.26 早上 7:30 出发，公交 2 路转 19 路到胡村，全程 50 分钟，包括行走和等车时间 继续召测数据 下午被武所长捎回单位，回到宿舍的时候不到 5 点 中午还是剔尖和豆角西红柿，晚上馒头土豆丝，崩了，胡村饭菜每天都一样 继续下雨，买电动的事又泡汤了 09.27，召测系统熟悉，考核指标算法分析 09.28， 早上要求 8:20 到所里，6:20 就起床了，结果等公交等了半小时 发现召测光伏数据可提升曲线指标，发现可弥补 T-2 日的召测数据 发现可以乘 15 路回城，时间更长，但少 1 块钱 发工资了，开心，去他的食堂，在 15 路下车点附近找了个饭店吃炒饼，买了瓶可乐当零食 09.29 7 点起床，本以为时间足够，结果等 15 路等了半小时，然后又开了半小时，9:10 才到所里 晚饭继续在 15 路下车点附近那家饭店吃，这次点了盖饭，这一家可以常来 硬生生走到了山西农大，终于买到电动了 09.30 骑电动上下班第一天，熟悉路线 确认宿舍的网线接口完全没用，内网都上不了，宿舍召测数据计划泡汤 ","date":"2021-09-30","objectID":"/2021/life-monthly-5/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 5 期 (202109)","uri":"/2021/life-monthly-5/"},{"categories":["日程及周刊"],"content":"观影 电影《彼得兔2：逃跑计划》，09.04 电影《白蛇2》，09.11 电影《缩小人生》，09.20 电影《失控玩家》，09.25 书籍《饱食穷民》 书籍《妻子们的思秋期》 ","date":"2021-09-30","objectID":"/2021/life-monthly-5/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 5 期 (202109)","uri":"/2021/life-monthly-5/"},{"categories":["日程及周刊"],"content":"思考 1、在别人的规则下和别人讲道理，就像和裁判踢球，所以要努力掌握规则制定权 2、就算没有梦想也没关系，只要幸福就好了 3、美食是一种情感、气氛和食物合而为一的东西。 ——《原神》逐月节任务中香菱在望舒客栈对话 ","date":"2021-09-30","objectID":"/2021/life-monthly-5/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 5 期 (202109)","uri":"/2021/life-monthly-5/"},{"categories":["日程及周刊"],"content":"收藏 1、床单买水洗棉，这种面料很喜欢 2、徒步圣地：雨崩村 ","date":"2021-09-30","objectID":"/2021/life-monthly-5/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 5 期 (202109)","uri":"/2021/life-monthly-5/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 照片备份 QQ和微信聊天记录备份 录音整理 浏览器书签备份 对账 月刊完成 ","date":"2021-09-30","objectID":"/2021/life-monthly-5/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 5 期 (202109)","uri":"/2021/life-monthly-5/"},{"categories":["日程及周刊"],"content":"未来规划 ","date":"2021-09-11","objectID":"/2021/future/:0:0","tags":["日程"],"title":"未来","uri":"/2021/future/"},{"categories":["日程及周刊"],"content":"5年规划 2021下半年，25岁 熟悉工作岗位的职责，掌握相关技能和知识 突发事件应对 2022，26岁 对应方向的职业等级证书 健康相关 沟通技巧、人际关系处理和相关心理学知识 关于恋爱、婚姻、生育等问题的思考 2023，27岁 饮食相关，中式烹调师初级证书 衣物相关 2024，28 住宿相关 出行相关 2025-2026，29-30 经济学和投资相关知识 副业和相关技能证书 ","date":"2021-09-11","objectID":"/2021/future/:0:1","tags":["日程"],"title":"未来","uri":"/2021/future/"},{"categories":["日程及周刊"],"content":"自理能力 衣物相关（包括床单、被罩、窗帘等需要一起洗涤的东西）⭐ 衣服的挑选与购买 衣服的穿搭 衣服的洗涤与熨烫 衣服的收纳与修补（缝衣服） 旧衣处理 饮食相关⭐⭐⭐ 常见米、面、油、蔬菜、水果、调味料的辨识、挑选和购买 各种厨具的挑选和使用方法 常见的切菜、调味、烹饪方式 各种主食、家常菜、喜欢的菜的做饭 【进阶】中式烹调师初级证书，预计需要 6 个月到 1 年 学习内容包括：烹饪原料知识、烹调方法，火候、勾芡、制汤、干料涨发，菜肴成本核算、营养卫生、浆糊、芡汁调制。刀工实习、切丁、片、块、条、丝。整鱼分档、美化刀工、冷盘。翻锅、旋锅、装盘、临灶。40多道菜肴。 信息来自 厨师培训—A级学校,中餐烹饪烹调课程,厨师证考证,全国通用 住宿相关⭐⭐ 租房子注意事项 房屋基本常识（产权、房产证、公积金等）及购房注意事项 逐步了解自己喜欢什么样的装修风格和装修的注意事项 各类基本电器的挑选和使用方法 逐步收集好用的家居物品 打扫、整理、擦玻璃等房屋清洁的技巧、工具和方法 出行相关⭐ 大巴、公交、地铁、火车、飞机、轮船等交通工具从购票到乘坐的流程 自行车、电动车、摩托车、汽车、滑板、旱冰鞋等交通工具的驾驶方法 健康相关⭐⭐⭐ 生活中常见疾病及用药 家庭小药箱应该放哪些东西（少数派，丁香医生都有相关文章） 常见外伤的处理和一些急救知识 定期体检，应体检的条目，体检单如何看，定期进行牙科检查（包括洗牙），每年做一次验光和眼部检查 医院看病的流程，医保缴纳与报销方法，拨打 120 的注意事项 关于职业⭐⭐⭐ 熟悉自己岗位的工作流程，掌握相关的职业技能，预计半年 【进阶】对应方向的职业等级证书 发展其它收入，包括写稿收入、当Up主、照片版权、当整理师等 【进阶】编辑证、整理师证等对应证书 了解股票、国债、基金，学习经济学课程，开始投资 预存失业、自然灾害、突发大病等意外的资金，并准备这些情况的 Plan B 学习沟通技巧、人际关系处理原则和一些心理学知识，学会开启和延续话题⭐⭐ ","date":"2021-09-11","objectID":"/2021/future/:0:2","tags":["日程"],"title":"未来","uri":"/2021/future/"},{"categories":["日程及周刊"],"content":"安全感 健身体系的整理，坚持锻炼以增强体质 五险一金相关常识，商业保险相关常识和购买注意事项 突发事件应对，如溺水、自然灾害、野外迷路等 及早规划身后事，比如意外身亡后各种账户、财产如何处理，如何安葬等，提前写好遗嘱留给亲人，可以每年更新一次 定期给父母体检，想好父母病了怎么办，一个人怎么陪床等 关于独居 需要去学习或准备的 拳击或格斗等相关技能，进阶为获取健身教练资格证、营养师资格证等行业相关证书 游泳 驾驶 急救 基本的野外求生知识 应急资源部储备 网上如何隐藏自己的隐私信息，从学习情报学开始，QQ或微信授权会获取到什么信息 对恋爱、婚姻、生育的看法，如何应对社会舆论压力，如何应对周围人的压力 ","date":"2021-09-11","objectID":"/2021/future/:0:3","tags":["日程"],"title":"未来","uri":"/2021/future/"},{"categories":["日程及周刊"],"content":"爱好/精神充实⭐ 电影、游戏、剧集 待看或待玩清单的整理、评论写在哪里（博客/豆瓣） 二刷清单 不可能看完所有剧和玩所有游戏，如何在观念上做出调整，如何取得娱乐和工作生活的平衡，如何将注意力集中于过程而非结果 写作 写作相关技巧 灵感的记录（Notion） 旅行 旅行目标的确定 自由行还是跟团，要带的物品，要注意的事情 旅行记录（照片、视频、文章等） 每年一个省份 学会认识星星 艺术鉴赏及品味提升 音乐、绘画、建筑等基础知识的学习，各领域鉴赏课程 美学基础知识，从朱光潜《谈美》开始 学唱歌或吉他 解惑 国学相关经典的阅读 哲学典籍阅读 心理学知识学习 用自动化减少重复工作（理念） ","date":"2021-09-11","objectID":"/2021/future/:0:4","tags":["日程"],"title":"未来","uri":"/2021/future/"},{"categories":["我所热爱的生活啊"],"content":"思考一些关于未来的担忧，包括人生之路、婚姻、自己意外身亡、父母生病等等。 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:0:0","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"未来 现在这个时代，大家都焦虑未来，尤其是像鞭子一样高悬在我们身后的房价，更是让人不敢懈怠。最近一个名为 人生重开模拟器 的小游戏爆火，玩的时候就发现，无论你这一生是困苦还是辉煌，甚至活到 100 岁开启修仙之路，最后你还是忍不住点下最后的「再次重开」的选项，那么，对于现实里只有一次的人生，又哪有什么甘愿呢，心里怕总是会有「如果我当初选择了……」这样的想法吧。电影《无姓之人》里，主角尼莫有着能看到未来的能力，然而面对不同选择所衍生的无数时间线，直到死亡也没能做出决定（仅是我的理解），白白蹉跎了一生，所以我觉得其实最重要的是做出选择后坚定的往前走，而不是永远纠结然后被动做出选择。 很小很小就开始读书，然后一毕业就陷入现代社会围绕婚姻和生育形成的固定模板，买房、彩礼、结婚、生育，两代人甚至更多人的积蓄被迅速花完，然后陷入抚育第三代的轮回，再难抽身去做其它尝试。不能说未来再也没有可能，只是以普遍理性而言（狗头保命），真的就少了太多的可能。我不是坚持终身单身的人，如果你问我，想要一个可以共度余生、分享自己的所有喜怒哀乐的人吗？我的答案是肯定的，但如果要绑定未来的人生，或许要再考虑一下。 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:1:0","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"健康 周期性的体检是监测自身健康状况的有效手段，这方面其实我们关心两件事，一是去哪儿体检，二是应该体检哪些项目，@刀客特Leslie 在 年轻人的体检指南 01：体检在检查什么 中做了详细解释，并在最后给出了一个总结性的思维导图（如下）。 另外，丁香医生也有一篇 别再花冤枉钱了，要做的体检项目就这些 | 内附体检清单 参考，有根据具体年龄的推荐。 其实除了自己定期体检外，最难的是说服父母体检，和说服父母坚持锻炼一样难。 父母病了如何陪床 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:2:0","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"身后事 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:3:0","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"遗嘱 谁也不能说自己永远不会发生意外，尤其是本科毕业的时候同专业的同学猝死，眼见着前一天还在楼道大喊大叫的同学第二天就没了，心里自然会诞生些许忧虑。后来有时候就想，如果自己也发生了这样的事怎么办，父母会不会太伤心，要不要留一封信安慰一下父母，自己那些珍视的事物父母会好好保留吗，银行卡密码、网上各种账户的密码没人知道怎么办，所以很早就动了留一份遗嘱的念头，只是最近才抽出时间做这件事 。首要就是两份法规的阅读 👉 《中华人民共和国民法典》第六编　继承 👉 最高人民法院关于适用《中华人民共和国民法典》继承编的解释 民法典第六编第三章即是关于遗嘱继承和遗赠的相关条目，其中将遗嘱分为以下几类 自书遗嘱：由遗嘱人亲笔书写，签名，注明年、月、日。 代书遗嘱：应当有两个以上见证人在场见证，由其中一人代书，并由遗嘱人、代书人和其他见证人签名，注明年、月、日。 打印遗嘱：应当有两个以上见证人在场见证。遗嘱人和见证人应当在遗嘱每一页签名，注明年、月、日。 以录音录像形式立的遗嘱：应当有两个以上见证人在场见证。遗嘱人和见证人应当在录音录像中记录其姓名或者肖像，以及年、月、日。 遗嘱人在危急情况下，可以立口头遗嘱。口头遗嘱应当有两个以上见证人在场见证。危急情况消除后，遗嘱人能够以书面或者录音录像形式立遗嘱的，所立的口头遗嘱无效。 公证遗嘱：由遗嘱人经公证机构办理。 首先要考虑遗嘱的有效性，可以看到，除自书遗嘱外，其它几种遗嘱均应有见证人在场，而民法典中规定见证人不可以是继承人、与继承人有利害关系的人以及 无民事行为能力或限制民事行为能力的人，所以这一条首先就对我们提出了挑战。再考虑到年轻人思想变化、财产变化都比较快，遗嘱的更新频率也会比较快，因此，自书遗嘱是我们最好的选择。 具有完全的民事行为能力：年满18周岁且精神状态正常的人 自书遗嘱的生效条件如下 由遗嘱人亲笔书写，签名，注明年、月、日 立遗嘱人必须具有完全的民事行为能力。无行为能力人所立的遗嘱，即使其本人后来有了行为能力，仍属无效遗嘱 遗嘱必须表示遗嘱人的真实意思，受欺诈、胁迫所立的遗嘱无效 伪造的遗嘱无效，遗嘱被篡改的，篡改的内容无效 遗嘱人以遗嘱处分了国家、集体或者他人财产的，应当认定该部分遗嘱无效 第一条的核心在于亲笔书写、亲笔签名以及注明年、月、日，如需涂改、增删还要在涂改、增删处签名并注明时间，否则，涂改、增删的内容无效。这里的日期是在有多份遗嘱时确定各份遗嘱先后的准据，只有日期最近的遗嘱有效。另外，关于受胁迫判定的问题，只要没有证据证明是在受到胁迫的情况下立遗嘱的，就是没有受到胁迫。最后，遗嘱格式参考下面的链接，事实上我也不确定网上这些模板是否可用，一个比较好的办法是第一次前往专业机构咨询和拟定遗嘱，之后按照这份遗嘱模板自己写就好，目前在网上查到的影响力大的专业机构是 中华遗嘱库 。 📝 遗嘱范本【标准版】 以已有的知识，或者从民法典中可以看到，遗产的第一顺序继承人为配偶、子女、父母，第二顺序继承人为兄弟姐妹、祖父母、外祖父母。所以这就意味着其实以我自己，可能也是很多年轻人的情况——没有配偶（更别提子女），即使我们没有留遗嘱，或者遗嘱无效，所留财产依法也是父母继承，因此目前更应该关注的是如何将自己拥有的财产清单、所珍视的物品、各种账户密码、对父母想说的话等留一个备份，并能在自己去世后及时的送达父母手里。当然，也要保证平时不会被父母随便找到，不然又是一场大型社死现场，这个地方就要自己好好斟酌了。对于我自己而言，我在 Notion 里动态更新着一份物品清单和账户密码清单，所以我只需要准备如下材料即可 电脑密码，Notion及账户密码及其内清单的简单说明； 对我有重要意义的物品清单，清单中每个物品的意义； 以何种方式安葬； 想对父母说的话。 所有这些放在火漆印章封好的信封里，父母不会随便打开这种封好的文件的。 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:3:1","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"葬礼 父母终有百年之后，事先了解一下丧葬办理程序，可以避免到时候的手忙脚乱，以下是中国殡葬协会给出的处理程序1： 开具死亡证明：当亲人去世后，死者家属或单位必须取得死亡证明：正常死亡的，由医疗卫生机构出具医学死亡证明；非正常死亡的，由区、县以上公安、司法部门出具死亡证明。 注销户口：死者家属持死亡证明书到驻地派出所注销户口。 联系火化 打电话或派人前往殡仪馆或殡葬服务站联系火化，登记死者姓名、住址、年龄、性别、死亡原因、死亡时间、遗体所在地、死者户口所在地； 登记家属姓名、住址、电话、与死者关系等； 预定殡葬服务项目，服务时间。 接运遗体：按预定时间，家属持死亡证明在指定地点等候灵车接运遗体。 遗体火化：遗体运送到殡仪馆，经过整容后举行告别仪式，然后进行火化并领取火化证明，火化完毕后领取骨灰装入实现选购的骨灰盒中。 骨灰安放：可以临时骨灰寄存，也可以选择各种葬式安放。 葬式类型除了传统的土葬外，火化后的骨灰有如下存放方式：骨灰堂、骨灰墙、骨灰廊、骨灰林、骨灰墓以及各种生态葬。父母选择何种葬式是他们的自由，需要尊重，但就我自己而言，眼见着广大的农村坟头林立，城市的墓碑又贵出天际，遗体捐赠和生态葬进入了我的视线。事实上从我小时候被村里的坟头吓到开始，就下定决心自己绝对不要以这种方式安葬，长大后又看到骨灰堂那一个个小格子，想着自己活着的时候住格子间，死了还要住格子间，还不如尘归尘土归土，更加坚定了信心，所以在上面的遗嘱中才会专门加入这一条。 一些细则和注意事项可以查看民政部发布的 殡葬管理条例（2012年修正本）和各地区自己的殡葬管理办法，这里要注意，在我自己所在地区的殡葬管理办法中看到了如下描述，在需要不断缴费的情况下，几乎已经可以肯定自己的墓穴一定会沦为无主穴位，而目前没有找到资料描述「无主穴位」究竟如何处理，因此，考虑海葬等生态葬又多了一条理由。 凡在公墓和骨灰存放设施安放骨灰，应按规定缴纳费用。逾期三个月不缴纳的按无主穴位处理。 以天津天海海葬服务中心 官网 给出的描述看，整体流程如下： 提前打进电话预约登记。 确定海葬进行的时间，以及随行人数。 缴纳海葬定金。 到指定地点进行海葬活动 海葬活动的具体流程如下 全体参加海葬的丧家起立,向本次骨灰海葬的先人默哀； 丧家将鲜花花瓣与骨灰相拌； 丧家陆续将拌有鲜花的骨灰撒向大海 ； 向先人海葬地献花海撒用品，鲜花、花瓣、手套、口罩等均免费提供。 嗯，我决定了，我以后就海葬。 中国殡葬协会，丧葬办理程序，2010-12. ↩︎ ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:3:2","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第四期月刊。 ","date":"2021-08-31","objectID":"/2021/life-monthly-4/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 4 期 (202108)","uri":"/2021/life-monthly-4/"},{"categories":["日程及周刊"],"content":"时政 1、塔利班控制阿富汗政府，政权开始交接 当地时间15日夜间，阿富汗塔利班发布消息称，已控制位于首都喀布尔的总统府，随后国际形势开始了一系列复杂变动。当地时间8月30日，美国国防部宣布，美国已完成从阿富汗撤军行动。 2、海地地震 当地时间14日上午海地西部尼普斯省发生里氏7.3级地震，随后，海地多地发生多次余震。至 8 月 18 日，地震共造成2189人遇难，至少12000人受伤。 ","date":"2021-08-31","objectID":"/2021/life-monthly-4/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 4 期 (202108)","uri":"/2021/life-monthly-4/"},{"categories":["日程及周刊"],"content":"生活 08.04，再次在 B站看到 UP 主戴建业，是一个讲古诗的中文系教授，幽默风趣 08.08，奥运开闭幕式观看 08.09，吃掉了老妈攒下来的粽子 08.10， 原神宵宫版本上线 观看小米发布会 08.16， 《安全感提升-灾难》文章完成并发布 单位通知社保和医保的办理事项 08.19，到三姨家拿了一袋嫩玉米 08.20， 媛福达超市半价，买了 300 多东西（实打实半价） 原神 2.1 版本前瞻直播 08.21，《安全感提升-独居》文章完成并发布 08.22，农历七月十五，做了四个菜 08.23，键盘换新电池，这一次测试一下可以用多久 08.31，《安全感提升-出行》文章完成 ","date":"2021-08-31","objectID":"/2021/life-monthly-4/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 4 期 (202108)","uri":"/2021/life-monthly-4/"},{"categories":["日程及周刊"],"content":"观影 电影《老友记·重聚特辑》 电影《夏洛特烦恼》二刷 电影《X特遣队·全员集结》 电影《地球上的星星》 电影《王牌保镖》 电影《杀手妻子的保镖》 纪录片《日常生存自救手册》 B站短片《消防说》系列 ","date":"2021-08-31","objectID":"/2021/life-monthly-4/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 4 期 (202108)","uri":"/2021/life-monthly-4/"},{"categories":["日程及周刊"],"content":"思考 1、国家的起源，国家的职责是什么 2、应对改变以前害怕负责任的想法，无论工作还是人际关系，负责任才能换来对等的回报 3、每个时代都有为梦想努力的人，即使大环境不太好。——看原神制作团队有感 4、有时候你只管做你想要做的，不必在意无脑的评论，你并不需要他们的认可。——看到无脑弹幕有感 5、情感方面也是有付出才有回报。——看原神视频看到多人游戏的快乐 6、有时候会有一种对年老后无法自理的恐惧。 7、国内的学校有时候完全不把别人家孩子当孩子，可能源自国内根深蒂固的官僚思想。——弟弟学校强制住宿，只给配 0.8 米宽的床 8、人的一生太多精力放在和不讲理的人讲理了，真是件悲伤的事情。 ","date":"2021-08-31","objectID":"/2021/life-monthly-4/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 4 期 (202108)","uri":"/2021/life-monthly-4/"},{"categories":["日程及周刊"],"content":"Check List 月末要完成的事情列表 照片备份 QQ和微信聊天记录备份 浏览器书签备份 对账 月刊完成 ","date":"2021-08-31","objectID":"/2021/life-monthly-4/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 4 期 (202108)","uri":"/2021/life-monthly-4/"},{"categories":["我所热爱的生活啊"],"content":"主要是日常出行和外出旅游过程中各种意外情况的应急预案建立，有些如电梯坠落、车辆落水等发生几率较小，但大家凭直觉会瞬间想到，所以也会包含其中。 注：作者并非求生专家，这些是作者阅读大量资料后为自己建立的预案，可选择性接受，参考资料置于文末。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:0:0","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"日常出行 首先是掌握各种交通工具的驾驶或乘坐方法，包括但不限于自行车、电动车、私家车、公交、地铁、客车、火车、飞机等。掌握各种公共交通的乘坐方法是因为不少人第一次乘坐它们心里总是很忐忑的，我上大学第一次坐地铁就显得手足无措，在网上也可以看到大量的如「第一次坐火车该注意什么」、「坐飞机的详细流程」这样的问题。有时候由于某种紧急情况可能会需要换乘，比如我的舍友有一次坐火车遇到暴雨导致停运，无路可走之下半路下车上了飞机，另外，客车也是常见的换乘工具，因此建议如果可以，第一次尽量找一个熟悉流程的同行者，体验过一次之后独立完成就不会有什么问题了，当然赶鸭子上架不是不可以，只是自己会比较焦虑，尤其对于社恐而言。 自行车、电动车、私家车这些有多有用就不需要我多说了，下面介绍相关的安全常识。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:1:0","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"电动车 根据最高车速、整体重量等参数，电动车可分为三类：电动自行车、电动轻便摩托车和电动摩托车，其中只有电动自行车判定为非机动车，后两者都属于机动车，需要驾驶证。那么满足什么样的参数属于电动自行车呢，根据国家标准 GB 17761-2018，主要是以下几条 具有脚踏骑行能力； 电驱动行驶时最高设计时速不得超过 25 km/h，电助力行驶车速超过 25 km/h 时，电动机不得提供动力输出； 整车质量小于等于 55 kg； 蓄电池标称电压小于或等于 48 V； 电动机额定连续输出功率小于或等于 400 W； 电动车在骑行时还要求有头盔保护，同时，这里还有两个需要明确的交通规则：电动车在十字路口如何左转和是否可以通过无信号灯的人行横道。《道路交通安全法》第六十八条规定：非机动车通过有交通信号灯控制的交叉路口，向左转弯时，靠路口中心点的右侧转弯（但交警的科普推荐二次过街的方法）。第七十条规定：驾驶自行车、电动自行车、三轮车在路段上横过机动车道，应当下车推行，有人行横道或者行人过街设施的，应当从人行横道或者行人过街设施通过；没有人行横道、没有行人过街设施或者不便使用行人过街设施的，在确认安全后直行通过。两种情况的图示如下，均来自济南交警的科普。 最后是载人的问题，《 中华人民共和国道路交通安全法 》第55条第3款规定：成年人驾驶自行车、电动车自行车，在确保安全的前提下，在城市区道路上可以载一名12周岁以下未成年人，在其他道路上载人不得超过一人。部分地区会放宽一定条件，比如《江苏省电动自行车管理条例》将这一条件放宽到了 16 周岁。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:1:1","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"公交 公交是我们平日里最常乘坐的交通工具，但由于我国人口较多，挤公交的情况较为普遍，发生事故时的伤亡也比较大，比如 10·28重庆公交坠江事故 有 13 人遇难，2 人失踪，6·7厦门公交起火案 有 47 人遇难，34 人受伤，因此下面介绍一些公交安全知识。 首先，公交车发生车祸时可能出现的情况有正常停车、翻滚和坠入水中，不同的情况采取不同的做法1 发生车祸后正常停车：司机开门后迅速有序离开车厢，等待救援人员入场，如果车门无法开启，使用安全锤击碎玻璃逃生； 车辆发生翻滚和侧翻：发生侧翻的一瞬间及时抓紧附近的固定支撑物，防止被甩出车外，坐在座位上时可以用双脚钩住前排座椅底部，还要保护好自己的头部，防止被碰伤。车辆停下来后及时从车门逃生，如果侧翻的车正好把门堵上，选择破窗或者从车顶的紧急出口逃生； 车辆坠入水中：保持镇定，注意不要被人绊倒，也不要拉扯别人，尽力移动到最有利于出逃的出口，等到水漫至腋下左右水压平衡时，破窗或开窗，然后深吸一口气从窗户离开车体，游出水面2。 另一种意外是公交起火，公交起火一般火势蔓延比较快，逃生时间比较少，比如 6.5成都公交车纵火案 从事发到消防赶到将明火扑灭只有短短 9 分钟，然而依旧造成了 27 人遇难，74人受伤。而根据相关的科普3，逃生的黄金时间实际上只有短短的 1~2 分钟，因此，在公交上应对烟雾、刺激性气味等异常情况提高警惕，发现及时时可以常识使用车载灭火器灭火，如果判定来不及，及时从车门或车窗逃生，如果烟雾较大，记得用衣服捂住口鼻4。 最后我们来总结一下公交车上的逃生路径，一共有四个5 6 灭火器。每辆公交车上都放置有至少两个灭火器，位置一般在驾驶座后部和车身中间。 公交车门附近应急开关。按照所提示的方向扳动应急开关，可以打开车门，注意，车门内外都有紧急开关，车外的人也可以协助开门。 安全锤。每辆公交车都配备多个安全锤，平时上公交车先确定下安全锤的位置，敲击车窗的边缘和四角可以破窗逃生。如果找不到安全锤，可以用高跟鞋、钥匙等尖锐坚硬物体破窗。 车顶紧急逃生窗。公交车头顶有紧急逃生出口，在紧急情况下旋转红色开关能打开窗口逃生。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:1:2","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"地铁 一份统计资料显示，国外近二十年的地铁事故主要类型为火灾、恐怖袭击、列车相撞、脱轨、停电、踩踏和自然灾害，而国内近二十年的地铁事故主要类型为踩踏、车辆故障、信号故障、机电故障、火灾、乘客原因和自然原因，其中踩踏事故占 30%，火灾、停电、自杀及设备故障各占 15%，水灾占 10%7。 首先来了解地铁上及站台的应急措施 紧急停车按钮：地铁站台的墙上有紧急停车按钮，当站台发生火灾、乘客上下车时被闸门夹到时，可以击碎保护罩按下紧停按钮，让列车紧急停车； 火灾报警按钮：依然是在地铁站台的墙上有火灾报警按钮，如果发生不可控制的火情，可击碎保护罩按下按钮，届时站台会自动启动火灾应急系统，广播告知旅客； 紧急报警器：每列车厢有紧急报警器，遇到有乘客晕倒、起火等紧急状况需要和地铁工作人员联系时，就可以启动紧急报警器接通司机室； 紧急开门装置：每节车厢及屏蔽门附近都有紧急开门装置，当乘客上下车肢体被闸门夹住时，就可以启动这个装置。装置启动后车厢车门将被解锁，运行中的列车会紧急停车； 灭火器：在每节车厢座位底部。 针对地铁内发生的不同意外，需要采取不同的措施8 车厢内有人突然晕倒。按下车厢内的紧急报警器，如果有能力及时开始急救； 车厢内起火。按下紧急报警器，利用车厢内灭火器自救，同时乘客及时疏散到附近安全车厢并关闭车厢门； 信号故障或车辆本身机电故障。听从车长或工作人员指挥； 自己或其他人被门夹到。及时按下紧急停车按钮或紧急开门装置； 掉下站台。及时按下紧急停车按钮，不要轻易下站台救人，如果地铁采用地面三轨供电，可能发生触电。 牢记地铁平均到站时间在两分钟左右，一定不要慌乱、拥挤，大部分事故中伤亡都是由于踩踏引起的，最后提供三个参考 安全门的科普，介是你从未在意过的地铁安全门-B站 地铁进水，关于地铁进水这件事，聊点你可能不知道的-少数派 地铁事故案例，11.19广州地铁事故-百度百科 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:1:3","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"电梯 电梯故障主要有两种：一是电梯突然停止运行，二是电梯失去控制急速下坠或上升9。如果是前者，首先不要惊慌，可尝试持续按开门按钮，并通过电梯内对讲机或手机拨打电梯维修单位的服务电话求助。也可通过大声呼救等方式向外界传递被困的信息，不要强行扒门或试图从轿顶天花板爬出。如果是后者，可采取如下做法： 快速把每一层的按键都按下； 如果电梯内有把手，一只手紧握把手固定位置，防止摔倒； 整个背部和头部紧贴不靠门的内墙，呈一直线，运用墙体作为脊椎防护； 膝盖呈弯曲姿势，借膝盖弯曲来承受重击压力； 把脚跟提起，呈踮脚姿势。 这里要注意的是，在一些科普中提到「快速把每一层按键都按下」并没有用，目前不知真假，而且，根据 SME科技故事 的科普，由于完善的设计，电梯突然坠落真实发生的可能性很小，电影往往是夸大的情节，如果实在想找现实案例，可以参考9·13武汉施工电梯坠落事故。最后，在雷雨天、火灾、地震、电梯发生异响时、电梯超过服役年限以及电梯超载时不要乘坐电梯。 聊完电梯最后聊聊自动扶梯，因为最近几年自动扶梯吞人事故已经多次成为社会热点，对此应当留意。乘坐自动扶梯时，乘客的脚、手以及鞋带、女士的裙摆有可能被夹在自动扶梯踏板缝隙，另外，扶梯本身可能突然停止、加速，扶手速度与踏板速度也可能不一致，这些都可能导致意外，遇到意外时，应及时按下或提醒别人按下自动扶梯首尾两端紧急停止按钮，注意按下后扶梯将在 1-2 秒内紧急停止运行，因为惯性，扶梯上的乘客可能会摔倒，所以可以提前提醒乘客。更详细的知识可以参考应急管理部的自动扶梯乘坐安全常识10， ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:1:4","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"疯狗 虽然狗是人类的朋友，但路上遇到不认识的恶犬也确实令人心忧，根据贝尔的日常生存自救手册11，下面总结遇到这种情况时的解决办法 保持冷静，慢慢远离，不要转身直接逃跑，狗可以感知你的恐慌，然后它们只会更放肆，而且你一般跑不过狗； 去车里或找一个它们上不去的高处作为掩护，尝试扔出去某些你身上的物品吸引它们的注意，然后乘此机会逃跑； 留意它们是否有项圈，如果有，意味着有主人，可以尝试向它们喊口令，像不准、坐下等，如果没有主人，也可以大喊，用大动作和权威的语气喝令它们后退； 躲不掉的情况下把外套缠在手臂上，然后用手臂堵着狗嘴，阻止它完全咬合，也防止它攻击胯下或颈部； 堵住狗嘴的情况下如果到了安全的地方，一定不要强行拽出手臂，可以用往狗脸上泼水等声东击西的方法令狗松口。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:1:5","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"抢劫 现在被抢劫的概率应该是非常小了，但还是摘录一下应对办法12 在人员聚集的地区被抢，大声呼救并及时报警 在僻静处或无力抵抗时，保持冷静，不要纠缠，人身安全最重要，确保自身安全后及时报警 被尾随时快速走向明亮的公共场所、人多的地方或到最近的住户按铃求援，或乘公交车、出租车离开，摆脱歹徒；或尽快拨打110电话，报警求助 无论何种情况，最好记住歹徒人数、容貌、声音特征、作案车辆号码、车型、车辆颜色和逃跑方向，并尽量留住现场证人。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:1:6","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"溺水 首要条件是学会游泳，另外关于溺水的急救参考 暴雨和洪涝的季节，这些技巧助你从容自保-少数派 这篇文章的溺水部分 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:1:7","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"旅行 首先介绍汽车和火车两种交通工具的应急避险，然后是旅行中容易遇到的几种情况。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:2:0","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"汽车 贝尔的日常生存自救手册提到了三种情况：被困燃烧车辆、被困触电车辆和汽车落水13。 汽车发生撞击后，泄漏的燃油和气体可能导致着火，浓烟和火舌笼罩车厢，造成乘车人死亡，同样，电气故障等其它原因也可能造成汽车燃烧，我们可以采取的措施如下： 发现车辆冒烟、起火、闻到刺鼻性气味等异常情况，尽快离开汽车到安全位置，注意不要打开引擎盖，如果引擎着火，会给它供氧； 如果需要打破车窗，选择侧窗而不是坚硬的挡风玻璃，并且打破的时候注意避开尖角和碎玻璃，避免受伤或加重伤势； 如果安全带无法解开，可以使用打破的镜子碎片作为刀子割断； 有刺激性气味时注意用湿布或湿衬衫掩住口鼻，保护气道； 离开汽车后尽量远离（25米以上），避开弹出的碎片和热浪，同时记得打电话报警。 汽车发生撞击时，还可能有断裂的电线落在车上，由于汽车轮胎是橡胶的，因此待在车里没事，但只要下车接触地面，就会立马触电，下面介绍安全离开触电车辆的方法： 如果有电缆落到车上，但没有发生汽油泄漏等其它危险，报警等待救援； 如果有其它危险，首先请求附近其它车辆救援，可以让他们把备用轮胎绑在车前做屏障，隔开自己的带电汽车，然后把自己的车辆推离电线； 如果只有自己，首先关掉引擎； 打破玻璃到车前或车后，双脚并拢跳到远处地面，注意一定要保持身体稳定，一旦跌倒或手触地或两脚分离就会触电； 落地后双脚蹭着走（尽量紧贴，不要分开），直到离开10米以上； 如果是自己在路上遇到这样的汽车，远离它，报警，提醒车内的人不要出来； 汽车落水的处理办法在上一章公交部分已有提到，这里做进一步的说明： 刚落水的时候如果能打开车门，及时打开逃生； 如果车内外已有压力差，系紧安全带之后破窗，这里如果解开了安全带，涌入车中的水流会将我们冲倒，随后行动更不方便； 一只手放在安全带扣的位置，一只手在车门把手处，等到水压平衡，解开安全带，开门逃生，不要从破开的车窗逃生，可能杯玻璃割伤； ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:2:1","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"火车 火车本身发生事故的几率就比较小，而且考虑到站台以及每节车厢都有工作人员，遇到事故听从指挥就好，所以乘坐火车更应该担心的是以下几种风险 在检票上车过程中由于拥挤、不遵守规则而引起的意外伤害事件； 乘客在列车行进过程中造成的碰伤、挤伤、烫伤等意外伤害事件； 列车上发生的盗窃事件。 下面是应对这些意外伤害的注意事项14： 听从站务人员的安排，在站台一侧的白色安全线内候车。来车后停稳再上，遵循先下后上的原则； 进入车厢后，将自己的行李物品放好，注意一定要放稳固，避免之后发生掉落，砸伤自己或他人； 倒热水时不要过满，以免列车晃动热水溅出后烫伤人； 火车有时会紧急刹车，当有所察觉时，应充分利用有限时间，使自己身体处于较为安全的姿势，或抓住牢固的物体以防碰撞。 列车相撞、脱轨、火灾等事故依然是造成伤亡的主要原因，而且也不是完全不会发生，所以依然介绍以下应对办法： 发生事故时，应远离门窗，抓住牢固的物体，以防碰撞或抛出车箱； 事故发生时，在座位或铺位上的乘客，应紧靠早牢固的物体上，低下头，下巴紧贴胸前，以防颈部和头部受伤； 火车出轨向前冲时，不要尝试跳车，否则会发生危险，如碰到带电的路轨、飞脱的零件等； 经过剧烈颠簸、碰撞后，火车不再动了，说明火车已经停下，这时应迅速活动一下自己的肢体，如果受伤应先进行自救； 火车停下来后，注意观察周围的环境。如果接近门窗，在身体情况允许时，应尽快离开；如果周围环境没有起火爆炸等危险，也可在原地不动，等救援人员到来；如果处于危险环境，可用逃生锤打破窗户爬出去或采取各种方式打碎玻璃逃离车厢； 离开火车后，设法电话报警，通知救援人员。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:2:2","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"丢失 无论是无意中丢失还是被偷，旅行中丢东西应该是概率挺大的一件事了，可以采取如下的措施防范： 乘坐交通工具，贵重物品要随身携带，不要随便把包托付给别人； 双肩包可以背在身前； 不要佩戴一看就很贵重的首饰； 到了旅店之后不要把所有东西都拿出来，走的时候会容易忘记； 准备好备用的手机、身份信息复印件、一些现金，放在不同的地方； 当然，如果丢失已经发生，我们需要立即采取相应的应对措施 银行卡丢失：及时进行电话或者到附近的营业厅进行临时挂失； 身份证丢失：如果是在车站临行前丢失，在专门的窗口办理临时乘车证明即可，如果是出差或旅行途中，则需要到当地派出所挂失并办理临时身份证（3个月有效期）。无论何种情况，回到户籍所在地后，及时补办或换领新的身份证，同时登报进行声明（可以在支付宝搜索「自助登报」小程序），这样丢失的身份证被用于不法活动时我们才可以免责15。 手机丢失：手机丢失后可以采取如下步骤16 拨打电话确认是否有人捡到； 如果无法打通电话，利用手机厂商提供的服务进行定位； 如果确认被盗，寻找警察帮助，英提供 IMEI 码和发票照片，并配合完成笔录； 立即挂失手机号，尽快补办； 尽快冻结手机银行、网上银行、支付宝、微信，按重要性修改各平台密码； 通知亲友和朋友，防止诈骗，同时自己谨防钓鱼。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:2:3","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"被骗 不管是黑心商家还是专业骗子，出门不踩几个坑仿佛就不叫旅游一样，这里简单列三个例子，更多的可以自己看一下纪录片 行骗天下 （不是那部电影）： 低价旅游团：一看就不正常的低价旅游团，要相信明面上赚不到的钱一定会在其它地方赚到，有可能在你加入旅游团后再以各种名义要钱，比如导游费/门票费/保险费用等，同时还会把游客带到各种购物点去，或者各种仿冒景点。 僧人/铜像合照：不限于僧人、铜像，凡是打扮艳丽并且热情的邀请你合照的都有这个嫌疑，等你开心的拍完就向你索要合拍费。 平安符/平安香等：一柱香几百上千乃至上万。 关于买东西，全国各地的小吃街/步行街卖的东西都一个样，还不好吃，而大部分景点的纪念品都来自义乌，可以直接从网上买。如果遇到确实想买的东西，一定要多看几家，对价格心里有数之后再说，有时候可以多砍几刀价，商家第一次爆出来的不一定是实际价格，尤其周围只有你一个人的时候。 另外，在外尽量选择公共交通和正规的出租车、网约车，不要坐黑车，尤其是那些一看就不正规的小型客车、面包车等。有些景区名声在外，去之前最好了解一下以前的案例，当然，最好还是少去这种地方。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:2:4","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"迷路 最近我所在的县有个阿姨去摘果子结果迷路了，一天后才被找到，这件事引起了我对迷路这一危险的警惕，在网上找了一些辨别方向的方法： 通过太阳的位置。在太阳足以成影的时候，在平地上竖一根直棍(1米以上)，在木棍影子的顶端放一块石头作标记，木棍的影子会随着太阳的移动而移动，三十分钟至六十分钟后，再次在木棍的影子顶端放另一块石头，然后在两个石头之间划一条直线，该直线末尾指向东方，此即木棒成影法； 通过树木生长状态。在北半球，树叶生长茂盛的一方即是南方，湿较、长着苔藓的一方即是北方； 通过积雪。中国境内，在沟谷地带有存雪的话，先融雪的一面山体是阳坡（朝南）； 通过河流流向。中国的大河一般自西向东流； 通过建筑。中国的建筑一般坐北朝南； 通过星星。如果是晚上，利用北极星辨别方向。 最后，如果随身携带指南针，使用指南针是最简单的办法，但要注意使用的时候要水平地拿着，且远离铁丝网、高压线等含有磁铁的物体或区域。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:2:5","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"求救信号 学会求救对遇险来说至关重要，下面是几种常见的求救信号17 声音和肢体信号：大声喊叫、挥舞手臂，这是我们下意识地举动，但也很有效； 烟火信号：燃放三堆火焰，彼此等距呈三角形是国际通用求救信号，另外，如果是白天，可以在火堆上放些苔藓、青嫩树枝等使之产生浓烟； SOS：这个标志大家都很熟了，可以在沙滩上画，也可以用石头、树枝等一切物体摆出该形状； 反光信号：镜子反射的光线可以在很远就看到，如果没有镜子，罐头盒盖、玻璃等都可以； 最后，如果决定离开，一定要留下信号表明自己的去向，对于搜救工作有重要作用。 ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:2:6","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"后记 为了应对大部分情况，可以准备 EDC 工具（Every Day Carry），即每日随身携带的工具，这部分可以参考乔老师的 一个防身术教官眼中的 EDC。另外，大家看这篇文章的时候可能注意到很多都是贝尔的日常生存自救手册的总结，在B站有资源。最后，还是那句话，永远不要放弃希望。 沈阳晚报，厦门公交车起火致47人死亡 乘公交车遇险自救方法，2013-06. ↩︎ 香宾车服，公交车落入水中，该如何快速逃生，2020-07. ↩︎ 网易新闻，模拟烟热实验，2017-09. ↩︎ 河南法制报， 公交车逃生指南，2013-06. ↩︎ 搜狐，自救指南 逃出起火公交车的关键步骤，2019-06. ↩︎ 新华网，公交车上安全锤、灭火器、逃生窗在哪里 你知道吗，2014-07. ↩︎ 网络文档，城市轨道交通运营阶段事故案例统计 ，2020-03. ↩︎ 知乎，地铁安全知识自救整理，2017-08. ↩︎ 搜狐，电梯出故障 来学学自救，2013-05. ↩︎ 中华人民共和国应急管理部，自动扶梯乘坐安全常识，2019-04. ↩︎ 贝尔·格里尔斯，日常生存自救手册 第2集，2010-05. ↩︎ 北京市东城区人民政府，遭遇街头抢劫我们该怎么办 (bjdch.gov.cn)，2020. ↩︎ 贝尔·格里尔斯，日常生存自救手册 第1/2/3集，2010-05. ↩︎ 安全管理网，乘坐火车的安全小常识，2015-04. ↩︎ 公安部，关于建立居民身份证异地受理挂失申报和丢失招领制度的意见_政策文件，2015-11. ↩︎ 沨沄极客，手机被盗之后，第一时间应该做什么？，2019-08. ↩︎ 中国灾害防御信息网，野外旅游 你需要了解的求救信号，2020.10. ↩︎ ","date":"2021-08-31","objectID":"/2021/sense-of-security-travel/:3:0","tags":["生活技能"],"title":"安全感建立-出行","uri":"/2021/sense-of-security-travel/"},{"categories":["我所热爱的生活啊"],"content":"我是一个想要万事做好准备的人，因此，为了毕业后独立生活不手忙脚乱（当然，还有其它原因），身在学校还比较安稳的情况下，2019 年的下半年我在校外租房过了半年独居生活，经历了独居要面对的很多事情。衣物挑选和洗涤、买菜买水果、做饭、房间清洁等很多知识和技能都是从那个时候起才逐渐开始学习，手忙脚乱的时候甚至会直接打电话向我妈请教，到现在回到家我基本可以替我妈打理很多事情，算得上进步明显。 当时最喜欢看的一本书是山本文绪的《然后，我就一个人了》，觉得特别有同感，但一个人生活的时候心里也担心很多事情，比如断电、断水、失火、入室盗窃、突发疾病等等，大部分因为年轻、身体足够好或者足够幸运没有遇到，但直到后来看到「北漂独居女孩被困浴室30小时」的新闻才知道自己不是杞人忧天，因此，这篇文章的内容其实是很早就提上日程的，只是遇到各种事情拖到现在才来做，好在还不算晚，漫长的独居时光才即将开始。 ","date":"2021-08-21","objectID":"/2021/sense-of-security-live-alone/:0:0","tags":["生活技能"],"title":"安全感建立-独居","uri":"/2021/sense-of-security-live-alone/"},{"categories":["我所热爱的生活啊"],"content":"🛠️基本生活技能 虽然现代社会中同居或婚姻生活所带来的便利大部分都有对应的公共服务，比如外卖、洗衣店、家政服务等，但洗衣服和做饭依然是应当掌握的最基本的技能，除此之外，还有一些零碎的生活建议： 第一点，也是最重要的一点，有一点点存钱计划，物质保障得排在独居安全感的第一位 自己给自己量身体尺寸有点难，所以如果遇到合身的衣服，记得把尺寸记录下来 利用手机日历或清单类软件建立周期性的洗衣提醒，看到堆积的脏衣服会毁掉你的好心情 可以稍微学一下缝纫，不仅省钱，而且少麻烦别人，社恐唯有自助 很多你以为一个人做不了的事其实可以，比如换被罩，把被芯全塞进去，对齐四个角，然后双手捏住两个角（连同里面的被芯），站在床上一甩，就好了 学会辨识和挑选各种蔬菜水果，这里推荐软件——果识（现在叫果蔬百科） 尽量购买小包装的食品和调味品，不要被商家活动蛊惑，牢记你买东西的前提一定是能在保质期前用完 记录一个人吃饭的食材用量，总是吃剩饭不仅容易出现卫生问题，心情也不好 冰箱里一定要有储备，喜欢出门的就每天散步的时候去超市或菜市场逛一圈，不喜欢出门或 996 的也每周休息的时候去一趟 冰箱里的食物或食材打好日期标签，到期后及时扔掉，相比这点浪费，你应该更不想生病和去医院 学会自己清洗油烟机、疏通马桶等，原因同第 3 条，举个换锁芯的例子，我按网上的教程换完之后才发现那么简单，极度开心省下了找开锁师傅的钱和时间 经济宽裕的话积极尝试各种智能产品，如电动窗帘、扫地机器人、洗碗机等，不然你的大部分时间都会耗在各种家务上 卫生间用完纸记得及时放新的，或者永远多放一卷卷纸 如果第二天早上有重要的事，让闹铃远离你的床，或者在前一天晚上预订一个大清早送到的外卖 如果你柔韧性不够好，那么你需要一个痒痒挠，以及一个单人搓背巾 你只有自己，所以，不要喝醉，如果可能，甚至不要喝酒 即便自己住，家里也最好有足够小型聚会使用的碗筷、酒杯、咖啡杯，这样在有朋友造访时不会措手不及。 再不喜欢交际，也要和周围居民混个脸熟，有时候被人打招呼的惊喜会让你开心好几天 要是在露天阳台和室外晒了被子、衣服，先看看天气预报再出门 不要总担心自己没锁好门，那是极小概率事件，如果没法控制这件事给自己带来的焦虑，换个智能门锁吧 每次出差或出游前，整理完房间再出门，否则，若干天后，回家开门的那一刻，总会有点丧气 ","date":"2021-08-21","objectID":"/2021/sense-of-security-live-alone/:1:0","tags":["生活技能"],"title":"安全感建立-独居","uri":"/2021/sense-of-security-live-alone/"},{"categories":["我所热爱的生活啊"],"content":"🚑意外预防 停水、停电、火灾这些都是小概率事件，我们随后再讲，这里先来讲独居时最担心的两件事：忘带钥匙和生病。 说起忘带钥匙，应该是很多人的痛，出门上班上学没带钥匙就不提了，丢个垃圾取个快递也能被锁门外边，有时候就觉得挺离谱的，解决这个问题我主要是两个办法 在实验室/公司放一把备用钥匙 在住处楼下找个人少的地儿埋一把备用钥匙。不在家门口的门垫、花盆、消防栓等地方放钥匙，主要是电影电视剧里出现太多了，实在是不放心，不仅容易被找到，还容易判断出是哪个屋子的钥匙，但埋在楼下就难说了，就算被人意外发现，顶多就是丢一把钥匙。 「洗澡被困浴室30小时」某种程度上也是钥匙的问题，同样可以通过在房间里藏一把备用钥匙的方法解决，当然，如果还是不放心，而且不心疼玻璃，那么可以备一把破窗锤，如果玻璃的位置不太好，打破也够不着门把手，可以在买个智能音箱放家里，并确认可以语音拨打电话。 如果说忘带钥匙带来的只是焦虑，那么生病所带来的就算痛苦了，这种痛苦不单单是由此损害的时间和金钱，更是由此而产生的孤独感。网上不是有个孤独等级排行榜，把「一个人去做手术」排在了最高等级吗，实际上别说做手术了，就是普通的病也能把人折磨的够呛，我到现在还记得有一天晚上受凉肚子绞痛硬生生痛醒的场景，愈是那种时刻，愈是渴望有人陪伴，孤独感也就越强，所以，最好做如下的准备 养成定期体检的习惯，如果已有职工体检，根据情况适当做一些补充 只要身体不舒服，就及时去医院，不要总以为撑一撑就过去了，大惊小怪总比病倒在房间崩溃好 了解常见疾病的症状和用药，常备这些药物，如感冒药、止痛片、过敏药等，定期检查保质期 掌握基本的外伤处理办法，比如磕碰、擦伤或者做饭时不小心的切伤，可以专门参加一些培训 👉 你的家庭小药箱，从这 8 种非处方药开始 - 少数派 (sspai.com) 👉掌握伤口自处理的小方法，帮你抓住自救和求助时机 - 少数派 (sspai.com) 由疾病更深一层的，关于独居的最大担忧是什么，是因为各种意外或突发疾病死在出租屋里无人所知，对这种意外我们除了建立豁达的死亡观外，还可以做如下准备 提前准备好遗嘱，交代自己已有的财产、未竟的心愿以及想对父母或其它人说的话，可以每年更新一次，实际上写遗嘱的过程也是审视自己的过程，你会发现什么对自己最重要； 坚持锻炼身体，增强体质； 和一个关系较近的、能够信任的，最好是每天见面的同事或朋友事先做好约定，无故失踪的时候能打个电话联系一下，如果电话打不通，最好能上门去看一下； 所以独居不是与世隔绝，你总要和其他人打交道的，你可以不喜欢同事，也可以畏惧恋爱，但你的精力必然要投入一个方面，可以是以前的朋友，可以是同城的亲戚，亦或者是找同样的同居者结成对子。不论是谁，他需要知晓你的家庭住址、工作单位，有你的父母或任意家庭成员的电话，有你家的钥匙，可以作为你的紧急联系人，也可以在发生漏水等意外时，如果你正在出差或者公司有事没法及时回去，帮你处理一些事情。 最担心的事情讨论完，现在我们可以聊一些发生几率不是那么大的事了。对停水、停电这两种情况，我们主要是准备蜡烛、应急手电、充电宝、储水桶和纯净水等物资，对于火灾，应对方法如下 了解常见火灾安全隐患，比如老化电线、密集堆放的易燃物品等，平时多注意； 安装烟雾报警器，准备灭火器、灭火毯、火灾专用防烟面罩等预警和求生工具，如果住在高楼，还可以准备求生绳，但切记不要跳楼（消防用具可以通过中国消防产品信息网查询是否合格）； 掌握灭火与逃生的科学方法，避免出现用水灭油锅火这样的错误。 拥有一些最基本的电器、电路常识不仅在预防火灾时有用，在日常生活中也至关重要，有时候停电只是因为跳闸，有时候插座没电只是因为线路松动，电池也不一定没电，你可以自己拿个万用表量一下电压，最离谱的是，只要你不怕麻烦，家里常备五金工具，就算你不会修，只是简单的拆开和复原，问题有时候就没了。当然，如果你真的不想自己动手，那就预先存好电工师傅的电话吧，与之类似的还有开锁师傅、送水师傅、漏水维修师傅等等各种师傅的电话，否则只有到用的时候才会后悔莫及。 让我们看看余下的还有什么，入室盗窃？遇到直接报警吧，不过由此引申出来的，恐怕是隐私保护的问题，毕竟排除熟人作案和随机作案的情况，也就是自己的隐私泄露了，所以独居的时候可以 在家里安装摄像头，发生作案时视频资料可以作为证据 尽力预防外卖、快递等公共服务中自己隐私的泄漏 准备自卫工具，但可能心理安慰作用更多 最后还有一件事，自己一个人在房间里可以肆无忌惮，这是独居的好处之一，但比较隐私的事记得拉窗帘，不然就会像《老友记》里的 Ugly Naked Guy 一样变成直播。 ","date":"2021-08-21","objectID":"/2021/sense-of-security-live-alone/:2:0","tags":["生活技能"],"title":"安全感建立-独居","uri":"/2021/sense-of-security-live-alone/"},{"categories":["我所热爱的生活啊"],"content":"🤦‍♂️感到孤独怎么办 独居的时候某些情况下孤独感尤其强烈，网上有个孤独等级，里面的场景比较有代表性，比如一个人去看电影、一个人去吃火锅、一个人去看海等等，我自己大部分都经历过，或者倒不如说一个人看电影、一个人旅游这些事本来就是我生活的常态，然而除了睡午觉在黄昏醒来时的「黄昏恐惧症」，很少有时候会感到孤独，而下面是我的一些预防孤独或孤独时发泄的建议： 即使房子是租的，也要用心去打点，比如换掉窗帘和壁纸，买一块好看的地毯，从心理上真把租的地方当家的时候，孤独感就会少很多 失去新鲜感时换个住的地方，这是独属于租房者的奢侈 养点植物或者宠物，让房间里除了你之外，还有其他喘气的，也多一个心的寄托 有一两部特别喜欢的剧集、综艺，孤独的时候它们的陪伴会让人好很多 积累一些不过分热闹，也不过分冷清的歌曲，做家务的时候放一下，气氛会不那么沉闷 有一两个熟悉的公共空间，比如咖啡馆或者快餐小店，不想独自在家时去坐一坐，并确保在你去卫生间时，有熟悉的店员和老板愿意帮你看东西 积极尝试新的事物，向外看的多了，顾影自怜就会少，而且这样也能扩展新的圈子，防止现在同事的小圈子里产生人际关系的内卷 和家人保持适当的联系，比如每周打一次电话 有一两个对微信、电话接近于秒回的靠谱朋友，遇到急事和情绪崩溃时，至少有可以即时联络来安抚情绪的人 那些痛苦的、喜悦的、有趣的、无聊的各种引起你强烈吐槽欲或分享欲的事，如果身边可没人可分享，可以用纸笔或手机记录下来，但不要公开发表（事后可能后悔），当然，发泄情绪的最好办法还是运动 不要在最孤独寂寞的时候向谁表白或答应谁的表白，大概率你会后悔 其实最重要的是自己心里做好准备，同居是正常的，独居也是正常的，婚姻是正常的，单身也是正常的，世界容得下你这么一个异类，何况，是不是异类还说不定呢，所以一个人出门吃饭、看电影时心态要好，要理直气壮，这是你的权利，无需因餐厅人多，而你独自一人占了一张桌子而感到抱歉。 最后，还是想说，你可以喜欢一个人，但也不要拒绝两个人。非常推荐大家看一下《家族的姓氏》这部日剧呀，看完之后你就会对主角下面这段话感同身受。 👉参考：宋诗婷，独居者需要知道的70件小事，三联生活周刊，2021年13期 ","date":"2021-08-21","objectID":"/2021/sense-of-security-live-alone/:3:0","tags":["生活技能"],"title":"安全感建立-独居","uri":"/2021/sense-of-security-live-alone/"},{"categories":["我所热爱的生活啊"],"content":"后记 前面已经提到，同居或婚姻生活中大部分便利都有特定的公共服务可以提供，但即使现代社会为独居提供了如此多的便利，也不提倡生活层面和精神层面的不自律，那不是自由，那是自我放弃。独居时所有事情都要一个人做，有时候就会懒得做，可以理解，偶尔放纵一下可以，不要一直这样，也不要一回到家就沉迷手机或电脑，那是逃避，是在利用网络的纷扰逃避现实的孤独，要学会用心去感受生活，如果最后真的发现没法接受独居，那就抓紧时间去找你的另一半吧。 至于我自己，可预见的可能很长一段时间都需要独居了，以后遇到没考虑到的事，会继续添加到知识库的。 ","date":"2021-08-21","objectID":"/2021/sense-of-security-live-alone/:4:0","tags":["生活技能"],"title":"安全感建立-独居","uri":"/2021/sense-of-security-live-alone/"},{"categories":["我所热爱的生活啊"],"content":"干旱、洪涝、疫情、地震……最近两年各种灾害日渐增多，而且据中国气象局消息，越来越多的迹象表明，地球正处于关键转折期——“气候临界点”，在人类的影响下，地球气候系统正从「缓慢」量变转为「剧烈」质变1。因此可预见的，未来各种灾害将持续增多，为了能够在遇到这些情况时有充足的储备，本文收集和总结应对各种灾害的办法。 注1：本文考虑自己常住地（山西）的情况，火山、台风这类发生几率极小的灾害只在以后去相关城市旅行时做知识储备。 注2：本文大部分信息来自「中国灾害防御信息网」和「中华人民共和国应急管理部官网」的科普 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:0:0","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"1. 灾害及应对 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:1:0","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"高温 高温天气是指日最高气温高于 35℃，且持续 3 天以上的天气，预警分为三级，分别以黄色、橙色、红色表示。其中，黄色表示连续 3 天日最高气温将在 35℃ 以上，橙色表示 24 小时内最高气温将升至37℃ 以上，红色表示 24 小时内最高气温将升至 40℃以上。 可能有人觉得高温不算灾难，但你可能不知道，2003 年欧洲热浪期间共有超过 3 万人死亡2，而今年（2021年） 6 月底，美国和加拿大也遭遇了历史最高纪录的高温热浪天气，号称千年一遇，整个不列颠哥伦比亚省从 6 月 25 日到 28 日的 4 天内共有 233 人死亡。7月1日发表于《柳叶刀·行星健康》的一项研究发现，全球范围内，每年与异常高温或低温相关的死亡人数超过500万，占所有死亡的近10%。而随着全球变暖的加速，异常低温导致的死亡率虽然会降低，但异常高温导致的死亡率则会升高，从而在长期提高整体死亡率3。可能有人很难想象高温为什么会致人死亡，风扇、空调、西瓜、冰粥，甚至直接躲到阴凉地方，趋利避害难道不是生命本能？我们从资料45中找到了如下原因： 高温影响人的生理健康，最常见的就是中暑和脱水，严重了（热衰竭或热射病）就可能会死人； 高温使本身有心脑血管疾病或呼吸系统疾病的患者病情恶化，导致死亡； 高温对人的心理状态产生影响，导致睡眠障碍或间接导致自杀； 现有预防措施只针对低频极端天气，当异常天气频繁，旧有手段不足。比如 2003 年欧洲热浪之所以死很多人，很大程度是因为，当地人习以为常的夏天不需要空调，这样高温来袭时，反而没了快速降温手段，而美国家家都有空调，但遇到热浪时大家同时使用，反而引发了城市电力供应危机。 姑且不论高温导致的其它灾害，如干旱、山火，我们平常要预防的其实只有两件事：中暑和晒伤。 按照临床症状的轻重情况，中暑可分为三级，表现及应对措施如下6 先兆中暑：多汗、口渴、无力、头晕、眼花、耳鸣、恶心、心悸、注意力不集中、四肢发麻、动作不协调等。这时如果及时转移到阴凉通风处，补充水和盐分，短时间内即可恢复； 轻症中暑：患者的体温升高到38℃以上，面色潮红或苍白，大汗，皮肤湿冷，脉搏细弱，心率快，血压下降。轻症中暑的处理办法同先兆中暑，但可能需要休息几小时； 重症中暑：大多数患者是在高温潮湿环境中突然昏迷，此前患者有头痛眩晕、不安或精神错乱、定向力障碍、肢体不能随意运动等，皮肤出汗停止、干燥、灼热而绯红，体温常在40℃以上。出现重症中暑需要尽快送医院救治，但现场的及时处理将会争取到治疗的最佳时间，减少危象发展。 对于中暑，下面是一些常见预防办法 进行有意识的体育锻炼，提高耐热能力； 人体对温度的变化有一个适应过程，所以初夏时不要急于开空调，炎热时启用空调温度应保持在26℃，不宜太冷； 出行注意避开正午时段，及时补充水分； 储备相关物资，如藿香正气水、风油精、冰袋等。 防晒也是高温时我们需要注意的一件事，不仅仅是为了不被晒黑或减缓皮肤老化，更重要的是防止晒伤和预防皮肤癌，我七月份毕业旅行的时候就是因为没有做防晒，结果被晒伤一直到回家还疼了好几天。对于男生而言，防晒最重要的不是了解相关知识，而是改变自身观念，不要认为防晒是女性专属行为。另外，这方面要储备的物资包括防晒霜、遮阳伞、防晒衣、太阳镜或冰袖等。 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:1:1","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"暴雨 暴雨本身有三个等级：暴雨、大暴雨和特大暴雨，但其预警级别有蓝、黄、橙、红四个等级，不同等级之间是以降雨量多少毫米这种数字为划分的，但实际上我们一般对这些数字没有太大概念，因此最简单的办法就是根据预警信息进行相关准备。暴雨的直接危害包括造成城市内涝和漏电触电，降雨量过大也会引发泥石流、滑坡、山洪等各种次生地质灾害4，尤其是河南的暴雨和洪涝还犹在眼前，大家想必对其后果和预防知识都有不少了解，这里根据网络上的相关科普资料，将情况分为普通暴雨和城市内涝（洪水）两种情况进行总结，途中会穿插暴雨时的危险地点、涉水注意事项以及灾后防疫三个重点。 普通暴雨 指蓝色和黄色预警级别的暴雨，其中，黄色预警级别的暴雨可能造成积水。这种暴雨强度比较大，但持续时间不会太长，所以注意事项如下7 如果待在室内，关掉煤气、切断电源、远离窗户，尽量不要出门； 如果在室外，尽可能快速进入室内； 在室外来不及躲进室内或者必须出门，则要注意 不要在大树底下避雨，不要拿着金属物品及接打手机，以防雷击； 绕过积水严重地段，警惕跌入窖井、地坑中； 避开路灯、高压电线、变压站等电线集中经过路段，尤其是看到电线落在水中或者树枝压倒线路时，一定要远远绕开，以防触电； 远离广告牌、建筑工地以及老旧建筑物等，以防坠物； 夜间要提防来往车辆 因为持续时间一般不会太长，家里只要有 1-3 天的食物储备就不需要太担心，如果正好相关物资耗尽，出门采买也没有太大的阻碍，只要注意上面第 3 点的几条即可。另外，关于触电有一些更详细的建议如下8 淌水通过前，观察附近有无电力设施，有无电线断落在水中，有无树枝压倒线路等，如发现有，应离开 8 米以外再判断是否通过； 如在水中感觉发麻等疑似触电征兆，可采用单脚跳的方式跳出积水区，另一只脚不要接触到水面或地面； 万一发生触电事故不可赤手救人，须站在干燥地面上，持干燥的木棒、竹棒等不导电的物体挑开带电导线施救。 积水覆盖之下，不注意可能掉入各种井窖中，识别这类隐藏风险可以采用如下办法8：管涌顶开井盖后，水面上一般会出现一股向上冲的水流，即突泉；当上游来水减少，水位下降时，又会出现一个漩涡。看到类似情况，要注意绕行，该方法也适用于发生洪涝时的涉水。 城市内涝 橙色和红色预警意味着此时的暴雨可能已经或即将导致江河湖泊水位上涨、城市内涝、地面交通中断、输电线路中断等灾害，此时应迅速向室内躲避并积极关注相关新闻咨询，如果一旦确定相关灾害不可避免，检查周围安全情况并尽力储备相关物资。 我们在这里假设相关灾害已经发生，则应当根据自身情况按照如下方法进行自救或互救： 如果在地势较高的广场、坚固的多层高层公共建筑的 2 楼以上区域(高于水面)，应尽量待在原地，等待救援人员的到来； 如果处在户外，尽量向第一条所示地点转移，如果洪水袭来没时间转移，要尽量往高处走，找到结实、便于停留的地方，如屋顶、大树、高墙等做暂时避险，并且利用好周围条件做好逃生准备，如船只、木排、门板、木床等。下面是一些发生洪涝时的危险地带，注意一定不要待在这些地方9 桥梁和河堤，河道可能形成洪涝冲垮它们 建筑物的地下部分、地铁、地下涵洞、过街隧道、地下人防工程、地下商街等，水可能漫入 老旧建筑物，可能倒塌伤人 山坡，可能发生泥石流和滑坡等次生灾害 树下和树旁，广告牌，可能有落雷或被砸到 下坡道和汽车后面，水冲下来会被一起撞到 各类公共交通设施，暴雨之下，所有公共交通都可能中断 各种电力设施周围，避免触电和雷击 向安全地点转移过程中，除非万不得已，尽量不要涉水，如果必须涉水，可以采用如下方法8 双臂向前伸展，在水中行走时，重心放在后脚上，前脚伸出，用脚尖左右扫动，确认前方是平地，双脚交替探路前进。 找来棍子、结实的长柄雨伞等作为探路工具 如有两人结伴，可一人在前，另一人双手抓紧前者裤腰部位，前脚虚、后脚实地跟着前进，如遇意外，后者可在第一时间将前者拽住。 一旦落水，要屏气捏鼻，尝试站立；如果双脚实在触碰不到地面，就将自己的脸部朝上，头向后仰，用手掌拍击水面，双脚不断向下踩水，尽量让自己的嘴露出水面，同时寻找身边的漂浮物，尽快抓住。 如果在车辆中，水线超过车轮 2/3 时或车辆不受控制时，及时弃车逃离，一定不要舍不得； 有能力的情况下，要尽力救助他人，当然，可以周围的人组建自救集体，协助求生。 发生灾难时，通讯在发生灾难时显得尤为重要，这方面可以遵循如下的办法9 离开交通工具时，给亲友发个消息（微信、朋友圈等），标记自己的位置、车辆位置、撤离计划，然后和大家撤离 到达安全位置后，再发一条消息，标记自己当前位置和身边人员的情况，告知大家自己暂时安全，并为了节省电力会减少和外界联系 如果周围水情已经导致自己无法离开，立即向警方汇报自己位置、人数、周围水情、紧急通讯方式等，然后停止使用手机，等待救援。 尽量节省手机电力，确保手机能支持到救援人员抵达、确保安全后还有能力和亲友联系，到达安全位置后，可以和亲友约定每隔 2-4 小时或更久通讯一次，以降低彼此通讯消耗 灾情下，周边电力、信号都有可能中断，也有可能出现全民集中通讯导致信号拥堵，遇到这类情况不要慌，设法和公安部分取得联系、告知情况，如果有收音机，可以使用收音机收听政府发布的消息。 灾后防疫 暴雨、洪水中可能夹杂动物尸体、生活垃圾等污染源，应避免口鼻和受伤部位接触洪水，脚部沾水后及时清洁冲洗，主要原因有 淌水后细菌容易从皮肤毛孔或伤口乘虚而入，钻到淋巴管，从而引发丹毒和淋巴管炎，表现为局部出现片状红疹，皮肤表面紧张炙热，迅速向四周蔓延，并伴有高热畏寒及头痛等 长时间在渍水中浸泡后，皮肤屏障功能被破坏，真菌和细菌便有机可乘，容易引发擦疹、脚足藓等 淌水回家后若用凉水冲脚，毛孔骤然关闭，加上锻炼后肌肉疲劳、紧张度增加，可能诱发关节炎和风湿病 因此涉水前最好做好如下准备 在涉水前，双腿涂上防水油膏，尤其是趾间 如果皮肤本来有破口，现在创口处图上抗菌药膏，有条件穿上高筒雨靴或套上厚实的塑料袋，不要光足涉水 涉水的鞋子尽量不要再穿，淌水回家后及时用流水（温水）和肥皂或者医用酒精清洗擦干腿脚，再换上干净的鞋、裤 如在涉水后出现红斑、水泡、瘙痒等不适症状，及时就医 此外，还要积极做好如下防疫工作，如对墙壁和地面进行消毒、衣物煮沸并暴晒、日常用品煮沸或暴晒、不吃洪水浸泡过的食物等等。 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:1:2","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"火灾 失去控制的燃烧称为火灾，而根据可燃物的类型和燃烧特性可以将火灾分为以下几种： A类火灾（固体火灾）：煤、木材、棉、麻、毛、纸张等固体物质火灾 B类火灾（液体火灾）：汽油、煤油、柴油、沥青、石蜡等液体火灾或可溶性固体物质火灾 C类火灾（气体火灾）：甲烷、氢气、煤气、天然气等气体火灾 D类火灾（金属火灾）：钾、钠、镁等金属火灾 E类火灾（带电火灾）：物体带点燃烧的带电火灾 F类火灾（烹饪物火灾）：烹饪器具内的烹饪物，如动植物的油脂火灾 无论哪种火灾，都离不开几个基本条件：可燃物、助燃用的氧气、燃点以上的高温环境，有时候还需要催化剂，所以灭火的机理其实就是阻断这几种条件中的任何一个，比如 隔离灭火法：将正在燃烧的物体同周围的物体隔离开，中断可燃物的供给 冷却灭火法：将低温的水或二氧化碳直接喷射到燃烧物上，将燃烧环境的温度降到燃点以下 窒息灭火法：阻止空气流入，或用不燃烧的物质如二氧化碳来冲淡空气，使燃烧得不到充分的氧气而熄灭 抑制灭火法：将有抑制燃烧作用的灭火剂，如干粉灭火器中的干粉，喷射到燃烧物上，导致燃烧反应的活化分子数降低 常用于初期火灾扑救的消防器材有：烟雾报警器、自动喷淋系统、消防栓、灭火器等，灭火器由于轻便、使用简单，因此使用最广，是扑灭初期火灾的重要消防器材。常用的灭火器有干粉灭火器、二氧化碳灭火器和水基型灭火器，其中，干粉灭火器灭火原理为抑制灭火，可用于扑灭A、B、C类火灾和电着火；二氧化碳灭火器的灭火原理为窒息和冷却，灭火范围为B类、C类和E类；水基型灭火器的灭火原理为窒息和冷却，新型水基型灭火器的灭火范围为A类、B类、E类和F类火灾。无论哪种类型的灭火器，使用方法都相似，包括 取出灭火器 拔掉保险销，干粉灭火器在使用前要晃动几次，水基型灭火器注意喷枪进气孔没有堵塞 站在上风方向，举例火源2~3米，对准火焰根部喷射 一手握住压把，一手握住喷管，如果是二氧化碳灭火器，握喷管的手要戴手套，防止冻伤 另外，使用灭火器时，除了要检查灭火器的外观和有效期，还要检查其压力和瓶身上绘制的灭火范围，灭火范围前面已经提到过，这里简单谈一下压力。干粉灭火器和水基型灭火器在瓶身上部有一个指示压力的表盘，分为红、绿、黄三个区域，如果指针位于红色区域，表明压力不足，灭火效果可能不好，指针位于绿色区域表明压力正常，指针位于黄色区域则表示压力过大，可能发生爆裂。 如果初期火灾扑灭失败，就要准备逃生，逃生主要有下面几个原则。首先要熟悉环境，在自己的居住地和常去的商场，了解有几个逃生出口，分别在什么地方，哪些是畅通的，平时在外也要多注意这些。其次在逃生时要保持镇静，注意明辨方向，不要跟随人流，可以根据安全指示牌首先往楼下跑，如果楼下已被烟火封锁，则向背向烟火的方向离开，可以通过阳台、天台等向室外逃生。另外，火场逃生时为了避免吸入浓烟，可以用毛巾、口罩等捂住口鼻，弯腰低身撤离，使用毛巾时注意充分打湿，尽量对折3次、叠成8层使用。 如果发现身上着火，不可惊跑和用手拍打，因为这样会加速空气流通，加重火势，应该采用迅速脱掉外衣、就地打滚或跳入水中的方式灭火，如果是替他人灭火，可以往其身上浇水、用灭火器喷射及用湿棉被和毯子包裹其身体等办法。如果是屋外或楼道着火，当摸到房门已经烫手的时候，一定不能开门，因为一旦开门火焰和浓烟就会铺面而来，这时应该关紧引火的门窗，打开背火的门窗，用湿毛巾或湿布把门缝堵住，然后不断用水淋湿房间，防止烟火渗入，固守在房内，发出求救信号，等待救援人员到达。如果家里有高空缓降器或救生绳，情况危急的情况下，可以自己从高层逃生。 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:1:3","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"地震 地震是地壳快速释放能量过程中造成振动，同时产生地震波的一种自然现象，地震灾害则是指由地震引起的强烈地面震动及伴生的地面裂缝和变形，使各类建筑物倒塌和损坏，设备和设施损坏，交通、通讯中断和其他生命线工程设施等被破坏，以及由此引起的火灾、爆炸、瘟疫、有毒物质泄漏、放射性污染、场地破坏等造成人畜伤亡和财产损失的次生灾害。 我以前一直以为山西不处于地震带，所以不关心这方面的知识，结果查资料的时候发现山西处于汾渭地震带，顿时一惊。不过，由于板块边沿和板块内部错动挤压都可能引起地震，所以即使自己的居住地不处于地震带，也应当掌握一定的防震知识。中国灾害防御信息网置顶的一篇文章提到，2014 年，地理位置比较「干净」的安徽省就因 4 级多的地震造成了人员伤亡，因此即便处于比较平稳的地区，如果不提高防震意识，也可能发生「小震大灾」的现象10。 破坏性地震从人感觉振动到建筑物被破坏平均只有 12 秒，在这短短的时间里，我们应该沉着冷静，根据所处环境迅速作出保障安全的抉择，下面主要分室内和室外两种情况做介绍。 室内避震11 地震中最危险的时刻，是在晃动最为强烈的时候，逃出房屋或返回房屋试图抢救同伴及某些物品都会加大被坠落物体砸伤的几率，所以地震时如果处于室内，一般直接就近躲避即可，短时间基本逃不出去，反而增加了风险。就近躲避时如下空间较为安全，可以优先选择 低矮、坚固的家具边 承重墙墙根、墙角； 水管和暖气管道等处，暖气的承载力较大，金属管道的网络性结构和弹性不易被撕裂，即使在地震大幅度晃动时也不易被甩出去；暖气管道通气性好，不容易造成人员窒息；管道内的存水还可延长存活期。更重要的一点是，被困人员可采用击打暖气管道的方式向外界传递信息，而暖气靠外墙的位置有利于最快获得救助。 而下面几个场所则较为危险，远离它们，至少不要在这些地方躲避 没有支撑物的床上、柜子、隔断墙 吊顶、吊灯下； 周围无支撑的地板上 玻璃（包括镜子）和大窗户旁 选择好躲避处后应蹲下或坐下（躺卧时人体被击中的概率要比站立大 5 倍，而且很难机动变位），低头，用手护住头部或后颈，闭眼以防异物伤害，有条件有能力时抓住桌腿等身边牢固的物体，以免摔倒或因身体失控移位而受伤。由于地震其实是有规律的，一次震动来袭，先是纵波上下动，后是横波左右晃，短的一二十秒，长的持续一两分钟，之后会有短暂的平静期，所以在房子晃动的时候我们躲在安全的地方，不晃的时候就迅速往下一个地点转移，在下一波震动来袭之前，躲在新的可藏身的安全之处。另外，跑的时候注意不要靠近窗边或阳台，不要跳楼或乘坐电梯，应选择安全通道迅速撤离，出去后找草坪等开阔地带，不要在两楼中间停留。 我们最好在平时就做好相关的准备，如 买房的时候就了解建筑的防震等级，了解家里的承重柱的位置； 装修的时候注意家具的摆放，确保安全空间，窗户可以选择防碎安全玻璃，避免破碎时玻璃飞溅； 平时对家里的大衣柜、餐具柜橱、电冰箱等做好固定，防止其本身倾倒或里面的物品掉出来； 准备好相关应急包，并思考地震发生时自己要躲在哪里等。 如果发生地震时自己在群众聚集的公共场所，因为人群很容易慌乱并引发拥挤踩踏，这时候一定要沉着冷静，特别是当场内断电时，不要乱喊乱叫、乱挤乱拥。 如果在影剧院、体育馆等场所，应就地蹲下或躲在排椅下，注意避开吊灯、电扇等悬挂物，用皮包等物保护头部，等地震过后，听从工作人员指挥，有组织地撤离。 如果在商场、书店、展览馆等处，应选择结实的柜台、商品(如低矮家具等)或柱子边，以及内墙角处就地蹲下，用手或其它东西护头，避开玻璃门窗和玻璃橱窗，也可在通道中蹲下，等待地震平息，有秩序地撤离出去。 Q：地震发生时，建筑高层还是底层更容易被破坏12？ A：高层虽然晃动幅度大，但是受到的力更小，而底层来回移动幅度小，但受到的力更大，所以底层更容易被破坏。但底层更容易被破坏不意味着高层更安全，如果建筑发生粉碎性倒塌，基本高层和底层一样危险，甚至高层部分会在坠落过程中产生更大的动能，高层碎石坠落带来的危害也更大，不过这种情况处在高层更容易被挖掘救援。如果地震不完全摧毁建筑，总体上高层更难发生局部破坏。 还应当知道的是，现行的建筑设计标准，对建筑物的抗震设计有着「小震不坏，中震可修，大震不倒」的要求，发生建筑倒塌一般只会发生在地震烈度特别大，超过该地区大震的设计烈度的情况，比如汶川地震（烈度11级）。 综上，发生地震时不用向高层跑，也不用向底层跑，而是遵循就近躲避的原则，采用本小节提到的方法进行自我保护和自救。 室外避震13 若在开阔地带，可原地蹲下，注意保护头部，不要随便返回室内。另外要注意避开如下地点 山崖、陡坡、河岸； 高大建筑物，特别是有玻璃幕墙的建筑； 过街桥、立交桥； 高烟囱、水塔、狭窄街道、危墙、砖瓦及木料堆放处； 变压器、电线杆、路灯、广告牌、吊车等。 如在街道上遇到地震，应用手护住头部，迅速远离楼房，到街心一带。 如果在行驶的地铁或公交中，和在室内公共场所相同，首先要做的是保持冷静，切勿慌张，不要拥挤，避免摔倒、冲撞和踩踏，应当牢牢抓住拉手、柱子及座位等，下蹲身体，放低重心保持稳定，或者就近抓紧扶手、双脚叉开站稳，同时保护好头部，以防摔倒或碰伤，待地铁或公交停稳后听从工作人员指示有序疏散至安全地点。一定要注意，除非严重危及人身安全，不得不进行自救，地铁中不要擅自拉下车厢的紧急制动停车装置，有疑问可以通过按压车厢内的紧急对讲装置的红色按钮和司机或工作人员通话。 如果在行驶的车辆中，驾驶员应立即打开双跳灯，避开十字路口靠边停车（让出紧急救援通道），待震动结束后下车寻找安全地带躲避。如果可以，不要锁上车门并将车钥匙留在车内，从而配合救援行动。停车地点还应当避开桥梁、高架、隧道、电线杆和路灯、广告牌、加油站、陡坡、高楼等，隧道内的车辆尽快驶离，如果无法通行及时弃车寻找隧道内的逃生门。震时如果在停车场，不要留在车内，宜躲在车旁并采取抱头下蹲的方式。 另外，震中或震后可能出现泥石流、山体滑坡等地质灾害（强降雨也可能引发），遇到这两种情况时，都要注意往两侧稳定地区逃离，不要向泥石流或滑坡体的上方或下方逃离，遇到滑坡无法逃离时可以速抱住身边的树木等固定物体，躲避在结实的障碍物下，保护好头部；但遇到泥石流一定不要爬到树上躲避，也不要在陡峻的山坡下躲避。 Q：室外开阔处如何判断？ A：没找到资料，但应当是周围建筑倒塌不会波及自身的地方，小区内各楼之间应该不符合条件，平时注意那些标注了应急避险场所的地方。 Q：遇到地表开裂怎么办？ A：首先明确不可能出现电影里那么大的裂缝，地震形成的裂缝一般面积和深度都不是很大，但存在掉下去后立即被掩埋的可能。其次，会导致地表开裂的地震强烈程度远远超过想象，不要说跑，站都站不住，这点从中国地震烈度表中的描述可以看到。总结就是，出现概率低，只能看运气，但是只要遇到没得跑。更多资料参考 什么样的地震会出现地表裂缝？ - 知乎 (zhihu.com)，有一个回答里有大量地震裂缝图片。 震后自救与互救14 地震时如被埋压在废墟下，周围又是一片漆黑，只有极小的空间，一定不要惊慌，要沉着，树立生存的信心，相信会有人来救你，要千方百计保护自己。 由于可能有多次余震发生，处境可能继续恶化，为了免遭新的伤害，要尽量改善自己所处环境。挪开头部、胸部的杂物保证呼吸畅通；避开身体上方不结实的倒塌物和其它容易引起掉落的物体，用砖块、木棍等支撑残垣断壁，扩大和稳定生存空间；闻到煤气、毒气时，用湿衣服等物捂住口、鼻。 如果找不到脱离险境的通道，尽量保存体力，用石块敲击能发出声响的物体，向外发出呼救信号，不要哭喊、急躁和盲目行动，这样会大量消耗精力和体力，尽可能控制自己的情绪或闭目休息， 等待救援人员到来。如果受伤，要想法包扎，避免流血过多。 如果被埋在废墟下的时间比较长，救援人员未到，或者没有听到呼救信号，就要想办法维持自己的生命，此时如果应急包在身旁，将会为脱险起很大作用，水和食品一定要节约，尽量寻找食品和饮用水，必要时自己的尿液也能起到解渴作用。 如果自身脱离危险且有能力进行救援，应积极参与救助他人。据有关资料显示，震后 20 分钟获救的救活率达 98% 以上，震后一小时获救的救活率下降到 63%，震后 2 小时还无法获救的人员中，窒息死亡人数占死亡人数的 58%。他们不是在地震中因建筑物垮塌砸死，而是窒息死亡，如能及时救助，是完全可以获得生命的。救助他们可以参考以下原则： 先抢救容易获救的被困者，如建筑物边沿瓦砾中的幸存者。 抢救时，要先使被救者头部暴露出来，并迅速清除其口鼻内的灰土，防止窒息，进而暴露其胸腹部。对怀疑有骨折或颈椎、腰椎受伤的被救者，抢救时一定不可强拉硬拖，避免二次损伤，要设法暴露其全身。 注意倾听被困者的呼喊、呻吟或敲击声，根据建筑结构的特点，先确定被困者的位置，特别是头部的位置，再开挖抢救，以避免抢救时造成不应有的损伤。 对于埋压时间较长的幸存者，要先喂些含盐饮料，但不可给予高糖类饮食。然后边挖边支撑，注意保护被救者的头部和眼睛。 对被抢救出来的幸存者，应采取各种适当的方法进行现场救护。 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:1:4","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"疫病 历经非典和新冠，大家在媒体的广泛科普下已经掌握了大部分应对方法，这里主要参考世卫组织官方的文件15，总结个人可以采取的措施。根据疫情严重程度或政府的相关要求，我们可以分为居家和出行两种情况 居家 在疫情蔓延期间，政府要求居家隔离的情况下，主要应做好室内的通风和消毒。 通风是有意识地将新鲜空气引入空间，同时去除污浊空气，以保持或改善空气质量。可以通过自然方式（例如打开窗户）或安装机械系统进行通风。 自然通风的方法是打开门窗，尽可能造成空气对流，例如让一扇窗户进来的微风穿过房间从另一扇窗户流出。 机械方式指使用空调或风扇，注意应减少空气的再循环和增加室外空气流入 消毒指由于采买物资等必须情况出门归来后，要彻底洗手，并且在处理和保存好购买的物品后再次洗手，对于购物袋、外出的衣物和鞋、买回来的物品都要进行消毒。 居家也要及时关注新闻，还要锻炼增强抵抗力以及保持心理健康。 出行 疫情不是很严重的情况下，人们总要因为各种各样的事出行，在出行时主要采取如下措施 与他人保持至少1米的距离； 戴口罩； 经常清洁双手。 戴口罩要掌握一些基本方法，根据世卫组织的《新冠疫情期间使用口罩的建议》，我们将关心的一些信息总结如下 买哪种口罩？在世卫组织的建议中使用除非是弱势群体，否则即使乘坐公共交通或处于人群比较密集的地方依然是非医用口罩即可。 如何戴口罩？ 戴口罩前做好手部卫生； 将口罩调整至鼻梁位置，并将带子系牢，从中间位置开始，朝两侧移动和按压鼻夹，减少口罩与脸部缝隙； 戴口罩时避免触碰口罩 如何摘口罩？ 不要触碰口罩正面，从后面解开带子； 取下口罩后或不小心碰触用过的口罩时，用含酒精成分的免洗洗手液洗手，如果手已明显变脏，用肥皂和水清洗； 口罩什么时候丢弃？口罩在变湿或有明显污渍后，应立即更换，口罩的各层面料有明显磨损痕迹时也应立即丢弃。另外，医用口罩一般是一次性口罩，不要重复使用，每次用后应丢弃，不过如果单次使用时间过短，可以考虑重复使用。 不要使用带阀门的口罩。 补充，国家卫健委发布了戴口罩指引，可以参考一下 另外，除了洗手外，还有一些保持卫生的良好要素 避免触摸眼睛、鼻子和嘴。手接触很多表面，会沾染病毒，一旦受到污染，手就会把病毒传递到眼睛、鼻子或嘴。从那里，病毒可以进入你的身体并感染你。 咳嗽或打喷嚏时，用弯曲的手肘或纸巾捂住口鼻。然后立即将用过的纸巾扔进封闭垃圾桶，并洗手。通过保持良好的‘呼吸卫生’，你可以保护你周围的人免受引起感冒、流感和COVID-19的病毒侵害。 经常清洁和消毒表面，特别是那些经常接触的地方，如门把手，水龙头和电话屏幕。 谣言与事实 【事实】人们在锻炼时不应戴口罩。汗水会使口罩较快变湿，导致呼吸困难，并助长微生物生长。锻炼时应采取的重要预防措施是，与他人保持至少一米的身体距离。 【事实】游泳不会传播新冠病毒。虽然病毒不会在游泳时通过水传播，但与人密切接触会导致病毒传播，因此即使在游泳或在游泳区域也要避开人群，保持足够的距离。 【事实】新冠通过鞋子传播的可能性很小 【谣言】晒太阳或高于 25 ℃ 的温度、洗热水澡能预防新冠。勤洗手才是最好的办法，这样可以除去手上可能携带的病毒，而且可以避免随后因碰触眼睛、嘴和鼻子可能发生的感染。 【谣言】低温和冰雪能杀死COVID-19病毒 【事实】新冠不能通过蚊虫叮咬传播。新型冠状病毒是呼吸道病毒，它主要通过接触已感染者咳嗽或打喷嚏时产生的呼吸道飞沫，或通过接触其唾液或鼻涕而传播。没有任何信息或证据表明蚊子可能传播2019冠状病毒病。 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:1:5","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"雪灾 虽然我国的大雪或暴雪天气多发生在东部的大兴安岭、长白山区和五台山等地以及西部的青藏高原、阿尔泰山和天山山区，但其它地区也不可因此大意，尤其是2008 年的南方雪灾，相比大家都印象深刻。 积雪和暴风雪是我们常遇到的雪灾类型，积雪过厚可能破坏交通、输电线路等生命线工程，造成断水、断电、压塌建筑物，影响人们出行，暴风雪则可能使人迷失。预防方面，暴雪和暴雨具有一定的相似性，暴雪也分为蓝色、黄色、橙色、红色四个预警等级，其中，蓝色、黄色预警时只需要及时清理积雪、注意保暖和防滑即可，橙色预警时就要开始储备物资，而到了红色预警，一般就停工停课了，此时应尽量待在室内，不要外出，必须外出时也要注意原理广告牌、临时搭建物等危险地带，避免砸伤1617。 Q：积雪有多重，真的能压垮房屋吗18？ A：由于含水量的不同，南北方的积雪重量有一定区别，在北方，100 平方米面积上 8-10 毫米的积雪重 100 公斤，而在南方，100 平方米面积上 6-8 毫米积雪就重 100 公斤。通俗的说，100 平方米的平面屋顶如果积雪一尺厚（333毫米），就会承受 3-5 吨的重压。 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:1:6","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"沙尘和雾霾 雾霾天气自不必多说，每年冬天都是大家关心的问题，沙尘天气在今年（2021）也得到了大家的重视，主要是因为年初整个北方的沙尘暴让大家过了一把末日废土风的生活。这两种天气的主要区别是空气中可吸入颗粒物大小的不同，但危害程度并无太大区别，都会对人体呼吸系统产生影响。对这两种灾害，我们可以采取一些相同的预防手段1920： 少开窗，减少有害物质向室内扩散； 少出门和戴口罩，减少有害污染物的吸入； 外出回来后勤洗脸洗手，将附着在皮肤上的雾霾颗粒或沙砾清理干净； 少食辛辣或过热食物，避免破坏呼吸道屏障，多吃蔬菜水果，清肺、补充维生素及增强抵抗力； 有条件的可以养一些绿植或购置空气净化器，净化室内空气。 但这两种天气也有一些区别需要注意 沙尘天气多发于春季，雾霾多发于冬季； 沙尘天气持续时间较短，但烈度较大，伴随大风，所以必要时需要用胶条对门窗进行密封，出门时除了戴好口罩，还需要用纱巾、防风镜等保护头部和眼睛等部位，同时注意高空坠物和交通安全，尽量选择空旷的地方和建筑有防护的内侧行走，远离建筑施工现场、树立了高空作业警示牌或拉起警示线的地方； 雾霾天气持续时间长，但烈度较小，一般没有大风，只要记得戴好口罩即可； 由于大风的影响，沙尘天气除了对自己做好保护外，也要妥善安置易受沙尘暴损坏的室外物品，避免产生高空坠物阻碍交通和伤害他人，注意点包括 外置雨水管道、空调外挂机等是否老化松动； 窗户边沿螺丝、窗扇和窗网边框是否出现松动脱落； 外墙的墙皮是否有脱落； 不要在阳台栏杆边缘摆放花盆，不要在窗户外悬挂杂物 ","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:1:7","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["我所热爱的生活啊"],"content":"2. 物资储备 事先储备相关物资对预防和应对一些灾害具有十分重要的意义，分两种情况考虑： 跑路物资储备，应对必须离开家里或个人受困的情况，一般是一个大双肩包，装有维持至少 3 天左右食物和水以及应付各种情况的物资，生存狂称作 BOB(bug out bag) 家庭物资储备，应对必须待在家里的情况 跑路物资储备 考虑背包空间和个人体力限制，将21中的物品精简为 8 类，参照《北京市居民家庭应急物资储备建议清单》 进行完善，具体如下 个人生存物资：空气、庇护所、水和食物，没有这些东西，人只能生存较短时间 呼吸面罩。保护面部，过滤空气中的有害物质，获得安全可呼吸的空气 帐篷/应急保温毯/睡袋：提供庇护，防止身体失温 水过滤装置，水瓶/水袋：前者用于获取可饮用的水，后者用于取水和存储水 口粮：体积小热量高的可维持至少 3 天的口粮，可以考虑山之厨户外食品，火箭军单兵自热，猪肉蛋卷/午餐肉罐头 衣物： 防割手套：手部保暖防护 帽子：头部保暖防护 防水衣物/雨衣：免受恶劣天气影响 替换衣物：在潮湿环境中用作替换，防止体温过低 取暖和照明： 防风火柴或其它取火工具：火可用于烹饪食物、取暖和发出求救信号，确保即使在潮湿环境下也可以取火 户外荧光棒：坚固耐用、可持续照明长达 12 小时，通常在一英里外可见，电影里常出现的这种荧光棒非常适合发出信号、驱离动物和基本照明。 手电筒：结实而耐用的手电筒，提供充足照明 头灯：如果包里有足够空间，考虑头灯以实现免提照明 急救：包括消炎、包扎和一些辅助工具，储备充足的急救物资在任何情况下都必不可少 碘伏棉棒/酒精棉棒：用于伤口消毒、杀菌 创可贴：止血护创 抗菌软膏：用于伤口抗菌 医用纱布块/纱布卷：用于外伤包扎 医用弹性绷带：外科包扎护理，起到包扎、固定作用 三角绷带：保护伤口，压迫止血，固定骨折等 止血带/压脉带：用于应急止血 医用辅助工具：如剪刀（剪开纱布绷带）、镊子、棉花球（伤口处理）、体温计、医用橡胶口罩（保护手部，用于伤口处理）、医用外科口罩（阻止飞沫病菌感染）和宽胶带（固定纱布）等 止痛药：在受伤时暂时缓解疼痛，必需品包括布洛芬和阿司匹林。 防晒霜：防止严重晒伤。 烧伤凝胶：被烧伤时，这种凝胶可以提供急需的缓解和舒缓皮肤。 处方药：自己正在服用的任何类型的处方药，用作备用。 急救说明：包括 CPR 技巧及其他基本外伤处理所需的步骤。 导航工具：地图和指南针 多用途工具：用于应对各种意外 折叠铲：挖火坑、挖沟、挖避难所、自卫，折叠铲可以用于大多数情况。 多功能组合工具：包含钳子、线剪、小刀、锉刀、十字/平头螺丝刀、开瓶器和登山扣等功能的工具 伞绳：可以用来钓鱼、打猎、串起包、保护住所和制造陷阱等 防水胶带：用于对帐篷、装备、包、背包、衣服进行紧急维修 自卫工具： 刀：一把坚固、可靠的短刀，确保它带有安全护套或刀鞘以防止任何事故。 胡椒喷雾：胡椒喷雾在抵御人或野生动物方面很好用。 杂项 收音机：应急求救 充电器：为各种电子设备供电的充电器，包括智能手机、手电筒和收音机。 护目镜：戴一副结实的护目镜，保护您的眼睛并提高视力清晰度。 哨子：用于发出求救信号或与可能在野外遇到的人保持联系。 小镜子：可以反射光线标记自己所在。 驱蚊剂：驱除蚊虫叮咬 重要文件：身份证、户口本、出生证、结婚证、驾驶证、护照等原件及其副本 产权和合同：房屋产权、保险单、贷款协议等重要产权和合同及其副本 紧急现金：随身携带至少 500 元的紧急现金 家庭成员资料：家庭成员的照片、血型、常见疾病及用药情况、住址，最好附有应急联系部门电话和紧急联系人电话 至于背包本身，应当由厚实耐用的面料制成，要有带衬垫的腰带，要防水、有独立的口袋和隔层，还要有用于扩展的卷顶结构，最后，需要是密闭的。购买以上所有物资时都要选择资质合法、信誉良好的生产经营企业。 另外，要熟练掌握应急物资的正确使用方法，定期对应急物资状况进行检查，并及时更换已过保质期的应急物资。还应当锻炼身体，可以给自己立一个目标，比如可以背着 BOB 跑五公里，要学习各种可以用到的技能，如户外运动、荒野求生、医疗急救、电气、建筑、地理、军事、格斗、缝纫、烹饪…保持对一切事物的好奇心。 家庭物资储备 藿香正气水、风油精等防中暑的药物，应对疫病、沙尘、雾霾的口罩，应对火灾的物品，应对停水停电等特定的物资只需要在家里储备。此外，由于家里空间较大，可以储备更多的食物、水和药物，BOB 中的物资也可以算作家庭物资储备的一部分。 适用灾害 物品名称 功能及用途 高温 藿香正气水，风油精 防中暑 冰袋 降温 沙尘、雾霾 防雾霾口罩 防沙尘雾霾 火灾 防烟呼吸面具 防烟尘、呼吸 水基或泡沫灭火器 灭火 硅胶灭火毯 灭火器用于初期火灾的扑救；灭火毯可用于扑灭油锅火等 应急逃生绳 高层逃生 停电 蜡烛 用于照明 应急灯 用于照明 停水 储水桶 用于储水 上表中涉及火灾的物资储备，但这部分不在本文中介绍，而是在另一篇文章《安全感提升-独居》中介绍。此外，其它额外储备的物资和工具如下 物品类别 物品名称 功能及用途 适用灾害类型 饮用水 矿泉水 用于满足避险期间生存需求 全灾种 食品 压缩干粮、单兵自热食物、巧克力等 用于满足避险期间生存需求 全灾种 洗漱用品 毛巾、牙膏、牙刷 用于个人卫生清洁 全灾种 个人用品 防水鞋，雨衣 用于雨雪期间防水防滑 洪涝、台风、雪灾 消毒液、漂白液等 对物品进行消毒、清洁 全灾种 逃生工具 救生衣 用于在水面漂浮自救 洪灾 手摇收音机 可手摇发电，FM、AM自动搜台 全灾种 反光衣 颜色醒目，便于搜救 全灾种 Check List 迪卡侬背包，30L，249 元。其它可选：Osprey 小鹰，Osprey 彗星，多特 3M HF-52 防尘毒面罩，79元 牧高迪睡袋，1.0kg，69元。其它可选：康尔 KS3121 浅绿睡袋 兵行天下应急保温毯，2.1米*1.6米，100g，10.8元 【可选】骆驼的星空液压帐篷，3.4kg，270元 Sawyer mini Filter 便携净水器附软水袋，198元 水瓶/水袋，50 军粮-火箭军单兵自热，22 元/件。其它可选：军粮-肉罐头(需要开罐器)，军粮-10型巧克力 万马堂防割手套，39元 帽子、防雨雪衣物（如冲锋衣）、雨衣、替换衣物 万马堂多功能打火石+求生口哨，32元 户外荧光棒，12元 防风蜡烛，10元 手电筒，已有 欣达急救医药箱全套，99元，买回来后根据自己需要填补 地图和指南针，已有 SOG 折叠铲，118元 NexTool 纳拓多功能刀，159元 万马堂伞绳手链，鱼骨款军绿迷彩，19元 得力防水胶带，13.9元 【可选】自卫工具，如短刀、斧头、胡椒喷雾，大多网上无法买到，买到也带不出去 手摇多功能收音机，185元 霍尼韦尔护目镜，25元 小镜子，15元 10%beet 避蚊胺驱蚊液，19元 重要文件：身份证、户口本、出生证、结婚证、驾驶证、护照等原件及其副本 产权和合同：房屋产权、保险单、贷款协议等重要产权和合同及其副本 紧急现金：随身携带至少 500 元的紧急现金 家庭成员资料：家庭成员的照片、血型、常见疾病及用药情况、住址，最好附有应急联系部门电话和紧急联系人电话 【高温储备】 降温贴 冰敷袋 藿香正气水，风油精 火灾储备 硅胶防火毯，98 消防防烟防毒面罩，36 小型灭火器 2L，59 高楼逃生绳，167 停水停电 长蜡烛，10只，12.9元 自带龙头的储水桶，10L，52 沙尘雾霾 3M 防雾霾，15只，独立包装，79 总计 1500 ~ 2000 元 中国气象报社，是谁打开了北纬40度的“天气盲盒”？ (zgqxb.com.cn)，2021-07-29 ↩︎ De Bono, A., Peduzzi, P., Kluser, S., \u0026 Giuliani, G. Impacts of summer 2003 heat wave in Europe. United Nations Environment Programme, 2004. Available: http://www.preventionweb.net/files ↩︎ Zhao Q , Guo Y , Ye T , et al. Global, regional, and national burden of mortality associated with non-optimal ambient temperatures from 2000 to 2019: a three-stage modelling study[J]. The Lancet Planetary Health, 2021, 5(7):E415-E425. Available: https://www.sciencedirect.com/science/article/pii/S2542519621000814 ↩︎ 夏天真能“热死人”! 牢记这几点不惧高温轻松度夏 | 中国灾害防御信息网 (zaihaifangyu.cn) ↩︎ 科学研究告诉你：“热死啦”不只是个段子！ - 知乎 (zhihu.com) ↩︎ 中暑的处理和预防 - 知乎 (zhihu.com) ↩︎ 汛期安全明白卡之暴雨 | 中国灾害防御信息网 (zaihaifangyu.cn) ↩︎ 积水区趟水通行，这些要注意！ | 中国灾害防御信息网 (zaihaifangyu.cn) ↩︎ 这份暴雨自救指南请收好 | 中国灾害防御信息网 (zaihaifangyu.cn) ↩︎ 流言标题：地震灾害不容易出现在板块稳定区域 | 中国灾","date":"2021-08-15","objectID":"/2021/sense-of-security-disaster/:2:0","tags":["生活技能"],"title":"安全感建立-灾害","uri":"/2021/sense-of-security-disaster/"},{"categories":["平日里的白日梦"],"content":"事情起源于新华社《经济参考报》8 月 3 日发表的文章《「精神鸦片」竟长成数千亿产业》，点名批评了《王者荣耀》，并以此为例痛批整个网游产业，因为用到了「精神鸦片」「电子毒品」这样的词来形容游戏，引起了强烈反响，但主要舆论偏向反对。在这件事中，我也看到了一些问题。 新华社的用语确实非常不合适，正如心动网络 CEO 黄一孟所说，对游戏行业那些或者为了自己的游戏梦想、亦或者为了提供高质量文娱等目标兢兢业业付出的人们是一种极大的伤害； 游戏行业确实存在问题，国内大部分的游戏企业以盈利为导向，无意或刻意的忽视或淡化负面影响，现有措施不够有力，而社会上沉迷游戏从而荒废学业和工作的情况普遍存在。当然，从这个意义上说，抖音等短视频虽然出现较晚，但带来的影响可能更大； 新华社一竿子打死，反对派的网民也不遑多让，大部分连原文都没看过，只是看到「精神鸦片」这个词就怒而反击，而忽视了官方实际想指出的问题。另外，在这起事件中，部分媒体发表的文章具有情感倾向，有刻意引导舆论的嫌疑，当然，这种事情似乎已经习以为常了； 在网上发声的不一定是事情的核心影响者，这起事件涉及的核心应当是高中及以下年龄段，也就是未成年人，但舆论发声的主体是自制能力较强的成年人，他们在发声的时候也许没有想过未成年人的现状，另外，大学生沉迷游戏荒废学业的事情也比较常见，他们也是网络活动的主体，但显然他们反对的意愿更高。这里突然想到，也许这起事件中更多的是持中立看法的个体，只是这部分人不发声，所以言论被发声的一部分人代表了，「被代表」就很可怕。 总之，在这起事件中可以看到大家的情绪似乎很容易被引导，以及看待事情很容易陷入极端。 在文章发布 5 小时后，腾讯游戏就发布了《腾讯推出游戏未保「双减双打」新措施》，所以最后官媒的文章虽然撤回，但目的似乎已经达到了。 ","date":"2021-08-06","objectID":"/2021/recent-discussions-about-games/:0:0","tags":["杂谈"],"title":"最近关于游戏的讨论","uri":"/2021/recent-discussions-about-games/"},{"categories":["爱编程爱技术的孩子"],"content":"U盘变只读是经常出现的情况，以前都是使用写保护开关，一旦没有开关就毫无办法，今天又遇到这种情况，解决问题后这里总结一下解决办法。 ","date":"2021-08-05","objectID":"/2021/clear-usb-falsh-disk-read-only-status/:0:0","tags":["Win10"],"title":"U盘只读状态清除","uri":"/2021/clear-usb-falsh-disk-read-only-status/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 检查写保护开关 某些情况下，U盘 或 SD 卡侧面或底部有一个可以拨动的开关，即写保护开关，如果发现 U盘变只读，先尝试拨动这里解锁。 ","date":"2021-08-05","objectID":"/2021/clear-usb-falsh-disk-read-only-status/:1:0","tags":["Win10"],"title":"U盘只读状态清除","uri":"/2021/clear-usb-falsh-disk-read-only-status/"},{"categories":["爱编程爱技术的孩子"],"content":"2. Diskpart 命令 虽然傲梅和 DiskGenius 等软件都有解除只读状态的功能，但我从来没有成功过，所以直接介绍使用 Diskpart 解除只读状态的方法。 # 以管理员权限打开 powershell # 进入 diskpart 执行状态 \u003e diskpart # 首先获取计算机中所有磁盘列表 \u003e lisk disk # 根据磁盘大写识别哪个是U盘，查看首列的磁盘编号，选中 \u003e select disk 1 # 清除只读状态 \u003e attr disk clear readonly 有时候U盘无法显示在资源管理器中，但磁盘管理中可以看到，这时候一般是由于其处于脱机状态，同样使用 diskpart 命令可以更改状态为联机，前三条命令相同，最后一条命令为 \u003e online disk ","date":"2021-08-05","objectID":"/2021/clear-usb-falsh-disk-read-only-status/:2:0","tags":["Win10"],"title":"U盘只读状态清除","uri":"/2021/clear-usb-falsh-disk-read-only-status/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第三期月刊。 ","date":"2021-07-31","objectID":"/2021/life-monthly-3/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 3 期 (202107)","uri":"/2021/life-monthly-3/"},{"categories":["日程及周刊"],"content":"生活 07.01-07.04，毕业旅行（山东） 07.05， Notion 物品整理 毕业论文提交到图书馆网站 07.05，07.07，07.13，07.17，07.25 回村里搬砖、拉土、做防水、摘菜 07.07， 图书馆论文审核通过 《原神》璃月主线做完 07.08，使用虚拟机体验 Win11 07.09 老妈尝试做排骨，炸油条 红旗街口买卤菜 《内向者破壁》文章完成 《院神》2.0版本预告直播 07.10，换眼镜框（原来的有点重），晚上散步 07.14，买的豆腐有点酸，以后买的时候记得闻一下 07.16，毕业证和学位证到手 07.17， 从家里回城遇到大雨 MIUI 12.5 升级，手机续航大幅改善 07.12-07.17，毕业旅行文章 07.19，物品整理、电脑及手机资料整理、软件账号整理 07.20，尝试做木须肉，成功 07.21， 自拍杆的评测文章 《原神》2.0 更新 07.26，早 1:30 肚子绞痛，上厕所之后缓解 07.27，寄材料到单位（毕业证、学位证等） ","date":"2021-07-31","objectID":"/2021/life-monthly-3/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 3 期 (202107)","uri":"/2021/life-monthly-3/"},{"categories":["日程及周刊"],"content":"观影 美剧《洛基》E04-E05，第一季完结 电影《黑寡妇》 每个人都在寻求内心的安定，而大部分的行为都是冲动行事 纪录片《世界遗产在中国》，三孔篇和泰山篇 电影《明日之战》 电影《大事件》 电影《特工绍特》 电影《极限特工》三部曲 电影《阳光姐妹淘》，韩版 ","date":"2021-07-31","objectID":"/2021/life-monthly-3/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 3 期 (202107)","uri":"/2021/life-monthly-3/"},{"categories":["日程及周刊"],"content":"阅读 吉姆·洛尔，《精力管理》，第一部分读完 ","date":"2021-07-31","objectID":"/2021/life-monthly-3/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 3 期 (202107)","uri":"/2021/life-monthly-3/"},{"categories":["日程及周刊"],"content":"思考 1、荣誉是护身符，虽然自己不一定利用它做点什么，但放在那里就可以防止别人在背后做手脚 2、咸鱼也要有咸鱼的底气，而不是一无所有的时候就想着咸鱼 3、君择臣，臣也择主，如果不喜欢现在的生活，那就自己去挑选志向一致的人一起共事吧。 ——《原神》稻妻反抗军剧情有感 4、社恐其实是不知道怎么应对这个与从小被教育的不一样的世界 5、理想的社会应提供给人多种选择，单身/结婚，丁克/生育，都应没有后顾之忧，现在显然没有选择，无论哪种都痛苦 6、现在的物质材料是否已极大丰富，只是被人为的控制 ","date":"2021-07-31","objectID":"/2021/life-monthly-3/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 3 期 (202107)","uri":"/2021/life-monthly-3/"},{"categories":["我所热爱的生活啊"],"content":"首先想说，这篇文章不算游记，也不算攻略，大概算一个人的碎碎念吧，只是这次旅行太难得，想给一个纪念。 本科毕业的时候，当时的舍友来了一次毕业旅行，从沈阳开始绕了大半个中国回到重庆，然后激动的和我们分享他的经历，当时我就动了心，但那时候我已经回到家，而且身上也没什么钱，只能就此作罢，不过这个念头却就此种下，再也无法消散。这一次硕士毕业，攒了大概 3000 块钱，在结束了学校的各项事情后，开始我的毕业旅行。 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:0:0","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"旅行策划 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:1:0","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"A. 路线 首先，因为在答辩之后我还有不少工作要了结，拖的时间过久导致身边的同学大部分都离校了，这次旅行只能成为一个人的毕业旅行。 其次，初步设想的路线有两条 河北承德—\u003e内蒙古乌兰察布—\u003e山西大同 山东济南—\u003e山东泰安—\u003e河南洛阳 两条路线中的城市确定都是因为有一些非常想去的景点，第一条路线是承德避暑山庄、乌兰察布的草原火山、大同云冈石窟，第二条路线是济南趵突泉、泰安泰山、洛阳龙门石窟，最后由于爬泰山的吸引力更大一点，所以选择了第二条路线。 最后是查攻略，主要用的软件是马蜂窝。在查攻略的过程中，我发现很多人在济南和泰安的旅行中都会插入曲阜，去看一看孔庙、孔府和孔林，老实说，确实对我有相当大的吸引力，毕竟在学生时代结束的时候去拜一下孔庙，怎么想都是一件很有意义的事情，再加上发现洛阳那边想去的地方有点多，除了龙门石窟外，还有白马寺、少林寺、老君山等等，而且洛阳牡丹的花期也已经过了，于是决定取消洛阳那边的行程，留待以后单独去一次。最终的行程就变成了济南、泰安和曲阜三地，变成了纯粹的山东之旅，到了山东之后发现路边的旅游口号是一山一水一圣人，即泰山、趵突泉和孔子，巧合莫过于此。 城市之后是确定具体的景点，除了我自己最想去的，还要收集一下每个城市其它的特色，来丰富整个旅行。于济南而言，除了老舍先生笔下的趵突泉，我脑子里第一反应便是陈小熊的民谣《济南济南》了，里面提到的千佛山、大明湖、护城河、解放阁，还有穿旗袍的姑娘、说快板的大爷、民国的火车站、户户垂杨的美景，这些都勾起了我的兴趣，听歌的时候我甚至还在幻想这自己听着这首民谣走在芙蓉街的小巷里的情景，这些差不多就是济南的景点了。曲阜除了孔庙、孔府和孔林这三孔外，看到不少攻略中还推荐去一下免费的颜庙，即孔子学生颜回的庙，对于这个「箪食瓢饮」典故的主人公，我确实抱着相当的兴趣。考虑到登山消耗的体力比较大，特意将泰安的行程放在了最后，而且也同样因为这个原因，除了泰山外没有为泰安安排其它的行程，其它如岱庙、地下大裂谷的溶洞都根据实地情况确定。 另外，还有一些其它原因对行程产生的影响。一是由于高铁和绿皮去济南的车费相差悬殊，甚至比我坐绿皮过去然后休息一晚再逛还贵，因此选择了后者，而且绿皮到达时间是下午，过去之后如果有精力还可以到百花洲的芙蓉街和曲水亭街逛逛，然后晚上看一下超然楼的灯光。二是千佛山和其它景点距离比较远，如果要去就要专门为这一个景点增加一天的行程，再加上著名的「佛山赏菊」又不在这个月份，之后也还要登泰山，因此决定不去千佛山了，只从大明湖或解放阁远眺一下。三是从天气预报看接下来几天都是阴雨，没有晴天，因此放弃了大部分攻略中推荐的夜爬泰山，选择白天去爬，这样也能看到更多的沿线风光。同时为了不被火车和住宿限制自己，只订了到济南的车票和相应的旅店，最终制定的行程如下： Day1（济南）：芙蓉街—\u003e曲水亭街—\u003e超然楼（夜景） Day2（济南）：五龙潭—\u003e趵突泉—\u003e泉城广场—\u003e黑虎泉—\u003e解放阁，宽厚里—\u003e大明湖 Day3（曲阜）：孔庙—\u003e孔府—\u003e颜庙—\u003e孔林 Day4（泰安）：岱庙（可选）—\u003e泰山 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:1:1","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"B. 目的 为了避免简单的拍照打卡，我还确认了一下此次旅行的重点，仔细思考了到底自己看了什么、做了什么就会感到满足，即使有其它遗憾和挫折回来也不会后悔。 首先，根据大家的普遍认知，我将景点分为三类：自然风光、历史人文以及混合景点。这一次的目的地种曲阜三孔是典型的历史人文，因此前期的工作要做的多一点，看一下相关的纪录片，查一下各处小景点的资料，回顾一下孔子及其七十二弟子的故事，以及儒家的发展和历代帝王的封赏，这里推荐《世界遗产在中国》系列纪录片，里面有三孔和泰山两处景点的介绍，可以作为简单了解。对曲阜的旅行其实没有太大的期待，更多的是抱着一种朝圣的心态，只要去过、祭拜过就好。同样的，泰山虽然是混合型景点，但此行更多的是重温历代帝王登山之路，只要能登顶就没有遗憾了，沿路的石刻，可以遇到的时候在网上查，另外，迎客松和挑山工可以略微期待一下。 济南的话更偏重自然风光一点，倒不是说济南历史不悠久，而是老舍先生的《趵突泉》一文和「大明湖畔的夏雨荷」这个梗影响太大，因此只要这两者符合预期，即使其它景点有遗憾也没问题。 除了景点外，美食也是很重要的一部分，鲁菜身为八大菜系之一，确实想尝试几道代表性的菜品，不过查到的菜如九转大肠、爆炒腰花这些都接受不了，更何况一个人进鲁菜馆点菜肯定吃不完，所以只好把目标放在各种小吃上，比如油璇、甜沫和把子肉等等，鲁菜只能等到以后有机会再说了。 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:1:2","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"C. 行李 大部分的行李都在离开学校前寄回了家里，旅行用品只保留了一下这些，放在一个小行李箱和双肩包中 衣物：两套换洗的T恤、短裤，一件牛仔衬衫，一件长裤（预防温度下降），一件防晒衣，两双运动鞋； 洗护用品：牙刷套装、洗面奶、面霜、防晒、纸巾； 电子产品：笔记本电脑、手机、充电头和充电线、充电宝、自拍杆、耳机； 其它：钱包、眼镜、各种证件、零食、耳塞和眼罩、雨伞、各种应急药品； 思考了旅行中可能出现的意外，因此准备了备用眼镜、备用手机、应急药物等，还查询了证件丢失时如何处理，好在这些备案都没用到。 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:1:3","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"旅行期间 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:2:0","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"Day1: 济南 06.30 出发，早上的火车，近九个小时的车程，进入山东后在火车上看到外面风雨大作，手机也接连收到雷电、大风、暴雨三条预警，相熟的同学还发来抖音上的视频，视频里济南街头行人迎着大风难以行走。下午五点左右到达济南，下了火车之后发现风停雨歇，只有路边的积水和倒下的树木在诉说着刚刚的情况，有点开心，济南果然欢迎我。 济南火车站给我的感觉其实并不算好，出站口处于地下一层且看起来有点脏乱，上台阶之后本以为是大型广场一眼过去海阔天空，没想到映入视野的是一栋比较破旧的楼，心情瞬间就不舒畅了（不过我是从南边出去的，听说有北广场）。在火车站附近等公交还一直没等到，然而拖着行李箱走到经一路之后一会儿就等到了，也不知道火车站那边的发车间隔是多少。我把旅店订在了大明湖西南门附近的铜元前街，因此乘 B98 路在少年宫站下车后，还没走到旅店就看到了大明湖的外围建筑，有点开心。 在旅店办理完入住，放下行李后就匆匆出门了，要抓紧时间逛一下百花洲社区，晚饭或许可以在芙蓉街解决，不过大明湖西南门附近的三叉路口属实不算友好，用了好半天才绕过去，然后沿大明湖路一路向东，经贡院墙根街拐入了芙蓉街。要说芙蓉街和我想象中的有点区别，其实也不尽然，既然冠以步行街之名，我的心里多少还是有点准备的，但委实不能接受的是，沿线的几个泉水被垃圾盖满，完全打破了我心中的幻想，而臭豆腐和其它食物的气味混杂在一起，耳朵里传来嘈杂的人声，累积之下好悬没有两眼一黑倒过去。之后怀着期待买了一份油璇，结果又干又硬，直接将印象分拉到了底，这时候我就在不断地问自己，我到底来做什么呢，就为了逛这种全国千篇一律的商业街，然后把自己的智商交给周围的商铺来摩擦吗？后来在曲阜才想通这件事，旅行的路上除了这些景点之外，所接触的人和事其实也是相当有趣的一部分，不论是好是坏，总归会在我的生命中留下色彩，我这时候所诞生的这些感触不就是因此而产生的吗，当时忽然想到原神冒险等级的经验单位叫做「阅历」，只有在进行世界探索行为的时候会产生，就感觉这个概念真棒，当你走过、看过、经历过，所有的一切留在了你的记忆力，就成为了阅历，然后你的冒险等级就提升了，这么来想现实生活，会发现多了不少乐趣。 如果说芙蓉街的旅程不太愉快，那么沿着石板小路拐入曲水亭街之后却有了一种柳暗花明又一村的感觉，游人的数量肉眼可见的稀少了下来，周围也开始变得静谧，你的步伐不由自主地就会慢下来。一路上有穿汉服的小姐姐在拍照，有附近的居民在散步，偶然发现的各处泉水也重新变得清澈，恍然间真的有了那种「家家泉水，户户垂杨」的美景再现的感觉，一切祥和又安静。 慢悠悠走完曲水亭街之后，天色已经暗了下来，虽然晚饭没有解决，但我还是决定按原计划去看一下超然楼的夜景。到达超然楼的世界大概在晚上八点，但灯光还没亮起来，旁边的阿姨说很有可能不亮了，考虑了一下起身直接离去，不过沿着大明湖路向西回到旅店的路上，发现路边各种建筑的灯光特别好看，也算是失之东隅，收之桑榆，晚餐没有找到合适的餐馆，在附近的沙县小吃解决的。 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:2:1","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"Day2: 济南 旅店蚊子有点多，晚上没有睡好，早上 5 点就起了，但歪打正着之处在于，这一来反而看到了济南的日出，还是很开心的，而且在附近的早餐店吃到了甜沫，虽然没有家乡那边的疙瘩汤好喝，但已经比昨天的油璇好多了，起码像正常的日常食物。 早饭后开始了当日旅程，这时心情正好，于是徒步沿着铜元前街向南，一路到了五龙潭公园，虽然地图上显示有北门，但其实并不开，只好由周公祠街转到西门，沿路看到有卖把子肉的，心里想着晚上过来吃。五龙潭相比芙蓉街的几个泉水好太多了，不仅清冽还时有鲤鱼游动，我之前看网上的攻略中有说济南这些景点的鲤鱼比较肥，此时发现果然如此，五龙潭的鲤鱼肥硕的身影已初现端倪，随后趵突泉的更甚，拖着巨大的身躯尾巴一摆一摆地游动，实在是让人忍俊不禁。我对五龙潭还有一个很有意思的误解，当初在网上看的时候以为那五条吐水的龙和下面的潭水才是景点本体，结果到了实地才发现五龙潭真的就是一汪潭水，而那五条吐水的龙是后来新修的东门。另外，在五龙潭还看到了五龙壁，想起在故宫时看到的九龙壁，又想起如果此行走的另一条线路，应该会在大同看到另一座九龙壁，端的是人生奇妙，即使走了不同路线，还是看到了相似的景色，而且，不知道哪里有七龙壁，非常想去看一眼。 从五龙潭东门出来后一路向南，很快就到了趵突泉。由于天色尚早，天气微凉，游人比较少，能够充分享受一段安静的时光。首先到达的是五三惨案纪念堂，堂前牌楼处有一座憨态可掬的石雕，非常喜欢，走进去之后发现堂内外非常干净整洁，可以看到工作人员确实非常用心，祭拜之后离去。随后陆续在泉水自然地质展览馆中了解了济南泉水的成因，在泺苑看到了不少小孩子在嬉水，给家里人买了两件纪念品，又在李清照纪念堂跟着讲解回顾了一下这个女词人的一生，出来后便到了此行的重点，趵突泉。老舍《趵突泉》原文描述趵突泉”有三个大泉眼，水从泉眼里往上涌，冒出水面半米来高，像煮沸了似的，不断地翻滚“，这一景色被称之为「趵突腾空」，很可惜并没看到，好像很多年都没有这样的景象出现了，不过三个泉眼咕嘟咕嘟地往往冒水，少了壮丽的同时却多了一分娇俏可爱，一样让人喜爱，而且趵突泉的水真的是让我第一次见识到了什么是「像一块温润的碧玉」，景色让人心醉。和旁边独自来玩的小姐姐互相拍了个照片后，恋恋不舍地离开了那里。 趵突泉往南过观澜桥，遇到了另外两个令我印象深刻的泉水，杜康泉和花墙子泉。前者的印象深刻之处在于其名字和山石环抱的格局，后者则主要是由于繁华簇拥的美丽景色，真的是只要你看一眼就明白泉水的命名确实有其道理。花墙子泉的前面有几个泉水直饮点，我试了一下，发现果然甘甜，后来在黑虎泉附近遇到了给市民开放的接泉水的地方，看到络绎不绝的拿水桶接泉水的市民，感叹果然有水就是任性。继续向南到了万竹园，里面的诸多泉水已经不再流淌，有的成为了一潭死水，有的则干脆干涸，但以环境而言，万竹园确实清幽，它最令我惊奇之处在于随处可见的竹林，之前我一直都以为只有南方，甚至只有四川才有这么多竹子。 从趵突泉东门而出，对面就是泉城广场，虽然不明白为什么这个看起来平平无奇的泉标会成为济南地标，但不妨碍我拍个照。本想从这里看一眼千佛山，发现看不到，只好买了一块山楂糕，骑上共享单车向解放阁而行，这一路的护城河终于不再是铜元前街那边小水沟的感觉，但感叹于此的同时却忘记了在黑虎泉停下来，直接就到了解放阁。解放阁本身没有什么惊喜，但我在解放阁第一次远眺到了千佛山，而且看到和听到了陈小熊民谣里提到的说快板的大爷，当天正好是七月一日，解放阁东南方向的一个亭子里传来歌颂党和祖国的快板声，很是有趣，快板声使得平日里让人烦躁的喧嚣人声也变得可以接受起来，甚至反而为这一幕增添了一抹色彩。 解放阁对面就是宽厚里，这里和芙蓉街的气氛非常相似，卖的各种食物基本也一模一样，实在是提不起什么兴趣，而且宽厚里的故事和六尺巷的故事太像了，也不知道是巧合还是刻意。于是简单歇了歇脚，提了一杯水果茶向着被我遗忘的黑虎泉走去，由于略有疲惫，这一次没再想着看一看沿线的其它泉水，而是直奔黑虎泉而去，寻找的过程中偶然发现了市民接水的地方，在那里又歇了一会儿。从接水处下去后很快就到了黑虎泉，黑虎泉的景色和趵突泉又有不同，是一种气势磅礴之景，泉水从三个虎头奔涌而出，途径一道阶梯泄入下方的护城河内，听身边带孩子的大叔说他小时候石壁后的洞穴还是可入的，但现在已经封闭，有一点遗憾。 午饭在宽厚里解决的预定计划再次作废，于是打算在附近的世贸广场找一家鲁菜馆，结果找来找去，脚步却停在一家日料店门前，最终吃了一份寿喜锅，不过这是一次不成功的尝试，我发现自己不喜欢寿喜锅。吃完午饭大概一点左右，直接去大明湖感觉自己可能有点撑不住，从地图发现离旅店不算远，于是骑着共享单车回去休息了两个小时，到下午三点左右才重新出发前往大明湖。 大明湖的游览自西南门始，走了没多久发现一处游船码头，于是乘船先到湖心的历下亭参观，值得一提的是，这里的船票 25 元，但如果我肯多走一段距离，北面有个码头只需要 10 元，而且可以送到对岸，这让我后悔不已，也令我得到了第一个旅行教训。游船返回起点后前行直到小沧浪亭，在附近给我老爸买了一罐雨荷茶，然后买了一份荷叶糯米鸡边走边吃，吃完的感受就是，在景区买吃的完全就是自找苦吃。继续前行到北极阁，北极阁没有人，而且门外好像标识了不允许入内和拍照，说来有趣的是，我去过的地方，佛寺总是人声鼎沸，道观则一般都冷冷清清，甚至直接不允许游人入内，不知是不是理念问题。北极阁附近有两个有意思的地方，一是前面台阶中间有不少小孩子在玩滑梯，那石头被磨的发亮，也不知道多久才成了这般模样，二是东边有个感应井泉，购买铁皮投掷中间的铜钟可以令泉水喷起，我去的时候正巧有几个相伴的学生在投掷，可惜十投九空，旁边围观的人群不住叹息，结果就在此时卖铁皮的大爷走过去，每投必中，惊叹声四起，称不得扫地僧，大概是卖油翁吧。 旅行教训：需要付钱的地方，一定要多看几家，如果怕错过，至少要在第二家再付钱 北极阁向东陆续到雨荷厅和汇波楼，而汇波楼对面前往超然楼的一段堤岸简直是观景的绝佳地点，不仅有垂柳依依、荷风阵阵、碧波澹澹，湖对面还有亭台楼榭点缀、千佛山若隐若现，真是好一副风景画，再往前两步在桥上还可以看到超然楼挑露的檐角，确实是很大的惊喜。 正式到达超然楼的时间是 4:30 左右，门口的小姐姐提醒我超然楼 5 点停止售票，5:30 之前需要出来，而且超然楼不像趵突泉，研究生证不可以用，只能买全票，但我犹豫了半天还是选择买票进去，只要能从超然楼顶俯瞰一次济南城，此行就算功德圆满了。进楼之后乘电梯直奔顶楼，在顶楼的三面分别看到了济南城、千佛山和大明湖的全景，还看到一帮大叔阿姨拿着长枪短炮在等待拍摄的好时机。留恋了有一会儿，开始自顶楼逐层向下参观，各层有石雕、木雕、书画等，作品虽不多，但非常精致，是的，连我都能看出的高超的雕刻水平，不过缺点就是楼内灯光极为昏暗，不少书画细节看不清楚，而且我去的时候一个人都没有，寂静的大厅配合昏暗的灯光，心里还是有点毛毛的。等到参观完的时候大概 5:25，时间刚刚好，开心地提起背包回旅店去喽。哦，对了，不知在哪层的楼梯口看到一幅字 ，内容非常有趣，令人哑然失笑，因此专门拍了照片如下，晚餐也吃到了把子肉，开森。 考虑到曲阜的行程比较宽松，因此在济南又休息了一晚，打算7月2日早上从济南出发去曲阜，下午游览结束之后直接到泰安。 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:2:2","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"Day3: 曲阜 再一次早起，为了赶一班从济南站出发的高铁（G343），到达曲阜东的时间是 8 点左右。本来看到修的大气又干净的火车站本来很开心，没想到和济南先抑后扬相反，这波出门就遭遇了滑铁卢。本打算在出站口南边的游客中心买票直接坐车过去，没想到不开门，于是在旁边的高铁超市寄存了一下行李，一个小行李箱收费 20 元，出来后到对面的汽车站坐 K01 路公交，结果在汽车站发现那边寄存行李只需要 10 元，有点气。K01 路在孔庙南门下车，但下车点离景点入口还有一段距离，正要看地图，被一个骑电动三轮拉客的老头缠住了，使劲忽悠我游览要从孔林开始，那里才能买到票，坐他的车到孔林然后回来只收 60 元，虽然我知道孔府和和孔林之间还有很大一段距离（在攻略上看到过这个），但还是持怀疑态度的，毕竟孔庙这里没有卖票的有点说不通，而且他这确实收费有点贵，遂果断拒绝，不过拒绝的时候随口问了下路，然而这老头给我指了一条远路，本来在公交站点下车向西走一小段就可以顺着大路拐进去，然后根据他的指向我往东走了一大段才找了个路口拐进去，最终绕了一大圈才走到孔庙的售票点，由此得到了第二个旅行教训。 旅行教训：人言不可尽信，凡事多留个心眼 孔庙的门前果然有三孔联票在售，更气了。景区门口一大堆提供讲解服务的导游，不过由于之前已经查过资料，我直接拒绝了，进去之后果然没有像其它景点那样扫码可得的语音讲解，于是我自己在网上搜到了语音讲解戴了耳机来听。孔庙的整体氛围确实是我想象的那种，古树成荫、建筑森严，石碑林立，只是导游有点多，声音有点吵，很快到达大成殿，祭拜后原路返回由东门而出。东门和孔府之间有大量的小商贩，心里想着给明年高考的弟弟挑个礼物，然后找了个刻印章的摊子，老板很和气，我挑了一个 30 元的石料，老板说刻字 8 元，我没多想，但刻完以后收款时老板说每字 8 元，气炸了，不过念着自己一个人在外，不想起冲突，只好付了钱走人，但确实很不开心，所以这里得到了第三个教训。 旅行教训：若非必要绝对不要在景区买纪念品 如果说孔庙红墙黄瓦，祭祀气息更浓，到了孔府就基本看不到黄色了，转而是灰墙灰瓦和各种黑色的柱子和大门，多了一点生活气息。孔府的建筑结构比较复杂（直接让我迷路了），其中令我印象最深刻的是后花园，因为这是我第一次真正见识到传说中的后花园是什么样的。从后花园直接出去，沿着小巷到达主干街道，一路向东过一个路口可以到达颜庙。颜庙虽然免费，游人却不多，建筑面积相对也小不少，而且颜庙和孔庙一样没有后门，需要原路返回。在颜庙的门口又遇到一个骑电动三轮的大爷，此时警惕心更重，打算直接离去，但这个大爷把价格降到了 5 块，而且我确实有点累了，于是上了车，随后发现颜庙到孔林这一段路确实有点远，因此这一次我付钱就相当爽快。从万古长春坊的牌楼下车，走了有一段距离才到孔林的门口，由于孔林比较大，需要观光车代步（100元），考虑到一路的不愉快经历，不打算付这笔钱，于是徒步前行，只去了孔子墓祭拜就直接离开。 出孔林后又被一个骑电动三轮的老头盯上了，这时候已经中午十二点了，我说我要吃饭，结果这老头忽悠我周围的饭店不接待散客，我都直接找了路边的饭店进去点完菜了，这老头竟然还跟了进去一直问吃完饭要不要坐车，我当时就在想我是不是真的长了一副好欺负的脸。简单吃了碗面离开，步行返回到万古长春坊附近，坐公交返回孔庙南门，等公交等了好久，等的时候心里还不无恶意的想，是不是故意这样给那些骑三轮的老头拉客的机会。自孔庙南门换乘来时的 K01 路返回曲阜东站，然后取了行李匆匆离开，由于在返程的公交上才买票，而且二等座已经没了，只好买了一个一等座。总之，在曲阜的旅行相当不开心。 到达泰安的时间是下午 3 点多，泰安站在指引方面做的就比较好，沿着指示牌找到了对应的公交，直接到了岱庙附近，由于这一天身心疲惫，办理了入住之后再也不想动弹，去岱庙的行程被我直接放弃，晚饭的时候出去购置一些第二天登山的补给。泰安的旅店环境没有济南好，但好在没有蚊子，睡得比较舒服。 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:2:3","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"Day4: 泰安 这一天早上大约 7:30 就到达了泰山脚下的红门游客中心，本想买一张实体票，但旁边一个干净利落的小姐姐在询问售票员的时候被强势的拒绝了，让在旁边扫码从网上买，一方面为这个小姐姐的气质和弱弱的语气的反差哭笑不得，一方面又感谢她帮我探了路，不需要自己再去和售票员交谈，接下来的登山之旅就跟在小姐姐身后开始了。另外，在开始正式登山之旅前买了一支登山杖，这支登山杖在后续的登山过程中起了大作用。 从一天门起很快到达红门，经过红门后又很快到了万仙楼的验票处，因为有点担心储备的水不够多，在这里买了瓶矿泉水，不过需要提醒的是，这里的矿泉水最便宜的 3 元，然而如果继续向前走，斗母宫前的矿泉水却保持在 2 元。开始的这一段一路青松翠柏，偶有溪流潺潺，有一种踏青的感觉，历经三官庙、经石峪、柏洞、元君殿、回马岭，大约在 9:30 到达了中天门。路上本想找小姐姐同行，但一直没有勇气开口，而且小姐姐走的太慢，到经石峪附近的时候已经彻底看不到她的身影了，于是作罢。顺便一提，三官殿的风铃特别好听，经石峪在一条岔路上，标注 300 米但是走起来感觉更远，而且需要原路返回。 红门到中天门这一段路上，各种石刻层出不穷，大多是不同时期的中国知识阶层面对泰山发出的感概，赞叹泰山美景，有些词句看到的时候真的感同身受。到中天门已经有点累了，这时候消耗完了第一瓶水，然后买了根老冰棍解馋（店家可能会开口 5 元，但实际上是 3 元）。其实我本来以为中天门的牌楼所在就是中天门，还在想为什么这里这么小，那些从天外村坐车上来的人都哪儿了，没想到下了台阶之后才看到大部队，在这里看中了一个挂着铃铛的泰山石敢当小人，但一想之后还要爬山，以及吸取了之前几次教训，决定沿线多看几家，下山的时候再买。 在中天门休息好了之后，开始朝南天门进发，本来以为马上就是十八盘，没想到走了很久，但这一路有不少有意思的地方，从起始的「迎天」牌楼，到不远处的斩云剑奇石，然后是斑驳的光线照耀在「天空」巨石上，以及民国二十六年中国旅行社的石刻广告，五大夫松以及附近的飞来石，著名的迎客松，还有大名鼎鼎的挑山工。想到自己轻装爬山都这么累，挑山工要担着那么多东西来爬，而且我跟了好久都没停过，感觉他们太辛苦了。 大概在 10:50 到达对松亭，前面就是最艰难的十八盘，十八盘一共1600多级台阶，有「紧十八，慢十八，不紧不慢又十八」的说法，而且往上看那宛如登天之梯的十八盘时，心里是有点发怵的，不过当你真的走上这条路，眼里和心里除了眼前的台阶就什么都没有了。在 11:05 左右走完慢十八到达了龙门，11:30 走完不紧不慢的十八到达升仙坊，这时候已经相当累了，于是补充了一瓶红牛，休息了一下恢复了一点体力，结果向上爬的时候还是特别累，我几乎是数着台阶走的，每 100 个台阶就休息一下，大概在 11:45 到了南天门。 穿过南天门就到了天街，这时候真的有一种登天的感觉，从这里不管是向上看天空还是向下俯瞰泰安，景色都非常美。在这里稍作休息，欣赏够了美景之后，发起了向玉皇顶的冲刺，途中看到的碧霞祠是我看到的第一个游人很多的道观。碧霞祠后是摩崖石刻，再然后是著名的五岳独尊石，附近的人太多，只能在旁边的台阶上远远地拍了个照，随后就就到了玉皇顶，此时时间在 12:40，因此算下来从红门游客中心那里出发到玉皇顶累计花了 5 个小时左右，还是蛮久的。 玉皇顶不是单纯的一个山峰，而是有一座庙，庙里立碑标注了泰山极顶，在这里俯瞰实际上景色没有天街那边好，不过望向拱北石那边可以看到碧蓝天空掩映下的天文台，尤为出彩。玉皇顶出来以后在门口发现一块无字碑，相当感兴趣，因为立马就想到了武则天那座碑，不过这一座相传为汉武帝所立。随后陆续前往了日观峰、拱北石和瞻鲁台，然后从瞻鲁台直接返回天街。 返回天街后没有停留，按照原计划乘缆车下山，据说节假日缆车要排好几个小时的队，不过这个时候游人并不多，一路没有遇到阻碍，很快就下山了。缆车到达中天门后花了 10 块买下了看好的那个纪念品，本想坐车到天外村，但手里的登山杖如果还回去还能换瓶水，而且红门到中天门一路登山的时候遇到几家便宜的饭馆想试试，遂继续步行下山。下山途中在元君殿附近吃了一份小米煎饼，随后试了 15 块的炒饭，发现果然便宜是有便宜的道理的，这里的炒饭就是简单的葱花鸡蛋，而且量比较少，不过即使如此，也比中天门动辄几十的饭菜好多了。下山途中耗费的水要比上山还多，大概 15:40 返回到红门，下山确实比上山快了很多，而且下山后没有去岱庙，直接返回了旅店，躺在床上休息了好久。 由于身体疲惫，不想连夜赶火车，于是续订了一晚旅店，第二天早起打车赶往泰安站（公交没开），从泰安到济南西，又从济南西到太原南，复从太原南回家，倒车 3 次，第一次用了站内换乘。 旅程结束。 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:2:4","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["我所热爱的生活啊"],"content":"旅行总结 从 06.30 到达济南开始，到 07.03 泰山游览结束，四天时间跨越 3 个城市，游览了 14 个景点，累计行走近 55 公里，其中最后一天在泰山就走了 21 公里。 如果算上起始与返程的车票，一共花费 1666.66 元，因为把游船、索道的费用都算到了门票了，所以下图看起来交通和门票占主要部分。 这次旅行算是了了一个心愿吧，除此之外还熟悉了从策划到完成一次旅行的所有流程，也收获了从学校走向社会的几个感悟，更有趣的是，回到家之后通过一张张的照片来回忆这次旅途，从纪录片里回顾一个个用脚步丈量过的景点，有一种奇妙的感觉。那么，旅行的意义到底是什么呢，也许就是这一份化为珍贵记忆的经历以及途中产生的各种感悟吧。 ","date":"2021-07-19","objectID":"/2021/shandong-one-mountain-one-water-one-saint/:3:0","tags":["旅行记录"],"title":"济南、曲阜及泰安（毕业旅行）","uri":"/2021/shandong-one-mountain-one-water-one-saint/"},{"categories":["Golang学习之路"],"content":"学习 Go 时收藏的一些网址，做一下收录，作为结尾。 Go文档-国内 (go-zh.org) Go文档-国外 (golang.org) Go语言爱好者周刊(studygolang.com) Go语言中文网 论坛(studygolang.com) Go语言标准库文档中文版(studygolang.com) 书籍: the-way-to-go_ZH_CN 博客: TY·Loafer的Go学习记录 (tyloafer.github.io) Go语言入门教程（非常详细） (biancheng.net) Go项目列表 (awesome-go.com) LeetCode Go实现(halfrost.com) Go语言学习之路第10天(Go并发编程) - 真的白给 - 博客园 (cnblogs.com) Go 语言调度器与 Goroutine 实现原理 | Go 语言设计与实现 (draveness.me) ","date":"2021-07-05","objectID":"/2021/golang-learning-materials/:0:0","tags":["Go语法"],"title":"Golang学习资料","uri":"/2021/golang-learning-materials/"},{"categories":["研究生的区块链学习之路"],"content":"区块链方向一些网址收藏，作为结尾。 Quorum文档 (goquorum.com) Dapp排行 (stateofthedapps.com) 登链社区 - 区块链技术爱好者都在这里 (learnblockchain.cn) 加密货币排名网站 | CoinMarketCap 各种区块链实时及历史信息(bitinfocharts.com) ","date":"2021-07-05","objectID":"/2021/blockchain-url-collection/:0:0","tags":["区块链"],"title":"区块链网址收藏","uri":"/2021/blockchain-url-collection/"},{"categories":["日程及周刊"],"content":"本月刊的目的是记录生活，发现生活中的美好，当前为第二期月刊。 ","date":"2021-06-30","objectID":"/2021/life-monthly-2/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 2 期 (202106)","uri":"/2021/life-monthly-2/"},{"categories":["日程及周刊"],"content":"时讯 1、金钱豹外逃事件-新华网 05.10 【社会热议】5月10日杭州新闻发布会称，早在4月19日上午，由于杭州野生动物世界的饲养人员在交接班时没有严格按照操作流程，三只金钱豹已经逃逸。不过最令人瞠目结舌的是，猛兽出逃前后22天，杭州野生动物世界既没有上报，也没有对外公布，存在严重的瞒报行为。 事件经过：2021年4月19日，杭州野生动物世界3只金钱豹脱逃，2岁半，一公两母。5月7日20时许，群众报警称杭州野生动物世界发生3只未成年金钱豹外逃事件，已捕获追回一只。针对这一情况，富阳区迅速采取行动 。8日17时许，杭州野生动物世界第二只外逃豹子被找到。这只金钱豹在杭州市富阳区银湖街道金苑山庄旁边山林被发现，被成功麻醉后捕获。5月9日凌晨，第三只也就是最后一只在逃的金钱豹被发现了踪迹，但目前还没有抓到。5月10日，杭州市公安局富阳区分局对杭州野生动物世界相关人员因“金钱豹外逃事件”涉嫌犯罪立案调查。 ","date":"2021-06-30","objectID":"/2021/life-monthly-2/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 2 期 (202106)","uri":"/2021/life-monthly-2/"},{"categories":["日程及周刊"],"content":"生活 06.02，打疫苗第二针 06.02，写笔袋的新玩意文章 06.03，旧键盘彻底坏了，买新键盘（高斯87G） 06.03，六餐番茄鱼丸米线过于酸甜，估计是番茄酱放多了 06.05，回复博客仓库的 issue 06.06，尝试使用楼下的洗鞋机，但效果并不好，Keep的黑色运动裤也起球了，也许不应该用洗衣机，而是应该手洗 06.08，购买T恤，纯白，淘宝马登工装 06.01-06.09，答辩材料准备 06.09，毕业答辩 说话时字与字不要相连，听起来永远都是一个音调，吐字要清晰 PPT中可以用红色标识重点内容，但不要过多 06.09-06.10，提交各种毕业材料，进行团关系转接 06.11，班级拍毕业照，让摄影师给宿舍和自己个人都拍了一下 06.13 早 5.30 起床洗漱赶 7:00 前往沈阳的火车 中午 11:00 到沈阳，坐 244 到东大南门 和世杰去太原街吃焖锅（世杰请的客） 下午1点左右返回南湖，智慧东大扫码从西门进校，和徐浩然他们会合 下午逛南湖，拍照，包括 258、九舍、汉卿、图书馆、大成、129花园 晚 5:00 打车前往奥体万达吃韩盛（世杰有事回浑南了） 晚 7:00 打车回浑南，在信息楼一楼唠嗑到 10:00 晚 10:00 和老王他们回到尚盈丽景租的房子 06.14 上午逛浑南，拍照 中午所有在的人（大概10个）在食堂二楼聚餐 下午 1:00 轻轨转地铁到沈阳北候车 晚 8:30 返回到宿舍 06.15，学院拍毕业照，发了三个校园里摘的杏 06.15，寄了一部分行李回家 06.15，毕业登记表填写及找老师签字 06.15，在老王他们的推荐下开始玩原神 06.16，卖掉了瑜伽垫 06.17，毕业晚会，很一般，没有惊喜，可能是研究生院人太少，出不了太多节目的原因 06.18，论文胶装 06.18，注销猎聘账号 06.18，和宿舍、栋哥、凯少在万达的比亚森烤肉自助聚餐，味道并不好 06.18，领毕业礼物及发放，是一堆徽章 06.19，宿舍在黑土地聚餐，菜还可以，量比较大，没吃完 06.20，卖掉了加湿器 06.25号，毕业证和学位证的壳发完了 06.01-06.26，英文论文 9号前，投入精力较少 15号之后投入全部精力 26日所有工作基本结束 06.26，和郭老师最后一次通话，和陈老师告别，向魏紫岩学弟交代相关材料，又一件毕业前重要的事结束了 06.30，开启毕业旅行 ","date":"2021-06-30","objectID":"/2021/life-monthly-2/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 2 期 (202106)","uri":"/2021/life-monthly-2/"},{"categories":["日程及周刊"],"content":"观影 纪录片《完美星球》E03-E05 海鬣蜥超像怪兽，听说是哥斯拉原型 摄影师果然是高危职业 电影《复仇者联盟2》 综艺《向往的生活第五季》 电影《夺宝奇兵》 B站视频，罗翔，《你眼中的世界》 B站视频，当下频道，《你每天刷了多少信息》 B站视频，Roomtour，《独居女孩的63平小户型》 电影《你眼中的世界》 美剧，《洛基》S1E01-E03 电影《哥斯拉大战金刚》 电影《瞒天计划》 电影《心花路放》 ","date":"2021-06-30","objectID":"/2021/life-monthly-2/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 2 期 (202106)","uri":"/2021/life-monthly-2/"},{"categories":["日程及周刊"],"content":"阅读 魏茹冰、曹昕玥，《从前有幅画》，介绍历史上一些名画，写的幽默风趣，对国画鉴赏可能有一些作用 ","date":"2021-06-30","objectID":"/2021/life-monthly-2/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 2 期 (202106)","uri":"/2021/life-monthly-2/"},{"categories":["日程及周刊"],"content":"思考 1、白云是怎么变成黑云的（有趣的知识） 2、子弹笔记改进，增加单独的页面，标记每天是否早起、是否吃早饭、洗漱是在早饭前还是早饭后、是否健身 3、每个人的知识基础不同，因此应该学会解释，而不是说“你怎么这都不懂”，每个人都是从不懂得时候过来的，虽然现在某些知识可能内化，但不意味着我们生而知之 4、或许社会发展的目的是让所有勤恳工作的人都能得到基本的生活与安全保障，现在可能还做不到 ","date":"2021-06-30","objectID":"/2021/life-monthly-2/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 2 期 (202106)","uri":"/2021/life-monthly-2/"},{"categories":["日程及周刊"],"content":"收藏 软件，3Dbody，可以看人体结构，从皮肤到骨骼一层层去掉 ","date":"2021-06-30","objectID":"/2021/life-monthly-2/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 2 期 (202106)","uri":"/2021/life-monthly-2/"},{"categories":["我所热爱的生活啊"],"content":"🛒 入手渠道：京东 💰 参考价格：50.81 元 接下来要一个人进行毕业旅行，以前都是只拍风景不拍人，但现在想想在开心的时候自拍一个还是挺有纪念意义的，为了让自己和风景都能入镜，决定买一个自拍杆。 经过挑选在京东买了小米的自拍杆，原价 69.9，杂七杂八的优惠减下来到了 50.81，主要有三个优点 整体外观比较小巧精致，重量在 156g，大概不到一个手机的重量； 下侧的手柄可以拉开，使其呈三脚架式放在平稳桌面上，视频通话的时候比较有用； 蓝牙连接的速度和稳定性，这一方面在随后的旅行中进行了实际体验，整体在可接受范围内，而且分离式的蓝牙遥控器镶嵌在手柄上一个皮垫里，握持的时候大拇指可以很轻松的按到。 这个商品整体比较符合心意，还是比较喜欢的，不过有一个缺点，就是蓝牙遥控器充电使用的是 Micro-USB 接口，而不是 Type-C，对于我好不容易统一起来的接口是一个阻碍，又要多备一根线。 ","date":"2021-06-18","objectID":"/2021/mi-selfie-stick/:0:0","tags":["好物评测"],"title":"小米支架式自拍杆","uri":"/2021/mi-selfie-stick/"},{"categories":["我所热爱的生活啊"],"content":"🛒 入手渠道：京东 💰 参考价格：380元 屋漏偏逢连夜雨，自前两天塑胶笔盒坏掉换了新笔袋后，第二天用了五年的键盘也坏了，可能是刷新键出了问题，桌面上的图标总是在不断闪烁，浏览器也打字打半天突然清空，买个新键盘迫在眉睫。 旧键盘是 2016 年花了 49 块买的航世的键鼠套装，其实用着也还行，但现在就是特别想用一把机械键盘，所以朝这个方向考虑，由于之前也用过一把雷柏的黑轴，有一些使用上的痛点，所以这里先总结一下需求： 87键。104/108 键有点太大了，太占桌面空间，而且之前的使用过程中从来没有需要小键盘的时候，83 键则是因为它的 Enter 键、右 Shift 键和退格键都不在最右侧，觉得可能需要适应，所以就决定选 87 键，毕竟之前的键盘都用的是 87 键的，比较熟悉键位。 茶轴。买上一把机械键盘的时候在玩《上古卷轴5》，于是选了黑轴，结果后来吃够了黑轴的苦。主要是因为后来玩游戏的时候不是很多，反而是开始鼓捣个人博客后码字频率大幅上升，黑轴那种总也按不到底的手感简直让人抓狂，再加上体验了一下舍友的青轴，当时就决定下一把键盘绝对不能买黑轴了。这一次则想着我不能从一个极端跑另一个极端吧，万一又出什么问题，比如现在的舍友受不了青轴的声音啊，或者我自己受不了青轴的声音啊，等等，所以打算选中规中矩的茶轴。 2.4G/有线双模。我是绝对的无线党，之前之所以放着黑轴不用还有一个原因就是拖着长长的线有点烦，所以一直在用无线的薄膜键盘，这一次挑键盘果断将条件设置为无线，而且我内心对蓝牙的稳定性是怀疑的，所以比较偏向 2.4G。当然，同样是 2.4G 的情况下，还是偏向和有线双模，毕竟，万一那天接收器丢了呢。 背光。关于背光的问题也是深受其苦，当时不懂事，为了省钱买了无背光，结果晚上用的眼瞎，全靠键位记忆打字，于是下定决心下一次买键盘的时候一定要有背光。但从去年开始关注用眼健康问题后，发现暗光环境下用电脑本身就是我自己的问题，我完全可以用键盘的时候开着房间灯，这样的话有没有背光其实无所谓，而且，马上也要毕业了，我晚上开灯也不会打扰到舍友，所以这一次有条件选背光，如果实在没办法，无背光也可以接受。 键帽材质。旧键盘用了五年，那个键帽简直不忍直视，字母磨掉了其实都不算大问题，主要是远远望过去就一片油光发亮，有时候打字的时候都不忍心下手，所以打算挑 PBT 热升华或者侧刻。 最后主要是在京造 K8、ikbc w200、高斯 87G/87D 之间选择，杜伽的无线有点贵，没有纳入考虑。京造 K8 和高斯 87D 是蓝牙双模，虽然高斯的蓝牙风评还可以，但心里还是有点不舒服，ikbc w200 有 2.4G 版本，不过它是深色调（京造 K8也是），而我个人比较喜欢浅色调的键盘，所以相比之下还是高斯 87G 更符合审美，而且为了不显得单调，我专门选了靛金石版而没有选白色，真的超好看。至于背光，前面已经说了，无背光还在我的承受范围内，更何况，键盘参数里还注明了可以 DIY 加灯，所以更没问题了。 优惠券东凑西凑最后把价格降到了 380，但等了整整四天键盘才到，快递有点慢，不知道是不是 618 的原因。包装非常严实，气泡纸裹了厚厚的一层，用小刀才割开，里面的键盘应该没有受到损伤，键盘盒的正反面如下图所示。键盘盒内部示意图如下，有Type-C 的线、拔键器、使用说明书和防尘罩，默认送了两节电池在右上角的格子里，接收器则在左上角的格子里（不在键盘里，要注意）。 键盘本体上手比较重，其实在拿到快递的时候就发现这一点了，但我当时以为有一部分盒子的重量，因为买的时候我看到键盘重量是 1080g，拆开后发现键盘本身就比较重，看起来我对 1 千克有多重的估计有误。 键盘的外观相当惊艳，确实长在了我的审美上，PBT 键帽的磨砂手感也比较喜欢，至于茶轴的声音和敲击感，我只能说在意料之内，总归不用换了。背部的脚撑有防滑皮垫包裹，挺不错的，另外，买之前在评论区看到有人说电池仓盖子不太稳固，一震就掉，经测试没有这个问题，相当稳固，接下来的工作就是测试续航了，说明书里称不用的时候键盘会自动休眠，所以这方面想期待一下。 2021.07.06日补充。入手第二天发现按键问题，一些按键会偶尔失灵，和客服联系后客服让再用一下试试，因为不想麻烦，用了将近两周，但问题越来越严重，再次和客服联系，这次给了新的固件，刷完固件没有改善，开始寄回，本来想退，但估计只能换新（不清楚15天是以下单时间算还是签收时间算），结果回来之后换新都没有，还是我原来的，而且比较脏，让我怀疑甚至都不是我自己的了，目前使用两天，问题没有复发，但还是希望给看到这篇文章的人一个参考，也许是个例，但从此对高斯真的没有好感了。另外注意，客服估计啥都不懂，技术问题不要对其抱希望。 2021.07.21日补充。到现在为止问题没有复发，使用良好。 2021.08.14日补充。比较费电，一个月换了 2-3 次电池，不用的时候最好关掉无线开关。 ","date":"2021-06-06","objectID":"/2021/gauss-87g-dual-mode-mechanical-keyboard/:0:0","tags":["好物评测"],"title":"高斯87G双模机械键盘","uri":"/2021/gauss-87g-dual-mode-mechanical-keyboard/"},{"categories":["我所热爱的生活啊"],"content":"🛒 入手渠道：京东 💰 参考价格：5.5 元 用了3年的PP塑胶笔盒扣不住了，决定换一个新的，考虑到继续用笔盒可能出现同样的问题，于是想到了笔袋，毕竟这个笔盒的前辈，我的老伙计，一个黑黄双色的笔袋，可是服役了两倍的时间。精挑细选之下，我在京东买了一个晨光的灰色透明网纱笔袋，原价 5.5 元，会员价 5 元，618活动这两天零零散散领了一些红包，最后实付竟然到了 3.24 元，多攒两天红包应该还能便宜一点，不过要注意，非会员的话还需要加上 6 元运费，这样就就到了 10 块左右，可以和其它物品一起买。 买的时候看中了这个笔袋两点。一是长度够长，之前的笔盒甚至放不下一只稍微长一点的铅笔，就特别苦恼，所以挑笔袋的时候特别注意了这一点，这个新笔袋长有21厘米，绝对足够了；二是透明，普通的不透明笔袋的痛点在于每次找个东西得翻半天，甚至可能翻完发现东西不在里面，透明笔袋就没有这个问题了，从外面不仅可以一眼看到里面装了什么，还可以看到在哪个位置，取用要方便很多。 买回来之后还发现了一个惊喜，那就是它的容量非常大，放我的几支笔简直小菜一碟，占不到三分之一，甚至还可以把眼镜盒也给放进去，所以或许也可以一起在里面放一下杂物。另外，买之前我担心的一点是这种网纱的笔袋能不能兜住自动铅笔的头，买回来后发现网眼非常密实，如果不是专门用力，不会被扎透，所以现在唯一需要担心的问题，就是这个拉链可以用多久了。 ","date":"2021-06-02","objectID":"/2021/mg-gray-transparent-mesh-pencil-case/:0:0","tags":["好物评测"],"title":"晨光灰色透明网纱笔袋","uri":"/2021/mg-gray-transparent-mesh-pencil-case/"},{"categories":["日程及周刊"],"content":"逐渐发现周刊有点工作量太大，每周末都需要拿出好多时间做这件事，所以换成了月刊，目的依然是记录生活，发现生活中的美好，当前为第一期月刊。 ","date":"2021-05-31","objectID":"/2021/life-monthly-1/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 1 期 (202105)","uri":"/2021/life-monthly-1/"},{"categories":["日程及周刊"],"content":"时讯 1、金钱豹外逃事件-新华网 05.10 【社会热议】5月10日杭州新闻发布会称，早在4月19日上午，由于杭州野生动物世界的饲养人员在交接班时没有严格按照操作流程，三只金钱豹已经逃逸。不过最令人瞠目结舌的是，猛兽出逃前后22天，杭州野生动物世界既没有上报，也没有对外公布，存在严重的瞒报行为。 事件经过：2021年4月19日，杭州野生动物世界3只金钱豹脱逃，2岁半，一公两母。5月7日20时许，群众报警称杭州野生动物世界发生3只未成年金钱豹外逃事件，已捕获追回一只。针对这一情况，富阳区迅速采取行动 。8日17时许，杭州野生动物世界第二只外逃豹子被找到。这只金钱豹在杭州市富阳区银湖街道金苑山庄旁边山林被发现，被成功麻醉后捕获。5月9日凌晨，第三只也就是最后一只在逃的金钱豹被发现了踪迹，但目前还没有抓到。5月10日，杭州市公安局富阳区分局对杭州野生动物世界相关人员因“金钱豹外逃事件”涉嫌犯罪立案调查。 2、第七次全国人口普查结果公布-央视新闻 05.11 【历史节点】2021年5月11日上午10点，国新办举行新闻发布会公布第七次全国人口普查结果，全国人口共141178万人，与2010年的133972万人相比，增加了7206万人。 东部地区人口占39.93%，中部地区占25.83%，西部地区占27.12%，东北地区占6.98%。 男性人口为72334万人，占51.24%；女性人口为68844万人，占48.76%。 0—14岁人口为25338万人，占17.95%；15—59岁人口为89438万人，占63.35%；60岁及以上人口为26402万人，占18.70%。 具有大学文化程度的人口为21836万人。 3、天问一号成功着陆火星-央视新闻 【历史节点】5月15日7时18分，天问一号探测器成功着陆于火星乌托邦平原南部预选着陆区，我国首次火星探测任务着陆火星取得成功。 4、“杂交水稻之父”袁隆平院士逝世-央视新闻 “共和国勋章”获得者、中国工程院院士、国家杂交水稻工程技术研究中心主任、湖南省政协原副主席袁隆平，因多器官功能衰竭，于今天（5月22日）13时07分在长沙逝世，享年91岁。 ","date":"2021-05-31","objectID":"/2021/life-monthly-1/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 1 期 (202105)","uri":"/2021/life-monthly-1/"},{"categories":["日程及周刊"],"content":"生活 05.04，去茂业逛了一趟，挑选笔和手账，看新发布的红米K40，发现电影院开了，发现地下一层有个永辉超市 05.05，毕业资格审查，在学校超市挑选中性笔，白雪、点石、晨光居多，且找不到0.38 05.07，win10自动化 windows聚焦壁纸定期保存 电影天堂下载的电影定期重命名 照片文件夹定期压缩备份到Onedrive 关闭windows通知栏 电脑微信聊天记录备份 05.08，两份盲审意见到达 05.09-05.12，游戏《刺客信条：英灵殿》 05.12，毕业派遣相关材料提交，稍后读软件对比整理 05.13，上交三方 05.15，到小米售后给手机换电池 05.17，最后一份盲审意见到达 05.22，性格色彩测试，结果为绿+黄（12+9） 05.23，注销建行卡，缝椅子垫 05.24-05.27，游戏《炉石传说》，毕业论文修改，Overleaf论文修改 05.24，替庆豪参加党史知识竞赛（观众），有不少感触 主持人功底很好，声音清晰洪亮，语言流利，能调动现场气氛，能很好地处理意外事件，如抢答器故障、部分人抢答过早等 活动的组织确实很棒，包括四个答题环节（尤其是第四个）的设置，充分调动了现场竞争氛围，现状来猜测一下活动组织的过程 确定活动形式及环节设置，确定答题范围，确定题目（策划案） 将比赛时间、题目范围、比赛形式等通知各学院 各学院选拔参赛人员并备赛 会场布置、观众通知、工作人员的确定和培训，主持人、领导的时间协调 发现不同同学确实看起来不一样，有些就看着非常「干净」，用这个词是我也不知道怎么形容那种感觉，可能是面容干净、衣服整洁、发型合适且头发干净以及气质良好的综合体 领导讲话可以讲些什么内容，看一下上面的记录就知道了，这件事充分说明了人家起码在认真看比赛（当然肯定有准备好的稿子） 人民日报《少年》视频 多见一些人、多参加一些活动还是有好处的，有很多感悟 05.28，和珂祯、文鑫、栋哥、杰哥去丢鞋撸串 05.30，智联招聘简历及账号注销，目前手里有的药品整理清单到Notion ","date":"2021-05-31","objectID":"/2021/life-monthly-1/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 1 期 (202105)","uri":"/2021/life-monthly-1/"},{"categories":["日程及周刊"],"content":"观影 国漫大电影《新神榜：哪吒重生》 内地电影《人潮汹涌》 电影《特种空勤团：红色通缉令》 综艺《向往的生活第五季》 电影《猎杀T52》 短剧《爱、死亡与机器人第二季》 日漫《比宇宙更远的地方》 电影《你好，李焕英》 纪录片《七个世界，一个星球》 电影《速度与激情9》 电影《银河护卫队》 电视剧《爱情公寓第五季》，二刷，看了开头一部分，觉得有点尬，看不太进去了 韩剧《我是遗物整理师》 电影《人之怒》 纪录片《完美星球》E01-E02 ","date":"2021-05-31","objectID":"/2021/life-monthly-1/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 1 期 (202105)","uri":"/2021/life-monthly-1/"},{"categories":["日程及周刊"],"content":"阅读 《子弹笔记》，仔细学习了一遍子弹笔记的写法，并于本月开始实践 克里斯多福·孟，《亲密关系》，学习如何维持亲密关系 罗兰·米勒，《亲密关系》，没看完 孟非《写给单身的你》，关于恋爱和婚姻观的思考 伊庭正康《当时这样说就好了》，关于交流技巧 ","date":"2021-05-31","objectID":"/2021/life-monthly-1/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 1 期 (202105)","uri":"/2021/life-monthly-1/"},{"categories":["日程及周刊"],"content":"思考 1、购物欲望 如果你关心，你就会心动，如果你心动，你就会无时无刻不想去买 如果不是当下需要，就不要去看，需要的时候再说 真的需要那么贵的东西吗，一支笔六七块，积少成多，最后多花好多钱 2、烦恼的很多事都是未来的事，其实只需要活在当下就好 3、﻿出版编辑资格证，可以试着考一下这个证 4、很多事真的没有意义吗，遇到困难就逃避真的好吗，抗战时人民军队怎么坚持下来的，普通士兵真的有那种觉悟吗，新中国建设时期的人们呢，总感觉现在陷入了虚无主义 ","date":"2021-05-31","objectID":"/2021/life-monthly-1/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活月刊第 1 期 (202105)","uri":"/2021/life-monthly-1/"},{"categories":["平日里的白日梦"],"content":"国学经典阅读顺序，摘自百度文库。 👉 国学经典阅读顺序及其推荐(陈双老师推荐) - 百度文库 (baidu.com) ","date":"2021-05-19","objectID":"/2021/chinese-classics-reading-order/:0:0","tags":["杂谈"],"title":"国学经典阅读顺序","uri":"/2021/chinese-classics-reading-order/"},{"categories":["平日里的白日梦"],"content":"幼儿养性 零岁至三岁前，心无分别，尘垢未染，真如湛然，性德纯正，心如明镜，朗摄无碍，先入为主，深深入心，终身不移。幼儿怡养本性，正宜此时。 ","date":"2021-05-19","objectID":"/2021/chinese-classics-reading-order/:1:0","tags":["杂谈"],"title":"国学经典阅读顺序","uri":"/2021/chinese-classics-reading-order/"},{"categories":["平日里的白日梦"],"content":"童蒙养正 至十三岁前，物欲微薰，烦恼潜伏，知识略萌，性德仍净，记性犹强，悟性微弱。童蒙蕴养正见，正宜此时。 经典精读 《三字经》《百家姓》《千字文》《千家诗》《弟子规》《孝经》 诗词启蒙 《声律启蒙》《笠翁对韵》《唐诗三百首》 典故类 《幼学琼林》《龙文鞭影》 古文类 《古文观止》 ","date":"2021-05-19","objectID":"/2021/chinese-classics-reading-order/:2:0","tags":["杂谈"],"title":"国学经典阅读顺序","uri":"/2021/chinese-classics-reading-order/"},{"categories":["平日里的白日梦"],"content":"少年养志 十三岁后，知识渐开，物欲既染，烦恼增多，心逸情泳，故真性渐隐，记性渐泯，然性向显发，崇效楷范，悟性转强。少年启养心志，正宜此时。 儒经道统 《大学》《论语》《孟子》《中庸》《诗经》《尚书》《礼记》《易经》《春秋左传》《四书章句集注》 历史经验《史记》 《资治通鉴》《汉书》 《后汉书》 《三国志》 ","date":"2021-05-19","objectID":"/2021/chinese-classics-reading-order/:3:0","tags":["杂谈"],"title":"国学经典阅读顺序","uri":"/2021/chinese-classics-reading-order/"},{"categories":["平日里的白日梦"],"content":"成年养德 凡所当读书，如能自幼扎根熟读，庶以诚意正心，格物致知，学以致用，而为将来成学立业之深基，修身明德之永磐。唯德业无穷，学无止境故，成年学养行德，随时皆宜，无有终时。 儒家《庄子》《荀子》，颜之推《颜氏家训》 兵家 《孙子》《三十六计》 法家 《韩非子》 农家 《农政全书》《齐民要术》 天文算法 《九章算术》 科技 《梦溪笔谈》 杂家 《墨子》 《吕氏春秋》 近代 《中国人的精神》 《湖上闲思录》《中国历史研究法》《中国历代政治得失》 《东西文化及其哲学》 《中国哲学简史》《美学散步》 《谈美书简》 《吾国与吾民》 《三民主义》 《蒋介石日记》 《毛泽东选集》 《邓小平文选》 南怀瑾书籍 ","date":"2021-05-19","objectID":"/2021/chinese-classics-reading-order/:4:0","tags":["杂谈"],"title":"国学经典阅读顺序","uri":"/2021/chinese-classics-reading-order/"},{"categories":["我所热爱的生活啊"],"content":"经济是每个人都躲不开的东西，作为普通人，搞懂一些生活中的经济常识，能帮助我们活得更明白一点，这些知识包括缴税、理财、买房、养老、生育、贷款等等，都是与每个人息息相关的。本篇学习缴税。 不管公司还是个人都要缴税，我们普通人涉及的税大致包括四种：个人所得税，流转税，财产/资源税和行为税。 ","date":"2021-05-07","objectID":"/2021/pay-taxes/:0:0","tags":["生活技能"],"title":"经济学常识-缴税","uri":"/2021/pay-taxes/"},{"categories":["我所热爱的生活啊"],"content":"个人所得税 个人收入需要缴税的部分大致包括：工资、个体经营、劳务报酬、稿酬、房租收入、中彩票和其它。 个税有一个起征点，工资缴税的时候会先减去这部分，然后乘以税率，得到的才是要缴的税款，税前的工资要扣掉社保，扣掉个人所得税，最后剩下的才是税后收入，也就是实际拿到的钱。 如果工资在起征点以下，就不需要交个人所得税了，当然，流转税是每个人都逃不掉的。 当前的起征点为5000元。 ","date":"2021-05-07","objectID":"/2021/pay-taxes/:1:0","tags":["生活技能"],"title":"经济学常识-缴税","uri":"/2021/pay-taxes/"},{"categories":["我所热爱的生活啊"],"content":"流转税 流转税是商品流通过程中的税，比如，一瓶可乐卖3块钱，可能就会含有0.5元税，我们在购买可乐的过程中就已经把这部分税缴了，国内发票上不会写这部分内容，但不意味着没交，国外会写。 流转税其实主要分三种： 增值税：商品从生产到销售的全流程中，价值不断增加，每个环节都要缴增值税 消费税：所有商品都要缴增值税，一些特殊的可能浪费资源或污染环境的商品如奢侈品、高能耗电子产品、不可再生的商品都要额外缴消费税 关税：国家对进口商品收的税，用来填补国库和保护本国产业 ","date":"2021-05-07","objectID":"/2021/pay-taxes/:2:0","tags":["生活技能"],"title":"经济学常识-缴税","uri":"/2021/pay-taxes/"},{"categories":["我所热爱的生活啊"],"content":"财产/资源税 人类财富，无论土地还是房产都要缴财产/资源税，比如购买房子要缴房产税。 ","date":"2021-05-07","objectID":"/2021/pay-taxes/:3:0","tags":["生活技能"],"title":"经济学常识-缴税","uri":"/2021/pay-taxes/"},{"categories":["我所热爱的生活啊"],"content":"行为税 为了限制某些对环境不友好或其它原因收的和行为有关的税，比如买车时缴的车辆购置税，再比如签合同或者炒股都要缴契税或印花税（合同上的印花，可以证明合同合法有效）。 所以其实整个生活都和税离不开，挣钱要缴所得税，花钱要缴流转税，有个房子还要缴财产/资源税，不过，正是这些税款才能保障国家的稳定运行，而国家的稳定运行才能让我们生活安乐，所以，额，差不多就是大型的保护费吧。 ","date":"2021-05-07","objectID":"/2021/pay-taxes/:4:0","tags":["生活技能"],"title":"经济学常识-缴税","uri":"/2021/pay-taxes/"},{"categories":["我所热爱的生活啊"],"content":"参考文献 [1] 陈磊等. 半小时漫画经济学[M]. 海南出版社. 2019.10 ","date":"2021-05-07","objectID":"/2021/pay-taxes/:5:0","tags":["生活技能"],"title":"经济学常识-缴税","uri":"/2021/pay-taxes/"},{"categories":["我所热爱的生活啊"],"content":"和很多人一样，我的整理收纳之旅也是从《砰然心动的人生整理魔法》这本书开始的，但是慢慢的，这件事就变成了一种打发无聊时间和释放压力的手段，甚至到最后发展成了爱好，愿意花费更多的时间研究这方面的内容。在这个过程中，极简主义的思想渗透到了我的整个生活中，整理收纳自然不例外，而计算机的背景使得我个人有一种一切都数据化的偏执，这两者协同作用从而诞生了我现在使用的这个基于Notion数据表格的实物管理方案。这篇文章就介绍一下这个方案，给大家提供一些参考，由于在Notion中做这件事不是很复杂，而且每个人的方案都应当与自己的生活想适应，我就不提供模板了。 ","date":"2021-05-03","objectID":"/2021/minimalism-and-data-notion-based-management-ideas/:0:0","tags":["生活技能"],"title":"穿搭整理4-基于Notion的实物管理","uri":"/2021/minimalism-and-data-notion-based-management-ideas/"},{"categories":["我所热爱的生活啊"],"content":"1. 整体分类 我把所有物品分为四类：衣柜、生活工具和附属品、浴室、电子产品，这个分类当初好像来自于某个作者的文章，虽然现在不记得是谁了，但还是表示感谢。我对这几个分类的认知也在这两年的实践过程中产生了一些变化，到一年前开始固定下来。目前，「衣柜」除了包括衣帽鞋包和配饰外，还包括床上用品；「浴室」包括个人清洁类的所有物品，比如洗漱、洗澡、洗衣服等过程中会用到的物品；「电子产品」就很容易理解了，电脑、手机、鼠标、键盘、手环、耳机等都属于这一类；其它所有物品都划归到了「生活工具和附属品」，所以或许你也可以称呼这一类为「杂物」。这四类位于同一个页面，但并不在同一个数据表格中，而是四个独立的表格，如下所示。 每次购物后，新物品的信息都要记得录入相应的表格中，而每次处理掉某个物品后，也要记得及时删除对应的物品。所以，这种精细化的管理方案和极简主义的生活方式是息息相关的，我们不能期待一个拥有成百上千件物品，而且每个月还在源源不断地购置的人能够很好的维护这个系统，因为那会占用太多的精力。而对于一个极简主义者，相对较少的物品和不太频繁的购置与处理活动会使这个系统的维护变得相当轻松，当然，如果自己希望培养一个极简的生活习惯，那么用这个系统也许可以抑制你的消费欲，毕竟，把你拥有的物品一览无余的摆在眼前，你会很清楚到底还需不需要买新的东西。 大家还可以看到上面的图中还存在第五个表：想买，这是辅助这个系统运行，也是践行极简主义的有一个手段。除去日用品和必须立马就买的物品外，所有心血来潮想到的、看个视频或看个文章被种草的物品会添加到这里，输入的信息包括物品名、购买的目标商品、预计的价格以及想要买它的理由，每个月给自己设置一个购买的物品上限，比如3个或5个，然后可以从这个表格中挑选自己喜欢的进行购买。但是购买依然要遵循一个原则，那就是要买的物品要么是自己不曾拥有的种类，具有不可替代性，要么就是旧的物品到了期限或自己不再喜欢了，这种情况下你要保证购入的同时处理掉旧的物品，或者扔掉，或者送人。整个表格每个月的更新除了这三五件物品外，剩下的应当基本都是日用品，也就是「浴室」那个分类，这样维护起来就相当容易。 这个方案陪着我走过研究生的这几年，而在学生时代之后，我的设想中它还应当有两个阶段的发展，第一个是工作以后开始独立生活，由于做饭而新增「厨房」分类，第二个是有了自己的房子之后做一次大改，按照每个房间来分类。 ","date":"2021-05-03","objectID":"/2021/minimalism-and-data-notion-based-management-ideas/:1:0","tags":["生活技能"],"title":"穿搭整理4-基于Notion的实物管理","uri":"/2021/minimalism-and-data-notion-based-management-ideas/"},{"categories":["我所热爱的生活啊"],"content":"2. 衣柜 如下图所示，衣柜数据表需要输入的元数据信息包括物品名、分类、季节、价格、购入时间、状态、尺码、图片、吊牌和备注。其中，物品名中还会以短横线将颜色、品牌等附注信息进行连接。表格整体的排序主要根据分类和季节两项，从上到下依次是夏季衣物、春秋衣物、冬季衣物、内衣、其它衣物、配饰、床上用品，每一部分之间插入一个空行进行分割，另外，为了展示所有部分的全貌，这里只给出了部分物品示例。状态分为使用中、闲置和待更换三种类型，使用中和闲置的区别并不是是否当季，而是是否在身边（可能放在了家里），待更换则意味着这件衣物不想要了，可以寻求各种处理方式。每个物品都需要实物图片和吊牌图片，实物图片可以用于衣物不在身边时回忆其具体样式，吊牌则主要拍摄产品基本信息和洗涤注意事项。图片中还有很多空白部分，有些是很久以前买的，有些则是父母给买的，这些都无法确定价格、购入时间乃至尺码，所以只能留空。最后还需要注意的是，有些物品一般是好几件一起买的，比如袜子，这时候价格部分输入的是单价，件数则作为附加信息使用短横线连接到物品名后。 表格的下方会显示物品总数，不过要注意的是，袜子等同样式的单件物品、套装都计为一件，而且这个总数包括分割各部分的空行。目前的学生时代当季与非当季的衣物分别存放在衣柜和行李箱中，当季衣物一般较少，衣柜会比较容易打理，如下图中所示，所有上衣类悬挂在左侧，下衣则叠放在右侧，右上悬挂裤架和皮带，下方的夹层放替换的床单被罩等。由于衣物的总数本身就比较少，非当季的衣物也能全部放在行李箱中，当然，在这里掌握各种衣物的叠法很重要。我的床位是在进门右手边第一个，所以我将床头看作平时家里玄关的衣帽架，然后和舍友商量后挪动了床的位置，留出了一部分空间在墙上安装了一面镜子，事实证明非常有用，舍友都很喜欢。 ","date":"2021-05-03","objectID":"/2021/minimalism-and-data-notion-based-management-ideas/:2:0","tags":["生活技能"],"title":"穿搭整理4-基于Notion的实物管理","uri":"/2021/minimalism-and-data-notion-based-management-ideas/"},{"categories":["我所热爱的生活啊"],"content":"3. 浴室 浴室数据表需要输入的元数据信息包括物品名、价格、数量、购入时间、购入渠道、状态、图片、本次启用时间和备注。物品包括洗漱、洗衣服、洗澡以及其它个人清洁或室内清洁的用具，这里价格依然是单价，但由于日用消耗品居多，数量进行了额外的标识，同时标记每次的启用时间，使得对使用时间有一个大致的把握。这一部分的状态有使用中、闲置和耗尽三种，而且闲置就真的是很久没有用那种，耗尽则是用完还没来得及补充。在每次的购物和使用过程中，我们会对产品的好坏有一个评价，遇到顺手的、非常喜欢的时，这一个购物来源就可以固定下来，包括购物渠道、店铺和品牌，长此以往，所有的消耗品就会形成一个固定的格局，不再需要专门去挑选，购入渠道在其中就是起一个记录来源的作用，便于下一次的购物。 根据宿舍床架的空间格局，我分配了一个格子用来存放洗漱用具，同一层另一侧的格子用来存放纸巾，这种单元格分配方式在我的第一篇文章 宿舍桌面布局，穷有穷的玩法 中已经介绍过一次，有兴趣的可以看一下，当然，下面可能也会在其它部分提到。洗澡用具、洗脸盆、洗衣盆则从上到下分层存放在上床的楼梯上，洗衣液、柔顺剂等存放在右下的柜子里，而所有批量购买的物品暂时不用的部分都放在左下柜子的小行李箱中。空间分配的基本原则就是因地制宜和以功能为基本单位，当然，取用后放回原位和定期整理也是维持整洁的不二法则，不求每天都整理，起码每周或每个月整理一次，但是很可惜，身边不少人除了入学那一次再没动过手。 ","date":"2021-05-03","objectID":"/2021/minimalism-and-data-notion-based-management-ideas/:3:0","tags":["生活技能"],"title":"穿搭整理4-基于Notion的实物管理","uri":"/2021/minimalism-and-data-notion-based-management-ideas/"},{"categories":["我所热爱的生活啊"],"content":"4. 生活工具和附属品 生活工具和附属品类别和浴室类别唯一的区别是减少了一个本次启用时间的元数据输入，基本上所有无法归类到其它三者的物品都会记录到此处，但有时候会采用一种记整不记零的方式，比如，所有重要的纸质文件都放在了蓝色文件袋中，但表格中只记录蓝色文件袋这一个物品，我只要知道要找某些东西的时候直接来这里找就行。 取用非常频繁的物品放在左手边的格子和抽屉里，如下图，而我梦想的抽屉就是《家族的形式》里男主那种有设计好的凹槽来放不同物品的抽屉。 ","date":"2021-05-03","objectID":"/2021/minimalism-and-data-notion-based-management-ideas/:4:0","tags":["生活技能"],"title":"穿搭整理4-基于Notion的实物管理","uri":"/2021/minimalism-and-data-notion-based-management-ideas/"},{"categories":["我所热爱的生活啊"],"content":"5. 电子产品 电子产品的元数据信息包括物品名、价格、购入时间、状态、购入渠道和备注。这里的状态包括完好、部分损坏和希望更换三种，希望更换和其它两种不互斥，因为完好状态下也可能由于各种原因想换新的。 大部分的电子产品都属于电脑及手机的配件，直接摆放在桌面上，剩下的小部分如剃须刀和树莓派等收纳在右侧的抽屉，移动硬盘和各类线材等则统一放置到左上角格子的线材收纳包中。 ","date":"2021-05-03","objectID":"/2021/minimalism-and-data-notion-based-management-ideas/:5:0","tags":["生活技能"],"title":"穿搭整理4-基于Notion的实物管理","uri":"/2021/minimalism-and-data-notion-based-management-ideas/"},{"categories":["我所热爱的生活啊"],"content":"6. 后记 极简的生活方式便于数据化的实现，而这两者相配合又使我们可以掌控自己的生活，这就是我的实物管理思路，此外电子数据整理将作为下一部分内容，而思维整理由于还在不断地迭代衍变过程中，暂时就先不介绍了，以后有机会再说。另外还有一个有意思的事，由于对数据化和自动化的不懈追求，我还设想过很多方案，比如利用 RFID标签或 NFC标签进行物品管理，又比如通过扫描商品的条形码实现物品的自动录入，就像超市那样，不过最后都因为成本问题和开发难度放弃，最近的一个思路是利用标签机和二维码对物品进行管理，充分利用二维码的文本存储能力，也许有空会试一下。 ","date":"2021-05-03","objectID":"/2021/minimalism-and-data-notion-based-management-ideas/:6:0","tags":["生活技能"],"title":"穿搭整理4-基于Notion的实物管理","uri":"/2021/minimalism-and-data-notion-based-management-ideas/"},{"categories":["我所热爱的生活啊"],"content":"🛒 入手渠道：Keep商城 💰 参考价格：108 元（手环独立售价 99 元 + 首月会员 9 元） 纠结了很久下一款可穿戴设备是买手环还是买智能手表，后来仔细想了想，就算我买了智能手表，我会不带手机出去吗？答案是不会，所以决定继续买手环。发现 Keep 手环B2会员版（以下简称为Keep手环）则完全是意外之喜，之前做调查的时候也考虑过 Keep 手环，但在价格和小米手环相差无几的情况下，它完全没有竞争力，网上给出的评价也是「除非你是 Keep 深度用户，否则不建议购买」。但前两天用 Keep 的时候发现这款新出的会员版开始预售，只有 99 元，而且有游戏化运动模式，想到自己本身就是会员，瞬间脑子充血就下了单。到手试用了一段时间后，本来是冲 Keep 软实力去的我，竟然意外的发现这款手环其它方面也比较合我心意。 首先是外观与基本功能。商城的图片其实看起来不算好看，结果到手之后意外的发现竟然还可以，无论是整体的外形、屏幕的触感还是图标的美观程度，都比我之前用的黑加手环1s要好，手臂出汗时腕带也没有黑加腕带那种不适的感觉，算是出乎意料。基本功能方面，时间显示、闹钟、消息通知、心率检测、睡眠检测、久坐提醒这几个最常用的功能都有（运动方面的功能稍后再说），此外，还提供了血氧检测功能。缺点的话可以总结出下面几个： 表盘主题较少。非会员 4 个，会员也只多了 3 个，这方面对我来说不太重要，但有人可能比较关心； 闹钟只能在手机端操作。黑加手环的界面中有独立的闹钟界面，可以手动开启和关闭预设的闹钟，不用打开手机，Keep 手环则不行，它与闹钟唯一的交互时间就是闹铃响起的那一刻。 消息通知比较简单。软件中可开启的通知一共有四种，微信、QQ、短信和其它通知，这些都基于手机通知栏，一条消息只有出现在了手机通知栏，手环才有可能收到。另外，这里的QQ就真的只包括QQ，Tim的消息通知是接收不到的，想接受Tim的通知只能打开其它通知的开关，而且手环的提示也不是Tim，而且「其它」。 Keep手环无法检测零星小睡。 然后是运动方面的功能。对于 Keep 深度用户这个手环最大的优点就是运动前不用点两次开始了（手环和Keep分别点一次），对于懒癌患者来说，这一点真是太省心了，更何况，使用 Keep 自家的手环能够使软件对于热量消耗的估计更加准确，这对于健身计划的制定非常有用。手环支持跑步、瑜伽、动感单车、行走、球类运动、椭圆机、游泳、划船机、自由训练一共九种运动模式，关于这方面可以查看网上关于 Keep 手环B2普通版的评测，两种手环硬件方面是没有区别的。但这里需要注意，说明书中提到手环可以在浅水游泳时佩戴，洗热水澡时则不可以。 最后是会员版独享的游戏化运动。致使我头脑发热下单的罪魁祸首，除了 99 元的价格，就是这个游戏化运动的说明了，当时满脑子都是 99 元的健身环这个想法，所以就没控制住自己。Keep 目前提供游戏模式的运动课程还不算太多，舞蹈方面有帕梅拉的两个有氧操课程，拳击方面同样是两个课程，健身方面则比较多，一共有10个课程，大部分是 HIIT，包括一个跳绳类课程。这三种运动我都挑了一个课程体验了一下，最后发现，帕梅拉和拳击有点类似于游戏厅的跳舞机，做出正确的动作会得到分数，连续的正确动作则会触发 combo，虽然确实比普通课程吸引人，但还存在下面两个问题： 手环只能检测到你做了手部动作，无法区分是哪个动作，举个例子，左直拳和左勾拳打错的时候，是检测不出来的； 对正确动作的反馈不是我之前想象的震动，而是音效，震动确实有，但只有在触发 combo 的时候才会出现，而且时间有点过长，感觉上不是很舒服； 健身的课程实际上是有点想要吐槽的，说是游戏模式，其实就是界面下方有一簇燃烧的火焰，做动作的时候火焰里会跳出一些分数，某种程度上还不如原先的课程，因为本来显示在界面上方的实时心率没有了。我觉得倒不如将跑步加入进来，对原来的剧情跑课程做一些调整，改为游戏模式，应该会很吸引人。 在手环所有功能都开启的情况下，五天下来手环一共还剩70%的电，我觉得这个续航足够了。所以总的来说，瑕不掩瑜，Keep 在这方面的探索我觉得是一个很棒的想法，非常值得鼓励，而99 元的真香价格，没什么后悔不后悔的，毕竟就算只开一个月会员，之后依然可以使用手环的基础功能，缺少的只有游戏模式，而提供同样功能的普通版手环，单买需要200多。 ","date":"2021-04-26","objectID":"/2021/keep-bracelet-b2-member-version-review/:0:0","tags":["好物评测"],"title":"Keep手环B2会员版","uri":"/2021/keep-bracelet-b2-member-version-review/"},{"categories":["研究生的区块链学习之路"],"content":"本文总结2018年12月到2021年4月的研究工作历史，不包括论文阅读工作。 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:0:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2018.12 区块链主流共识算法收集了解和分析 IIoT 与区块链结合的场景收集和一些研究思路， 总结文档地址 利用 Hyperledge Composer 完成供应链场景下的易腐食品运输示例 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:1:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.01 实时与非实时数据的区别，区块链存储问题分析，总结文档地址 区块链平台比较和选择，总结文档地址 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:2:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.03 Ethereum 原理、架构等基本知识学习 利用虚拟机搭建 Ethereum 私有链，熟悉转账、挖矿等相关命令和操作 了解智能合约编译、部署、调用全过程，了解智能合约开发与测试框架 Truffle 搭建 Swarm 分布式存储网络 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:3:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.04 Ethereum 区块生成时间数据集获取及分析 过程记录 场景思考，初步的方案设计和实验设计，工业4.0背景了解。未完成的智能工厂方案设计 智能合约编程语言 Solidity 语法学习及练习 基于已有知识的区块链综述文章撰写，文档地址 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:4:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.05 继续撰写综述文章，智能工厂场景可行性分析及相关问题考虑 区块链安全与隐私问题总结分析，比如可能的攻击、相关解决方案等，相关方向论文阅读 注意力集中在两篇当时新出的区块链和智能工厂结合的论文，初步确认了应实现一个访问控制方案 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:5:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.06 各论文使用的访问控制方案总结比较 各论文使用的存储方案总结 起草开题报告第一版，确认三个创新方向为：访问控制，存储，其它（如共识、通信方式、不相干区块过滤），并确认具体的细节 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:6:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.07 开题报告内容继续完善 开始关注区块链平台性能分析工具，并将其作为一个可能的方向 确认要做的三件事：1. 在 Zhang 的方案上复现然后做改进；2. 区块链压缩；3. 移动性和通信链路不稳定性问题解决 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:7:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.08 关注性能分析可能遇到的问题及其实验设计细节，寻找可能的方向 安排访问控制方案实现的时间表 熟悉 Quorum 区块链及其网络搭建 开题 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:8:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.09 设计树莓派和PC的组网方案，Quorum 客户端编译部署到树莓派，最终将树莓派作为节点加入 Quorum网络 Zhang 论文中的访问控制合约复现，部署及相关问题解决 开始关注异常检测方向，了解强化学习概念和信誉问题 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:9:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.10 复现合约的功能测试，相关测试脚本的编写 异常检测方向的论文收集和阅读，相关思路提出，总结文档地址 访问控制方案场景思考，可优化之处分析，总结文档地址 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:10:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.11 实验室已有设备梳理及实验方案设计 优化的访问控制方案设计及智能合约实现 区块链用于物联网访问控制的全部问题总结，文档地址 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:11:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2019.12 区块链发展情况调查，包括论文发表情况，期刊、会议和基金信息，研究团队，著名研究者，征稿情况等 已实现的访问控制合约功能测试，使用Truffle 部署，Gas和时间消耗统计，合约安全性检查 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:12:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.01 整理已完成访问控制工作，总结创新点，思考下一步研究方向（异常检测、区块链压缩，细化方案，性能测试工具） 通过阅读论文了解当时访问控制发展情况，区块链理论发展情况 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:13:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.03 论文写作 分析存储方向研究思路的可行性 开始阅读 Edge-D2D-区块链 的论文 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:14:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.04 D2D与区块链结合背景情况调查，初步方案提出，总结文档地址 阅读已有论文分析现有访问控制工作的可扩展性 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:15:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.05 设计具体的信誉函数，包括奖励和惩罚两部分 修改现有合约结构，加入信誉合约，在其中实现设计的信誉函数 搭建基于Docker的Quorum区块链环境，寻找合适的区块链浏览器 进行合约功能测试，解决浮点数运算产生的影响 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:16:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.06 完成合约功能测试，使用Mythx 进行合约审计（失败），尝试不同的合约部署方式，确定待测量值及测试方式 设计具体的实验场景和设计的访问控制操作，阅读并对比 IBM Food Trust（一个基于区块链的供应链解决方案， 测试私有合约及交易，获取合约部署的Gas消耗，测试访问控制时间并和未添加信誉部分时的系统进行对比 复现wang的论文 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:17:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.07 对复现的论文进行功能测试、获取Gas消耗、访问时间测试 确认访问时间与智能合约逻辑（代码逻辑、合约结构等）、和网络（发起访问的时机、CPU占用率）之间的关系 利用linux time命令测试访问控制进程实际执行的CPU时间 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:18:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.08 阅读关于事件到达仿真的相关资料，模拟泊松过程，生成符合指数分布的事件到达间隔时间 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:19:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.09 阅读论文，跟踪 iot-blockchain-access control 最新发展 查找 discrete event simulation 的相关资料，以及查找阅读 supply chain 事件产生符合的数学模型，目前没有进展 进一步明确要取得什么样的实验结果，明确攻击模型，对属性、策略等非法的增删改行为，可能造成系统出错的行为，寻找更多的风险行为。 寻找时间序列数据集，供应链相关的、过程控制相关的。 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:20:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.10 完善信誉部分的实验，包括到达时间间隔的生成、恶意行为分类、公平性指标的制定 寻找其它待测量的性能指标 调整代码，添加策略冲突解决机制、修复源信誉算法的错误、尝试浮点数运算的实现，匹配最新的编译器，统一代码风格，整理实验文档 测试系统重构，重新进行实验测试 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:21:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.11 代码整理打包到Github 调整检测算法和输入的相关参数，重新进行实验 整理文档，实验收尾 对众包、计算卸载、隐私保护方向研究的探讨 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:22:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"2020.12-2021.04 研究生毕业论文书写 ","date":"2021-04-22","objectID":"/2021/2018-2020-research-history/:23:0","tags":["科研记录"],"title":"2018-2021 研究历史","uri":"/2021/2018-2020-research-history/"},{"categories":["研究生的区块链学习之路"],"content":"每周会议摘要及老师提到的一些问题总结。 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:0:0","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"2018 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:1:0","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"11.23 问题：物联网场景下，设备算力有限，没有激励机制，用PoW还是PoS共识？ 论文1中使用PoS，论文2中节点借用边缘服务器的算力完成工作量证明，这些都是解决节点算力问题的有效方法，但是无论PoW还是PoS都有激励机制。 论文3中采用的是一种叫做轻量级可扩展区块链(LSB)的区块链技术，LSB没有使用PoW，避开了节点算力有限的问题，同时也没有看到关于激励机制的描述，采用的是称为“scheduled block generation process”的方式，每个节点在固定的时间间隔只被存一个块。 如果LSB能成功满足两个条件的话，这一技术显然是最适合使用的；而PoS机制和借用边缘服务器的算力两种方法，现在更偏向PoS，因为借用边缘服务器的算例很容易造成算力的集中，从而达成51%攻击，这种情况类似于加密货币领域现在的“矿池”，矿池的出现曾一度面临算力几近超过50%的情况，依赖于部分参与者主动离开算力最大的矿池才避免这个问题。 问题：区块链有哪些安全和隐私漏洞 论文4中提到基于区块链的智能车辆的安全与隐私的方案继承了区块链的种种优点，但也继承了缺点。指关于隐私的一个缺点，区块链使用密码学技术构造的地址和其它节点通信，但攻击者可以通过把用户行为（如交易数据）和地址做关联，从而达成去匿名化，这会危害用户隐私。 问题：无限传输损耗(延迟、同步、丢包等)对区块链的影响 同样，后面几篇论文还没来得及看，这一问题还不能完整回答。我只是在[4]中看到了关于这一方面的一个描述，因为4中使用了一种划分簇的方式，簇首节点管理该簇中的其它节点和执行区块链的功能，这里涉及到的被管理的节点中包括了智能车辆，智能车辆的移动可能造成和簇首节点之间的通信延迟。4中采用了软切换的方式完成智能车辆从高延迟簇到低延迟簇的转移，从而解决了这一延迟问题。 注：关于簇划分在选修的数据挖掘里有介绍，软切换在新一代互联网技术里有介绍，所以都能够理解。 Analysis of the Communication Traffic for Blockchain Synchronization of IoT Devices 一个思路是模拟通信链路不稳定对区块链的影响 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:1:1","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"12.01 探讨工业物联网+区块链的可研究性，是否值得研究，是否可以由学校中一到两个人研究某具体的细的方面 比较PoS,DPoS等非工作量证明的其它共识算法 比较可做实现的各平台 完成构架所需要的东西，平台或设备， 最近的工作做一个综述，写一篇文章 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:1:2","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"12.08 提一个场景 异常行为检测 通信链路造成的影响 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:1:3","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"12.29 数据分为几种情况考虑：实时、静态、大数据量 各情况下是否有必要用区块链，到底有什么优点 数据的控制可以是分布的，但是存储呢，数据存在链中开销很大 考虑实时和静止两种情况下不同场景的数据问题 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:1:4","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"2019 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:0","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"02.16 以后自己的方案要进行安全性分析，典型的攻击方式有以下几种 Sybil Attack 女巫攻击。这一名称来源于Flora Rhea Schreiberie在1973年的小说《女巫》（Sybil）改编的同名电影，是一个化名Sybil Dorsett的女人心理治疗的故事，她被诊断为分离性身份认同障碍，兼具16种人格。女巫攻击是在P2P网络中，因为节点随时加入退出等原因，为了维持网络稳定，同一份数据通常需要备份到多个分布式节点上，这就是数据冗余机制。如果网络中存在一个恶意节点，那么同一个恶意节点可以具有多重身份，就如电影中的女主角可以分裂出16个身份，原来需要备份到多个节点的数据被欺骗地备份到了同一个恶意节点（该恶意节点伪装成多重身份），这就是女巫攻击。女巫攻击是攻击数据冗余机制的一种有效手段。 女巫攻击的解决办法一般有两种。一种方法是工作量证明机制，即用计算能力证明自己是一个合法节点，增加攻击的成本，比特币就是这种方式。另一种方法是身份认证（相对于PoW协议，女巫攻击是基于BFT拜占庭使用容错协议的Blockchain需要考虑的问题，需要采用相应的身份认证机制）。认证机制分两类： 基于第三方的身份认证：每加入一个新的节点都需要与某一个可靠的第三方节点进行身份验证。 纯分布式的身份认证：每加入一个新的节点都需要获得当前网络中所有可靠节点的认证，这种方法采用了随机密钥分发验证的公钥体制的认证方式，需要获得网络中大多数节点的认证才能加入该网络。 一个通俗的解释，女巫攻击就是分身诈骗术，几种应对方法分别是： 干活 你即便分身千千万，唯有真心能干活。分心是虚幻的，没有力气，pow证明。 发身份证 可靠第三方公安局给你发身份证，没有身份证都是分身妖怪。 熟人社会 你迁户口到一个新的村子里，必须得到村子里，大部分人的认证，这就是中国传统社会的身份认证方法。群众的眼睛就是火眼金睛，照出一切妖魔鬼怪。 Spoofing 欺骗性攻击是指一个人或程序通过伪造数据成功伪装成另一个人以获得非法利益的情况。它与sybil攻击相反，攻击者试图创建大量虚假或虚拟身份，在欺骗攻击中，攻击者试图欺骗合法用户的身份以利用他的权限 DDoS 分布式拒绝服务攻击，全称是 Distributed Denial of Service，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。一个形象的例子如下 我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。 这就是DDoS。 应对DDoS的方法主要是以下几种： 高防服务器：还是拿我开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~ 黑名单：面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。 DDoS 清洗：就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。DDoS 清洗会对用户请求数据进行实时监控，及时发现DOS攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。 CDN 加速：可以这么理解，为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。 Message replay 重放，顾名思义，重复的会话请求就是重放攻击。可能是因为用户重复发起请求，也可能是因为请求被攻击者获取，然后重新发给服务器。这种攻击会导致请求被攻击者获取，并重新发送给认证服务器，从而达到认证通过的目的。可以通过加密，签名的方式防止信息泄露，会话被劫持修改。但这种方式防止不了重放攻击。抵御方式主要有： 时间戳验证：请求时加上客户端当前时间戳，同时签名（签名是为了防止会话被劫持，时间戳被修改），服务端对请求时间戳进行判断，如超过5分钟，认定为重放攻击，请求无效。 时间戳无法完全防止重放攻击。 序号：顾名思义，在客户端和服务端通讯时，先定义一个初始序号，每次递增。这样，服务端就可以知道是否是重复发送的请求。 挑战与应答的方式：我们一般采用这种方式来防御重放攻击。客户端请求服务器时，服务器会首先生成一个随机数，然后返回给客户端，客户端带上这个随机数，访问服务器，服务器比对客户端的这个参数，若相同，说明正确，不是重放攻击。这种方式下，客户端每次请求时，服务端都会先生成一个挑战码，客户端带上应答码访问，服务端进行比对，若挑战码和应答码不对应，视为重放攻击。 Message substitution 消息替换攻击：在替换攻击中，攻击者在传输过程中拦截有效消息，并以接收者接受伪造消息的方式对其进行更改，就好像它们是由原始发件人发送的一样。 参考论文：Hammi M T, Hammi B, Bellot P, et al. Bubbles of Trust: A decentralized blockchain-based authentication system for IoT[J]. Computers \u0026 Security, 2018, 78: 126-142. ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:1","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"03.10 Azure 可以进行20000美元研究经费申请 做不同共识协议受攻击的安全评估 在网络中模拟恶意攻击的节点 节点间距离很远造成的时延 模拟传感器数据流的生成 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:2","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"03.17 以太坊私链网络+智能合约+Swarm存储方案 选择合适的共识方案 模拟恶意节点的攻击，模拟时延 账户自动生成 考虑以太坊私链如何接入公链 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:3","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"03.31 PoA共识了解 随机数据生成 存储权限和查看数据权限 利用马尔科夫链控制数据生成时间 监测区块生成时间，并形成数据集 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:4","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"04.07 监测自己的私有区块链的区块生成时间，重点关注分叉 随机时间的数据生成和固定时间的数据生成 工厂场景激励机制改动，可以改为信誉积分的激励机制 工厂场景新的共识 用户随机时间访问区块链 实验场景想清楚，模拟攻击，下周提一个方案出来 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:5","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"04.12 了解工业4.0，5G，Smart Factory等可能结合的新技术，完善背景 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:6","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"04.28 论文应针对特殊的应用场景 之前做的仿真能不能用，能做什么改进，产生什么数值结果 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:7","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"05.12 整理访问控制中分层管理的思路实现 共识部分可以对共识进行分类，然后用树形图表达 考虑最终的方案应实现一个工业的控制流程 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:8","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"05.19 工厂内存在隐私问题，有设备厂商参与运营监测设备情况，同时有一对一通信的情况 论文着重关注私有区块链中的攻击方式，明确私链中是否还存在女巫和日蚀攻击 明确BSeIn论文中区块链结构的安全性由什么保证 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:9","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"06.09 各种存储方案的优点 重构论文，下周讲论文，要提出框架为什么这么设计 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:10","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"06.15 找三点创新点，以防万一 想一个合适的标题 如果架构算创新点，要提出创新在哪里 论文架构Background中的论述应该放到其它地方，Background是别人的东西 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:11","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"06.23 设备选择问题 创新点问题 新课题：终端资源共享（毫米波,5G,区块链） ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:12","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"06.30 实验创新：便宜有效 要往前看一眼，因为毕业要三年，做的东西很可能别人就做了 往IIoT的移动性方面想 众包（CrowdSouring）和Testbed ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:13","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"07.07 实验应有数值分析，具体分析哪些指标和结果，要先想清楚 对安全性分析，也可以完全理论上来做 可以考虑两个方向 模拟通信链路不稳定对区块链网络造成的影响 考虑移动性带来的问题 要尽量看的远一点，两年的时间研究会发生很大变化 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:14","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"07.13 移动性 when mobile blockchain meets edge computing中，提出移动设备从边缘服务器借算力的思想，并提出算力的定价方案 Blockchain: A distributed solution to automotive security and privacy中在Future research directions一节中描述了关于移动性的方面，认为车辆的频繁移动会增加移交过程的数据包和处理开销，应寻找移动友好的方法来减少开销 存储 物联网下的区块链访问控制综述一文的展望中提到，未来面临的问题包括 存储优化 区块链的存储是一个增量的过程,即只能增加而不能减少,所以会给存储带来巨大的负担.因此,如何降低区块链存储的代价,是物联网访问控制需要解决的另一个问题.目前的解决方法有两种:第一,压缩区块链中存储的数据,使相同大小的区块存储更多的内容[28];第二,将区块链与区块链存储解耦[69],区块链中存储的是指向某个内容的哈希值[39]. 故应对1中基于合约的访问控制进行存储优化，一是区块链存储哈希值，二是区块链压缩改进（SCC : Storage Compression Consensus for Blockchain in Lightweight IoT Network） 实现后分析压缩节省的存储空间，以及随着节点数增加带来的延迟 方案改进 针对Smart Contract-Based Access Control for the Internet of Things一文的复现及改进 原文使用了两台电脑，两台Raspberry Pi 实验包括对合约的调用，部署与执行合约的Gas消耗 进行时间机制优化，多级权限定义以及换用Quorum实现 可以对改进方案添加安全性分析 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:15","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"07.14 下周完成开题初稿，包括 现有的问题 自己用什么方案解决什么问题 产生什么工作成果 完成后比较之前硕士论文的工作是否有相似的，工作最好不要重复 小点的改进可以，但也可以想一下有什么新的想法 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:16","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"10.12 物理量+网络参数，一起作异常检测 以区块链、CPS和异常检测为关键词检索 异常分为动态和静态 IoT节点不一定是实际的传感器 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:17","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"10.27 网关被攻破时所管理的设备进行归属权转移 实验实施上的优化可以总结出来 异常不只是链上的交易数据，还有链下的设备行为，有可能从始到终设备提交的都是错误数据 重点在于检测什么样的异常行为，也就是检测量的问题，算法的问题老师可以解决 工业常用的传感器是震动、加速传感器，凡是有执行这一动作的都是执行器（LED，小电机，麦克风等） ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:18","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"11.03 加入设备属性，基于属性做访问控制和异常检测 异常检测应实现环境自适应和时间自适应 可以使用最简单的Arduino+传感器/执行器方式 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:2:19","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"2020 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:0","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"03.08 论文改进 使用latex，最好用overleaf进行多人协作，然后在本地备份 将自己的贡献放到Introduction部分 Overview改为System description/System Overview Simulation 改为Validation/Experiment(推荐) discussion里添加方案的缺点描述，但总体要保证利大于弊 研究方向 在工业控制的大前提下 尝试结合5G/Edge/D2D(device to device) Edge举例：100个节点，30个是常规区块链节点，70个其它可用设备，充分利用可用设备 第二条不可行的情况下，继续研究存储问题 投稿 最好是国内有英文版本的期刊 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:1","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"03.15 论文改进 明确所作的工作是用什么思路解决了什么问题，在Introduction部分写清楚 确认论文的关键词和标题，要能反映出自己做的工作 整体工作是通用于IoT的，但 Case Study 部分可以针对IIoT举个例子 研究方向 针对最近发生的事情思考有什么解决办法，比如区块链用于解决谣言传播问题 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:2","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"03.29 使用ABAC代替ACL和减少合约数量有好处，但是有哪些缺点也要确定 提炼一些关键词，确认标题，比如可以去掉scheme，加入efficient 关于如何efficient可以在discussing部分讨论一下，一定要明确这样做的好处 Edge 场景现有利用D2D网络协作解决深度学习的算力需求和解决别的设备的存储需求 协作时也需要达成信任，即利用区块链解决D2D网络的信任 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:3","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"04.05 论文改进 语法修改 工作的优越性要展示出来，比如在discussing部分加一个比较表 标题再考虑一下，不吸引人 新方向 将看过的论文总结一下，做个PPT周三讲一下 MEC或者说Edge方向可以研究 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:4","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"04.08 不使用边缘服务器或基站的原因是频谱资源有限 发现设备的方法包括社交网络，蜂窝系统等 移动性，动态是两个关键词，参与的节点随时加入或离开 如果使用信誉度评估系统，应该注意的新用户没有信誉度，这是一个风险 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:5","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"04.22 接下来做两件事 整理一下以前做过的事，只列提纲就好，发给老师 区块链也面临好多攻击，那它还有什么用，思考一下这个问题 信誉系统结合到现有工作中 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:6","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"04.29 首先是关于Overleaf那篇已完成的论文的问题 整体写的比较随意，逻辑性应再高一点 要逐层推进，前面提过的后面不要再提，比如网关作为设备代理这件事，提了好几次 插图中使用的图标要注意版权问题 按照上述三点要求之后更新一下 关于信誉函数设计问题，信誉值上下应有界，不要一直增长，关于这一点可以参考 CUSUM算法 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:7","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"05.06 信誉函数设计问题： 如果先期积累了很高信誉值，产生一个恶意行为只会导致信誉值下降，无法检测到。老师提示：可以设立长期和短期两种情况，短期在单位时间T内计算，这样就不会忽略恶意行为。另外，可以按时间计算，也可以按次数计算。 实验： 最后应该得到一个一般性的数学函数来描述 绘制得到一个ROC曲线，根据虚警值计算概率 长期的改进可以使用强化学习的信誉度计算 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:8","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"05.27 Overleaf 暂时不着急上传到 arXiv, 可以继续更新，最好把信誉系统加进去 测试时，输入的行为频率应符合一个模型，比如什么时间产生一个合法行为或什么时间产生一个恶意行为，不然结果没有说服力（一般情况产生频率是泊松分布，使用1个恶意节点） 同时应人为的产生 奖励、容忍、惩罚、报警 四种情况进行测试，看系统能不能识别； 考虑几种针对信誉问题的攻击：bad mouthing，on-off，conflliting behavior ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:9","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"06.03 实验场景 Smart home改为 Smart building更普遍更适合，听起来也更好 考虑输入的参数模型，会产生影响的变量有三种：属性、行为和请求时间 请求产生的时间应符合泊松分布，换句话说两次请求的间隔应符合指数分布，最后我们应得到的一个叫做到达率的值 泊松分布的到达时间可用 Matlab 产生 三种输入变量可以用一种方法表示，首先建立输入文件，文件的内容有三列，第一列是请求产生的时间，使用 Matlab 产生的值；第二列是属性，对属性进行随机的定义和更新；第三列是行为，定义当前时间执行的行为，比如属性的管理、策略的管理和访问请求 信誉合约中遗忘因子的计算是指数函数，因为智能合约对浮点数运算的限制，可以将指数运算用泰勒级数展开；权重或者说遗忘因子的取值可以令其符合泊松分布，与0-1内取值相同 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:10","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"08.12 访问控制请求同时发起怎么办，区块链的交易池如何处理，是否有排队论的问题 合约不同的行为是否都符合泊松过程，恶意行为可能是集中的 如何确定某个时刻发起哪一种类型的行为，是否用概率模型 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:11","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"09.12 寻找供应链的事件生成模型不如直接寻找相关的数据集，数据集应包括什么时间产生什么行为，设备具有哪些属性等； 寻找数据集可以尝试 process control 的关键词； Discrete event system 仿真可以使用 matlab 或 octav 如果发起访问请求的时间间隔量级比区块链交易池的等待时间大，可以忽略，因此应首先确定它们的时间量级； 攻击模型的问题，短时间大量请求是一个攻击模型，但非法的访问控制或属性和策略修改不是，因为会被挡住，再仔细思考一下 另外，不管攻击有没有被挡住，都可以介绍一下，最后说明区块链挡住了哪些攻击，访问控制挡住了哪些攻击，信誉系统挡住了哪些攻击； ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:12","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"09.19 查找 Trust , Credit 等看这些论文里用到的时间序列是什么样的； Risk-based 和动态访问控制方向，它们会基于访问请求、用户属性、操作严重性、资源敏感性、用户风险历史记录等计算风险值，控制访问是否通过，是可以借鉴的，多看几篇论文参考一下； 可能的异常还包括：异地访问、长时间不访问突然开始访问 需要对惩罚有个指标衡量，因为加入惩罚一定需要对现有的系统有好的部分，比如以太网中某个设备如果总是发不出去包，会推迟一段时间再发，这就是一个惩罚，这个惩罚可以减小网络中包碰撞的几率，访问控制系统加入惩罚也需要对某一方面有优化，如果实在找不到这个指标，可以利用基尼系数定义一个公平指标。 ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:13","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["研究生的区块链学习之路"],"content":"10.17 老师给的建议 整数信誉算法和浮点数信誉算法都实验一次，比较一下； 输入数据集（即输入文件中的多列数据），可以试着用机器学习的方式做一下检测，看一下结果，老师推荐了 weka; 恶意行为添加了对特殊策略条目的处理，实验时如何把它加入输入数据集； Wang W, Niyato D, Wang P, et al. Decentralized Caching for Content Delivery Based on Blockchain: A Game Theoretic Perspective[J]. arXiv: Networking and Internet Architecture, 2018. ↩︎ Xiong Zehui, Feng Shaohan, Niyato Dusit, et al. Edge Computing Resource Management and Pricing for Mobile Blockchain. ↩︎ Xiong Zehui, Zhang Yang, Niyato Dusit,等. When Mobile Blockchain Meets Edge Computing[J]. IEEE Communications Magazine, 56(8):33-39. ↩︎ Dorri A, Steger M, Kanhere S S, et al. BlockChain: A Distributed Solution to Automotive Security and Privacy[J]. IEEE Communications Magazine, 2017, 55(12): 119-125. ↩︎ ","date":"2021-04-21","objectID":"/2021/summary-of-issues-discussed-with-the-teacher/:3:14","tags":["科研记录"],"title":"历次和老师讨论的一些问题总结","uri":"/2021/summary-of-issues-discussed-with-the-teacher/"},{"categories":["我所热爱的生活啊"],"content":"力量训练的作用、原理，制定和执行计划的注意事项，常见的力量训练动作。。 不同健身者进行力量训练（Strength Training）的目的不同，有些人希望提升肌肉力量或肌肉耐力，也有些人想要获得一个视觉效果更好的肌肉围度，但力量训练的好处不止于此，它还可以提高EPOC，从而增加运动后的脂肪消耗，另外，随着肌肉的增长，人体的基础代谢会逐渐提高，减脂也变得更加容易。 ","date":"2021-04-12","objectID":"/2021/strength-training/:0:0","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"1. 关于肌肉 运动解剖学中，我们已经简单了解了肌肉的结构，这里主要理解肌肉的生长机制、训练方式等。 ","date":"2021-04-12","objectID":"/2021/strength-training/:1:0","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"1.1 肌肉的生长机制 肌肉生长的本质是对外部刺激的适应，总体过程如下图所示，抗阻训练导致肌肉组织受损，同时导致炎症的发生和激素等化学信号的释放，产生可修复损伤的成肌细胞或子细胞核，以合成更多的蛋白和肌纤维增长。肌肉持续受到这种锻炼方式的刺激，就会不断适应并且变得更大，以便减少整块肌肉横断面得压力，这个过程会一直持续到肌纤维达到最大生长潜力，或训练安排不当产生过度训练症状。所以，肌肉增长的实质是肌肥大（单个肌纤维大小的增长），而不是肌纤维数量的增加。 两个原则组成肌肉生长的基础。第一，肌肉必须受到刺激才能增大，但是，那个刺激必须在自然状态下被合成代谢。这个合成代谢刺激可能与抗阻训练中的负重次数及相关的神经激活有关。第二，增大肌肉需要能力和新蛋白生长的原材料。人体需要碳水化合物、蛋白质和脂肪以修复和重建肌肉。因此，每天的饮食模式（包括健身锻炼后营养物质的摄入时间）、适当的睡眠以及健康的生活方式，都对肌肉的修复以及肌肉生长有着重要影响。如果这两个原则中的任意一个被忽略，那么肌肉就无法简单地调整优化成所需的增大肌肉。 肌纤维数量决定了整块肌肉的绝对生长能力，纤维类型影响生长速度以及其他生理功能，不同身形的个体具有不同的肌肉含量，这些身形右三类：外胚型（瘦型体质）、内胚型（胖型体质）和中胚型（运动员型体质）。外胚型的人以较少肌纤维和较低脂肪含量为典型，中胚型以较多肌纤维和较低体脂为典型，内胚型有较高体脂，但可能是潜在的中胚型或者外胚型。因为抗阻训练和固定的营养摄入习惯会减少体脂含量，所以体形间的转变也是清晰可见的，多数人都是两种体形的混合体（比如，中胚型-内胚型或内胚型–外胚型）。 现有的研究表明，增加肌纤维的数量是不可能的，因此个体是无法从外胚型转变成完全的中胚型。但是，内胚型经过训练也能够使肌肉力量、爆发力以及线条得以展现。经过精心设计的递增负荷抗阻训练能够优化人体体形。 无论你是拥有私人教练，还是自己设计抗阻训练计划，只要想促使肌肉生长，你都要将这三件事熟记于心：肌肉收缩方式、运动强度和运动量、间歇时间长短。对于肌肉收缩方式，需要向心和离心都参与，训练计划中，小于等于10RM的负荷通常用于较重的锻炼项目，目的在于增大肌肉围度及增强肌肉力量。与使用重负荷和较长间歇时间（3分钟的训练相比）（Kraemer etal., 1990, 1991），较短间歇时间（1到2分钟）可用于调整高强度和大运动量的训练，从而引发对合成代谢激素更精确的反应。较短间歇时间（低于1分钟）与更强的代谢性应激相联系（如血液中高水平的乳酸）。 ","date":"2021-04-12","objectID":"/2021/strength-training/:1:1","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"2. 训练计划的制定 想增加肌肉力量的人和想增加肌肉耐力的人的训练计划是不一样的，此外，为了达到训练目标，训练计划还必须考虑个体的差异，如训练经验、训练时间、训练设施、身体情况以及个体的任何特殊需要。但有一些原则是通用性的： 肌肉只有经过训练刺激才会做出适应和变化； 肌肉的锻炼也符合一般适应综合征的三个阶段：1）警觉期，由生理应激引起（如抗阻训练）；2）抵抗期，机体开始适应需求；3）衰竭期，过度训练造成； 训练强度应逐步提高。力量训练的基本原理是对肌肉的刺激以及人体对这种刺激的适应，当训练水平提高时，原有的训练计划或动作对身体产生的影响将逐步减弱，因此训练的强度应当逐步增加，增加的方式包括提高训练重量、增加训练组数、增加重复次数和减少休息时间等。另外，改变训练动作或者调整动作的顺序，也可以打破身体对原有训练模式的适应。 训练的优先次序：要使身体每个部分都被充分锻炼是很困难的。因此，每一训练周期都应集中注意优先发展训练目标。 当健身者达到某一特定目标后，由于基础代谢已经足够大，只需要很少的努力，就可以保持身材以及训练水平，此时可以适当减小训练强度。但减小训练强度不意味着停止，一旦训练停止或训练强度无法达到维持训练水平的标准，肌肉力量或围度就会停止增加，甚至开始后退。 任何一个合理的力量训练方案应由许多变量组成，包括所选择的动作练习、练习的先后次序、练习的强度或负荷、练习重复的次数和组数以及练习的休息时间间隙，我们可以通过下面的图一窥一二 ","date":"2021-04-12","objectID":"/2021/strength-training/:2:0","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"2.1 练习方式 应当首先确定自己想从抗阻训练方案中得到何种益处，然后再针对所需肌群和关节角度选择练习方式，与单关节练习相比，多关节练习需要进行更长时间的基础学习，但多关节练习激活的肌肉组织、激素反应以及新陈代谢都远高于单关节练习。 ","date":"2021-04-12","objectID":"/2021/strength-training/:2:1","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"2.2 练习次序 练习的先后顺序安排不同会影响训练的效果，多数专家认为先锻炼大肌群能给涉及的肌肉提供更好的训练刺激，主要有两个原因。一是训练大肌群会刺激更多的神经、新陈代谢、内分泌激素和循环反应，这有可能增强后续肌肉的训练，二是运动初期是训练个体体力最充沛的时候，应该进行那些涉及多种类、多数量肌肉的练习。下面是一些常用的训练顺序： 先大肌群，后小肌群； 先多关节运动，后单关节运动； 全身运动环节中交替进行推拉练习 全身运动环节中交替进行上肢和下肢练习 先进行弱侧练习，然后进行优势侧练习 进行其他类型的练习前首先进行爆发力训练 进行低强度的练习前先进行高强度的练习，尤其是相同肌群连续运动的情况下‘ ","date":"2021-04-12","objectID":"/2021/strength-training/:2:2","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"2.3 强度或阻力大小 确定一项练习最佳阻力的最简便的方法就是看动作能做到的最大重复次数（Repetition Maximum，RM），举个例子，用30kg的重量进行二头肌的弯举训练，当最多只能连续弯举6次就完全力竭，那么这30kg的重量对于该训练者的二头肌练习而言，就是6RM。通常，健身者可以选择一个数值（如10RM）或者一个范围（如3～5RM），然后调整阻力去达到它。 另一种确定阻力的方法就是计算运动过程中最大负荷重量的比重。例如，如果一次运动中最大负荷重量为100磅，按最大负荷重量的80%计算就是举重80磅。这种方法需要你经常记录在每一次举重时所用到的最大力量，然后你就可以适当地调整阻力使其变得更大。 低强度（轻阻力）、多重复次数的训练能够有效地激活Ⅰ型纤维（更适合于肌肉耐力的发展），但是无法充分激活Ⅱ型纤维（主要对最大力量产生和肌肥大起作用）。所以，如果你想将你的力量最大化，就应该增加训练负荷并且减少训练重复次数。如果想要增加肌肉耐力，那么你应该使用较轻的负荷，并多次重复动作 ","date":"2021-04-12","objectID":"/2021/strength-training/:2:3","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"2.4 训练量 训练量等于组数×次数×负荷。研究发现，多组训练的方案设计更有利于增加肌肉力量、爆发力、尺寸和耐力，但对于特定的抗阻训练所需的最佳运动次数没有相关研究。 在训练过程中一直保持相同不变的训练量容易使人感到厌烦而且难以坚持下去。周期性地改变运动量能够使你在长期的训练过程中感受不同的运动刺激，还能够提供休息和肌肉恢复的时间。 ","date":"2021-04-12","objectID":"/2021/strength-training/:2:4","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"2.5 组间及动作练习间休息间歇 组间休息时间决定了三磷酸腺苷（磷酸肌酸能量合成的程度以及血液中乳酸浓度的）产生量，休息时长可明显改变新陈代谢、激素水平和心血管系统对短时间抗阻训练以及对随后组数的反应。 对于使用最大或次最大负荷的结构性动作练习（如深蹲、高翻、硬拉）而言，推荐至少3到5分钟的组间休息时间，而肌肉参与程度较小的练习或单关节练习由于对神经肌肉系统压力较小，只需要较少休息时间（1分钟以下）。另外，对糖酵解和三磷酸腺苷（磷酸肌酸能量系统）增加压力可以促进肌肉增长，因此，如果训练的目的是增加肌肉围度，那么较少的休息时间（低于60到90秒）更为有效。此外，如果训练的目标是要同时增加肌肉力量和尺寸，那么则需要改变组间休息时间，保证运动过程中能够刺激更多合成代谢激素，增加其在血液中的浓度。 ","date":"2021-04-12","objectID":"/2021/strength-training/:2:5","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"3. 训练动作 根据涉及的关节数量，可以将力量训练动作分为多关节动作和单关节动作。多关节动作需要多个肌群协同工作，比如俯卧撑、深蹲、卧推、硬拉等，单关节动作通常只需要一个肌群参与，例如杠铃弯举、哑铃侧平举等，由于只有一个肌群做功，单关节动作使用的训练重量远小于多关节动作。研究表明，减脂期的力量训练动作应以多关节训练动作为主。多关节训练动作可以调动更多肌肉，肌肉调动越多，热量消耗越大，增加肌肉围度则使用单关节训练动作为佳。 如果根据是否负重，可以将力量训练动作划分为徒手训练（Body-weight training）动作和负重训练（Weight training）动作，徒手训练利用自身体重为阻力，而负重训练利用哑铃、杠铃等外部器械。 在我们已经知道了循序渐进等基本原则，也从上一篇几种减脂运动中知道了要组合不同的动作形成组，每个动作重复一定的次数，组间要有休息时间等注意事项之后，接下来最重要的工作就是积累自己的动作库以及学习每个动作的正确姿势，毕竟每个人都有自己喜欢的动作，也有自己不喜欢的动作，我们收集动作的途径主要有如下几个： 书籍：《囚徒健身》等 软件：Keep 健身达人的分享：在Keep的社区、B站、微博、公众号都能找到大量资料，目前比较喜欢的是克里斯 因为喜欢徒手健身，收集的大部分动作都是徒手健身动作，虽然我觉得我喜欢徒手健身很大一部分原因是不想花钱买器械以及器械携带不方便。 多关节动作：触地折返跑、 Burpee，保加利亚深蹲，俯卧撑、跳箱子、澳大利亚引体、弓步、板凳臂屈伸 ","date":"2021-04-12","objectID":"/2021/strength-training/:3:0","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"臀腿 臀腿部的肌肉主要是股四头肌、股二头肌、臀大肌、臀中肌和臀小肌，如下图，腿部肌肉负责膝部运动，臀部肌肉负责髋部运动。 臀腿部分的动作库如下，从上到下动作的难度递增，但同一个节点中的动作难度相同 ","date":"2021-04-12","objectID":"/2021/strength-training/:3:1","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"核心 不同的人对核心有不同的理解，我们这里认为核心是指从胸廓到髋部的这一部分，主要肌肉包括腹直肌、腹内斜肌、腹外斜肌、竖脊肌、臀大肌、背阔肌、腰方肌和腰大肌等。 核心区肌肉的收缩或带动脊椎和骨盆的运动，也是上下肢力量传递的媒介。核心区的训练动作库如下 ","date":"2021-04-12","objectID":"/2021/strength-training/:3:2","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"手臂和胸 肱三头肌、胸：俯卧撑类 肱二头肌：弯举类 ","date":"2021-04-12","objectID":"/2021/strength-training/:3:3","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"肩背 肩：弯举类 背：引体向上类，倒立类、背推 ","date":"2021-04-12","objectID":"/2021/strength-training/:3:4","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"4. 问题 Keep的一个重要作用是训练时间和休息时间的设定，训练动作实际上可以按自己喜好更换 还应当明白每种动作是在训练哪个部位 如何判断什么样的训练强度对自己合适，多少组，每组多少次，什么样的动作 如何确定当前动作对自己的刺激够了，如果进行自我评价 进行动作时如何呼吸 ","date":"2021-04-12","objectID":"/2021/strength-training/:4:0","tags":["健身"],"title":"力量训练","uri":"/2021/strength-training/"},{"categories":["我所热爱的生活啊"],"content":"流行的五种减脂运动：低强度恒速有氧、空腹有氧、HIIT、减脂力量训练、循环训练。来自书籍《本能减脂》。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:0:0","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"1. 低强度恒速有氧训练 以中-低训练强度（恒速）持续进行30-60分钟的有氧运动就叫做低强度恒速有氧训练（LISS），举几个例子 以8-10公里/小时的速度，在跑步机上跑30-40分钟； 以恒定速度，绕操场跑8-10圈； 以恒定速度，骑行5-10公里； 以恒定速度，在椭圆机上运动45分钟； 以恒定速度，蛙泳3000米。 LISS 的理论依据是20世纪90年代初罗梅恩（Romijn）博士等人提出的脂肪燃烧区（Fat Burning Zone）概念。他们发现：当健身者进行长时间的有氧运动时（45~60分钟），如果心率为最大心率（MHR=220–年龄）的65%，脂肪燃烧的比例最大。 LISS的缺点主要有三个 耗时较长（30-60分钟），而且容易对关节产生磨损，选择游泳而不是慢跑可以有效避免这一点。 LISS训练前要注意热身，训练后要注意拉伸，训练中要注意补充足够的水分。 长期进行LISS训练，身体为了加快营养物质在肌肉纤维中的运输速率，可能会使肌肉纤维变小。另外，还有研究表明，马拉松运动员心脏功能障碍和动脉斑块（与中风和痴呆有关）的风险都比较高，过长时间的有氧运动还会降低男性体内睾丸酮激素（雄性激素）含量。 但由于LISS的训练强度较低，运动时心率一般为最大心率的50%~75%，因此适合训练基础薄弱的健身者或孕妇和中老年人等不适合剧烈运动的人，它也是大众健身时会第一时间想到的运动。除此之外，想参加耐力型比赛（马拉松、长跑等）的健身者需要LISS作为日常训练，由于上瘾机制的存在，也有相当一部分人就是单纯喜欢LISS，比如慢跑。但我们需要注意，LISS并不是减脂效果最好的训练，要追求减脂效果更应该尝试后面提到的HIIT和循环训练。 下面是网上的一份海豹突击队16周跑步训练计划，可用于提高心肺功能和耐力，1-9周为第一阶段，10-16周为第二阶段。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:1:0","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"2. 空腹有氧训练 空腹有氧训练（Fasted Cardio，简称FC）即人体在空腹状态下进行的有氧训练，它和LISS唯一的区别就是训练的时机，但它有更好的减脂效果。其基本原理是：在进食状态（人体正在消化、吸收食物的时间段）下，由于血糖升高、胰岛素分泌，人体处于合成代谢状态，脂肪更容易堆积，而在空腹状态下，血糖含量降低，胰岛素回归初始状态，人体会更多的调动脂肪提供能量，此时脂肪更容易被分解，简单的示意图如下。不少研究都证明了这一结论的正确性，比如，发表在《英国营养学杂志》的研究表明，相比在进食状态下运动，在清晨进行空腹有氧运动的受试者，额外燃烧了20%的脂肪。 脂肪在人体各部位的脂肪燃烧速率不同，一些部位的脂肪更容易堆积，也更难被消除，这些部位被称为顽固部位。从生理机制的角度来讲，造成这种现象的原因主要有两个。 α受体和β受体：人体通过儿茶酚胺（一种化学物质）才能达到分解脂肪细胞的目的，基本过程是儿茶酚胺通过血液与脂肪细胞中的受体结合，然后完成分解脂肪和释放能量的过程。脂肪细胞中这种肾上腺素受体有两种：α受体和β受体，β受体被称为“好受体”，它可以促进脂肪燃烧，当儿茶酚胺与它结合后，脂肪细胞就会被调动，为人体提供能量；α受体被称为“坏受体”，它的作用刚好与β受体相反，儿茶酚胺与它结合后，无法调动或分解脂肪细胞。人体不同部位的α受体和β受体含量不同，研究表明，大腿和臀部脂肪中的α受体是β受体的9倍，此外，男性腹部脂肪中含有更高比例的α受体。 血液流通量：人体不同部位的血液流通量有一定差异，血液流通量越大的部位，脂肪燃烧越快，温度越高（臀部或大腿的温度更低）。血液流通能力差主要会造成两方面影响：1）一些血液承担荷尔蒙（例如儿茶酚胺，可以促进脂类分解）很难进入脂肪细胞；2）这些部位的脂肪代谢更加困难。研究表明，进行空腹有氧训练时，腹部的血流量将会得到显著提升，儿茶酚胺更容易与腹部脂肪中的β受体结合，促进腹部脂肪的燃烧。 因此，FC对消灭腹部、腿部等顽固部位的脂肪有很大的作用，同时这也是FC燃脂效果更好的另一个因素，不过要注意，FC不仅加速了脂肪燃烧，也加速了肌肉消耗。 由于FC实际上就是空腹状态下的低强度恒速有氧，因此它们的适用群体没有太大区别，但是，由于空腹状态下人体血糖较低，低血糖、糖尿病患者以及正在进行低碳水饮食的人不推荐进行FC训练。另外，FC最好的训练时机是清晨，考虑到生活习惯及工作因素，有些健身者可能不太方便。 同样，FC的训练计划和LISS也没有太大区别，只是由于此时人体血糖较低，运动时间要做一定的缩短，下面是一些例子 以6-8公里/小时的速度，在跑步机上跑20-30分钟； 以恒定速度，绕操场跑6-8圈； 以恒定速度，骑行5-10公里； 以恒定速度，在椭圆机上运动30分钟。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:2:0","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"3. 高强度间歇训练 高强度间歇训练，也就是我们熟知的HIIT，全称为High-intensity Interval Training，这种训练的核心特征是在训练中进行高强度运动（例如冲刺跑）和低强度运动（如慢走或休息）的交替循环，高强度和低强度运动可以用RPE表格（Rating of Perceived Exertion，自感劳累分级）判定 等级 自我感觉 0 毫无感觉 1 非常轻松 2 轻松 3 感觉适中 4 有点难 5 困难 6 7 非常困难 8 9 10 非常非常困难 身体极限 HIIT减脂的基本原理是EPOCEPOC（Excess Post–exercise OxygenConsumption，运动后过量耗氧），即在剧烈运动后，身体会处于缺氧状态，此时，一些身体指标将处于非正常状态，比如心率、血液温度等，为了将这些指标恢复正常，人体会进行自我调节，包括：平衡荷尔蒙含量、修复肌肉细胞、补充糖原和排除乳酸等，在这一过程中，氧气摄入率和新陈代谢率都会提高。因此，HIIT不仅在运动中消耗能量，同时增加了运动之外20多个小时的能量消耗，而且训练强度越大，人体进行自我调解时消耗的能量就越多，训练后的静新陈代谢会越高，LISS的中低强度运动无法带来EPOC。 除了更高的燃脂效率外，研究还表明HIIT具有一些其它的优点，包括 HIIT可以像LISS那样有效提高心肺能力，同时又不会造成肌肉流失，反而会促进肌肉增长。 HIIT可以增强大脑特定区域的神经反应，抑制健身者的食欲。2014《美国临床营养学》 HIIT可以提高健身者的胰岛素敏感度（+25%），胰岛素敏感度更高，意味着更多的脂肪燃烧、更快的肌肉增长和更小的糖尿病患病概率。2009年瓦特大学 但HIIT也有它的缺点，过高的训练强度使得它的适用性不如LISS，体能或心肺差的健身者、空腹状态、低碳水饮食期间、身体状态较差的时候（过度疲劳、感冒等）都不适合进行HITT训练。 进行HIIT训练最重要的一点是不要让身体适应同一训练强度， HIIT可以以多种方式进行：跑步、骑车、游泳、爬楼梯、跳绳、徒手训练（深蹲、俯卧撑、开合跳等）等，训练时间通常为15~30分钟，可以安排在力量训练后，也可以单独进行。以训练强度区分，HIIT有三种训练模式：标准HIIT、爆发性HIIT和Tabata，训练强度呈递增的关系。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:3:0","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"标准HIIT 在标准HIIT中，高强度和低强度运动的时间比通常为2∶1，高强度阶段的RPE等级应在6~9的范围内，低强度阶段的RPE等级应在1~3的范围内，即低强度运动或完全休息。在刚开始进行标准HIIT时，高强度和低强度运动的时间比可以调整为1∶1、1∶2，甚至1∶3，当训练水平逐渐提高后，再修改这一比例，并延长训练时间。 下面是标准HIIT的一个跑步训练计划，如果是跳绳，可以以30秒为单位。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:3:1","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"爆发性HIIT 爆发性HIIT（Power HIIT）高强度和低强度运动的时间比通常为1∶1（各20秒），使用的训练动作全部为爆发性训练动作，如深蹲跳、Burpee（波比跳）和爆发力俯卧撑等。一套完整的爆发性HIIT训练计划通常包括5~8个训练动作，每个训练动作进行3次循环。 下表是一个使用哑铃的爆发性HIIT全身力量训练计划：A训练做完后，休息1~3分钟，进行B训练，做完后，再休息1~3分钟，进行C训练。全部做完后，若体能允许，再进行1~2次重复。每周进行3次训练，训练一天，休息一天。训练日不宜进行其他形式的力量训练，以防训练过度。训练使用的哑铃重量应当合适，这个合适指的是可以在20秒内较艰难完成的重量，表中的壶铃摇摆可换成哑铃摇摆动作。 除上面的这种训练方式外，也可以进行多天的分离力量训练，比如，训练三天，休息一天。训练日的第一天进行A计划，根据自己的体能执行1~3轮，每轮之间休息2~5分钟，第二天和第三天进行B计划和C计划，同样根据自己的体能进行1-3轮，每轮之间休息2~5分钟。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:3:2","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"Tabata Tabata训练模式由日本科学家田畑泉（Izumi Tabata）博士发明，并以他的名字命名，训练时间为4分钟，高强度和低强度运动的时间比为2∶1，20秒高强度运动与10秒低强度运动交替，共交替8次，这是最高强度的HIIT。Tabata常用动作包括平板支撑、Burpee、深蹲跳、高抬腿和仰卧起坐等。进行Tabata训练时，RPE等级应为9~10。 可以将Tabata训练穿插在常规力量训练中，例如，在背部和肱二头肌训练日，按以下顺序进行训练：背部训练→Tabata训练（1轮，4分钟）→肱二头肌训练。也可以选择2-4个动作，利用Tabata模式训练单独的肌群，每周执行3次，训练1天，休息1天，可以代替传统的力量训练。下面是一个简单的Tabata腹部训练计划。 不过最常见的还是Tabata全身性力量训练，即选择一些全身性的训练动作按Tabata模式进行，比如选择4~8个训练动作，每个动作进行一次Tabata训练，拼接成总时长16~32分钟的完整训练计划。 下表的训练计划中，依次进行A~H训练计划，每个计划之间休息1~3分钟。每周进行3次训练，训练1天，休息1天。训练日不宜进行其他形式的力量训练，以防训练过度。每次训练时，记录每个训练计划所完成的动作次数，在下一个训练日，争取超过该次数。这种训练可以代替传统力量训练，也可以单独进行。 训练计划 时长 高强度与低强度比例 高强度训练动作 低强度训练动作 A 4分钟 2：1 Burpee，20秒 休息，10秒 B 4分钟 2：1 俯卧撑，20秒 休息，10秒 C 4分钟 2：1 深蹲跳，20秒 休息，10秒 D 4分钟 2：1 卷腹，20秒 休息，10秒 E 4分钟 2：1 徒手深蹲，20秒 休息，10秒 F 4分钟 2：1 平板支撑，20秒 休息，10秒 G 4分钟 2：1 开合跳，20秒 休息，10秒 H 4分钟 2：1 登山者，20秒 休息，10秒 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:3:3","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"自己制定训练计划 一套HIIT训练计划包括四大要素：训练模式、训练时间、训练频率、高强度训练和低强度运动时间比。 首先，根据自身调节从下表选择适合自己的训练模式 其次，由于HIIT训练强度过大，训练时间应控制在15-30分钟内。 最后，关于训练频率，研究结果表明，如果想在短时间内快速提高训练水平（心肺功能和耐力等），可以在2~3周内每天进行1次HIIT训练，并在2~3周后恢复常规训练频率（一周3~6次）；如果想以最快的速度燃烧脂肪，每周进行3~6次HIIT训练即可，每周至少留出1天的休息时间。 刚开始进行HIIT时，高、低强度运动的时间比可以设定为1∶2或1∶3，随着训练水平的提高，将这一比例逐渐提高到1∶1、2∶1、3∶1，甚至4∶1。对新手而言，将高强度阶段的时间设定在20~30秒较为合适，在低强度阶段则可以完全休息。当训练水平逐渐提高后，在低强度阶段建议进行动态活动，如慢走等。研究表明，在低强度阶段进行动态活动，而不是完全休息，可以更好地提高心肺功能，促进脂肪燃烧。 另外还要注意，在训练前要充分热身，训练后进行3-5分钟的拉伸，训练中要补足水分。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:3:4","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"4. 减脂力量训练 我们平常听到的泵铁、练腿、练肩等其实都是在谈论力量训练（Strength Training），这是是一种利用阻力引起肌肉收缩，从而促进肌肉力量、肌肉耐力和维度增长的体育运动。虽然力量训练的主要目的大多是促进肌肉生长，但对减脂其实也有一些作用，这是因为 力量训练会促进肌肉增长，肌肉含量越高，基础代谢率就越高，每天消耗的热量就越多，这是一种长效的、也是根本的提高每天消耗的方法； 力量训练可以显著提高EPOC，增加运动后的能量消耗。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:4:0","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"5. 循环训练 循环训练是一种综合训练模式，不同于传统力量训练或有氧训练。进行循环训练时，健身者需要选择N个训练动作，这些训练动作可以是力量训练动作（例如俯卧撑、深蹲），也可以是有氧训练动作（例如跳绳、跑步），接着，按照一定的顺序将这些动作排列在一起，依次进行，每个动作之间不休息或尽量少休息，所有动作完成后算一个循环，根据体能，健身者通常可以进行1~5个循环，每个循环之间休息1-3分钟。下面是一个循环训练计划示例，最近两年大火的CrossFit也属于循环运动的一种。 训练动作 次数 俯卧撑 15 徒手深蹲 15 仰卧起坐 15 循环训练将无氧运动和有氧运动结合在一起，不仅可以增加肌肉力量，塑造优美的肌肉线条，还可以提高肌肉耐力和心肺功能。它可以帮助健身者在最短的时间内增强体能，改善体型，是最高效的减脂训练，也非常适合突破平台期，减去顽固部位的脂肪。但和HIIT一样，循环训练强度较高，不适合空腹状态和身体状况较差的时候（过度疲劳、感冒等）进行。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:5:0","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"自己制定训练计划 训练动作的选择 循环训练的动作以多关节力量训练动作（例如俯卧撑、Burpee）和有氧训练动作（例如跳绳、跑步）为主，下面是常见的训练动作 训练部位 动作 上肢 俯卧撑、爆发力俯卧撑、击掌俯卧撑、杠铃卧推、杠铃推举、哑铃推举、引体向上、杠铃划船 下肢 深蹲、箭步蹲、深蹲跳、箭步蹲跳、团身跳、跳箱子 腹部 仰卧起坐、卷腹、悬垂举腿、平板支撑、登山者 全身 Burpee、壶铃摇摆、硬拉、开合跳 有氧 跳绳、跑步、划船机、动感单车 训练重量和重复次数 力量训练动作有3种选择方案：1）每个动作做到力竭，然后进行下一个动作的练习；2）每个动作做够一定的重复次数，然后进行下一个动作的练习，推荐重复次数为5-50次（训练重量相应调整）；3）每个动作做够一定的时间（0.5-3分钟），进行下一个动作的练习，如进行1分钟俯卧撑，然后进行1分钟深蹲。 有氧训练动作有2种选择方案：1）每个动作做够一定时间（5-15分钟），进行下一个动作的练习，如跑步10分钟，然后进行10次俯卧撑；2）每个动作做够一定的次数（100-500次）或公里数（1-3公里），进行下一个动作的练习，例如跑步1公里，然后进行100次跳绳。只要符合训练训练的核心原则，完全可以自行调整训练重量和重复次数，例如进行100次俯卧撑，然后进行100次深蹲，或跑步5公里，然后跳绳3分钟。 时间安排 循环训练需要的时间不多，因此时间安排比较灵活，常见的有以下几种，但不拘泥于此 以循环训练的模式进行独立训练。若循环训练的时间小于30分钟，一天可以进行1~3次训练，每周训练3~5天；若循环训练的时间大于30分钟，一天可以进行1~2次训练，每周训练3~5天。每天的训练总时长不宜超过90分钟。 在常规力量训练后，进行20~30分钟循环训练，代替LISS或HIIT。 在循环训练后，进行20~30分钟LISS或HIIT。 在制订循环训练计划时，只要总体原则不变，任何变化都是允许的，包括训练动作的种类、数量、重复次数、每轮之间的休息时间等。经常自我制订不同的训练计划，可以让运动过程变得有趣，也可以防止身体对训练产生适应性，进入平台期。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:5:1","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"示例训练计划 交替循环训练 选择两个力量训练动作交替进行，如 两个上肢训练动作，如引起向上和俯卧撑 两个下肢训练动作，如深蹲和箭步蹲 一个上肢动作和一个下肢动作，如俯卧撑和深蹲 两个全身性动作，如Burpee和壶铃摇摆 也可以选择两个有氧动作交替，以循环训练的模式进行，如 当然，一个力量训练动作和一个有氧训练动作是最好的，如 1个有氧动作和1个刺激特定部位的力量动作，如跳绳和卷腹 1个有氧动作和1个全身性动作，如跑步和Burpee 下面是一些示例 标准循环训练 选择3个及以上的训练动作，制定一套完整的循环训练计划，由于可选的动作非常多，所以训练计划各异，看自己喜好。 一种是分肌群的，如下面的示例包括了所有的腹部肌群，可以替代常规的腹部力量训练 一种是挑选的动作分别刺激身体各部位，如下 也可以选择力量和有氧结合，趣味性更强，燃脂效率更高 也可以采用上下肢分离训练方案：周一、四进行方案A，周二、五进行方案B，周三、六、日休息。选择一次性最多可以完成15~20次的训练重量，训练过程中，训练重量尽可能不变或小幅度降低。 EMOM循环训练 EMOM循环训练是时间效率最高的循环训练模式，使用EMOM循环训练，健身者在10~30分钟内就可以彻底耗尽体能，在训练中和训练后消耗大量脂肪。EMOM为EveryMinute on the Minute的缩写，指在每分钟内，完成规定训练，休息，直到下一分钟来临，继续训练。例如，在1分钟内进行5个俯卧撑和10个开合跳，完成后，休息片刻，等到下一分钟来临后，继续进行5个俯卧撑和10个开合跳。每1分钟都包括了训练和休息时间，训练时间越短，休息时间越长。由于健身者只有1分钟的训练和休息时间，所以每分钟的训练总次数不宜过多，通常在5~15次。进行EMOM循环训练时，建议选择能够刺激全身各肌群的力量训练动作。 海豹突击队PT训练计划 周一、四进行方案A，周二、五进行方案B，周三、六、日休息。进行深蹲跳时，若一次性无法完成规定次数，可以分多次完成。 ","date":"2021-04-08","objectID":"/2021/five-types-of-fat-loss-exercises/:5:2","tags":["健身"],"title":"五种减脂运动","uri":"/2021/five-types-of-fat-loss-exercises/"},{"categories":["我所热爱的生活啊"],"content":"介绍热身与拉伸的相关知识，来自书籍《本能减脂》。 ","date":"2021-04-04","objectID":"/2021/warm-up-and-stretch/:0:0","tags":["健身"],"title":"热身及拉伸","uri":"/2021/warm-up-and-stretch/"},{"categories":["我所热爱的生活啊"],"content":"1. 热身 ","date":"2021-04-04","objectID":"/2021/warm-up-and-stretch/:1:0","tags":["健身"],"title":"热身及拉伸","uri":"/2021/warm-up-and-stretch/"},{"categories":["我所热爱的生活啊"],"content":"益处 无论选择什么运动，训练前必须热身，其益处包括 可以逐渐提高中枢神经系统的兴奋性，克服机体惰性，保证体能的正常发挥 可以提高肌肉和关节韧带的弹性，降低粘滞性，使关节腔内滑液增多，预防肌肉和韧带拉伤 提高心率，促进血液循环，提高氧气和其他营养物质的输送率，促进乳酸等代谢废物在运动过程中排出， ","date":"2021-04-04","objectID":"/2021/warm-up-and-stretch/:1:1","tags":["健身"],"title":"热身及拉伸","uri":"/2021/warm-up-and-stretch/"},{"categories":["我所热爱的生活啊"],"content":"注意事项 正确的热身可以提高心率和体温、放松肌肉，防止运动损伤，错误的热身则会耗费身体的能量储备，影响锻炼效果，因此热身有一些要点，包括 热身准备的强度不应过大。正确的热身可以提高体温，使身体微微出汗，但不会导致身体疲劳； 热身应包括拉伸练习，有助于放松肌肉； 热身的时间不应超过10~15分钟。 ","date":"2021-04-04","objectID":"/2021/warm-up-and-stretch/:1:2","tags":["健身"],"title":"热身及拉伸","uri":"/2021/warm-up-and-stretch/"},{"categories":["我所热爱的生活啊"],"content":"正确步骤 最后，正确的热身方式分为三步 第一步：全身性热身 全身性热身（Full-body Warmup）有助于提高心率和体温，增强氧气和其他营养物质的输送率。常见的全身性热身包括慢跑、快走、骑车（动感单车）、划船（划船机）、跳绳和爬楼梯等。全身性热身的强度应较低，时间以3~5分钟为宜。 第二步：拉伸 拉伸（Stretching）有助于放松肌肉，增强肌肉的功能性，防止运动损伤。拉伸可以在训练前、训练中和训练后进行。在理想状态下，健身者应该拉伸全身所有的肌群，如果时间不允许，至少应该拉伸目标肌群（在训练中将会调动的肌群）。 第三步：小重量练习 在正式的负重训练开始前，健身者应该进行小重量练习（Lighter Versions of the Exercises）。例如，在进行杠铃卧推前，使用小重量（正式训练重量50%左右的重量）进行2~3组的热身训练（每组12~15次重复），对防止运动损伤极有帮助。 ","date":"2021-04-04","objectID":"/2021/warm-up-and-stretch/:1:3","tags":["健身"],"title":"热身及拉伸","uri":"/2021/warm-up-and-stretch/"},{"categories":["我所热爱的生活啊"],"content":"2. 拉伸 拉伸是健身运动最重要的组成部分之一。对健身者而言，拉伸主要会刺激两类结缔组织：筋膜和肌腱/韧带。筋膜是包裹肌肉的外壳，拉伸可以软化筋膜，促进肌肉增长；肌腱和韧带是人体重要的结缔组织，拉伸可以扩大肌肉和肌腱的收缩范围，防止运动损伤，促进力量增长。此外，拉伸还具有缓解肌肉酸痛、防止肌肉疲劳、放松身心、缓解压力的功效。 注意，训练前肌肉在冷却状态下不宜拉伸，在拉伸前应进行3~5分钟的全身性热身。 ","date":"2021-04-04","objectID":"/2021/warm-up-and-stretch/:2:0","tags":["健身"],"title":"热身及拉伸","uri":"/2021/warm-up-and-stretch/"},{"categories":["我所热爱的生活啊"],"content":"静态和动态拉伸 拉伸可以分为静态拉伸和动态拉伸。静态拉伸是健身者最常用的拉伸方式，它的方法非常简单，保持某一拉伸姿势不动，维持15~30秒，接着休息片刻，再进行下一次静态拉伸。静态拉伸有助于放松和冷却肌肉，适合在训练后进行。在训练前或训练中进行静态拉伸，会降低运动水平，影响训练效果。动态拉伸，顾名思义就是在拉伸中保持动态。动态拉伸可以帮助健身者保持更高的核心体温，有助于增强身体的灵活性，防止运动损伤，适合在训练前和训练中进行。腿部摇摆是典型的动态拉伸动作，即有控制、缓慢地前后摆动腿部。 ","date":"2021-04-04","objectID":"/2021/warm-up-and-stretch/:2:1","tags":["健身"],"title":"热身及拉伸","uri":"/2021/warm-up-and-stretch/"},{"categories":["我所热爱的生活啊"],"content":"常见拉伸动作 常见的拉伸动作包括 胸部-静态拉伸：右手抓住一直立杆，身体向左前方轻微旋转，直到胸部有明显的拉伸感，保持该姿势10秒，接着换另一侧。 胸部-动态拉伸：站姿，双脚站距与肩同宽，手臂在身体前方完全伸直，双手触碰在一起，保持手臂伸直，向后方摆动双臂，直到胸部有明显拉伸感，接着回到初始位置，进行下一次重复，摆动速度由慢变快。 背部-静态拉伸：站姿，双手抓住一横杆，双手握距比肩稍宽，手臂完全伸直，保持背部平直，向下方俯身，直到背部有明显的拉伸感，保持该姿势10秒，休息片刻，进行下一次重复 肩部-静态拉伸：左手臂伸直，横放于身体前侧，用右手稳定住左手臂肘部，向胸部方向按压，保持该姿势10秒，然后换另一侧 肩部-动态拉伸：站姿，手臂在身体两侧完全伸直，与地面平行，先向前缓慢地旋转手臂10次，再向后缓慢地旋转手臂10次，旋转速度约为1秒/次。 肱二头肌-静态拉伸：右手向后方抓住一直立杆，拇指向下，右手臂与地面呈40°~45°角，保持手臂伸直，向左侧弯曲身体，直到肱二头肌感觉到明显的拉伸感，保持该姿势10秒，换另一侧 肱三头肌：站姿，弯曲右手臂，将右手放在背部正中间，左手放置于右手臂肘部，向下按压右手臂肘部，直到肱三头肌有明显的拉伸感，保持该姿势10秒，换另一侧。 股四头肌-静态拉伸：站姿，保持背部平直，弯曲左腿，将左手放在左脚前脚掌上，左手用力，向后方轻微拉动腿部，直到大腿前侧有明显的拉伸感，显 股四头肌-动态拉伸：勾腿跳 股二头肌-静态拉伸：站姿，将右脚脚后跟放置于身体前侧，左腿弯曲，将双手放在右脚脚踝处，保持右腿伸直，向下俯身，直到大腿后侧有明显的拉伸感，保持该姿势10秒，换另一侧。 股二头肌-动态拉伸：前后摆腿。 小腿：静态拉伸：将右脚脚后跟放在台阶上或较高位置，身体前倾，用左手抓住右脚脚趾，重心稍向左腿移动，右手放在右侧大腿上，左手用力，将右脚脚趾拉向膝盖方向，直到小腿有明显的拉伸感，保持该姿势10秒，休息片刻，进行下一次拉伸，每条腿拉伸3~5次。 ","date":"2021-04-04","objectID":"/2021/warm-up-and-stretch/:2:2","tags":["健身"],"title":"热身及拉伸","uri":"/2021/warm-up-and-stretch/"},{"categories":["我所热爱的生活啊"],"content":"这一篇主要认识手臂和腿部的肌肉和骨骼。 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:0:0","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"1. 上肢 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:1:0","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"1.1 骨骼 上臂为肱骨 前臂为桡骨与尺骨，桡骨在外，尺骨在内。 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:1:1","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"1.2 肌肉 手臂的主要肌肉如下图 肱肌 肱肌始于肱骨前面（下半部），止于尺骨冠突前面，作为肘部最直接的屈肌，它的收缩可从前部肱二头肌下方看到。当肘屈时，前臂旋前。 肱桡肌 肱桡肌起于肱骨外侧缘（下方1/3处），沿前臂走行最后止于桡骨茎突，作用是使肘关节屈，旋前或旋后开始时，它使前臂处于居中位置。 肱二头肌 肱二头肌有两个头，短头始于喙突，长头从上面跨越关节囊，沿结节间沟下行，和短头合并止于肘关节下的桡骨粗隆，其功能是使肘屈及旋后。 肱三头肌 肱三头肌有三个头，一个始于肩胛骨，两个始于肱骨后面，三个头最终合为一条宽且扁的肌腱，止于鹰嘴上面。肱三头肌的作用是使肘关节伸。 肘肌 肘肌属于小型肌肉，始于肱骨，止于尺骨后面（上部1/4处），它参与肘的伸展，旋前运动时作用于尺骨。 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:1:2","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"1.3 手臂的运动 肘关节具有双重功能，一方面，它能使上肢并拢或伸直，从而缩小或者增大肩关节与手之间的距离。例如：当肘关节屈时，手可上举至头顶、嘴部；当肘关节伸时，手可伸至远离肩关节的身体部位或物体边。此时，肘关节为屈伸关节，图示如下。 肘关节还能使前臂以它为纵轴转动，即旋前与旋后，图示如下，值得注意的是，前臂的旋前旋后要在屈肘角度下研究，否则容易和肩关节的运动混淆。 旋前的肌肉包括旋前圆肌，旋前方肌以及肱桡肌，附着于三块骨头，如下图 旋后的肌肉包括肱二头肌、肱桡肌和旋后肌，附着于四块骨头，如下图 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:1:3","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"2. 下肢 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:2:0","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"2.1 关节 髋是下肢的近端关节，连接了股骨与骨盆，髋部肌肉的稳定性与力量是人体保持直立行走的必备条件。 膝是下肢中部的关节，具有很强的屈、伸能力，这使得它能大幅改变足与躯干之间的距离。膝盖骨骼的稳定性比较弱，主要由韧带与肌肉系统对其进学校加固。 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:2:1","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"2.2 骨骼 股骨为长骨，和肱骨有相似之处 髌骨是位于股骨底前方，镶嵌在股四头肌腱内的一块小骨，它的主要功能就是保护股四头肌腱。股骨与髌骨构成股髌关节，股骨和胫骨构成股胫关节，但髌骨和胫骨并不直接接触 膝关节的三块骨位于同一关节腔，内有滑液流动 小腿骨包括腓骨和胫骨，它们均为长骨 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:2:2","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"2.3 肌肉 臀中肌 臀中肌呈宽大的扇形，起于髂窝外侧中部，肌纤维在大转子处汇合，止于大转子外侧面。若髂骨固定，它的主要功能是使髋关节外展。 臀小肌 臀小肌起于髂窝外侧，位于臀中肌前方，止于大转子前面，功能和臀中肌类似。 股四头肌 股四头肌分四束，止于一条共同肌腱，该肌腱包围髌骨，附着于髌骨上形成髌腱，最后止于胫骨粗隆。 若骨盆固定，它可使髋关节屈和伸膝，如行走，若股骨固定，它可使骨盆前倾同时伸膝。 缝匠肌 腘绳肌 大腿后部有三块肌肉组成股后机群，称为腘绳肌，这些肌肉均起于坐骨，经过髂骨后部，最后止于小腿骨 腘绳肌均为多关节肌，当髂骨固定时，它们的主要作用是使股骨伸。 臀大肌 臀大肌为人体最大且最强劲有力的肌肉之一，位于两个平面上：深面和浅面。它起于骶骨、尾骨背面、髂窝外侧（后部），深面止于股骨粗线（上部），浅面止于阔筋膜。 臀三角肌 膝部肌肉 小腿三头肌 为小腿上最有力的肌肉，由三个肌腹（“头”）组成，走向同一个止点：跟腱。 跟腱附着于跟骨的后面，腓肠肌参与膝关节的屈运动。所以，它们对膝部与足后部起着连接作用。 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:2:3","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["我所热爱的生活啊"],"content":"2.3 运动状态下的肌肉 髋部 膝部 行走 ","date":"2021-03-31","objectID":"/2021/notes-on-sports-anatomy-4/:2:4","tags":["健身"],"title":"运动解剖学学习笔记3-四肢","uri":"/2021/notes-on-sports-anatomy-4/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第十五期。 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["日程及周刊"],"content":"时讯 1、土耳其金融震荡 03.22 当地时间22日凌晨，土耳其里拉对美元汇率暴跌，跌幅一度达到15%。创下了自2018年8月以来的最大跌幅。分析人士称，土耳其原央行行长阿巴尔遭解职是里拉暴跌的主要原因。上午，伊斯坦布尔交易所开盘后大跌6.65%，触发熔断机制，10:30股市恢复交易后，继续大跌再次触发熔断。 此外，土耳其的食品价格持续上涨，过去一年鸡蛋价格几乎涨了一倍，市民现在买菜茄子都只能论根买。 2、反仇视亚裔游行 03.22 当地时间3月16日，亚特兰大发生连环枪击案，造成8人丧生，其中6人为亚裔女性，在警方对嫌疑人略有偏袒的情况下，自新冠疫情以来亚裔受到暴力迫害的情绪产生了爆发，从3月20日起，包括亚特兰大、洛杉矶、芝加哥、华盛顿、纽约等50多个城市都出现了反歧视亚裔的游行，随后，加拿大的温哥华、蒙特利尔等城市也爆发游行，并受到国际关注。 3、苏伊士运河巨轮搁浅 03.23 当地时间23日，中国台湾长荣海运公司旗下的巨型货轮“长赐”号（Ever Given）在埃及苏伊士运河新航道搁浅，导致运河双向堵塞断航，主要原因是狂风与沙尘暴影响，到28号，巨轮仍未脱离，对亚欧贸易线产生了重要影响。 4、国新办发表《2020美国侵犯人权报告》 03.24 国务院新闻办公室今天（24日）发表《2020年美国侵犯人权报告》，对美国侵犯人权的状况进行揭露。报告分为序言、疫情严重失控酿成人间悲剧、美式民主失序引发政治乱象、种族歧视恶化少数族裔处境、社会持续动荡威胁公众安全、贫富日益分化加剧社会不公、践踏国际规则造成人道灾难，全文约1.5万字。2020年美国侵犯人权报告（全文） 最近一段时间，不仅中国和西方国家之间明争暗斗、局势紧张，俄罗斯同样如此，双方在外交、经济以及军事等多领域展开了激烈交锋，26日， 俄罗斯外交部发言人扎哈罗娃再次对近期一些西方国家涉及俄罗斯的无端指责进行批驳，强调俄罗斯反对将人权问题政治化。 5、全球食品价格上涨 03.24 国际上食品价格上涨的新闻以及屡见不鲜了，美国肉类由于饲料价格上涨而随之升高，韩国大葱的平均零售价每公斤高达7400韩元、约合人民币43元，部分民众无奈在家种葱，尼日利亚的食品通胀率已经创下15年来新高。据联合国粮农署发布的报告，今年2月，全球食品价格连续第9个月上涨，其中食糖和植物油价格涨幅最大，食糖价格环比上升6.4%，植物油价格指数环比上升6.2%，达到2012年4月以来的最高水平，乳制品、谷物及肉类价格指数分别环比上升1.7%、1.2%和0.6%。 发改委称国际粮价上涨目前不会对国内市场产生较大影响。 6、埃及发生两列火车相撞 03.26 当地时间3月26日，埃及卫生与人口部官方发言人穆贾希德说，索哈杰省塔赫塔地区发生的两列火车相撞事故，导致32名公民死亡，受伤人数增加至165人。参与救援的救护车也已增加到74辆。 7、新疆棉花遭抹黑 03.27 由国外服装企业H\u0026M的一份“停用新疆棉花”的声明引发的在国内舆论和外交上引发了大量风波，国内多个电商已下架相关产品，明星代言人也断掉合约，官方开始普及新疆棉花的机械化生产过程。27日，外交部宣布针对美国、加拿大基于谎言和虚假信息于3月22日对中国新疆有关人员和实体实施单边制裁的行径，中方决定对美国国际宗教自由委员会主席曼钦、副主席伯金斯，加拿大联邦众议员庄文浩、众议院外委会国际人权小组委员会实施制裁。在22日和26日，外交部还分别宣布了针对欧盟和英国的制裁决定，共19名人员、8个实体和机构受到制裁。原因是在新疆问题上恶意传播谎言和虚假信息。这是对欧盟和英国以所谓新疆人权问题为借口对中国制裁的回应。 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["日程及周刊"],"content":"小事 1、03.23，关于图片的相关知识总结 2、03.24，毕业论文第二次修改完成 3、03.24，晚饭在一餐的韩料窗口吃的肉松紫菜包饭，很好吃 4、03.25，衣物更新换代计划整理，确定了今年还需要买的衣服 5、03.25，少数派私信有个找写软文的，加了微信，软件是 Effie，但以目前来看还不够完善，起码我没法日常使用，所以拒绝了 6、03.25，购买了毛球修剪器，选了半天买了小米，除了清理不方便，其它方面还行 7、03.26，研究课题中发现的未来可做的工作总结完成 8、03.28，健身系列之《运动解剖学》学到了第3章 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["日程及周刊"],"content":"文章 1、央视新闻，丢过身份证的，这几点一定要重视 2、少数派，2020，一场与不确定性的大型拥抱 看一看别人人生的意义，大概就是给自己一点参考吧。 3、IT之家，这个 90 后办了一家帮年轻人 “规划身后事”的网站，拿到 1500 万融资 即使年轻，也要想好自己身后的事情，谁知道会出什么意外呢 4、沙丘研究所，「技艺人」的自由与现代人的厌倦：从播放量超过 2 亿的建造视频聊起 详解集中视频火爆的原因 5、少数派编辑部，从房源选择到好物分享，给准备租房的你一些小建议 租房问题，找个时间系统总结一下，这里就是很好的参考 6、经济观察报书评，人口红利与人口陷阱：内卷的经济学解释 7、海外学区房揭秘:英美“马太效应”显著 德国如何杜绝学区房困境？ 德国的教育制度值得参考 8、我找到了100只丢失的猫，窥见了100个年轻人的故事 有谁活着容易呢，所以为什么还要把下一代带到这个世界 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["日程及周刊"],"content":"剧集 1、日剧《钱断情始》 受极简群里的人推荐，但最后被男主治愈，不过，果然只有在日剧里一切才是美好的，现实更残酷，剧都没拍完男主自杀了。 2、美剧，漫威的《旺达幻视》 本来打算下周一周看完，结果短短两天看完了，编剧真的很厉害，五星。 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["日程及周刊"],"content":"摘录 1、B站评论区：我们的教育生产理想主义者，再由现实击碎他们的幻想，并将这种重塑称之为成长。每当我回顾我所接受的教育，我总感觉到被欺骗的愤怒，到现在还是无法释怀。 下面有回复：我觉得前人教育我们理想主义是想让我们即使见到世界是如何残酷现实，也不要忘了我们心中还有理想和希望吧。如果一开始就教育我们什么是现实，什么是利己，那中国不会发展成为现在的样子，有些事情对比国外应该可以很清楚的感受到。我觉得之所以痛苦的原因是，你不是纯粹的理想主义，然后你现实的也不够彻底。你在两者间反复，就像晚上睡不着的你找不到能让你舒服睡着的姿势，怎么做都不能让你安宁。 2、少数派文章，人是有多面的。你的计划面对的，是一个偶然情绪高涨的自己，你也考虑考虑那个情绪不咋地、学习兴趣一般般、甚至有些时候只想做咸鱼的自己吧！ 3、柳婼大神的博客，我发现那些稍微准备就去干的人和非要准备充分才去行动的人最大的区别就在于对人生的认知不同。前者认为人生是各种体验的集合，后者认为人生是各种成功的档案。因此前者往往充满活力和冒险精神，充满勇气和自信。注重过程，乐于接受变化和挑战，不惧怕失败，情绪乐观，面对失败也较轻松和正面，觉得至少能收获一份经验。这样的人常常大胆尝试，敢于打破规则，愿意去做许多未知的事情；后者则畏首畏尾，缺乏勇气和自信，全然以目标为导向。害怕变化和挑战，也非常害怕失败，只要一失败简直会要了他的命，压力沉重，甚至陷入无法自拔的沮丧和毁灭之中，这样的人因为很多的不敢为，所以经历的事情也比较少，囿于自身思维中的各种限制，躲在自己认为的安全区中。 4、如果遇到一个问题，想用技术手段来解决，这背后的思维是：默认技术是一种用最低成本最高效率解决问题的手段。这背后是关于效率和速度的崇拜，或者说对这两者优先考虑。“﻿如果用效率优先和速度优先的思维，就不可能考虑用技术手段来解决一个低效率的问题，更不会考虑用一个非技术的方法来解决。”邢麟舟说，比技术更重要的，是思维认知。 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["日程及周刊"],"content":"知识 1、﻿巴纳姆效应（Barnum effect）”。这是1948年由心理学家伯特伦·福勒（Bertram Forer）通过试验证明的一种心理学现象：当用一些笼统的、含糊不清的形容词来描述一个人或事的时候，人们往往很容易就会接受并相信这些描述，也就是我们常说的“对号入座”。这一现象常出现在一些模棱两可的性格测试或人格分析中，当然，人们搜索病症时的焦虑部分也源于此。 2、QQ或微信的账户所有权是腾讯，意外身亡里面的资金可能无法返还给亲人 3、《科幻世界》，国内科幻的重要刊物，大刘的《全频带阻塞干扰》即来自于此 4、中国也有火山，并且还很多。典型实例有吉林的长白山、黑龙江的五大连池和镜泊湖、内蒙古的阿尔山、广东和海南的雷琼火山群、山西的大同火山、云南的腾冲火山、台湾的基隆火山和大屯火山等。 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:3:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["日程及周刊"],"content":"思考 1、用数据来量化生活可能造成更大的焦虑，比如手环的睡眠监测。 2、看剧时可以打开笔记本，随时在上面记录自己的想法 3、媒体的甚至其他任何人的话只能信一部分，可能是刻意只让你看到想让你看到的，比如《旺达幻视》里天剑局长欺骗杰拉尔丁，也可能是他们的认知不完善 4、国家和法律是为了保护弱势群体的利益，不是为了富人服务 5、什么是喜欢，就是只要和她在一起就开心 ","date":"2021-03-28","objectID":"/2021/life-weekly-15/:3:5","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 15 期 (20210328)","uri":"/2021/life-weekly-15/"},{"categories":["我所热爱的生活啊"],"content":"本篇认识躯干部分的骨骼和肌肉，包括脊柱、骨盆、肩胛骨，以及肩、胸、腹部的肌肉。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:0:0","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"1. 脊柱 躯干的运动以及躯干对神经所起的传导作用都与脊柱密切相关，因此先从脊柱开始看起。 脊柱是由很多骨骼组成的管状结构，从上到下分为颈段、胸段、腰段、骶骨和尾骨五部分，如下图所示，总体来看，脊柱一共有四个生理弯曲，颈曲凸向前，胸曲凸向后，腰曲凸向前，骶曲凸向后，从上到下，呈一种逐渐增大的态势。 组成脊柱的主要骨骼是椎骨，由两个主要部分组成：椎弓和椎体，结构如下图所示。各椎骨之间通过三个关节相连，椎体部分通过椎间盘相连，椎弓部分则通过两个对称的关节突关节相连。 椎间盘在运动中起着缓冲器的作用，由外层犹如洋葱片一样呈同心圆状排列的纤维环和中心含水较多（实际上是胶状黏液）的髓核组成。我们做不同方向的运动时，髓核的状态如下图所示，任意方向的运动都会使髓核向相反方向滑动，此时纤维化呈紧张状态，如果长时间维持该状态，就可能致使纤维环老化并出现裂缝，髓核得液体就会由裂缝中流出，这就是椎间盘突出。可以注意到，椎间盘的位置使得它无论处于静止还是运动状态，都容易出现被过度挤压的情况，典型的如平时弓着腰久坐，后者俯身搬东西。 脊柱上有三条长韧带，如下图所示，为连续的带状结构，始于枕骨，止于骶骨，其它的韧带则都是不连续的，逐层分段附着在相邻椎弓的突起上面，上图中髓核受到挤压时，前纵韧带、后纵韧带和棘突上的韧带都会随之被拉紧或松弛。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:1:0","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"2. 骨盆 骨盆是个环状骨质结构，由三部分组成：位于后部的骶骨、左右两块髋骨和一小节尾骨。 髋骨实际上到了成年期才会成型，成年期之前，其位置是髂骨、坐骨和耻骨三块骨头。从下图中我们可以认识髋骨的几个特征点，一个是最外层上缘的髂嵴，髂嵴最前部的髂前上棘甚至可以用手直接摸到，另一个是两块耻骨中间的一个关节，叫做耻骨联合，这个关节可以轻微的运动，比如滑动或扭转，妇女分娩时耻骨联合也可以轻度分离。还有一件事，男性与女性的骨盆是有一定差异的，男性的骨盆偏窄，女性的骨盆偏宽，所以在医疗技术不发达的古代用骨盆来判断女性是否容易生育还是有一定道理的，当然，现在就不需要抱有这种偏见了。 骶骨位于骨盆后部正中央，即两块髋骨之间，它呈倒三角形，由五块椎骨合并而成，脊柱部分已经见到过它。 尾骨是个三角形的小骨，由3-5块尾椎融合而成，但一般已经不能清晰的分辨出每块尾椎。 骶骨和髂骨都有两个耳状面，骶髂关节在此形成，使得我们可以做各种运动，同时，骶髂关节周围也有关节囊和韧带的保护。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:2:0","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"3. 肩部关节与骨骼 由于肩部承担的主要作用是连接上肢和胸廓，因此肩部主要由三个关节组成：连接肩胛骨和锁骨的肩锁关节，连接胸骨和锁骨的胸锁关节，以及连接肱骨和肩胛骨的肩关节。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:3:0","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"肩锁和胸锁关节 后部的肩胛骨、前部的锁骨和正前方的胸骨一同构成了上肢带，其中，锁骨是位于胸骨和肩胛骨之间犹如支架一样的圆柱形短骨，内侧与胸骨相连，外侧与肩胛骨相连。 锁骨的内侧端呈三角形棱柱状，和胸骨上部相切合构成了胸锁关节。胸锁关节属于鞍状关节，因此锁骨可以通过该关节做如下动作，这些动作在肩胛骨运动时自行发生。 肩胛骨是一个三角形的扁骨，有两面（前面和后面）、三个角和三个缘，此外，还有两个重要结构：喙突和肩胛冈。 肩胛冈下部有一个凸起，叫做冈结节，肩胛冈外侧逐渐变宽形成一个扁平的突起，即肩峰。肩锁关节正是由位于肩峰和锁骨外侧端的两个椭圆形关节面相连。 胸锁关节和肩锁关节一同加强了肩胛骨的运动性，使得肩胛骨能向多个方向运动，因此，以肩胸为一整个功能区，我们可以看到上提、下抑、外展、内收、旋内和旋外六种核心运动。 肩胛骨和胸廓之间存在一些滑动面，使得这些相对运动可以发生，比如，上提时肩胛骨轻微向前翻转，下抑时肩胛骨则平贴在胸廓上，内收运动中肩胛骨向脊柱靠近，外展则远离脊柱。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:3:1","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"肩关节 肱骨是上臂的主要骨骼，其上方为肱骨头，和肩胛骨的关节盂相连，人们谈论肩部通常指的就是这一部分。 肩关节的关节囊附着在肩胛骨上，包裹在关节盂的四周。在前上部，它上至喙突，包含了肱二头肌长头腱。在肱骨上，关节囊附着于肱骨头的四周，形成诸多皱褶，下部尤为明显。肩部的关节囊和韧带组合较为薄弱，因此容易发生脱臼。 肩胛骨上，在肩峰与喙突之间呈紧张状态的韧带为喙肩韧带，作用是保护肩胛冈上的肌腱。但是，当肱骨上提超过一定限度时，该韧带会摩擦冈上肌腱。这时候，它反而成为肌腱劳损的罪魁祸首，能最大程度放松韧带的姿势（关节休息姿势）为上臂轻微前屈、外展和旋内。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:3:2","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"4. 腰腹肌肉 脊柱腰段，即腰椎部分，共五节，有一个重要关节是腰骶联合，位于骶骨和第5腰椎之间。 腰椎侧面有两块重要肌肉，腰大肌和腰方肌，这两者协同作用完成腰椎的侧屈、前屈和对侧向同侧的回旋。 腹直肌位于腹部正前方，它的纤维呈纵向伸展，起于第5、6、7肋软骨及胸骨剑突，至于耻骨，肌腱相交呈现出各种方形的切块，也是它的典型形态。腹直肌的作用是收缩使胸骨接近耻骨，当然，反过来也可以使耻骨接近胸骨，因此这两种动作可以有效训练到腹肌。 腹肌还包括深层的延伸至腹部两侧甚至后面的肌肉，其中，腹横肌位于最深处，它的纤维呈环状，在收缩过程中使得腹部直径变小。如果保持椎骨固定，腹横肌收缩引起收腹运动，如果以腹前筋膜为定点，则会引起腰椎前凸，因此，腹式呼吸可以锻炼到腹横肌，短促的呼吸乃至咳嗽可以感觉到腹横肌的强烈收缩。 腹内斜肌的肌纤维呈扇形走向，单侧腹内斜肌收缩可以使得躯干向同侧侧屈和回旋，两侧肌肉同时收缩可以使躯干前屈，因此，卷腹和侧屈动作都可以锻炼到它。 腹外斜肌同样位于两侧，肌纤维呈扇形走向，如果一侧肌肉收缩，使躯干向同侧侧屈和向对侧回旋，注意，这里是向对侧回旋，这是由肌纤维走向决定的，如果两侧肌肉同时收缩，它使躯干前倾，因此，仰卧对焦伐木之类的动作可以有效训练腹外斜肌。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:4:0","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"5. 胸部肌肉 脊柱胸段由12块椎骨组成，称为胸椎。后部的胸椎、侧面的肋骨以及前部的胸骨则一同组成胸廓。 胸廓前面的扁骨为胸骨 肋骨是细长的弓状扁骨，这种形状也使它具备完成呼吸运动的伸缩性，如下图所示，呼吸过程中肋骨的运动会改变胸廓的直径，吸气肋骨上升而胸廓增大，呼气肋骨下降而胸廓减小。另外，随之年龄的增加，肋骨与胸骨相连的肋软骨的弹性会减小，从而致使胸廓的运动性减弱。 一些深层的胸肌如下所示，表层的大肌群将在之后介绍 在胸廓内部，还有一种扁薄阔肌，它向上汇集成一个穹形屋顶，这就是膈。 膈是主要的吸气肌，它和腹肌一起参与呼吸运动，注意，从力学角度看，躯干的胸部和腹部是完全不同的，胸部可比作一个可变形且可压缩的液体箱，腹部则是可变形而不可压缩的液体箱，膈犹如一个气门，在两个箱之间来回移动，这三部分协作完成如呼吸、发声、喊叫、咳嗽、排便、分娩和打嗝等活动。 当我们吸气时，膈收缩下降，从而使胸廓体积垂直增大，肺将通过中间媒介胸膜感应到这种变化，于是肺内会产生负压及对空气更多的需求，从而引起吸气。 呼气则分两种，静态呼气是通过肺部组织的弹性回缩实现的，这部分组织在吸气时被拉伸，肺的回缩产生肺内压，使得肺中空气排出，但无法彻底排空。深呼气则是呼气肌作用的结果，此时胸廓被拉低，肺内压增大，从而使更多的空气被排出，但值得注意，无论深呼气的力量有多大，总是有一定体积的空气留存在肺中，称为残气量。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:5:0","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"前锯肌 首先是前锯肌，它位于胸廓一侧（上臂下方），起于肩胛骨深面，沿内测缘缠绕到肋骨前外侧，逐渐变宽并形成一些肌束，附着在前10块肋骨上。 以肋为定点，前锯肌的作用是稳固肩胛骨使其紧贴在胸廓内侧缘，比如，在俯卧撑运动中，有无前锯肌的区别如下。固定的肩胛骨是上肢所有力量运动的必备条件，这有赖于前锯肌和中斜方肌的共同作用。另外，前锯肌上部肌纤维可以将肩胛骨向外牵拉（外展），上臂向前推这一动作可以有效说明这一点。前锯肌的下部肌纤维则可以在以肩胛骨为定点时提升位于中部的肋骨。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:5:1","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"锁骨下肌和胸小肌 锁骨下肌起于锁骨下面，至于第1肋骨及第1肋软骨，它的功能是拉低锁骨。胸小肌则起于第3、4、5肋，向上治愈喙突，若以肋骨为定点，它的作用是向前内下方牵拉喙突，即肩关节上提动作，若以肩胛骨为定点，它的作用是提升肋骨。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:5:2","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"肩胛提肌和棱形肌 肩胛提肌起于肩胛骨上角，至于前四块颈椎的横突处，若定点为颈椎，作用是提升肩胛骨，使其旋内，若定点为肩胛骨，作用是使颈部向同侧侧屈。棱形肌为扁机，位于脊柱和肩胛骨之间，起于肩胛骨内侧缘，止于第7颈椎至第4胸椎之间的棘突，若定点为脊柱，作用是使肩胛骨做内收与旋内运动，若定点为肩胛骨，作用是向两侧牵拉胸椎。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:5:3","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"斜方肌 斜方肌覆盖了颈后及背部两肩胛骨之间的肌肉，形成了宽阔的表层肌肉。它起于枕骨基底部，一直延伸到第10胸椎的棘突，三束肌纤维分别至于三个部位，其中，斜方肌上束至于锁骨后缘（外1/3处）及肩峰处，肌纤维向外下斜行，中束至于肩胛冈，肌纤维呈水平走向，下束至于肩胛冈内部（冈结节处），肌纤维向外上斜行。 以脊柱颈胸段为定点，斜方肌的三个肌束具有内收功能，向背正中线方向牵拉肩胛骨，另外，斜方肌上束还可以上提肩胛骨，下束可以下拉肩胛骨，均使其向旋外转。当上肢悬空运动时（例如：敲打键盘的工作），上斜方肌可能发生“过劳”现象。 肩胛骨六种运动涉及的肌肉如下图 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:5:4","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"胸大肌 胸大肌是我们最常说的胸肌，它附着于锁骨（前缘内侧2/3处）、胸骨以及第1~6肋软骨与第7肋骨，之后肌纤维集中扭转形成肌腱，止于肱骨结节间沟外侧嵴。 若以胸廓为定点，胸大肌可以使上臂内收并且旋内，但上下部肌纤维有所不同，上部肌纤维做前屈动作，直至胸大肌成60°夹角，下部肌纤维使其恢复到0°夹角。 若以肩为定点，上部肌纤维拉低锁骨，下部肌纤维为吸气肌。而若肩关节固定且伴随上臂前屈，所有肌纤维均为吸气肌。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:5:5","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"6. 肩部肌肉 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:6:0","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"肩胛下肌 肩胛下肌起于肩胛骨前面，向肩胛骨外角集中，在此形成一块肌腱，，止于肱骨上部的肱骨小结节，它的主要作用是将上臂拉向胸部。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:6:1","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"冈上肌和冈下肌 冈上肌起于冈上窝，形成一块肌腱，穿过由肩峰、喙突以及韧带组成的穹形间隙，然后止于肱骨大结节最高点，主要作用是使上臂外展，但需要和三角肌协同作用。 冈下肌起于冈下窝，经过肩关节囊，止于肱骨大结节、岗上肌的后面，其作用是使肱骨旋外，并少量地参与外展运动。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:6:2","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"小圆肌和大圆肌 小圆肌起于冈下窝，沿肩胛骨外侧缘跨过肩关节后方，止于肱骨大结节、冈下肌后面，它的作用是使肱骨旋外。 大圆肌起于肩胛骨外侧缘，向外上方走行，止于结节间沟，主要作用是使上臂旋内、内收和后伸。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:6:3","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"喙肱肌 喙肱肌起于喙突，止于肱骨内侧面，作用是使上臂屈或内收。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:6:4","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"背阔肌 背阔肌起于第7胸椎至第5腰椎、骶正中嵴以及最后四肋，其肌纤维向肩部集中拧成一束，最后止于肱骨结节间沟内腱膜。若以肩部为动点，其作用是使上臂旋内、内收和后伸，若以肱骨为定点，两侧背阔肌同时收缩，则使脊椎胸、腰段后伸。 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:6:5","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["我所热爱的生活啊"],"content":"三角肌 三角肌位于表层，构成肩部轮廓，由三个肌束组成， 肩关节的各种运动涉及的肌肉如下图 ","date":"2021-03-25","objectID":"/2021/notes-on-sports-anatomy-2/:6:6","tags":["健身"],"title":"运动解剖学学习笔记2-躯干","uri":"/2021/notes-on-sports-anatomy-2/"},{"categories":["爱编程爱技术的孩子"],"content":"由于博客的原因，每周都需要进行图片处理，所以这里对相关知识做一个总结，包括图片格式、图片压缩的原理、水印、工具、最合适的大小等等。 ","date":"2021-03-23","objectID":"/2021/picture-knowledge/:0:0","tags":["新知识学习"],"title":"图片知识一文知","uri":"/2021/picture-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"计算机如何显示图片 图片显示的两个要素是密集排列的像素和每个像素的颜色，仅从原理理解的角度看，LED显示屏是最好的模型。如下图所示，图中每个小圆点是一个二极管，二极管的亮灭即可确定显示的文字和图形，当我们采用体积更小、数量更多、可以显示不同颜色的二极管，也就构成了图片显示的基础。 OLED（Organic Light-Emitting Diode，有机发光二极管）就是这种思路发展的结果，也正是因为OLED是根据材料的特性自发光，因此某一处亮的太久会导致材料老化，从而出现亮度衰减，这就是俗称的「烧屏」，但也同样由于自发光，OLED的可视度和亮度都很高，且没有可视角度问题，可以做到很薄。 与OLED相对的是传统的LCD（Liquid-Crystal Display，液晶显示屏），它的基本思路是屏幕本身不发光，但在屏幕后面设置一个发白光的光源，在光源和屏幕间设置许多滤光片控制颜色，然后偏转光线角度从而控制亮度，从而显示最终的颜色。LCD没有烧屏现象，它的老化是光源的整体老化，显示在屏幕上是全局的发黄或颜色不鲜艳。 我们已经知道每个像素都是三种颜色光的混合，但实际上这三种颜色光还有亮度的区别，共分为0-255级亮度，因此三种颜色的不同亮度一共可以构成 256×256×256 中组合，这也是一个像素可以显示的颜色总数，远远超过人眼对颜色的分辨率。 显卡所负责的，正是计算机和屏幕之间的转换过程，计算机中的程序将像素的颜色值送入显存，GPU随即根据显卡BIOS中存储的对应信息将其转换成电信号输出给显示器，我们就在屏幕上看到了图像。 ","date":"2021-03-23","objectID":"/2021/picture-knowledge/:1:0","tags":["新知识学习"],"title":"图片知识一文知","uri":"/2021/picture-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"图片颜色数据的存储 由上我们已经知道了计算机中存储的实际上是每个像素的颜色值，通常有多种编码体系，最常用的是RGB颜色空间，即每个像素点用三个0-255范围内的数字存储，分别表示R（red)、G(green)、B(bule)三种颜色，最终即可表示整个图片。另外，如果仅用一个数字存储，那么就只有亮度信息，表现出来就是黑白图片。 但这样存储会占据大量空间，一个数字（最大255）就需要用8位（1个字节）来存储，每个像素就需要3个字节，仅一个 1024×768 的图片就需要 2.25MB，更不用说更高分辨率的图片了，因此图片的编码格式有了必要性。 常见的编码格式有bmp、jpg、png、webp、svg， bmp 就是没有额外编码的存储方式，除了文件头、图像头，剩下的就是所有的像素数据，除了用三个字节表示一个像素外，还可以用 8 位（256中颜色）、4位（16中颜色）和1位（黑白）来表示一个像素。文件头信息和 bmp 图片头信息的结构如下 jpg是有损压缩格式，拥有一个质量参数选项，取值在1-100之间，值越大越保真，但图片体积也越大，通常可以选择70或80，如果在50以下，图片就会有明显失真。用相机拍出来的照片一般就是高保真的 jpg 图片，一般有一个附属的 exif 信息，其中包括图像大小、拍摄时间、拍摄的相关参数等信息。jpg有个非常有用的特性是支持不完全读取整张图片，即可以选择读取原图、1/2、1/4、1/8大小的图片，相比于读取原图再将其缩小的方法，这种方式读取的速度要快很多 png是一种无损压缩格式，可以不损失原图的颜色，比较适合矢量图、几何图 webp是google开发的一种有损、透明图片格式，相当于jpeg和png的合体，google声称其可以把图片大小减少40% 总结：jpg适合存储色彩多的拍摄图片，png适合存储几何特征强烈的矢量图 ","date":"2021-03-23","objectID":"/2021/picture-knowledge/:2:0","tags":["新知识学习"],"title":"图片知识一文知","uri":"/2021/picture-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"最合适的图片尺寸 前端的布局一般会对图片进行处理，即所谓的自适应，不同的设备使用不同的图片尺寸，所以我们应当选择较大的尺寸，但尺寸过大又会造成加载过慢，所以不能太大。受页面宽度影响，1024×768的尺寸目前来说已经足够，所有上传到博客的图片按这个1024宽进行统一处理，如果是高大于宽的图片，则以768进行处理。 ","date":"2021-03-23","objectID":"/2021/picture-knowledge/:3:0","tags":["新知识学习"],"title":"图片知识一文知","uri":"/2021/picture-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"图片处理软件 我对图片处理的需求主要有如下这些 本地客户端，最好免安装。因为有些图片涉及隐私或版权问题，不希望使用在线的图片处理软件，一个本地软件最合适不过了； 可以调整图片大小（压缩） 可以转换图片格式 可以加水印，加阴影 可以去除exif信息 可以批量执行上述提到的功能 最好能提供命令行接口，便于之后进行自动化，但不是刚需 之前图片压缩主要使用图压，有时候使用在线的 OKTools，加阴影主要使用 WinSnap，其它功能均无法得到满足 目前统一使用Image Tuner，可以轻松提供上述除命令行接口外的所有功能。 ","date":"2021-03-23","objectID":"/2021/picture-knowledge/:4:0","tags":["新知识学习"],"title":"图片知识一文知","uri":"/2021/picture-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"参考 [1] 知乎，计算机中的文字和图像是如何显示的，https://www.zhihu.com/question/296297701 [2] CSDN，各种图片编码格式详解，https://blog.csdn.net/jemenchen/article/details/52658476 ","date":"2021-03-23","objectID":"/2021/picture-knowledge/:5:0","tags":["新知识学习"],"title":"图片知识一文知","uri":"/2021/picture-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"Keep的健身时长已经超过了一万六千分钟， 但各种健身的知识还是零零散散的状态，没有什么太大的作用，而且随着软件逐渐变得不好用，也意识到了依赖某个工具并不是太好的选择，最终决定系统的学一次，查漏补缺，然后把所有的知识串起来，基本目标就是不需要软件协助也知道自己应该干什么，以及知道做某件事原理到底是什么。 第一部分的学习是运动解剖学，参考资料为布朗蒂娜.卡莱.热尔曼的《运动解剖学》和B站 人体肌肉结构 这个系列视频，基本目标有三个（如下），本篇只介绍一些必须的基础知识。 能够叫的出来全身主要的骨骼、肌肉和关节的名字，并大致知道它们在哪个位置； 知道主要骨骼的形状、一些标志性的部位名称，关节的形态与位置 知道主要肌肉的形态及起止位置，能够从自己或别人身上找到这些肌肉，理解它们在运动中所起的作用； 注意，运动解剖学只关心三部分内容：骨骼、肌肉和关节，而这些东西很多时候没有亲眼看到只凭文字描述真的很难理解，所以有个实物模型参照很重要。 ","date":"2021-03-22","objectID":"/2021/notes-on-sports-anatomy-1/:0:0","tags":["健身"],"title":"运动解剖学学习笔记1-基础知识","uri":"/2021/notes-on-sports-anatomy-1/"},{"categories":["我所热爱的生活啊"],"content":"1. 人体的运动面 为了准确的描述一个动作，我们需要先设定标准的解剖学姿势，以其为基础，所有的运动都发生在三个面内，分别是矢状面、冠状面和水平面。矢状面将人体分为左右两部分，冠状面将人体分为前后两部分，水平面将人体分为上下两部分，注意这三种面都有无数个，彼此相互平行，不是单指平分人体的那一个面。 标准解剖学姿势：身体直立、双足并拢且平行，双臂下垂，掌心向前 从侧面可以看到矢状面的全貌，直立时人体关节在矢状面内发生向前的运动就叫做屈，向后的运动叫做伸，注意，屈和伸都是针对关节而言的，不是在描述骨骼和肌肉。 从正面可以看到冠状面的全貌，骨骼向人体正中靠近的运动称为内收，远离人体正中的运动称为外展。 从上往下可以看到水平面的动作，骨骼向外的旋转称为旋外，骨骼向内的旋转称为旋内。 最后还有一些方位术语，如 前后：前指靠近腹部，后指靠近背部， 上下：上指靠近头部，下指靠近足部， 内外：内侧指靠近身体正中面，外侧指远离身体正中面，这里的身体正中面指的是过肚脐眼的矢状面， 近侧端和远侧端：近侧端指四肢靠近身体的一端，远侧端指四肢远离身体的一端。对于手臂来讲，一般相对于肩关节而言，肘关节比腕关节近，对于腿部则相对于髋关节而言。 深浅：浅指靠近体表，深指靠近身体内部。 ","date":"2021-03-22","objectID":"/2021/notes-on-sports-anatomy-1/:1:0","tags":["健身"],"title":"运动解剖学学习笔记1-基础知识","uri":"/2021/notes-on-sports-anatomy-1/"},{"categories":["我所热爱的生活啊"],"content":"2. 骨骼的形态及作用 骨骼用来支撑人体，在肌肉的牵引运动中一般起杠杆作用，所以要牢记，在运动中骨骼不是主动使力的那一方，肌肉才是，大脑通过神经向肌肉发出指令，肌肉通过收缩带动骨骼产生了运动，骨骼本身起的是支撑（杠杆）作用。 不考虑不规则骨的情况下，骨骼可以分为三类：长骨、短骨和扁骨。 硬度和弹性是骨的两大属性，其中，硬度由骨骼中无机物的含量决定，硬度过高容易骨折，过于柔软则容易变形，弹性则由骨骼中有机物的含量决定。 一个长骨的结构如下图所示，这种结构主要是为了应对人体直立产生的压应力、手提东西产生的拉应力和各种其它方向动作产生的切应力。 ","date":"2021-03-22","objectID":"/2021/notes-on-sports-anatomy-1/:2:0","tags":["健身"],"title":"运动解剖学学习笔记1-基础知识","uri":"/2021/notes-on-sports-anatomy-1/"},{"categories":["我所热爱的生活啊"],"content":"3. 关节组成 骨与骨之间相联结的部位叫关节，不同关节的可活动幅度不同，我们常提到的肩、肘、腕、髋、膝等关节具有较大的活动幅度，叫做动关节。人体中还有很大一部分关节可活动幅度很小或根本无法活动，仅起连接作用。 相接触的两个骨的对应面构成一个能互相调整并进行移动的凸凹面，称为关节面。关节面有多种形式，一般与常见的简单机械系统作比并命名，如球窝关节、椭圆关节、鞍状关节等。关节的各个面完全或部分相嵌套，我们称之为联结，关节失去正常联结就是我们常说的脱臼。 关节的两个面之间有个隔离区域把两块骨骼联结在一起，这片区域叫作关节间隙。关节间隙的一些关键结构有：软骨、关节囊和韧带等。 ","date":"2021-03-22","objectID":"/2021/notes-on-sports-anatomy-1/:3:0","tags":["健身"],"title":"运动解剖学学习笔记1-基础知识","uri":"/2021/notes-on-sports-anatomy-1/"},{"categories":["我所热爱的生活啊"],"content":"软骨 软骨是骨面上覆盖的光亮白色层，成分与骨骼类似，但含水量更高，更具有弹性，作用是保护所覆盖的骨骼，应对压应力和摩擦应力（软骨表面光滑）。软骨中没有血管，它从滑液（下面会讲）和它所覆盖的骨质中获取营养。软骨遭受撞击或运动过量后会产生损伤，即我们常说的关节炎，通常伴随着关节疼痛、关节和肌肉硬化等症状。另外，除了软骨外，以下结构对关节进行补充保护和增加关节稳定性的作用。 ","date":"2021-03-22","objectID":"/2021/notes-on-sports-anatomy-1/:3:1","tags":["健身"],"title":"运动解剖学学习笔记1-基础知识","uri":"/2021/notes-on-sports-anatomy-1/"},{"categories":["我所热爱的生活啊"],"content":"关节囊 关节囊是包在关节周围支撑所有关节面的套装纤维层，它使关节间成为了一个密闭结构。 关节囊内部附着一层膜，有如大衣的衬里，称之为滑膜，主要功能是分泌滑液，如下图阴影部分。滑液充满关节腔，可以润滑关节面，提高关节灵活性，同时也为软骨提供养分。同样如下图，关节囊随着运动方向的变化或者展开或者收合。 关节囊有时候也对运动产生阻力，如下图 ","date":"2021-03-22","objectID":"/2021/notes-on-sports-anatomy-1/:3:2","tags":["健身"],"title":"运动解剖学学习笔记1-基础知识","uri":"/2021/notes-on-sports-anatomy-1/"},{"categories":["我所热爱的生活啊"],"content":"韧带 韧带为带状的结缔组织，其作用主要是连接相邻的两块骨骼。通常情况下，韧带既可位于关节囊内部，也可位于关节囊外部。 不同姿势会使韧带处于不同的状态（紧绷或松弛），而过度牵拉可能使韧带出现撕裂，这就是韧带拉伤。 ","date":"2021-03-22","objectID":"/2021/notes-on-sports-anatomy-1/:3:3","tags":["健身"],"title":"运动解剖学学习笔记1-基础知识","uri":"/2021/notes-on-sports-anatomy-1/"},{"categories":["我所热爱的生活啊"],"content":"4. 肌肉组成与作用 身体的运动是由肌肉收缩引起的。肌肉由肌纤维组成的肌束构成，而肌纤维本身由细长的圆柱形结构（肌原纤维）构成，每条肌原纤维（经过高倍放大后发现）由肌丝组成，中心部分包含着肌肉收缩的基本单位：肌节。 肌肉除了可以收缩（主动）之外，还具有弹性（被动）。也就是说在一定的限度内，通过拉长肌肉各附着点之间的距离，我们可以拉伸肌肉。拉伸肌肉时的运动方向与肌肉本身的运动方向相反。 肌肉通过以下两种方式附着于骨骼之上： 通过肌纤维直接附着于骨骼上（通常是在附着点较大的时候），例如肩胛下肌 通过椎板或肌腱附着于骨骼上，例如腰方肌和喙肱肌 一块肌肉可以有多个肌体，我们称之为头，如二头肌（两个头）、三头肌（三个头）。通常情况下，肌肉近端的附着点叫起点，远端附着点叫止点，例如，腰大肌起点位于腰椎骨上，止点位于股骨上。一块肌肉可以有很多个起点，例如，指浅屈肌起于桡骨和尺骨，同样，一块肌肉也可以有很多个止点，例如，骨间肌以一种复杂的方式止于近节指骨与指伸肌腱上。 因为肌纤维束的排列不同，肌肉的大小与形态也各不相同，例如： 肌肉只跨越一个关节时，我们称之为单关节肌，它的收缩只使一个关节运动。当肌肉跨越多个关节时，我们称之为多关节肌，它的收缩可使多个关节运动，为了拉伸这种肌肉，我们必须同时在多个关节上做跟肌肉本身运动方向相反的运动，比如大腿前侧静态拉伸（拉伸股直肌）。 做运动（例如：髋关节屈）的肌肉称为原动肌（主动肌），做相反运动的肌肉称为对抗肌（拮抗肌）。 肌肉通过收缩引起运动，但运动并不一定源于肌肉收缩，比如卷腹时胸骨靠近耻骨是腹直肌收缩的作用，但站立时该动作是重力的作用。 如果运动是通过正在收缩的肌肉来完成的，这种肌肉的收缩就叫做向心收缩，此时各肌肉附着点之间的距离缩小，上面提到的卷腹就是腹直肌的向心收缩运动。而如果一块肌肉收缩时，正进行的运动不是它引起的，它只起阻止所进行运动的作用，这种收缩叫离心收缩，此时肌肉各附着点距离变远，比如躯干前驱，是重力作用影响，腹直肌起减慢下落速度的作用。还有一种情况，肌肉在没有任何运动的情况下产生了收缩，收缩只是为了维持该姿势，这种收缩叫静力收缩，此时肌肉附着点不发生移位，比如扳手腕的两个人处于僵持状态。 ","date":"2021-03-22","objectID":"/2021/notes-on-sports-anatomy-1/:4:0","tags":["健身"],"title":"运动解剖学学习笔记1-基础知识","uri":"/2021/notes-on-sports-anatomy-1/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第十四期。 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"时讯 1、2021年3·15晚会 03.15 央视的3·15晚会如期举行，曝光的企业和行为基本看一下新闻标题就能明白个差不多，随后就是一连串的企业道歉，但这种事不是道个欠就啥事没有了，有些比如简历问题，本来就是平台在卖建立，结果平台自己说要严厉打击这种行为，还有360，老朋友了，一个做安全的公司，劣迹斑斑。媒体发挥了其监督作用，政府就应该处理，大家对这个世界的感觉就是这么一桩桩一件件累积起来的。 科勒卫浴、宝马、MaxMara商店安装人脸识别摄像头，海量人脸信息已被搜集 智联招聘、猎聘平台简历给钱就可随意下载，大量流向黑市！ 揭秘360搜索医药广告造假链条，UC浏览器涉及为无资质公司投虚假医药广告 手机清理软件黑手伸向爸妈！它们正将老人推向诈骗深渊… 又见瘦肉精！瘦肉精羊流向多地！ 这款英菲尼迪变速箱故障频发！竟给车主封口费？ 这款福特汽车变速箱生锈！设计存缺陷却坑消费者！ 揭秘名表维修内幕：手表原封不动躺一夜，几千维修费就到手 记者直击：废旧钢筋一夜翻新！一年上万吨黑心钢筋流入工地 当然，还有个很好玩的事情，那就是央视在某二手车交易公司的卧底记者做到了公司二把手，简直是现实版无间道。 2、我国北方地区发生大规模沙尘暴天气 03.15 受蒙古国发生的特大沙尘暴影响，3月14日晚，沙尘随气流向南移动，从15日开始影响导我国北方的大部分区域，包括新疆、内蒙古、甘肃、宁夏、陕西、山西、河北、北京、天津、辽宁10省（自治区、直辖市）的221个县（市、区、旗），人口约6417万人，受影响土地面积约132万平方公里，一度成为网络热点。 3、叙利亚内战十年 03.15 叙利亚战争已经持续十年了，比二战时间还长，这些年至少38万人死于战乱，目前存在大约560万难民和620万流离失所者，这后面充斥着美苏博弈和国内各方政治势力影响，深刻的让我们认识到了，想寻求话语权必须谋求自身的强大。 4、意大利为新冠逝者举行全国性悼念活动 03.18 有谁能想到，这场疫情一直持续到了现在，全球累积死亡已经达到了269万例，当初深陷危机的意大利，截至3月17日累积死亡103432例，目前意大利举行了全国性悼念活动，包括意大利总理府在内的众多公共建筑降半旗，向新冠肺炎疫情中的逝者致哀。 5、朝鲜宣布与马拉西亚断交 03.19 据朝中社19日报道，朝鲜外务省当天发表声明称，由于马来西亚当局17日将一名无辜的朝鲜公民当成“罪犯”并最终引渡至美国，朝鲜宣布与马来西亚完全断绝外交关系。声明表示，涉事的朝鲜公民是多年来在新加坡从事合法对外贸易活动的工作人员，马来西亚指控其参与“非法洗钱”活动是毫无根据的捏造，完全是阴谋。马来西亚当局的此次行径，是对美国企图掠夺朝鲜主权、生存权和发展权的反朝敌对活动的直接参与。金将军真硬气，不过说到这个，3月18日的中美高层战略对话，中共中央政治局委员、中央外事工作委员会办公室主任杨洁篪和王毅外长出席，杨洁篪的发言非常强硬，不再是「有理有节，不卑不亢」，大人，时代真的变了，当然，可能和美国现在自顾不暇，没能力反击有关。发言我就直接抄过来了，虽然不少，但我觉得挺有必要。 杨洁篪指出，中方主张和平、发展、公平、正义、民主、自由的全人类共同价值，主张维护以联合国为核心的国际体系、以国际法为基础的国际秩序，而不是以一小部分国家制定的规则为基础的秩序。世界上绝大部分国家并不承认美国的价值就是国际价值，不承认美国说的就是国际舆论，不承认少数国家制定的规则就是国际规则。美国有美国式的民主，中国有中国式的民主。中国坚持走和平发展道路，为国际和地区和平与发展、为维护联合国宪章宗旨和原则作出不懈努力，而不像美国动辄动用武力，造成世界动荡、不安。美国国内在人权等方面存在很多问题。美国应当做的是改变自己的形象，管好自己的事，而不应自己的问题没解决好，向世界转嫁矛盾、转移视线，不应对中国的人权、民主说三道四。中国共产党领导和中国政治制度得到中国人民衷心拥护，任何要改变中国社会制度的做法都是徒劳的。 杨洁篪强调，中美都是大国，在抗击疫情、实现复工复产、应对气候变化等方面有很多共同利益。希望美方改变零和博弈思维，放弃“长臂管辖”等错误做法，不要滥用国家安全概念干扰两国正常贸易往来。中美两国应当同亚太各国都发展良好关系，应该有共同的朋友，这才是21世纪的处世之道。台湾、香港、新疆都是中国领土不可分割的部分，中方坚决反对美方干涉中国内政行径，并将继续作出坚定回应。美国没有资格居高临下同中国说话，中国人不吃这一套。与中国打交道，就要在相互尊重的基础上进行。历史会证明，对中国采取卡脖子的办法，最后受损的是自己。 5、时隔35年三星堆考古再启 03.20 三星堆啊，青铜神树、青铜面具什么的，简直是神秘的代名词，我严重怀疑盗墓笔记好多脑洞来自三星堆。1986年7月导9月，三星堆遗迹现世，没想到这两天考古工作再启，又发现了几个坑，瞬间就上了热搜，到处都是这个新闻，作为中华文明的重要组成部分，我们的历史拼图又多了一块儿。 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"小事 1、03.15，《家族的形式》二刷完成，还是有很多感触。 2、03.15，做了一个十六型人格测试，属于 INTJ 专家型，不知道是不是正确，看个开心。 3、03.16，收到了返校通知，不过能赶在返校前完成论文初稿，也很开心。 4、03.17，我的生日，能过完生日再走好开心，老妈还给买了一个蛋糕。 5、03.17，拖了这么久的网文防沉迷系列文章写完了，同步发表在了少数派，而且上了首页，虽然本来以为两篇都可以上首页的，但只有一篇也还是很开心啊。 5、03.18，返校，火车站遇到白姐和小凤姐，还都在一个车厢，挺好。 6、03.19，到达学校，出租车司机有点坑了，不打表按人头收，果断滴滴走起，下午做了核酸检测，给几个老师发邮件报了一下行程，接下来就是继续慢慢改论文了。 7、03.19，《健身少女》二刷，《比宇宙更远的地方》接着没开始的地方开始看，果然看番最治愈。 8、03.20，和老师通话完成，基本已经没有什么事了，全都是首位工作，好好享受最后几个月。所有博客图片的重命名完成，不过没有开容灾，希望以后不会手误把存储桶给删掉。 9、03.21，给昨晚看的扎导版《正义联盟》写了影评，果然还是期待太高了，现在就很失望，四个小时，真的看的我心力交瘁。 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"视频 1、国风舞武混剪，漂亮的小姐姐 2、鹿小草翻唱，《好想爱这个世界啊》，别有一番感觉，质量上乘 3、Linux给员工提供资金改造小屋，这期是Andy，这个装修风格很符合我的审美 4、对生活充满热爱的妹子向我们介绍她的小屋，一个人也很幸福 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"文章 1、B站，37天找回iPhone8P全过程 尽管是针对iPhone的，但很多东西对安卓用户也很有用，最触动的一句话是「现在人的一切隐私都被绑在了手机上」，最震撼的是支付宝的挂失流程。 2、北辰青年公众号，学校里学不到的，房东会教你 北辰青年出品，算的上租房指南，是我本来独立生活计划一部分的，是那种你必须学会的知识，所以这里看到就比较惊喜。 3、IT之家，抖音打击“卖惨式”带货 封禁10个百万粉丝情感主播 真的是，卖货就好好卖，非得博同情，就好像当初各种综艺，表演就好好表演，卖个惨凭啥给你过。 4、虎嗅，“心灵鸡汤”如何摧毁我们的心智？ 标题已经足够吸引人了，内容也是。 5、知我心理学，如何判断ta爱不爱我？ 爱的共有应答性，第一次知道这个知识，很有用。 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"工具 1、双面绒棉被，被视频部分那个热爱生活的女孩种草的 2、沥水篮，老妈买的时候感觉不好，买回来真香 3、行李箱罩，出火车站的时候看到有个女生用，想到防雨防尘是个不错的东西 4、刮水器，洗完澡后收拾浴室的神器，不用再费劲拖地了 5、洞洞板，虽然早就知道这个东西，但是感触最深的还是上面老莱工作室的视频里出现的那一幕，或许以后可以试试 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"电影 1、《扎克·施奈德版正义联盟》 正义联盟的重新剪辑，扎导构建了一个自己的DC宇宙，四小时片长，不是真粉丝没耐心看完的。 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:3:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"知识 1、做饭时案板要生熟分开 2、保险分定期寿险、意外险和医疗险 3、健身后30分钟摄入蛋白质吸收效果最好，《家族的形式》里从男主那里得到的知识，然后看健身书籍的时候不断地看到 4、dfinity区块链，群里看到大家在讨论，听说很火，但还没去细看 5、习俗记录：上车饺子下车面 6、G219、G331、G228三条国道绕全国一圈，从这里知道了，原来国内有这么多路风景很好。 7、玻璃能抵御热成像 8、有些蜂蜜有毒，取决于蜜蜂采的是不是有毒的花，有毒的蜜一般尝起来比较苦涩 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:3:5","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["日程及周刊"],"content":"思考 1、其实不少不想社交，没有人不需要情感支持的，只是缺乏这种能力，最后慢慢成了习惯 2、对网络上瘾是因为现实孤独，加强社交是很好的方法，所以学习这方面的知识也可以放到独立生活计划里 3、每天看的东西都最好当天消化吸收掉，不然再捡起来就不知道什么时候了 4、有些书看一部分不看了，或者为了写文章只需要看其中一部分内容，就比如写网文防沉迷系列时看了不少书，可以完整看完的没多少，这种书在豆瓣应该怎么进行标记，是个很重要的问题 5、虽然不喜欢很多事，但是既然它们客观存在，就要学会遇到这些事怎么办 ","date":"2021-03-21","objectID":"/2021/life-weekly-14/:3:6","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 14 期 (20210321)","uri":"/2021/life-weekly-14/"},{"categories":["平日里的白日梦"],"content":"八年的看小说经历，其实不是想放下就能放下的，身体好似已经形成了本能，一旦闲下来，脑子还没过，手就自己拿起手机打开了小说网站，所以为了进一步的解决这种问题，我打算充分的理解上瘾的生理和心理学机制，从中寻找相关的解决办法。由于查阅到的文献一般用成瘾这个词，但在科普书籍和我们生活中使用上瘾一词则较多，所以本文可能会同时出现两种描述。 ","date":"2021-03-17","objectID":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/:0:0","tags":["杂谈"],"title":"网络小说防沉迷之以理解上瘾机制结束","uri":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/"},{"categories":["平日里的白日梦"],"content":"1. 上瘾的生理机制 我们脑子里对上瘾的概念有些什么，烟草？酒精？毒品？赌博？电子产品？在以前，上瘾一般专指药物成瘾（论文里一般用成瘾这个词），《上瘾五百年》1里将其归结为三大宗（酒精、烟草、咖啡因）和三小宗（鸦片、大麻、古柯叶），这些东西虽然有一定的心理因素的影响，但更多的是明显的生化机制和生物学效果。但随着研究的发展，在行为科学中提出了行为上瘾的概念，常见的有赌博成瘾、过量饮食、性成瘾、过量运动、计算机游戏成瘾、过度亲密和财富成瘾等。这些行为不涉及任何具有直接生物效应的物质，而是以某些具有强烈心理和行为效应的现象为基础2。当前，虽然我本身还对是否将网络小说沉迷划分到行为上瘾保持抵制和疑惑，但却不妨碍我从这个角度来理解它。 对于行为上瘾，科学家们提出的假设是：一个人的行为、经历和药物酒精等物质一样，都能对大脑及周围神经构成的网络，即神经通路产生刺激，当这种刺激达到一定量时，就可以使大脑陷入一种强迫状态，也就是依赖和成瘾。大脑的这一部分区域正是奖赏通路，相关的科学知识，包括多巴胺这种神经递质在其中所起的作用，由于媒体的大量科普目前已经为人们所熟知。但与成瘾机制相关的神经递质实际上有 6 种：r-氨基丁酸、乙酰胆碱、去甲肾上腺素、多巴胺、5-羟色胺和 β-内啡肽3，其中，5-羟色胺正是在文章中提到的血清素，与稳定情绪相关的一种物质，感兴趣的可以查看这篇文章，其中也有关于多巴胺的一些科普。 1954年 J. Olds 和 P. Milner 的小鼠实验直观的展示了电刺激对于多巴胺释放的作用，但我们平常的自然奖赏是通过行为反射形成的，当我们在发生进食、饮水、性交和哺育行为时，就会激活奖赏回路，多巴胺释放，身体出现比较好的感受和体验。打网络游戏或看网络小说这些行为，在长期反复进行的过程中，大脑逐渐适应并改变，使其成为触发奖赏回路的一种新的行为。 做一个总结，无论物质刺激还是心理体验，都可以通过脑的奖赏系统引起脑内的改变，它们唯一的区别是，药物的刺激更直接更剧烈，而相关的行为比较缓和。 ","date":"2021-03-17","objectID":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/:1:0","tags":["杂谈"],"title":"网络小说防沉迷之以理解上瘾机制结束","uri":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/"},{"categories":["平日里的白日梦"],"content":"2. 上瘾的心理机制 上瘾的恶劣之处在于，一旦某种行为和大脑的奖赏机制形成了联动，多巴胺就已经不是其中关键的一环。20世纪九十年代，密歇根大学神经学家肯特·贝里奇做了一个实验4，在这项实验中，贝里奇给大鼠喂食糖水，观察到了它们愉快地舔着自己的嘴唇，研究人员之前已经观察到舔舐嘴唇正是大鼠表示愉悦的黄金标准。从多巴胺的角度分析这个过程，贝里奇假设每只大鼠一吃到糖水，它小小的大脑里就会充斥多巴胺，多巴胺的提升驱使大鼠舔舐嘴唇，因此从逻辑上讲，如果阻止大鼠生成多巴胺，大鼠就应该停止舔舐嘴唇，于是贝里奇给大鼠做了脑外科手术，阻止它们产生多巴胺，并再次给它们喂糖水。手术后，大鼠不再主动去喝糖水了，但如果直接给大鼠喂糖水，大鼠依然会舔舐嘴唇，它们似乎不再想要糖水，可一旦尝到，又似乎享受着跟手术前一样多的愉悦。 因此上瘾不是简单的多巴胺增多的问题，它还有着复杂的心理学机制的影响，我们可以这样理解，上瘾是未能得到满足的心理需求和一组短期内可安抚该需求（但长期而言有害）的行为相结合的。因此哪怕你已经痛恨某种上瘾行为毁了你的生活，但你的大脑依然渴望它，它记得这种行为是用来宽慰心理需求的，因此这种渴望保留了下来，以网络小说为例，就算我们现在痛恨它给我们带来了很多不好的影响，但大脑已经记住这种行为是用来缓解孤独、焦虑或其它痛苦的，所以我们依然频繁的看网络小说，就像从前它还让我们感到开心的时候一样。从这个意义上讲，上瘾的根源也可以视作心理痛苦5，很多时候那种快感早就没了，但是重复做这种行为的渴望依然存在，因为它们被大脑认为可以使我们免受心理困扰。 ","date":"2021-03-17","objectID":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/:2:0","tags":["杂谈"],"title":"网络小说防沉迷之以理解上瘾机制结束","uri":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/"},{"categories":["平日里的白日梦"],"content":"3. 解决上瘾的办法 如果一旦上瘾之后，连阻断多巴胺都不起作用，那意志力就更不可靠了，畅销书《习惯的力量》中提到了不少实验，都充分的说明了这一点，因此我们主要从阻断行为方面寻找出路。《行为上瘾》6一书中提到，人类底层行为公式为 B = MAT，即 $$ Behavior（行为）=Motivation（动机）×Ability（能力）× Trigger（触发） $$ 其中，动机是人们做一件事的动力，比如早上要赶航班；能力是阻止行动存在的壁垒，比如手机没电就没法玩手机；触发则是因触动而激起某种反应，最典型的是广告营销，我们一遇到「送礼」这个场景，就会想到脑白金、安慕希。这三者是乘数关系，只要任何一个因子为零，等式左边的行动就会为零，这就是我们实践的理论知道。 ","date":"2021-03-17","objectID":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/:3:0","tags":["杂谈"],"title":"网络小说防沉迷之以理解上瘾机制结束","uri":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/"},{"categories":["平日里的白日梦"],"content":"能力 日常生活中，我们总是想方设法增加自己看网络小说的阻碍，这是在消除看小说的能力，一般包括三个层次的手段： 手机层次：开启类似于MIUI专注模式的功能，在一定时间内禁止手机的使用； App层次：注销阅读类软件账户并卸载其App，或者为指定的App设置使用时间上限； 网络层次：修改Hosts，重定向指向小说网站的访问，或者在路由器的后台拦截指向相关网址的流量 但这些手段都有其缺点，真要有作用也不会有那么多人依然深陷其中了。首先是手机承担的功能不止看小说，我们可以在一段时间禁止使用，但总有结束的时候，这时候不仅没法组织，还可能产生报复性使用；其次，账户注销不代表无法看小说，我注销各类阅读软件账户已经有几个月了，结果成了起点网页版的终端使用者，两天一换的限时免费，每周的新书强推，俗话说，办法总比困难多，人的能动性果然是无限的；最后，路由器做了限制，流量没有啊，更何况，自己设的规则自己关闭简直再简单不过了，和自己的欲望作斗争真的是屡战屡败。因此接下来我们从其它两个方面寻找解决办法。 ","date":"2021-03-17","objectID":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/:3:1","tags":["杂谈"],"title":"网络小说防沉迷之以理解上瘾机制结束","uri":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/"},{"categories":["平日里的白日梦"],"content":"触发 触发可以大致可以分为三种：喜好触发、社会触发和个体触发。喜好触发最为经典的就是外表魅力，我们总是会对容貌姣好的人投以更多的关注，投射在网络小说中，就是作者在书中人物的外貌描写上总是极尽能事，男子就剑眉星目、玉树临风，女子就肤若凝脂、貌若天仙，然后我们就对这些人物喜爱更多而对其行为的容忍度更高，减小脱坑几率。近两年又发展出什么样的描写呢，就是男性主角帅出天际，凡是女性看了就会脸红，凡是男性看了就自叹不如，甚至到了以外貌纵横天下的地步，这类小说初看可能还可以，尤其是作者在情节构思、场面描写或矛盾构建等任一方面比较突出的时候，非常容易让人沉浸，但一旦你意识到了这一点，再想到现实里哪怕最好的皮囊也和书中有着差距，你就再也看不下去了。另外，俗话说以其行观其人，郭靖、杨过、鲁智深、林黛玉，这些人物各有特点，可不仅仅是从别人嘴里说「此人如何如何」而得到的，用这种方法来描写人物的小说怕也不值得一看吧。 相似性是喜好触发的另一个因素，主要的原理是，如果进入我们视野的内容与我们的观点、个性或生活方式有一定的相似性，那么我们就会不由自主被吸引。举个例子，如果我们平常就喜欢游戏，那么少数派首页推送的「一周游戏见闻」就可以吸引我们注意从而点开，网络小说也有这方面的因素，当我们打开小说网站时，我们通常只会点击自己关注的分类或小说页面，而对其它的内容不置一顾，这就是喜好在起作用。阻断这种相似性触发的手段是寻找小说的不合理之处，无论我错别字等语法错误，还是金手指安排太刻意或不合理，只要发现这些问题，就说明它和我们脑中的逻辑产生了冲突，相似性触发就被打断，我们也就i从中脱离了出来。 社会触发的两个因素是权威和从众。权威是指人们总是倾向重视有一定地位、威信、受到社会尊重的人或机构所说的话、所推荐的内容或所做的事，知识付费课程的营销是典型案例，这些课程总是会加上各种名校、名企的标签，比如《XX女神的幸福哲学课》《X大师的北大金融课》等，从而引起我们的注意，然后忍不住点进去。但网络小说受到主要影响的是从众心理，以我自己而言，我迈入网络小说这个坑就是受身边朋友影响，高中的时候有个晚上相伴回家的同学，每天晚上都给我讲他看的小说剧情，一来二去，我就忍不住自己上手看了起来，初次接触网络小说的人真的很难抵御这种冲击，华丽的想象、畅快淋漓的情节，尤其是在少年时期未养成独立思考能力的时候。上一篇文章已经提到，我们国家目前的网文用户达到了近4.7亿，这就意味着每个人的身边都可能有这样的朋友，所以，虽然我们阻挡不了阅文集团等小说网站的轰炸式广告投放，但和身边的朋友声明不要在讨论网络小说还是可以的。 恐惧、互惠、一致性是个体触发的主要因素。恐惧触发是利用人类担惊受怕的心理来制造压力，从而试图改变他人的态度或行为，这也是我们总说媒体贩卖焦虑的主要原因，因为它们只有利用这样的标题或内容，才能引起我们的注意。互惠则是对人善意的利用，一个简单的例子，很久不联系的朋友突然给我们的朋友圈点了赞，如果我们随即看到了他的朋友圈，那么通常也会给对方回一个赞，超市里的零食导购给我们试吃了一点东西，那么出于互惠心理，我们购买正品的概率就会提升。一致性理论认为，每个人都努力设法使自己的内心世界没有矛盾，所以一旦做出了某个决策，之后的行为就会不自觉地按照这件事地轨迹来进行，比如，超市里找不到价格标签的产品，拿到收银台即使发现价格比想象中高，也会硬着头皮买下来。网络小说中反映最为突出的是第三个因素，主要表现在一旦我们开始看一本小说，在没有意外出现的情况下，就倾向于把它看完，可是每一本小说都至少数十万字，想看完何其艰难，强求的后果就是一目十行，结果越来越无法进入深度阅读，反而影响了平时的学习。那么，我们提到的「没有意外出现的情况下」中的意外指什么呢，就是指小说和我们自身逻辑的不一致性，所以解决办法和喜好触发的相似性原理一样，都是努力寻找小说存在的问题。 ","date":"2021-03-17","objectID":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/:3:2","tags":["杂谈"],"title":"网络小说防沉迷之以理解上瘾机制结束","uri":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/"},{"categories":["平日里的白日梦"],"content":"动机 触发部分提到的办法解决的是如何从网络小说中脱离的问题，对于我们总是不由自主地打开手机看小说的情况毫无效力，所以，我对自己看小说的场景做了总结，看一看我为什么这些场景引起了我看小说的行为。 场景 看小说原因 一个人吃饭 无聊 一个人走路 无聊 上大号 无聊 实验时程序自动运行 无事可做 Deadline之前 压力较大（焦虑） Deadline之后 想放松 看完相关电影、动漫 意犹未尽 交通工具上 心疼流量 晚上 不管做什么，就是不想睡 从表中可见，最多的两种原因是无聊和焦虑，比如吃饭、走路、上厕所、工作时程序自动运行等，但实际上这些场景中还存在另外一种心理，那就是如果我做某件事的同时看小说，就好似同样的时间完成了两倍的工作，岂不是变相的节省了时间，虽然明眼人都看得出这种想法站不住脚，但是在自我安慰的时候，这可是有用的不得了。至于看完电影、小说意犹未尽还想多看点东西，于是打开了小说网站，这就没什么办法了，因为这种心理正是同人出现的主要原因。晚上迟迟不想入睡所以打开了小说网站，就和睡眠问题扯到了一起，我用的解决办法是晚上健身使身体疲劳，以及睡前的仪式性行为，比如听一期固定的节目。最后，是心疼流量的问题，很多时候真的是想玩手机但是心疼流量，于是选择了最不花流量的办法—看小说，目前主要办法就是手机里常年保证有下载好的番剧或电影，以及对微信听书的使用。 实际上，大部分场景下，我们可选的排解无聊和焦虑的手段不止一种，但最终还是选择了看网络小说，主要原因就是经年累月的阅读已经形成了条件反射，只要遇到这种情绪，大脑下意识的反应就是通过看网络小说这种方式来排解，所以我们总是会不由自主地打开小说页面。要想一劳永逸地解决这个问题，最好的办法就是培养一个新的习惯来替代，当然，不是指成瘾性更大的其它方式，而是对我们而言相对无害甚至有益的方式，这方面可以阅读斯蒂芬·盖斯的《微习惯》7一书或者咨询心理医生来寻找相应的替代行为。作为临时性的方法，我建立了一个名为闲时待办的单子，如果不知道自己该做什么，就从这个单子里找，而不是直接就去拿手机打开小说网站，目前来看，这种方法还算有一定的效果。 ","date":"2021-03-17","objectID":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/:3:3","tags":["杂谈"],"title":"网络小说防沉迷之以理解上瘾机制结束","uri":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/"},{"categories":["平日里的白日梦"],"content":"4. 后记 最后补充两个看小说时常用的自我安慰的理由，一是觉得网络小说里也有大量的生活文化常识，甚至还有一些专业性的知识，能够扩展视野，觉得自己放松的同时顺便学习了一波，但我们应当明白，小说中普及的常识或其它知识受到小说作者学识的限制，正确性难以得到保证，不如主动的去专业书籍和课程中学习。二是觉得看网络小说、看电影，都是娱乐活动，都达到了放松身心的目的，有什么区别呢？而且我虽然看网络小说，但我没耽误正事儿啊，持有这种想法时，我们通常忽略了沉迷小说对工作效率、对视力的影响，不正确的看手机姿势还对颈椎和腰椎带来了压力。 希望大家都有节制的看小说，就像其它娱乐活动一样，专注现实才能不虚度人生。 戴维·考特莱特，上瘾五百年：烟、酒、咖啡和鸦片的历史[M]. 中信出版社, 2016-08. ↩︎ 陈猛，网络成瘾的剖析[OL]. https://old.pep.com.cn/xgjy/xlyj/xlgj/xskj/yyxl/201008/t20100827_784239.htm，2004-06. ↩︎ 梅松丽，网络成瘾的神经生理学研究[C]. 中华医学会首届国际行为医学学术大会暨第九次全国行为医学学术会议论文汇编. 中华医学会行为医学分会:中华医学会, 2007:4. ↩︎ Berridge K C. Food reward: brain substrates of wanting and liking[J]. Neuroscience \u0026 Biobehavioral Reviews, 1996, 20(1): 1-25. ↩︎ 亚当·奥尔特，欲罢不能：刷屏时代如何摆脱行为上瘾[M]. 机械工业出版社，2018-01. ↩︎ 何圣君，行为上瘾[M]. 中国华侨出版社，2019-11. ↩︎ 斯蒂芬·盖斯(美)，微习惯[M]. 后浪出版社，2016-11. ↩︎ ","date":"2021-03-17","objectID":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/:4:0","tags":["杂谈"],"title":"网络小说防沉迷之以理解上瘾机制结束","uri":"/2021/the-exploration-of-quit-novels-ends-with-understanding-the-mechanism-of-addiction/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第十三期。 ","date":"2021-03-13","objectID":"/2021/life-weekly-13/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 13 期 (20210313)","uri":"/2021/life-weekly-13/"},{"categories":["日程及周刊"],"content":"周总结 得到了恶意行为检测部分研究内容的最后一张实验图，随后完成了毕业论文初稿； 毕业论文的格式要求总结； 将论文从Markdown迁移到Word并调整其格式，篇幅可能有些不够，因此同时在进行二次修改和内容扩充，目前已经完成第三章，预计在60-70页，但目标在70页以上； 日剧《家族的形式》4-8集重温，B站观看 健身按计划进行，但尝试脱掉手环，感觉戴着手环反而心理压力更大 成瘾的生理学机制部分文献的查找阅读，做了笔记和总结 确定了存在腾讯云中的博客图片的命名规则，以所属分类的首字母缩写和文章创建日期开头，目前完成了「研究生的区块链学习之路」部分的图片重命名 百乐 juice 系列的三只笔到了，初用手感不太好，但经过一周的磨合发现还可以 03.13，回家给奶奶送吃的，和老妈一起到二姐家串门，超市买菜 ","date":"2021-03-13","objectID":"/2021/life-weekly-13/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 13 期 (20210313)","uri":"/2021/life-weekly-13/"},{"categories":["日程及周刊"],"content":"文章阅读 1、央视新闻，朋友的八交九不交，莫名其妙就被这篇文章吸引。。。 2、半月谈，男女互撕，值得深思，分析现在男女对立问题的文章，很有意思 3、独居问题专题，想单身就得考虑这个问题，最近这方面的文章比较多，收集几个有深度的 极昼plus，北漂女孩被困卫生间30小时：敲水管获救，因独居遭网暴 IT之家，独居者的智能生活指南：盘点那些专为独居者发明的智能产品 深燃团队，独居女孩的烦恼，不止“被困浴室30小时” ","date":"2021-03-13","objectID":"/2021/life-weekly-13/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 13 期 (20210313)","uri":"/2021/life-weekly-13/"},{"categories":["日程及周刊"],"content":"优秀视频 1、B站UP主木羽说科技有一个木羽眼中系列，讲述他眼中的苹果、小米、魅族、老罗，虽然主观但很有参考价值。 2、日剧《钱断情始》B站上线，之前不少极简主义者推荐 视频地址：https://www.bilibili.com/bangumi/play/ss38156 3、法国电影《轻松自由》，受到安利，讲述一个学霸选择宅家的故事，对我们发出心灵叩问：为什么要工作 ","date":"2021-03-13","objectID":"/2021/life-weekly-13/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 13 期 (20210313)","uri":"/2021/life-weekly-13/"},{"categories":["日程及周刊"],"content":"知识收集 1、防雾眼镜擦布 2、冰箱收纳盒，受少数派本周的编辑部最近买了啥推荐，感觉很好用 3、木羽视频看到一个桌面手机支架，很好看 4、整理收纳师职业火爆 5、诺曼博士的《设计心理学》，豆瓣地址：https://book.douban.com/subject/4606471/ 6、网络神书《临高启明》及北朝论坛 7、应急设备包括速干衣、救生盒、多用途刀，特别是百度百科关于救生盒的描述非常有意思，没想到还有这种东西 ","date":"2021-03-13","objectID":"/2021/life-weekly-13/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 13 期 (20210313)","uri":"/2021/life-weekly-13/"},{"categories":["研究生的区块链学习之路"],"content":"当一个同学问我论文格式问题时，我欣然应允，当两个、三个同学问我论文格式问题时，我意识到了什么，当预答辩的老师在那里说着“你们不会比对着学校的格式要求一个一个看吗”的时候，我终于恍然大悟，啥，就那个写的不清不楚的东西？所以我打算自己整理一份Word 版论文格式要求，以硕士论文模板为基础，补充一些缺失细节的同时，给出在 Word 中进行这些格式设置的方法。不使用 LaTeX 的原因主要是学校要求最后的提交版本是 doc 或 docx 格式，而 LaTeX 转 word 总不能尽善尽美。 为了描述方便，我们先声明 word 中几个区域的标准叫法，如下图所示，智能搜索框的作用在于将多步点击简化为一步搜索。 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:0:0","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"1. 论文组成 学位论文主要部分由前头部分、主体部分和结尾部分（只限必要时采用）组成。 类别 组成 前头部分 - 封面 - 扉页——题名页（中、英两种） - 声明（独创性声明） - 摘要（中、英两种文字） - 目录 - 插图和附表清单（只限必要时） - 缩略字、缩写词、符号、单位表（只限必要时） - 名词术语注释表（只限必要时） 主体部分 - 绪论（前言、引言、绪言） - 正文 - 讨论、结论和建议 结尾部分（只限必要时采用） - 参考文献 - 致谢 - 攻读学位期间发表的论著、获奖情况及发明专利等项。 - 作者从事科学研究和学习经历的简历 - 可供参考的文献题录（只限必要时采用） - 索引（只限必要时采用） ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:1:0","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2. 格式要求及设置方法 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:0","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 纸张大小与版芯 格式要求为： 纸张大小：标准A4复印纸（210mm×297mm） 版芯（打印尺寸）要求160mm×247mm（不包括页眉行、页码行） word 默认纸张大小即为A4，但默认版芯大小和要求不一样且没有办法直接设置，而是通过调整页边距来得到。页边距等于纸张大小减去要求的版芯尺寸，以左右页边距为例，大小为 (210-160)/2=25mm，上下页边距经过计算同样为 25mm。 在智能搜索框搜索「页面设置」，然后在弹出的窗口中将上下左右页边距均设置为 2.5cm。 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:1","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 正文 word 中大部分格式设置的基准都是正文，因此首先来设置正文格式，且为了减小对其它部分的影响，遵循最小更改原则。正文格式要求为 汉字小4号宋体，外文、数字字号与同行汉字字号相同，字体为 Time New Roman 体或相近字体 每页30～35行，每行35～38字 这里缺少行距和对齐方式的说明，网上有部分说法为行间距设置为1.5倍，但很可惜不满足第二个要求，学校的模板论文行间距设置为固定值22磅，满足要求。为了排版美观，对齐方式选择两端对齐。 右键「开始」选项卡「样式」功能区的正文一栏，设置字体、字号、行间距和对齐方式，如下图所示。 格式要求中还缺少的一个部分是段落缩进，为了不对正文样式产生影响，最好是写作时在每一段起始手动输入 Tab 键。由于 Word 默认的制表位为 1.75 字符，我们需要先将其修改为 2 个字符，方法如下图所示，键入四个空格的效果是相同的，下图给出了一个简单的示例，「段落」功能区的显示/隐藏编辑标记可以让我们看到这一点，该按钮后续还会有其它用处。 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:2","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 标题 论文标题的排版格式要求如下表，只分至第四级，再分可用（1）（2）……；（a）（b）……等。不同级标题的阿拉伯数字编号之间用点「.」（半角实心下圆点）相隔，最末级编号之后不加点。摘要、目录、参考文献、致谢等标题作为第一级标题排版。 标题 字号字体 格式 举例 第一级(章) 二号黑体 居中，占3行 第 1 章 XXX 第二级(条) 三号黑体 居左，占2行 1.1 XXXXXX 第三级(款) 四号黑体 居左，占2行 1.1.1 XXXXXX 第四级(项) 小四号黑体 居左，占1行 1.1.1.1 XXXXXX 隐藏的要求包括 一级标题为：第 1 章、第 2 章，不能是第一章、第二章，且中文和数字间应有空格； 一级标题占3行的含义是段前1行，段后1行；二三级标题占2行的含义是段前0.5行，段后0.5行； 标题中出现的外文和数字字体依然是 Time New Roman，字号与同行汉字字号相同； 多级标题的格式设置和正文相似，都是在「开始」选项卡的「样式」功能区进行修改，下面以一级标题为例进行演示，字体设置时字形默认为加粗，记得勾选为常规，行距本身应该为单倍行距，但最终效果不太好，因此选择了保持和正文相同。 用同样的方式设置二级和三级标题，字体字号参照上面的格式要求，对齐方式选左对齐，段前段后0.5行。「样式」功能区的标题级别只到标题2，三级标题及以下默认是隐藏的，但是在使用一次上一级标题后就会自动出现，比如，使用一次二级标题后，三级标题就会出现在「样式」功能区，此时即可对其进行设置。 样式设置好之后，插入标题只需要左键点击样式功能区的对应标题级别即可，然后输入想要的标题名。注意，此时插入的标题是没有第1章或1.1这样的标号的，需要自己从「开始」选项卡「段落」功能区的多级列表中添加，添加后还需要自己在标号和文字中间加入一个空格。 在「视图」选项卡的功能区中开启导航窗格，可以实时查看各级标题，我们写了一个例子来展示三个级别标题的效果，如下图所示 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:3","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2.4 图表和公式 2.4.1 插图 插图包括示意图、曲线图、框图、流程图、布置图、地图等，要求有图号、图题、图例。图号编码用章序号，如「图2.1」表示第2章第1图。图号与图题文字间置一字空格，置于图的正下方，图题用5号字，字体可用宋体，须全文统一。图中标注符号文字字号不大于图题的字号，此外还有几个补充说明 图题与图应当连在一起，不能断页； 图的横纵坐标应有单位，中英文应统一； 虽然大家有占篇幅的需求，但是图片中空白部分不能太多，不然老师依然会给出图片太大的评价； 考虑到黑白打印，统计图表不要使用颜色区分，柱状图饼图等使用不同的填充线条，折线图使用不同几何图形的点。 由于我们将正文行距设置为了固定值，此时插入图片只会显示一小部分（默认插入格式为嵌入式），一种解决办法是将图片格式设置为文字环绕-上下型，但这种方式会导致图片浮动在正文中，稍有不慎就不知道飘到了哪里，合适的解决办法是在「开始」选项卡「样式」功能区新建一个单独的图片样式，如下图所示。考虑到插入图片样式的不同，若有必要可设置段前0.5行。 在待插入位置点击样式功能区的「图片」，然后从「插入」选项卡插入来自设备的图片，即可完成图片的插入。为了将图号与章节序号关联，使得论文改动时它可以自动更新，我们使用题注功能插入图号与图题，如下图所示。右键图片，选择「插入题注」，原生的标签是「图表」两个字，选择新建标签「图」，然后在点击编号弹出的菜单中选择「包含章节号」，分隔符设定为句点，最后，插入位置选择在所选项目下方，正文中提到后文如果再次用到该图，可以利用「引用」选项卡中的交叉引用插入。 第一个题注插入成功后，「开始」选项卡「样式」功能区将出现「题注」样式，修改其格式为单倍行距，居中对齐，字体与正文相同，中文宋体，数字和英文 Times New Roman，字号为五号。 在用以上方法插入图片和图片标题时，图片与前文段落间距、图片与图题间距、图题和后文段落间距应当是比较合适的，如果有问题，可以在样式设置时自行调整段前段后。 2.4.2 表 表号也用章序号编码，如：表2.1是第2章中的第1表，表题与表号之间空1～2字，置于表的上方居中，用5号宋体，表中的内容字号不大于表题的字号。 格式要求中对于行高和列宽都没有指定，表题与上文内容的间距、表题与表的间距、表与下文的间距也都没有说明，但如果我们采用标准插入方式，这些都可以不关心，注意，一般要求都是三线表，插入步骤如下 在「插入」选项卡「表格」中选择需要的行和列数量； 选中表格，选择无框线，然后勾选上框线和下框线，选中表格首行，勾选下框线，此时得到三线表； 向表格中填入内容，全选然后将内容字号设置为五号； 选中表格，右键选择「插入题注」，和图片一样，新建「表」标签，调整编号，但位置选择在所选项目上方； 题注设置及最终的效果如下图所示 2.4.3 公式 公式包括数学、物理和化学公式，正文中引用的公式、算式或方程式等可以按章序号用阿拉伯数字编号（式号），如：式（2.1）表示第2章第1式，公式一般单行居中排版与上下文分开，式号与公式同行居右排版。 要补充的细节有两点： 式号用英文括号包围，不使用中文括号； 公式的释义用统一的表达方式，比如「其中」、「式中」。 MathType 是广泛使用的公式输入插件，但考虑到 Word 目前支持以 LaTeX 格式输入公式，这将是我们的首要选择。另外，为了令公式居中而式号右对齐，一种做法是整体右对齐，然后在公式和式号中间插入空格，我们采用另一种更简单的办法，也就是使用一个单行三列的表格，将公式居中置于第二个单元格，将式号右对齐置于第三个单元格，然后隐藏所有边框。公式在固定行距下同样显示不全，因此使用单倍行距，基于它和图片的相似性，我们采用图片样式进行插入，插入具体步骤如下 插入单行三列表格，光标移动到第二个单元格，点击样式功能区「图片」样式； 在第二个单元格插入公式，此时功能区为公式的相关选项，选择 LaTeX； 以 LaTeX 形式输入公式，将公式显示模式更改为「嵌入」； 在第三个单元格输入式号，设置为右对齐； 隐藏框线； 设置前和设置好的对比图如下， 公式的编号面临和图号表号一样的问题，即后续编辑时的自动更新和文中的引用问题，但公式较少时依然以直接输入最为简单快捷，公式较多时，可以考虑使用域代码。 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:4","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2.5 参考文献 格式要求里关于参考文献只有一句话：采用顺序号编号体系，然后分别给了期刊、专著和学位论文的一个例子，显然这是不够的，我们将要求补充如下： 参考文献使用国家标准 GB/T 7714-2015，最新一版为 2015.12.01 开始实施，不同类型文献的格式大家基本都清楚，下述摘录总结一些不清楚或需要注意的地方； 参考文献序号使用方括号，如[1]、[2]，而不是1、2； 文献作者采用姓在前名在后的形式，欧美作者遵循同样的规范，而且姓为全程，名为首字母缩写，假设作者名为 Albert Einstein，那么规范的书写形式为 Einstein A。 作者不超过 3 个时，全部列举，超过 3 个时，其后加「，等」或[, et al]，注意，等字之前要有逗号； 没有完全理解标准中对于标点符号使用的说明，但标准中给出的示例标点符号全部使用中文符号，但无论中文还是外文文献，需要的时候都使用实心圆点「.」而不使用空心句号「。」； 有不同版本时，第一版不额外说明，但其它版本应使用阿拉伯数字、序数缩写形式或其它标识表示，举例如下 O’BRIEN J A. Introduction to information systems[M]. 7th ed. Burr Ridge, III：Irwin 报纸、公告日期、更新日期、引用日期等，需要具体到某一天时，采用 YYYY-MM-DD 的格式，以短横线相连 从专著或论文集中析出的有独立篇名的文献，和原文献的关系需要用 // 表示，因此找到的参考文献格式中的该符号不要删掉； 凡从期刊中析出的文献，应注明年、卷、期、页码，卷和期不一定都有，书写格式举例如下 关于引用格式的参考，大家可能习惯从百度学术中找，但百度学术提供的参考中页码缺失情况比较严重，对于国内文献，可以直接从知网文献页码找到相关材料，或者使用知网提供的引用格式参考，如下图所示。对于外文文献，谷歌学术提供的引用格式参考较为规范，页码缺失情况不多，如果确实找不到，可以到论文所在原数据库中寻找。 关于正文中文献的引用，可能大家已经注意到了我前面的 Word 截图中有 Zotero 插件，但考虑到文献格式问题，还是使用大家熟知的交叉引用最为保险。交叉引用使用的步骤如下 文末新建参考文献一级标题； 另起一行以正文格式插入以方括号开头的列表格式，如下图所示，注意，文献占据多行时，遵循默认格式，第二行不必顶格； 编辑正文内容，需要插入参考文献时，在参考文献部分输入正确的引用格式，然后将光标移动到正文需要插入文献的位置，选择「引用」选项卡，在「题注」功能区选择交叉引用，在弹出的窗口中选择对应的文献，如下图所示 插入后的文献标号需要设置为上标形式，可以在插入后直接使用快捷键「Ctrl+shift+=」，也可以在论文中所有参考文献插入完成后，论文定稿前，使用高级替换功能，如下图所示，注意，为了避免将全文所有方括号格式的内容都替换掉，应不断地点击查找下一处，逐个进行替换。 最后，导出PDF时编号可能会从上标恢复，所以应当在导出之前复制一份论文，然后在复制的论文里全选所有内容，使用 ctrl+shift+F9 快捷键取消所有超链接（交叉引用属于一种超链接），将其固化为文本，然后再使用导出或另存为 PDF。 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:5","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2.6 目录 格式要求中对目录没有说明，根据论文模板、学长学姐的论文参考、询问老师、网上查阅等途径，总结格式如下 一级标题为黑体小三，二三级标题为宋体小四，英文字号与同行中文保持一致，字体为 Times New Roman； 虚线和页码字号为小四，尤其要注意一级标题的虚线和页码大小； 目录行间距为1.5倍（有些学校可能有具体要求）； 在「引用」选项卡的「目录」功能区选择自定义目录，根据上述格式进行设置，如下图所示 设置完成后插入的目录如下图所示，内容改动完成后，右键目录选择更新域，可以根据是否更新了标题内容而选择不同的更新方式。另外，在定稿前，需要手动对一级标题的虚线和页码字号进行调整，然后调整目录行间距为1.5倍。 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:6","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2.7 页眉页码 要求自摘要页起加页眉，眉体可用单线或双线（二等线、文武线），页眉说明5号楷体，左端“XX大学硕士、博士学位论文”，右端“章号章题”。对页码则要求用阿拉伯数字连续编页，字号与正文字体相同，页底居中，数字两侧用圆点或一字横线修饰，如 ·3· 或－3－。 同样，关于一些细节补充说明如下 页码从独创性声明开始加入，从独创性声明到目录统一使用罗马数字，如I、II、V等，从绪论开始使用阿拉伯数字； 空白页也应有页码； 智能搜索框输入「编辑页眉」，页面上方将出现横线，在横线上方输入文字，调整为5号楷体，为使文字分列于左右两端，中间插入空格，我们将编辑标记显示如下图 页码采用域代码插入方式，如下图所示 另外，摘要、目录、不同章节、参考文献等页眉右侧的文字都不相同，要实现这一点需要在每一部分的末尾插入分节符，如下图所示，位于「布局」选项卡 分节符插入后的效果如下图所示，此时开启页眉页脚的编辑页面会发现上下两页显示的节数不同，光标移动到数字较高的一节页眉，在功能区中取消勾选「链接到前一节」，随后修改页眉文字将不会导致前面一节的文字随之改动。 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:7","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"2.8 装订打印 论文要求双面打印，沿长边装订，但一般还有一个默认的要求是：中英文扉页、独创性声明、中英文摘要、目录、每一章、参考文献、致谢的首页都要求位于奇数页。该要求的目的是双面打印时使首页位于正面而非反面，这也是论文中大部分空白页出现的原因。 前面已经提到，空白页也是需要有页码的，所以很多人热衷于充分利用这一规则占篇幅，这种做饭挑不出毛病，但是要注意，论文一般不可以单字成行、单行成页，简单来说就是不要太过分。 ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:2:8","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["研究生的区块链学习之路"],"content":"3. 常见问题 在这一部分我们总结一些上面没有提到的问题。 首先，中文摘要中不要出现 this paper 字样，不少人可能直接复制中文摘要的机翻结果，但机翻完成后自己起码校对一次，不仅仅是因为机翻痕迹很容易被看出来以及标点符号需要调整，还因为机翻内容总是在查重的时候莫名奇妙被标红； 其次，论文中的叙述方式，应尽量使用“被动语态”，避免使用“主动语态”。换个说法就是避免出现“我们”、“我”这种第一人称主语，不过可以说“本文……”； 最后，学校有页数要求，考虑到部分同学确实有扩充篇幅的需要，利用空白页和图片的做饭是允许的，但做的不要太明显，不要被老师一眼看出来（老师如是说）； 祝大家，也祝我自己毕业愉快！ ","date":"2021-03-08","objectID":"/2021/masters-thesis-format/:3:0","tags":["科研记录"],"title":"硕士论文的格式","uri":"/2021/masters-thesis-format/"},{"categories":["日程及周刊"],"content":"闲时可以做的事 ","date":"2021-03-06","objectID":"/2021/to-do-in-free-time/:0:0","tags":["日程"],"title":"闲时待办","uri":"/2021/to-do-in-free-time/"},{"categories":["日程及周刊"],"content":"闲时 整理独立生活指南 基本的生活保障：吃穿住 免受暴力及心理威胁：良好的体格、驾驶和游泳等技能 抵御环境侵害：药物、急救、应急包、野外生存基本知识 确认一下文章中放的图片大小多少合适，PC端需要一个抹去exif信息和压缩图片的软件 找个箱子，把家里暂时不用的东西放到里面，然后把所有衣服放到统一的一个地方 用三个箱子，一个放不再需要的东西（可以进一步分成想卖的、想送的和想扔的），一个放暂时不用的东西，最后一个放储备的东西 对食堂所有菜做一次划分，包括想吃的、健康的、不想吃的，没什么感觉的等，然后指定饮食计划 想清楚什么是需要系统学习的，比如健身体系，什么只需要临时的学一下即可，比如浮尘天气如何应对 考虑如何面对通胀 人格侧写的方法 对各种社会问题进行分类，如教育，养老，恋爱，房子等，总结对它们的看法 学习在宿舍可以做的食物，应当以蒸煮为主，避免油烟 在一楼大镜子拍照，整理自己的穿搭 每年定个时间去眼镜店清洗眼镜 在银行租个保险箱，放遗嘱啊什么的小物品 在房管局网站查询房子的实际数据（实测山西省需要在山西省智慧建筑管理服务信息平台 (shanxi.gov.cn)查询） 尝试 figma 这个软件 好物评测、旅行记录可以作为博客的两个单独分类 博客图片的重命名 对看完的书或电影列一个二刷清单 将九寨沟加入旅游列表 ","date":"2021-03-06","objectID":"/2021/to-do-in-free-time/:1:0","tags":["日程"],"title":"闲时待办","uri":"/2021/to-do-in-free-time/"},{"categories":["日程及周刊"],"content":"理想的工作日时间安排，可根据此安排灵活调整 07:00，起床 07:00 - 07:30，做饭、洗漱、打扫整理 07:30 - 08:00，吃早饭、新闻、查看消息 08:00 - 08:30，通勤时间，去上班/上学 08:30 - 12:00，上午的工作，避免久坐，多喝水 12:00 - 12:30，吃午饭 12:30 - 13:00，消息查看，社交媒体/听音乐 13:00 - 13:30，午睡半小时 13:30 - 14:30，读书 14:30 - 18:00，下午工作，避免久坐，多喝水 18:00 - 18:30，通勤时间，回家/回宿舍 18:30 - 19:30，做晚饭和吃晚饭 19:30 - 20:00，洗碗、收拾房间 20:00 - 21:00，学习/电影/读书/…. 21:00 - 22:00，健身 23:00 - 23:30，洗漱，准备睡觉 ","date":"2021-03-06","objectID":"/2021/ideal-daily-schedule/:0:0","tags":["日程"],"title":"理想的工作日时间安排","uri":"/2021/ideal-daily-schedule/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第十二期。 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["日程及周刊"],"content":"时讯 2021 两会召开，第十三届全国人大第四次会议3月5号开幕，第十三届全国政协第四次会议 3月4号开幕，政府工作报告的一些值得关注的内容如下 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["日程及周刊"],"content":"周总结 完成文章网络小说防沉迷之从提高审美能力开始，发布在少数派和个人博客 研究生毕业论文初稿第五章及涉及的相关实验（还差最后一个实验） 健身两天，因为实验的关系这周健身时间大幅减少 B站观看电影《末日病毒》《天地大冲撞》，灾难类型片 日剧《家族的形式》1-3集重温，B站观看 记账软件从随手记切换到一羽记账。随手记会员才可以导出账本数据，为了避免尾大不掉，在数据还不多的时候及时迁移，一羽记账使用 webdav 同步数据，无需登录，因此重新注册了坚果云账户，此后坚果云将专门用于所有需要 webdav 的软件 为了平台的同步，日程体系从小米自带日历迁移到了 Outlook 日历 03.05 进行了学期注册，同时公布了答辩的重要时间点，依次规划了毕业前要完成的事 03.05 和老妈一起到超市买菜，换了换心情 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["日程及周刊"],"content":"文章阅读 1、少数派文章，从跟团小白到旅行规划能手 | 年度征文 作者对旅行的自我定位是「周末短途的平价旅拍游，非徒步非越野」，旅行理念是「去往值得探索的风景和文化，心怀尊重地通过旅行去认识这个世界”」。这里值得探索的范围包括自然风光、历史人文和探索体验，作者还介绍了旅行前做调研应该包括哪些事，细节可以查看文章。 自我感触：旅行前最好先学会收集摄影 2、少数派文章，匆匆不平 GTD 相助，情怀区居民奶昔羊说 | 年度征文 这篇文章直接对我的日程体系产生了影响，使我从手机自带日历迁移到了 Outlook 日历，设定了一个理想的工作日时间安排，同时直接导致了本文归属的周刊系列的重新启动。 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["日程及周刊"],"content":"工具推荐 秘塔写作猫，一个中文校对工具，用于文章写完之后进行语法检查，界面布局都和 Grammarly 比较像，还算好用 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["日程及周刊"],"content":"知识收集 1、路西法效应 2、zone 饮食法 3、crossFit 4、犬儒主义 5、1688批发网 6、喜马拉雅海盐，淡粉色，富含矿物质 7、排骨架床板，一乔桑啊视频里出现的那种很低的床 8、旅游预警 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["日程及周刊"],"content":"语句摘录 1、也许猜测别人的人生是否幸福，很傲慢吧。出自《家族的形式》第3集第42分钟 2、如果因为害怕结束就从不开始，那该有多少遗憾啊 3、遍体鳞伤也好，光芒万丈也好，你总要亲眼去瞧一瞧这个世界 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:6:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["日程及周刊"],"content":"生活技巧 刷牙前唤起小爱计时 3 分钟 用专门的血压计血氧检测仪也许比手环更好 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:7:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["日程及周刊"],"content":"一些思考 为什么有人在家里的时候就特别安心，即使他什么都不做，一个人的时候就不踏实 ","date":"2021-03-06","objectID":"/2021/life-weekly-12/:8:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 12 期 (20210306)","uri":"/2021/life-weekly-12/"},{"categories":["平日里的白日梦"],"content":"2020 年，中国的网文用户达到了近 4.7 亿1，阅读网络小说已经成为一种普遍性的社会现象，但这也意味着，任何的影响，在如此巨大的用户数量的扩大下，都会成为不可忽视的问题，比如，网络小说沉迷。我目前尚不清楚网络小说导致沉迷的机制与原理，但从结果来看，它对我的工作、学习和生活显然造成了比较严重的影响，比如难以集中注意力、熬夜、人际交往减少等。从每周的手机使用时间统计中可以看到，阅读网络小说占据了一半以上的份额，超过 20 小时，所以毫无疑问，在这场争抢用户时间的战争中，网络小说胜过了社交和视频等其它活动，取得了绝对的胜利。 任由它将我们拖向深渊吗？当然不，百度的戒小说吧、豆瓣的戒小说小组、知乎的相关话题常年保持着活跃状态，这个世界上从不缺乏与之对抗的人，但这些人大多以打卡为主要行为，缺少科学的解决办法。俗话说，知己知彼，百战不殆，我决定从理解网络小说的叙事逻辑开始，了解它的特点和存在的问题，从而寻找相关的解决办法。幸运的是，学术界对此已经有了一定的研究，在知网的论文库中，相关的文献条目足有上千条，我阅读了《上海文化》网络文学讨论专题的部分文献和北京大学出版社的《网络文学经典解读》一书2，观看了一些具有深刻见解的网络小说评论家的视频3，从而总结了玄幻4、游戏5和同人6这三种我最爱的题材的叙事逻辑和潜在问题，并建立了自身的网络小说评价体系和审美观，缩减可阅读的网络小说数目，从源头上减少被吸引的概率，事实证明，这种方法确实有一定的效果。 ","date":"2021-02-27","objectID":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/:0:0","tags":["杂谈"],"title":"网络小说防沉迷之从提高审美能力开始","uri":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/"},{"categories":["平日里的白日梦"],"content":"1. 网络小说的叙事结构 ","date":"2021-02-27","objectID":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/:1:0","tags":["杂谈"],"title":"网络小说防沉迷之从提高审美能力开始","uri":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/"},{"categories":["平日里的白日梦"],"content":"1.1 玄幻小说 「玄」是玄奥、玄妙，「幻」是虚幻不真实，玄幻小说最大的特点就是天马行空的想象。在作者创建的第二世界里，不需要现实基础，也不需要历史基础和科学基础，限制存在的只有想象力。吴子林对这种想象涉及的方面做了一个概述7，可以让我们一窥玄幻世界的全貌：对于自然现象，海可煮之沸，地可掀之翻，山可役之走，人可化为兽，天可隐灭无迹，陆可沉落无形；关于故事的境界，天外还有天，地底还有地，水下还有湖沼，石心还有精舍；对于生命的看法，灵魂可以离体，身外可以化身，借尸可以复活，自杀可以逃命，修炼可以长生，仙家却有死劫；生活方面，不食可以无饥，不衣可以无寒，行路可缩万里成尺寸，谈笑可由地室送天庭；战斗方面，风霜水雪冰、日月星气云、金木水火土、雷电声光磁，都有精英可以收摄，炼成各种凶杀利器，相生相克，以攻以守，藏可纳之于怀，发而威力大到不可思议，等等。 所以我们可以看到玄幻小说世界不求严谨只求新奇刺激，越是不可思议、越是超越常规、越是匪夷所思，越能得到人们的喜爱，这时它同合理性逐渐地分离开来。 但玄幻小说依然具有自身的一套逻辑自洽而结构完整的体系，这体现在它的升级系统上。传统文学常以冒险、复仇为主题构建剧情，但这种方式绝难支撑起网文动辄数十上百万字的篇幅而不使读者厌烦，毕竟，不是所有的作者都有《魔戒》作者托尔金那样的笔力，甚至即使是《魔戒》也经历了十二年的创作和四年的修改，而网络小说却往往是一蹴而成。对于大多数普通写手来说，只有让主角一步一步升级并且不断的换地图，然后再辅以各种人物关系、支线小剧情、战斗场面的描写，才能让小说延伸下去，同时为不同的等级设立明显的能力和地位差距，作者还可以利用主角的升级轻而易举设计出很多陡转的剧情，为读者带来一种翻盘的爽快感。 长篇幅和作者笔力的矛盾不止于此。首先，为了维持较大的篇幅，小说一般会设立非常多的等级，这就极易导致作品的后期乏力，严重的甚至导致力量体系崩坏，因此我们可以看到各种玄幻小说高开低走非常普遍，大量的作者在后期难以驾驭剧情从而匆匆结尾，徒留无数遗憾。其次，由于作者经历和想象力的有限，难以在如此长的篇幅中填充足够丰满的剧情，导致了网络小说中的拿来主义盛行，发展到目前，各种小说的同质化现象已经极为严重，甚至很多小说基本看到开头就能猜到结尾，极大地削弱了小说的趣味性。最后，较长的篇幅中涉及大量的人物，由于作者精力和思维能力的限制，人物塑造容易出现脸谱化，人物间的逻辑关系不能自洽，像《长生界》中七绝天女这样关乎剧情发展的人物有时候也交代不清楚，更有甚者，一些前期浓墨重彩描写的人物，后期出场寥寥甚至会直接消失，就比如《诛仙》中的林惊羽，这些都导致了玄幻小说极易出现各种「坑」，这方面出名的就是「坑神辰东。 以前的网络小说中所体现的那些崇尚暴力、唯我独尊、视人命如草芥等的思想随着行业的发展正在逐渐地得到修正，因为大多数读者越来越愿意看到一些有着积极向上价值观的小说。但是，网络小说受资本驱动的固有特点使得一些问题永远无法得到改善，比如，大多数小说描绘的都是主角从弱小开始逐步成长为世界强者的这种经历，一定程度上满足的是人们面对社会的一种期望，即通过自身的努力达成心中所想要的成就。但就像游戏的地图是等比例缩放的一样，为了吸引读者，小说的剧情也必须紧凑，主角的升级速度往往远高于同世界观下的其他人，因此主角的成长成为了一系列奇遇与巧合的积累，努力在其中所占的比例并不高。发展到现在，干脆就将努力的过程也直接省去，诞生了无敌流和签到流小说这些派别，折射出的是一种不劳而获、投机取巧的心理，这种剧情满足了人们的欲望，但也会潜移默化的影响着读者，致使整个社会越来越浮躁。另外，近些年主角光环这种东西几乎是尽人皆知的了，一些作者虽然在尝试着解决这个问题，但在以个人为主角充斥着英雄主义的网络小说中，主角光环这种东西是不可能消除的，因此我们总是可以看到出门遇见大佬、捡漏捡到神器，甚至垃圾技能用成神技等情节，剧情发展的需要和逻辑的严密性之间的冲突是不可调和的。更有甚者，为了达成戏剧化的效果，作者不断强化人与人之间的利益关系，也会对读者的心理产生影响，从而波及到现实的人际交往。 最后，玄幻不是无源之水、无根之木，科幻、西方奇幻、日式奇幻、中国本土的神话寓言、志怪小说、港台武侠、动漫游戏都对其产生了一定的影响。从九十年代这个词被赋予黄易的小说开始，随着网络文学的发展，言情、都市、悬疑、军事、历史、神话、武侠等越来越多的元素都被融入玄幻的概念中。到目前为止，我们甚至已经不太可能为玄幻给出一个明确的定义和分类，但为了把握玄幻小说当前的概况，我们暂且按照起点中文网的方法将玄幻小说划分为四大类： 东方玄幻：基于东方文化背景、描写主角修炼、冒险的幻想作品，如《完美世界》。 异世大陆：带有独特性的世界架构，充满奇异想象的小说作品，如《斗罗大陆》。 王朝争霸：基于幻想背景下，将个人武力和争霸战争相结合的作品，如《紫川》。 高武世界：以位面、星球、小千世界为主体架构的修炼升级作品，如《全球高武》。 ","date":"2021-02-27","objectID":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/:1:1","tags":["杂谈"],"title":"网络小说防沉迷之从提高审美能力开始","uri":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/"},{"categories":["平日里的白日梦"],"content":"1.2 网游小说 游戏是我们宣泄心理负能量的一种手段，但在游戏中，我们依然受到整体世界观和各种既定事实（等级限制、人设、主线剧情等）的约束，有时候更由于剧情设定或自身操作能力问题，不仅坏心情没调节，反而又在游戏中产生了新的挫折感，结果越玩越气。为了抒发自己的内心情绪，自由操控自己的想象与意志，一部分玩家开始向网络小说作者转变。 网游小说的分类要简单一些，依据小说内容中虚拟世界与真实世界的交互程度以及游戏虚拟真实的程度，可以将其分为游戏生涯、虚拟网游与游戏异界三大类。游戏生涯还包括一些小说网站中提到的电子竞技分类，除了描述玩家在游戏中的活动，还描写以此为中心所展开的现实生活，如《全职高手》。在这类小说中，游戏生活与现实人生相互缠结，游戏角色和现实角色相互指向，游戏不止具有娱乐消遣的基本属性，还承载着玩家的人生意义，因此在故事的末尾，主角往往可以将虚拟的成就转化为现实的人生价值，实现游戏与现实的双赢。虚拟网游则是描写未来网游的作品，在这类小说中，游戏操作不再以键盘为媒介，而是以游戏头盔、手表或者其它设备为传输工具，借助虚拟现实技术让思维进入到游戏世界中，这种方式虽然和穿越的表现相同，但玩家可以意识到游戏的虚拟性，因此在行为和心理方面有着极大的不同，典型的小说如《伊塔之柱》和日式轻小说《刀剑神域》。虚拟网络更侧重于塑造游戏世界中的生活，展现角色的成长过程，一般能给读者带来更兴奋刺激的阅读体验。游戏异界则以玩家从现实穿越到虚拟的游戏世界为主要背景，或者将游戏中的道具或技能带入现实世界，在这类型小说中，现实与虚拟的界限被打破，主角需要在这个过程中重新寻找自己的人生意义，这方面典型的小说如《琥珀之剑》，另外，最近流行的第四天灾流也属于这种类型，如《超神机械师》。 网游小说的叙事特点首要体现在对主角形象的塑造上。在游戏世界中，主角要么通过已有的精湛游戏技艺赢得敬仰与尊重，要么靠着敏锐的领悟力与极好的运气在跌跌撞撞中实现惊人的成长，如果小说涉及现实世界，那么主角还会因为游戏玩得出色或其它人格魅力实现人生价值，收获完美的事业与爱情。这种形象虽然和主角光环有一定的相似，但网游这种类型的特点大幅削弱了主角光环的违和感，人们对此的容忍度一般比较高。更何况，这种塑造是网络小说这种形态出现的必然结果，因为现实中的个体受到法律、道德、舆论等各种社会和人际关系制约而被束缚的个体情绪，资本主义极力渲染的消费欲望与可求而不可得的现实的冲突，使得主角必须足够的传奇才能满足人们对一个理想化的自我形态的追逐，并从中获取一种自恋式的幸福感和存在感。 以战斗为基础是网络小说的第二个叙事特点。其它类型小说的战斗并不是必须的，作者可以选择着重文戏或走轻松流，但网游本身就是通过战斗、通过竞技来宣泄情绪、赢得尊重的，宣扬的就是一种暴力美学，网游小说也必须继承这一点。在网游小说中，要塑造一个生动的游戏世界，那么战斗及与之相关的场景就如同一棵大树的主干，成为故事情节发展的脉络与线索，师徒、同盟、爱情等角色关系或其他轶闻趣事，则都是以竞技为主干的中心叙事衍生出来的旁枝。在这种情况下，与战斗相关的描述是否精彩，就成为一部网游小说能否吸引人的关键。 最后一个叙事特点是专业性的描述语言。在构建真实游戏世界观的同时，作者必须使用大量游戏专业术语来展现特定的风格和玩法，使得读者能从描述中融入虚拟世界。但是，这也导致了网络小说本身对于作者和读者身份的挑剔，就作者而言，他必须玩过多款游戏或精通一种游戏才能形成属于自己的构思框架，触发自身对重塑理想游戏世界的冲动并付诸实践，而对于读者而言，他必须具备一定的相关游戏经验才能理解诸如「红Buff」这类指向性的代称。 和玄幻小说类似，网游小说也致力于描述努力拼搏和实现理想间的关系，但是主角充满传奇的经历很大程度上又消解了这种意义。网游小说普遍引入的重生元素，使得主角相比于其他人具有着极大的优势，一个有数年游戏经历的高手穿越到游戏开服，他不仅有着磨练好的技术，还熟悉游戏的套路，知道什么时间做什么事和怎么减少不必要的弯路，在这种情况下，其他人所有的努力都是苍白的，一步一个脚印这种价值观完全没有立足的余地。读者通常都将自己代入主角的视角，但试想一下，如果自己是和主角同一世界观下的人，是不是会感到绝望呢。 ","date":"2021-02-27","objectID":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/:1:2","tags":["杂谈"],"title":"网络小说防沉迷之从提高审美能力开始","uri":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/"},{"categories":["平日里的白日梦"],"content":"1.3 同人小说 同人小说的诞生与网游小说有一定的相似性，都是粉丝为了填补心中的遗憾进行的再创作，当他们对原作的配对、情节或结局不满意时，就利用同人小说的方式，按照自己期待的视野重新安排，得到一个理想中的世界。这些二次创作出的作品，有忠于原作的改编或者基于原作结局基础上的续写，也有对原作改头换面的重写，甚至于有些同人仅仅只是利用了原作人物的名字，人物的性格、故事背景和故事主线已经完全不同于原创作品。但无一例外的，这些同人小说都是对原作世界观的补充，如果是原作是一个世界的冰山一角，那么同人就是在挖掘海面下的部分。 相比于其他类型的小说，同人小说是具有优势的，一方面，同人小说的人物性格、素材、背景和情节都是现成的，作者只需要利用这些材料即可进行写作，而不需要自己进行精心的构思和反复琢磨，降低了对作者个人能力的要求。另一方面，同人小说和原创作品的读者是重合的，这就避免了需要重新打开读者群的窘况，能在一开始就吸引到一定量的读者。但我们也应当注意到，同人是一把双刃剑，它更像是戴着镣铐跳舞，一旦打上了同人的烙印，就必须要在尊重原著的基础上进行再创作，很难不受原创的影响。更重要的是，同人小说的人气也受到原作的极大影响，一旦原创作品过气，同人小说也很难保持原来的热度，更别提成为经典了，这方面典型的就是影视剧《琅琊榜》和游戏《绝地求生》的同人小说，当初曾火爆一时，现在则基本不见踪迹。 除了依附性和短暂性外，同人小说还表现出一种反经典的特性。同人小说需要对原作进行二次创作，由于蝴蝶效应的存在，作者所做出的任何调整都会对最后的结局产生重大的影响，更何况，同人是为了弥补作者的遗憾创作的，这使得它必然对原作产生一定的颠覆。同人作者对原作解读的新颖性一定程度关于作品的吸引力，这方面代表性的就是今何在的《悟空传》，同原作内涵已经有了彻底的不同，但也有很多时候，一些作者走上了某种极端，开始对原作进行一种歪曲和消解，代表性的就是对各种历史人物的重新定义，使他们与历史原型有了极大的不同，不过，也说不准有些读者就喜欢这一种。 按原创内容的类型，我们可以将同人小说划分动漫同人小说、影视同人小说、神话同人小说、历史同人小说、小说同人小说、游戏同人小说、真人同人小说、综合性同人小说几类。其中，神话同人普遍来源于各国神话故事和神话人物，常用的有圣经故事、希腊神话故事、北欧神话故事、佛教故事以及在创作中逐渐形成体系的中国神话（洪荒体系）。历史同人对作者的历史素养有较高的要求，常以历史上的一些重要时期或重要人物为基础，比如中国的春秋战国、三国、强汉、盛唐、富宋、刚明、清代、民国，以及一战、二战和其它国家的重要历史时期。真人同人则是由对演艺圈、体育界明星的崇拜和向往激发的创作热情，目前比较多的是韩娱明星同人。综合类是在读者对单一同人产生审美疲劳之后，将多部作品放在一起创作的小说，一种是同一世界观下的作品和人物放在一起，比如漫威、X战警等同属美漫世界观的作品，另一种则是作者将风马牛不相及的作品和人物通过自己的巧妙构思结合在一起形成的作品，典型的就是各种无限流穿越、聊天群类、或者一部作品中的角色穿越到另一部作品等。对于动漫、影视、小说和游戏，有没有同人，或者同人有多少，基本和原作的热度呈正相关的关系，前面的两个图片已经展示了动漫和影视类同人的主要来源，下图中为小说及游戏类同人的主要来源，比较特别的是，电子竞技类小说类别中，英雄联盟是绝对的主角。 ","date":"2021-02-27","objectID":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/:1:3","tags":["杂谈"],"title":"网络小说防沉迷之从提高审美能力开始","uri":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/"},{"categories":["平日里的白日梦"],"content":"2. 建立自身的评价体系 截至 2021 年，仅仅起点中文网就诞生了超过 100 万篇网络小说，每天都有旧的作品在完结，有新的作品在开始，这也就导致了任何时刻我们打开手机，总有新的作品可以阅读，所以我们一次又一次的被网络小说吸引，总也逃不开它的诱惑。 如何解决这个问题，我的想法是建立一个自身的评价体系，提高自己的审美水平，使得不再是任何作品都可以进入我们的视野，占据我们的时间，当供选择的小说数量减少，我们被吸引的概率就会降低，从而达到小说防沉迷的效果。当然，与之相适应的，我们还应当学会正念阅读（参考正念饮食8的概念），积极将小说与自己的评价体系相匹配，思考有助于我们从小说世界中脱离，减少拿起放下一晃过了几个小时的情况。 我构建的评价体系主要由三部分构成。第一部分是世界观和等级体系设定，我们看网络小说，很大程度是想看天马行空的想象，因此世界观的新颖性应当作为我们评价网络小说的一部分，另外，新颖的世界观应当有着严谨而逻辑自洽的等级体系，整个等级体系必须让人们信服，就像人类的数学体系是由几条简单的公理推得的一样，新的世界观也需要能自然的得出其它的设定。举一些例子，《无限恐怖》的无限流、《佛本是道》的洪荒流、《飘渺之旅》的修真流、《龙蛇演义》的国术流等都是以世界观设定和严密的等级体系吸引人的例子，将目光放到最近，《赛博英雄传》和《赛博剑仙铁雨》等将赛博朋克元素同中国传统的武侠仙侠相结合的探索也非常有新颖性，详细的设定介绍可以看下面的视频。 第二部分是立意，读者阅读网文仅保持着一种娱乐消遣的心态，网文的可读性也仅能满足人们最浅薄的欲望狂欢，停留在人的情绪表层而无法触碰到人们内心深处最柔软的部分，不能带给我们更加强烈的心灵震颤。然而文学不仅是供给烦闷的人们去解闷，逃避现实的人们去陶醉的，它应当有激励人心的积极性，应当可以和人的灵魂、人的精神发生对话9。很多人会说网络小说本来就是通俗文学，不必承担和传统文学一样的责任，但这显然是不对的，只要某种东西成为社会现象，会对整个社会产生影响，它就应当担负起引导社会价值观的责任，毕竟所有人都不希望下一代整体拥有一种扭曲的价值观。这种扭曲价值观集中体现在崇尚暴力、抄袭、蔑视人命、鼓吹侵略以及对金钱、情色等三俗内容的宣扬，越是影响力大的作品，产生的影响越恶劣，因为很多网文读者年龄都不太大，即使是三观已经形成，阅读时整个人的意识也处于一种不设防状态，容易被潜移默化的影响，以唐家三少为例，其作品影响力较大，但也存在抄袭和宣扬三俗的问题，长期阅读其作品的人应该已经意识到了这一点，想详细了解的可以参考 唐家三少十大“名场面” 这个视频。 但我们也不能否认，还有相当一部分作者在努力挖掘网文中积极的正面意义，凭借着较高的立意来吸引读者，乃至成为经典，邵燕君老师在《网络文学经典》解读中提到的一些作品就都属于这方面的例子，如今何在的《悟空传》、烟雨江南的《亵渎》、梦入神机的《佛本是道》、月关的《回到明朝当王爷》等，甚至江南的《龙族》也是凭借着少年成长这种意象才吸引了大批的读者（不提后面垮掉的部分）。有些题材本身就蕴含着很高的立意，全在于作者是否从这方面去思考和写作，典型的如穿越和重生元素，B站 UP主 大门ZRR 在对《琥珀之剑》的分析中给出了详细的说明。 第三部分是文学的底蕴。我们所有人都感受过诗歌的华美，也感受过那种战争场面的波澜壮阔，文字有着震撼人心的力量毫无以为，而网络小说以文字作为载体，也有着相同的潜力，尤其是网文的复杂性使它经常涉及各种场面和情节的描写。从语言本身的美感到人物形象的塑造、人物关系的处理，再到气氛和情绪的渲染、战斗场面的描写，等等，网络小说不能因为自己是通俗文学就放低要求，它必须在一定的水准之上才能满足读者的审美。当前，网络小说的典型问题在于人物描写的脸谱化和语言本身的问题，如各种错别字频出，标点符号使用不当，字词的使用过于低龄化，语句过于冗余（所谓的「水」）等，要走的路很长。 ","date":"2021-02-27","objectID":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/:2:0","tags":["杂谈"],"title":"网络小说防沉迷之从提高审美能力开始","uri":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/"},{"categories":["平日里的白日梦"],"content":"3. 后记 写完这篇文章发现，网文对篇幅长度和创作速度要求和作者的笔力之间的矛盾是不可调和的，写作门槛极低导致了网文虽然有经典，但多数都是滥竽充数的「毒草」，甚至即使是经典，受到读者反馈、资本诱惑、作者笔力等因素影响，后期也会出现各种问题。那么，我为什么还要看网文呢，追求刺激，我可以去看大场面电影，追求体验，我可以去玩 RPG 游戏，而论文学底蕴语言琢磨，传统文学不香吗，为想象力买单，真的值吗（仔细想了想好像还可以）。 有意思的是，当你了解了网文的叙事逻辑，就会产生「它好像也没什么大不了的」这种想法，于是诱惑力瞬间下降，再加上人们总是会对无形的威胁抱有更大的警惕，如果说网文导致我们分心、熬夜，可能不会有什么感触，但是突然明白网文会潜移默化影响我们的三观，内心防线瞬间就建立了起来，这个时候网文再想让我们沉浸就不太容易了。所以到最后，苦心建立的评价体系反而没起太大作用，不过，我好歹达成了自己的目的，这也就够了。 最后的最后，其实本来打算写两篇的，还有一篇是对上瘾机制的分析，现在就把它放到手机防沉迷中吧，因为网络小说也才只占了手机使用时间的一半，自我纠正之路，任重道远。 中国互联网信息中心，第 46 次中国互联网络发展状况统计报告，2020.09.29. ↩︎ 邵燕君. 网络文学经典解读[M]. 北京大学出版社. 2016.03. ↩︎ 大门 ZRR，B站小说评论类 UP 主，对网络小说的见解非常深刻。 ↩︎ 幸鑫. 窥见“玄幻世界”[J]. 上海文化,2018.06 ↩︎ 李榛涛. 重构理想的网络游戏新世界—网游小说类型研究[J]. 上海文化, 2017.10. ↩︎ 王哲. 想象的可能和另一种世界的构建—网络同人小说研究[J]. 上海文化, 2017.08 ↩︎ 吴子林．玄幻小说的文化面相．重庆三峡学院学报，2007（4）． ↩︎ 珍·克里斯特勒. 学会吃饭[M]. 中国友谊出版公司. 2019.07. ↩︎ 沈雨前．网络类型小说新伦理叙事研究．广州：暨南大学，2014 ↩︎ ","date":"2021-02-27","objectID":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/:3:0","tags":["杂谈"],"title":"网络小说防沉迷之从提高审美能力开始","uri":"/2021/the-exploration-of-quit-novels-begins-with-understanding-the-core-of-the-novel/"},{"categories":["我所热爱的生活啊"],"content":"最近几年人们总说年味儿越来越淡，我却很少有这种感觉。确实，随着时代发展，本来只会在大年夜吃到的大餐平时想吃就吃，本来过年时令我们激动不已的新衣平时也想买就买，加上最近两年灿烂的烟花不再出现在除夕和元宵的夜空，本来精彩纷呈的联欢晚会变得无聊至极，元宵节的花车游行又屡屡被禁止，过年似乎已经简化为了一个简单的符号。但年味儿真的仅仅如此吗，那些成百上千年流传下来的习俗，似乎已经被我们忘却了许多，而它们，也是构成这个年很重要的一部分。 这篇文章我想介绍一下我们家在整个过年过程中所保留下来的习俗，正是这些习俗维持着我映像中那股年味，从小到大，永远不散。当然，这些习俗很有地域性，大家有兴趣也可以在留言区写一下自己地区的习俗。 腊月初一，咬灾。在腊月初一之前，要提前准备好爆米花，腊月初一早上醒来，在说第一句话之前，要先吃几颗昨天晚上放在枕头旁的爆米花，叫做「咬灾」。 腊月初八，腊八粥。之前好像没过过这个节日，但老妈说有，那就在这一天吃顿好的吧。 腊月二十三，灶王爷上天。腊月二十三是北方小年，老一辈说这一天灶王爷上天述职，之后一直到除夕，这段时间就开始过年的准备工作了，包括大扫除、添新衣、买年货和做年菜等。前两个不需要多说，买年货主要是购置足够的米面蔬菜、小零食和干货，多数是用于正月期间的待客，年菜的话现在唯一保留的是蒸抓钱和枣山，后面会写哪一天来吃它们。 大年三十，除夕。大年三十早上要吃黄枣糕，以前是下图中左边这种，现在一般是下图右边这种。 早上吃完饭，就要去祭拜先祖了（上坟），需要先拜一下土地，然后再开始拜祖先，当然，这里的祖先一般仅仅是祖辈或曾祖辈。祭拜完之后，回到家开始贴春联和福字以及挂灯笼，如果是以前，不仅家门口，碾子、平车、牲畜圈都要贴相应寓意的春联，如果家门口对面有树，还要贴一张「出门见喜」，不过现在需要贴的就很少了，一般只有家门和车库两个地方。除夕的中午吃面，而且需要专门留下一部分，到初一的晚上吃汤面饺子，叫做「隔年面」。 下午打扫一遍倒完垃圾后，就开始准备晚饭了，一旦烧香、响鞭炮（当然现在不可以了）、吃晚饭这一套流程走完，就不可以做其他事了，包括倒垃圾等等的杂事，然后开始一边看春晚一边守岁。虽然最近两年春晚越来越无聊，但是它不重要，重要的是一边看一边聊天，然后一边包饺子的氛围。守岁到十二点，需要先烧香然后响鞭炮，叫做「震灾」。之后大人继续守岁，小孩子一般就去睡了。 初一，拜早年。初一早上穿新衣服，然后要先给父母拜年才可以吃早饭。上午的时候如果在村里，会有子辈成群结队挨家挨户去给长辈拜年，这时候一般是看望同宗族的年龄大的老人，现在则一般是邻里之间相互走动。初一的晚上，是年夜饭了（我们这边年夜饭是初一）。 初二，早上吃抓钱，去舅舅及叔伯家拜年 初三，去师傅家、姑姨家拜年 初四，回娘家 初五，早上吃寿头枣山，由于「五不动，十不动」，初五不走亲戚 另：从除夕晚上烧香祭完神开始，一直到初五结束，都不可以倒垃圾，据说是会把财倒掉。 初五以后，长辈到小辈家，叫做「送十五」 正月十五，元宵节。早上吃七星枣山，白天街上会有花车游行和各种表演，晚上则有花灯和猜灯谜活动 ","date":"2021-02-20","objectID":"/2021/life-skills-spring-festival-customs-record/:0:0","tags":["生活技能"],"title":"生活技能-春节习俗记录","uri":"/2021/life-skills-spring-festival-customs-record/"},{"categories":["研究生的区块链学习之路"],"content":"论文的编辑要插入两段伪代码，这里总结一下伪代码书写用到的 LaTeX 包和书写规范。 ","date":"2021-01-18","objectID":"/2021/pseudocode-specification/:0:0","tags":["科研记录"],"title":"科研基础3-伪代码规范","uri":"/2021/pseudocode-specification/"},{"categories":["研究生的区块链学习之路"],"content":"1. 伪代码规范 伪代码是一种接近自然语言的算法描述形式，其目的是在不涉及具体实现（各种编程语言）的情况下将算法的流程和含义清楚的表达出来，因此它没有一个统一的规范，有的仅仅是在长期的实践过程中形成的一些约定俗成的表达样式。下图是一个简单的例子1，但已经包含了大多数主要元素 首先需要一个标题来描述整个算法，一般还会有一个与之一起的编号。在上图中，算法的标题为「Acesscontrol algorithm flow」，编号为「Algorithm 1」。标题与编号一般位于算法顶部，但也有人放在底部，编号多按全文的算法总数进行索引，但也可以按章节分别进行索引。 其次，在正式的算法流之前需要声明输入和输出。通常使用关键字 Input 和 Output 来声明，但也有人使用关键字 Data 和 Result。 顺序、选择与循环结构是算法的主体。通常，不同的程序块使用缩进来保持结构清晰，但也有不少人使用垂直连接线进行进一步划分，如上图。另外，和编程语言类似，伪代码中的选择和循环使用 if-then-else、while-do 和 for-do 等关键字和结构来描述2，举例如下，其中，每个程序块结束的 end 关键字有人选择写，也有人选择不写。 赋值操作一般使用左箭头「\u003c—」表示。A[i] 用来表示数组 A 的第 i 个元素，A[1…j] 则表示下标从 1 到 j 的子数组；函数调用使用函数名+传入参数的形式；返回值使用 return 关键字，这些都和常规编程语言相同。需要注意的是，未声明而使用的变量都可以视为算法内的局部变量，如果是全局变量则需要进行解释，可以在上下文中，也可以使用注释；注释的形式也和传统语言相同，使用 // 或 /*……*/。 算法整体通常使用三线框包围，但也有少部分人使用一个完整的框。 伪代码的语句一般不需要在末尾使用分号，但行首通常会添加行号。 ","date":"2021-01-18","objectID":"/2021/pseudocode-specification/:1:0","tags":["科研记录"],"title":"科研基础3-伪代码规范","uri":"/2021/pseudocode-specification/"},{"categories":["研究生的区块链学习之路"],"content":"2. LaTeX包 latex 书写伪代码主要有三种排版格式：algorithm+algorithmic、algorithm+algorithmicx 以及 algorithm2e3。我们使用 algorithm2e，它提供了垂直连接线，可以去掉 end 关键字，而且写起来更像编程语言，用着非常舒服。 引入 algorithm2e 包使用如下语句 \\usepackage[options]{algorithm2e} 几个重要的 options 如下 ruled：让标题显示在上面，默认会显示到最下面； vlined：默认启用垂直连接线； linesnumbered：让算法显示行号，不包括 input 和 output 部分； noend：程序块结束不打印 end。 常用命令如下4 命令 含义 \\caption{} 插入标题 \\KwIn{输入信息} 效果为：“In：输入信息” \\KwOut{输出信息} 效果为：“Out：输出信息” \\For{条件}{循环语句} for 条件 do 循环语句 end \\If{条件}{肯定语句} if 条件 then 肯定语句 end \\While{条件}{循环语句} while 条件 then 循环语句 end \\tcc{注释} /*注释*/ \\tcp{注释} // 注释 \\eIf{条件}{肯定语句}{否定语句} if 条件 then 肯定语句 else 否定语句 end 一个官方的例子如下 \\begin{algorithm} \\SetKwData{Left}{left}\\SetKwData{This}{this}\\SetKwData{Up}{up} \\SetKwFunction{Union}{Union}\\SetKwFunction{FindCompress}{FindCompress} \\SetKwInOut{Input}{input}\\SetKwInOut{Output}{output} \\Input{A bitmap $Im$ of size $w\\timesl$} \\Output{A partition of the bitmap} \\BlankLine \\emph{special treatment of the first line}\\; \\For{$i\\leftarrow2$ \\KwTo $l$}{ \\emph{special treatment of the first element of line $i$}\\; \\For{$j\\leftarrow2$ \\KwTo $w$}{\\label{forins} \\Left$\\leftarrow$ \\FindCompress{$Im[i,j-1]$}\\; \\Up$\\leftarrow$ \\FindCompress{$Im[i-1,]$}\\; \\This$\\leftarrow$ \\FindCompress{$Im[i,j]$}\\; \\If(\\tcp*[h]{O(\\Left,\\This)==1}){\\Left compatible with \\This}{\\label{lt} \\lIf{\\Left $\u003c$ \\This}{\\Union{\\Left,\\This}} \\lElse{\\Union{\\This,\\Left}} } \\If(\\tcp*[f]{O(\\Up,\\This)==1}){\\Up compatible with \\This}{\\label{ut} \\lIf{\\Up $\u003c$ \\This}{\\Union{\\Up,\\This}} \\tcp{\\This is put under \\Up to keep tree as flat as possible}\\label{cmt} \\lElse{\\Union{\\This,\\Up}}\\tcp*[h]{\\This linked to \\Up}\\label{lelse} } } \\lForEach{element $e$ of the line $i$}{\\FindCompress{p}} } \\caption{disjoint decomposition}\\label{algo_disjdecomp} \\end{algorithm} 渲染后的样式如下 注：当前算法选然后条件语句会带有下划线，主要是因为同时使用了 \\ulem 包，产生了冲突，去掉该包即可 当算法过长，超过一页时，由于algorithm2e 没有提供相应的拆分机制，需要自己进行处理，文档描述如下 Caution: algorithms cannot be cut 自行拆分的方法是，在需要拆开的部分提前加入算法结束符，然后新建算法，示例如下，例子中省略了非必要的代码，但已足够说明如何使用，即只需要新开一个算法块，然后设定行号即可。 \\begin{algorithm} $\\mathcal{E}\\leftarrow\\emptyset$\\; \\end{algorithm} \\begin{algorithm} \\setcounter{AlgoLine}{12} $\\mathcal{E}\\leftarrow\\emptyset$\\; $\\mathcal{E}\\leftarrow\\emptyset$\\; $\\mathcal{E}\\leftarrow\\emptyset$\\; $\\mathcal{E}\\leftarrow\\emptyset$\\; $\\mathcal{E}\\leftarrow\\emptyset$\\; \\end{algorithm} P. Wang, Y. Yue, W. Sun and J. Liu, “An Attribute-Based Distributed Access Control for Blockchain-enabled IoT,” 2019 International Conference on Wireless and Mobile Computing, Networking and Communications (WiMob), Barcelona, Spain, 2019, pp. 1-6, doi: 10.1109/WiMOB.2019.8923232. ↩︎ algorithm2e package document ↩︎ Joe_WQ，latex 中的 algorithm 环境，简书，https://www.jianshu.com/p/fe9ba3c2424d ↩︎ 熏风初入弦，用 LaTeX 优雅地书写伪代码—Algorithm2e 简明指南，知乎，https://zhuanlan.zhihu.com/p/166418214 ↩︎ ","date":"2021-01-18","objectID":"/2021/pseudocode-specification/:2:0","tags":["科研记录"],"title":"科研基础3-伪代码规范","uri":"/2021/pseudocode-specification/"},{"categories":["平日里的白日梦"],"content":"当我们处于压力或无聊的心理状态中的时候，就会想要寻求一些即时的缓解，而这些消遣手段却总是让我们陷入更糟糕的状态。所以，我们需要集中在积极而有建设性的事情上，通过合理的饮食和锻炼，照顾好自己的身体，以及加强社交，这样才能应对一些不可避免地负面情绪，才会有更好地状态。 ","date":"2021-01-14","objectID":"/2021/addicted/:0:0","tags":["杂谈"],"title":"上瘾","uri":"/2021/addicted/"},{"categories":["我所热爱的生活啊"],"content":"健这一篇主要来构建健身体系的框架，后续的工作即完善和填充这个框架的细节。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:0:0","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"1. 对健康的追求 开始健身的目的很单纯，就是为了减肥，最好拥有良好的肌肉形态，但逐渐的，促使健身的因素变得复杂，包括 为了增强体质，预防各种疾病，终极的追求是直到死亡前的最后一刻都没有大病缠身； 为了达到一定的体能水平，以便进行任何喜欢的运动或应对可能的户外风险； 为了释放压力。 直到最后，追求健康成为了健身的终极目的。但追求健康并不意味着更简单，因为现代意义的健康包括身体、情感、社交、智力、精神和工作能力等各方面，具体描述如下 身体：有足够精力完成日常活动的能力； 情感：理解感情、接受限制、稳定情绪的能力； 社会：处理家庭和社会关系的能力； 智力：为自我发展而学习和运用知识的能力； 精神：能够找到人生的意义和现实生活的方向； 工作能力：在工作中获得自我肯定和自我价值感的能力。 为追求健康所采取的行动也不再限于健身，还包括了健康饮食、睡眠和压力管理。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:1:0","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"2. 运动、体力活动和健身 运动代指由骨骼肌收缩引起的，能使机体能量消耗增加的一切身体运动。从运动与饮食两个对立面看，运动的主要目的就是消耗能量，而我们的能量消耗主要来源于三个方面 维持生命体征的基础代谢，约占总能量消耗的 60-70% 食物特殊动力学作用（即通常说的食物消化），约占总能量消耗的 10% 各种类型的体力活动，约占总能量消耗的 20-30% 「体力活动」指那些需要付出努力、能量消耗高于安静时水平的体力活动，比如轻型园艺、家务劳动、上班走楼梯等日常活动，它是三种能力消耗来源中最可控的一个，因此也是我们用来保持健康或减肥的主要手段。日常生活中的体力活动主要分四方面： 职业性活动：与工作相关的体力活动； 家务性活动：家庭中的体力活动（如家务、照看小孩、园艺等）； 交通性活动：交通中的体力活动（如步行、骑自行车等）； 休闲性活动：闲暇时间的体力活动，可以进一步分为竞技运动、娱乐性运动和体育锻炼等。 从增加能量消耗的角度看，不少手段都是在这四个方面寻求办法，比如站立办公就是在增加职业性活动所消耗的能量，步行或骑车上班就是在增加交通性活动所消耗的能量等。而我们所提到的健身，主要指人们为增进身体健康，按照结构化流程进行的一种专门的、有计划的体力活动，以提高自身有氧能力为目标的有氧运动、以提高肌力和肌耐力为目标的力量训练都属于其范畴。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:2:0","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"3. 体能 为了囊括所有需要讨论的东西，我们从体能（体适能） 这个概念入手来建立整个框架。 体能代表了身体和精神的能力，不仅表现在运动能力和工作能力上，也表现在对疾病的抵抗力和对环境的适应能力，通常包括与健康相关的健康体能和与运动技能有关的运动体能两部分，它们各自包含的内容如下。 体能 健康体能 运动体能 成分 心肺耐力 肌肉力量与肌肉耐力 柔韧性| 身体成分 速度 爆发力 灵敏性 平衡性 协调性 反应时间 目的 保持身体健康，提高生活质量 提高运动技能水平，增大比赛中获胜的几率 科学研究表明1，运动和健康饮食确实可以避免肥胖和预防各种慢性病，包括心血管病、冠心病、II型糖尿病、部分癌症、部分精神疾病、心肌梗死、痴呆、中风、骨质疏松等。其中，心肺耐力的锻炼可以促进心腔扩大、心壁增厚以及提高心脏最大射血能力，还可以保持血管弹性、维持动脉血压的稳定、增大冠状动脉直径、改善心肌的血液循环。肌肉力量和肌肉耐力的练习则对骨骼系统有重要功效，可以防止骨质疏松，增加关节稳定性，提高动作平衡能力，对由于摔倒、骨折、功能衰退所造成的不良结果起预防作用，也可以使神经肌肉系统、骨骼、关节和韧带承受更大负荷，降低损伤概率。因此，我们主要从健康体能的四个方面进行介绍。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:3:0","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"3.1 心肺耐力 心肺耐力指由心脏、血液、血管和肺组成的呼吸和血液循环系统向肌肉输送氧气和能量物质，维持长时间身体活动需要的能力。 良好的心肺耐力可以使我们轻松应对日常学习和工作，不易感觉疲劳，同时对预防心血管和呼吸系统疾病有重要作用。因为经过长时间的运动刺激，一方面，左心室内腔扩大，心肌有氧代谢能力改善，增强心脏的泵血能力，提高循环系统运输氧气和养分的效率；另一方面，肺通气量的藏家和弥散能力的提高又能促进肺功能的改善，使机体对抗负荷时能得到充足的氧气供应。 训练心肺耐力的主要方式是有氧运动，有氧的含义是运动过程中机体摄入的氧气量和所消耗的氧气量基本相等，处于「有氧」状态，这种状态下，略感气喘，又不至于上气不接下气；稍微出汗，又不至于大汗淋漓；感到全身舒展，但不觉得肢体疲劳。因此，有氧运动主要指以有氧代谢为主的、有节律的、全身主要肌群参与的、经常进行的耐力运动，如步行、慢跑、有氧操、游泳、越野滑雪、跳绳、骑自行车、登山等，另外，某些球类活动（乒乓球、羽毛球、足球、篮球等）、我国传统的体育活动（太极拳、太极剑等）和小负荷的力量训练也都有提高心肺功能的作用。有氧运动具有如下特性 长时间的运动，至少持续 20-60min 全身性的大肌肉活动，不得少于 1/6 有稳定性，应当维持在某一特定强度 有节奏性，是有律动的肢体活动 评价心肺耐力最简单的方法是台阶测试，而通用的评价指标是运动强度。以最大摄氧量百分比计算，运动强度应该在 50%~85%，以更简便实用的心率来算，应该为 60-80% 的心率储备或 77-90%最大心率。 训练频率上，每周训练3天，每天运动 20-60min 是最佳选择。如果以较低强度训练时，其训练频率每周应超过3天，当然，每周训练次数的设定要取决于热量消耗的目标、个人的习惯以及日常生活作息时间等因素，每个人应该根据自己的情况制定。 最后，心肺功能的锻炼应遵循渐进原则，运动强度和持续时间应该逐渐增加，长此以往，就可有效地提高或保持最大摄氧量，达到减重和促进健康之目的。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:3:1","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"3.2 肌肉适能 肌肉适能是指机体依靠肌肉收缩克服和对抗阻力维持身体运动的能力，通常表现为肌肉力量、肌肉耐力和肌肉功率等方面。日常生活中的一些小事，如搬运重物、做家务、坐、走、跑、跳等都离不开肌肉适能。 肌肉力量是肌肉所能发挥的最大力量，比如拳击运动员出拳所释放的最大力量。肌肉耐力是肌肉持续工作的能力，比如长跑和限时仰卧起坐考研的就是肌肉耐力。肌肉功率是肌肉在短时间快速发挥其力量的能力（通常用爆发力作为指标）。因此，肌肉力量的评价技术通常包括卧推、负重蹲起、负重曲肘、俯卧屈膝、杠铃上举等；肌肉耐力的评价技术通常包括连续蹲起次数、曲臂支撑时间、1分钟俯卧撑、1分钟仰卧起坐、1分钟引体向上等；肌肉功率的评价技术包括立定跳远、深蹲跳、半蹲跳、多级跳、跳箱等。 肌肉适能主要受遗传、年龄、性别、体重、激素以及训练的影响，研究表明，绝对力量的遗传度为 35%，相对力量的遗传度高达 64%，不过，遗传因素只决定运动能力的起点，通过后天训练依然会有较大的提高。肌肉力量也随着年龄而变化，少年儿童肌肉组织中含水量较多，蛋白质、脂肪以及无机盐类较少，能量储备较差，因此肌肉力量较弱，男女达到最大肌肉力量的年龄分别是 25 岁和 22 岁，此后肌肉力量就会随着年龄增长而衰退。 抗阻训练可以改善肌肉适能，包括居中、弹力带、自重和器械训练等多种形式，主要是因为运动刺激一方面可以使身体的有氧耐力增强、肌纤维的横截面增大，另一方面可减少大脑皮层的抑制作用，增强肌群间的协调能力，进而在总体上提高肌肉力量和肌肉耐力。 男生训练肌肉时大致可以分为几个部分：胸部、手臂、腹肌、肩部、臀部、腿部和背部。其中 胸部由胸大肌、胸中肌、胸小肌等肌肉构成，常见的胸部训练动作有：哑铃卧推、宽距俯卧撑等。 手臂主要包括肱二头肌、肱三头肌及其它前臂肌群，常用训练动作有：哑铃锤式弯举、反握引体向上。 肩部主要由三角肌等肌肉构成，练肩能有效解决溜肩问题。常用训练动作有：哑铃侧前交替平举、弹力绳推举。 腿部肌肉主要包括四头肌和小腿肌群等。 腹肌主要包括腹直肌、腹外斜肌、腹内斜肌等，常用训练动作有悬垂抬腿。 臀部主要有臀大肌、臀中肌、臀小肌等，常用训练动作有负重臀桥、俯撑抬腿等。 改善肌肉适能的原则包括：持续训练、循序渐进、变换负荷、有效负荷和训练恢复。对于第三点，是因为人体对外来负荷刺激具有适应性，长时间使用同样的训练负荷和手段，锻炼效果就会越来越弱。负荷的变化体现在训练方式、负荷的量和强度等方面，在不影响训练效果的前提下，应当定期增加新的训练手段，一些常用的训练手段也应该采取间隔使用或不同组合的方式进行变化。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:3:2","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"3.3 柔韧性 柔韧性指人体关节在不同方向上的活动幅度，以及跨过该关节的肌肉、韧带、皮肤等软组织的弹性和伸展能力。以髋关节为例，可进行屈、伸、内收、外展、旋内、旋外等活动。良好的柔韧性可以降低肌肉受伤和酸痛的几率，也可以预防和矫正不良姿势。 影响柔韧性的生理因素主要有四种：关节面结构、肌肉、韧带组织的伸展性、关节周围组织的体积以及中枢神经系统对骨骼肌的调节能力。其中，关节面结构是由遗传决定的，其它三方面都可以后续锻炼。另外，温度增加也可以增大肌肉运动的范围和伸缩性，因此在寒冷的冬季人体会感觉柔韧性较差。 柔韧性的评价主要是通过测量身体有关部位完成动作时活动的幅度完成的，比如坐位体前屈等。柔韧性本身则通过全面的拉伸训练而保持，通常作为准备活动和整理活动的一部分。 准备活动（热身）的作用： 可以逐渐提高中枢神经系统的兴奋性，克服机体惰性 作为剧烈运动前的预热，可以增强机体的新陈代谢，保证体能的正常发挥 有助于改变血流方向，在正式运动时使更多血液流向肌肉，为肌肉输送更多的养料和氧气 可以提高肌肉和关节韧带的弹性，降低粘滞性，使关节腔内滑液增多，预防肌肉和韧带拉伤 运动完整理活动的作用： 有助于血液返回心脏，促进运动中代谢物的排出，加速运动后的体力恢复 通过舒展肌肉痉挛，缓解运动后的肌肉酸痛 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:3:3","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"3.4 身体成分 身体成分是指身体的构成成分。我们的身体由无脂肪组织（包括肌肉组织）和脂肪组织组成。一般来讲，人们会把身体成分的焦点放在肌肉以及脂肪的相对含量和比例上面，反映出来的就是更好的身材，也是人们追求的主要目标。 身体成分通常用 BMI 表征，BMI = 实际体重（kg）/身高(m^2)，其中，18.5 \u003c= BMI \u003c 22.9 为正常体重。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:3:4","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"4. 饮食、睡眠及压力管理 从阴阳平衡的角度看，如果健身为阳，那么饮食、睡眠及压力管理就是阴，都是追求健康过程中不可缺少的一环。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:4:0","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"4.1 饮食 健康饮食不是只选择那些没有吸引力的食物，完全可以既美味又富含营养，中国营养学会每5年发布一版《中国居民膳食指南》，会针对国人的特点提出相应的建议。 健康的饮食模式应该包括蔬菜、水果、谷物（至少一半的全谷类）、脱脂或低脂的食物，以及多样化的蛋白质食物（如海鲜、瘦肉、家禽、蛋类、豆类、坚果类、种子类以及大豆制品）。同时，应控制饱和脂肪、反式脂肪、添加的糖类以及钠的摄入。上述策略可以个性化，以符合个人的健康需求、饮食喜好及传统习俗，而不必规定单一的、严苛的饮食模式。重点在于合理、灵活地搭配各种食物，从而建立健康的饮食模式。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:4:1","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"4.2 睡眠 睡眠对于我们身体各项功能的正常运行至关重要。相关功能如下 睡眠期间，心率和血压会自然波动，以促进心血管健康。 深度睡眠期间，由于生长激素的分泌，细胞和组织得以修复。 通过产生靶向性细胞因子，身体的免疫功能得到提高。 与食欲相关的荷尔蒙会产生变化（抑制食欲的瘦素增加，而刺激食欲的胃饥饿素减少）。 睡眠不足会使日常工作如学习、集中精力和反应更加困难。那么怎样判断自己的睡眠是否充足呢？白天打瞌睡是缺乏睡眠的一个非常简单却很明显的指标，表明身体需要更多的睡眠。白天明显的困倦表明需要更多或更好的睡眠，或者两者兼而有之。另外，观察和记录自己的睡眠习惯和睡眠状况的变化趋势会带来很大的帮助。 一些改善睡眠的小技巧如下 每天坚持按时睡眠，包括周末时间。 执行一种能让自己放松下来的睡眠仪式。 每天坚持体育锻炼。 保证卧室有理想的温度、声音和光线。 在舒适的床垫和枕头上睡觉。 当心那些可以影响睡眠的物质，比如酒精和咖啡因。 睡前关闭所有的电子设备。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:4:2","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"4.3 压力管理 什么是压力？从最基本的层面来讲，压力是大脑对需求的反应。不是所有的压力都一样，它可以被划分成很多种，包括急性压力、发作性急性压力和慢性压力。 急性压力源自最近发生的事件，或不久的将来要发生的事件所产生的需求和压力。其压力源是短期的，比如弄丢了汽车钥匙，或者要处理客户的投诉。处于这种压力中的常见症状包括情绪易怒、暴躁、焦虑、紧张性头痛、肌肉紧张、消化系统问题，以及其他生理反应，包括血压升高、心率加快、出汗，甚至呼吸急促或胸痛。 发作性急性压力常发生在急性压力频繁出现时。想象一下，一个人担子太重，任务太多，他总是匆匆忙忙，又总是迟到。似乎永远在一个危机结束时又迎接下一个危机，或遭受持续的困扰。承受发作性急性压力的症状包括持续的紧张性头痛、偏头痛、高血压、胸部疼痛和心脏病。 慢性压力是持续性的、很折磨人的压力，它会无情地、长时间地困扰我们。未经处理好的慢性压力所引发的健康问题包括焦虑、失眠、肌肉疼痛、高血压及抵抗力降低。另外，压力还会引发心脏病、抑郁症和肥胖病。 面对短期压力，人们通常在对特定的情况做出反应之后就回到放松的基本状态。长期压力比较麻烦，因为我们的身体会长期处于警戒状态。这种状况相当于我们为身体启动了“冲刺”装置，时刻准备一触即发（见下面的“战斗或逃避反应”），迫使身体一直处于“马拉松式”或持续的紧张状态，时间久了就会导致身体崩溃或者系统衰竭。压力影响着我们身体的每个系统，比如我们的肌肉与骨骼系统会出现肌肉紧张；消化系统会出现腹泻或便秘；内分泌系统会出现应激激素分泌增加和血糖水平升高；另外，也会增加心血管系统中高血压、心脏病及中风的发作风险。 在生活中未雨绸缪，提前准备应对生活中可能出现的状况有助于防止压力给我们带来负面影响。当然，不是所有的压力都能够被避免，因此，有效控制自己对压力的反应尤为重要。经常用来帮助应对压力的有效方法就是有规律地参加体育锻炼和健康饮食。此外，下面的小技巧也可以用来防止或管理压力 给自己安排一份时间表。记得并执行日程安排可以帮助减少紧急情况带来的压力感。 避免拖延。提前有序地完成工作任务可以有效避免压力。 做深呼吸放松。有意识地减慢呼吸频率，并加深每一次呼吸有助于消除在面临压力时通常会出现的快速呼吸和浅呼吸。 控制酒精的摄入。尽管酒精有暂时缓解压力的作用，但长期依赖酒精减压有非常大的副作用，并且会产生更多的身体压力。 跟家人或朋友聊天。跟信任的人聊一下带来压力的事情很有好处。这不仅仅是因为它能帮助我们“摆脱烦恼”，还可能会得到有用的建议。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:4:3","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"5. 规律锻炼的技巧 开启锻炼，以及要取得良好的锻炼效果，需要科学的锻炼计划。这个锻炼计划除了包括一个明确的锻炼目标，还需要确定锻炼项目、锻炼强度、锻炼频率和每次锻炼的时间。其中，锻炼项目应根据锻炼目的选择，改善心肺一般选择有氧运动，强壮肌肉则选择力量训练。最后，锻炼计划还需要适时的评价与调整。但要注意，锻炼计划并不是精确的公式，它有点像菜谱，虽然列举了各种食材和配料，但烹饪过程中每个人依然有自己的习惯，因此每个人的锻炼计划都是独一无二的，应该根据自己的健康状况、现有运动水平和健身目标指定适合自己的计划。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:5:0","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"5.1 评价锻炼计划的参数 体力活动的定量测量最常用的指标是锻炼强度、锻炼时间和锻炼频率2。 运动强度的评价方式有很多，比如最大摄氧量、自我感觉、代谢当量等，但最容易操作的方式是根据心率判定。心率，即每分钟心脏跳动的次数。在一定范围内（100～180次/分），心率与运动强度呈直线关系，所以心率可以反映运动的强度。由于心率受年龄、身体状况、训练水平和性别等多方面影响，因此实际应用时，通常采用最大心率百分比的方式对运动强度分级，最大心率可按照 220-年龄（岁）来计算。比如，20岁的健康成年人，最大心率=220-20=200（次/分）。一般而言，运动时心率在 40%～54% 最大心率范围内为小强度；在55%～69%最大心率范围为中等强度；而运动时心率大于70%的最大心率为大强度。如要减肥，对年轻人而言，一般运动强度控制在60%～75%的最大心率，则对脂肪的消耗比较有效3。 锻炼时间指每次运动的时间，长短根据运动种类和个人身体情况确定。经常参加体育锻炼的人，每次锻炼的有效运动时间应达到 30-60min。初次参加体育锻炼的人，建议按如下方式确定：第一周 10-15 min，第二周 15-20 min，第三周 20-25 min，第四周及以后达到 30-60 min，还要注意，每次锻炼前后应有 5-10 min 的准备活动和整理活动。 运动频率指每周参加锻炼的次数，每周1次锻炼效果不大，2次可累计，3次运动效果明显，增加到4-5次锻炼效果依然可以提高，但终止体育锻炼，已获得的健身效果会以获得效果 1/3 的速度消失，所以要坚持锻炼。有体育锻炼习惯的人，每周锻炼频率应在3次以上，初次参加可遵循下面的原则，第一周1-2次，第二周2-3次，第三周及以后3次及以上。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:5:1","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"5.2 锻炼目标的制定 忽视运动要素中的任何一项都会使健身计划失去平衡，因此，为了改善个人健康或达到健身目标，有氧、肌力和肌耐力、柔韧性都需要得到锻炼。下表列出了一些基于体力活动的有氧耐力及抗阻训练的目标指导 体力活动水平 有氧训练重点 抗阻训练重点 初级（体力活动不足或几乎没有体力活动，后者被划分为未进行过锻炼者） 未进行过锻炼者：重点是每天进行20-30分钟低至中强度的活动。也可以每次持续10分钟，累计完成。总的来说，一周内的目标是60-100分钟。 之前有少量体力活动者（即一旦达到每周60-100分钟的目标）：重点是每天进行30-45分钟低至中强度的活动，也可以每次持续10分钟，累计完成。每周总目标为100-150分钟。 选择6种动作（分别针对以下部位的肌肉：髋部和腿部、胸部、背部、肩部、下背部及腹部）。开始时每周2次，每个动作1组，每组重复10-15次，随着个人的额进步，可以把目标定为每周训练2-3田，每个动作8-12次，1-2组（注意：对于抗阻训练经验不足的中老年人来说，建议每组重复10-15次） 中级（有一定的体力活动，但总体来说还处于中等水平） 中等水平者：重点是每天30-60分钟中强度的活动，每周的总目标是150-250分钟。 选择10种动作（分别针对以下部位的肌肉：髋部和腿部、股四头肌、腘绳肌、胸部、背部、肩部、肱二头肌、肱三头肌、下背部和腹部）。训练目标为：每周训练2-3天，每次2组，每组重复8-12次（注意：对于抗阻训练经验不足的中老年人来说，建议每组重复10-15次） 有运动习惯（会定期有规律的进行中至较高强度的锻炼） 定期锻炼者（中至较高强度）：重点是每天进行30-90分钟中至较高强度运动。每周总的目标是进行150-300分钟的活动（持续时间取决于运动强度） 可以继续中级水平的方案（一旦适应了负荷，应增加重量），也可以把运动方案拆开练习，在某一天专门联系某个肌肉群。 重复次数和组数是抗阻训练的两个重要指标，以举重为例，重复一次指举重的一次动作，举起某个重量再乘以连续完成动作的次数称为一组。对于每个肌肉群都应该进行几组训练。可以重复做某个动作，也可以选择不同的动作来训练同一个肌肉群。重复次数和组数取决于目标。通常来说，抗阻训练应完成2～4组，每组每个动作重复8～15次。对于那些专门针对肌肉耐力的抗阻训练，重复次数一般会增多（如15～25次），比如，像俯卧撑这样的自重练习，就可以25个一组，多做几组。 为了提高肌肉适能，必须对肌肉和肌肉群进行超负荷训练。抗阻训练过程中，相对强度与动作的重复次数和完成组数息息相关。如果不能够一次性重复完成8次规定的训练动作，那么说明使用的重量或阻力太大了。如果能够一次完成15个以上的规定动作，那么使用的重量或阻力可能太轻了。当刚开始锻炼的时候，我们会发现需要不断调整。 合理休息是肌肉能够产生适应性改变的关键。在制定抗阻训练方案时，不要连续两天训练同一肌肉群。开始时，可能会出现肌肉酸痛的情况，但随着训练的推进，这种情况会降到最低。 ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:5:2","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"参考文献 [1] 北京师范大学，《运动与体能提升》，中国大学MOOC，2020年九月第五次开课。 [2] 季浏，《体育与健康》，普通高中课程标准实验教科书，华中师范大学出版社，2004 [3] 芭芭拉·A·布什曼，《ACSM体能指导手册（第2版）》，人民邮电出版社，2020.06. 王香生,黄雅君.体力活动与健康:研究及应用[J].体育与科学,2008(06):76-78+55. ↩︎ 田野,陆一帆等.国民运动健身科学指导系统研究与建立[J].体育科学,2010,30(02):3-10. ↩︎ 王剑，如何为运动计算强度，科学网，2015.05 ↩︎ ","date":"2021-01-11","objectID":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/:6:0","tags":["健身"],"title":"健身的理论框架及基础知识","uri":"/2021/theoretical-framework-and-basic-knowledge-of-fitness/"},{"categories":["我所热爱的生活啊"],"content":"子弹笔记（Bullet Journal）是一种记笔记的方法，集日程表、任务清单、日记本于一体，用几个简单的符号完成所有的记录，我接触它主要是平常就有在纸上写写画画的习惯，但是因为用的切开的 A4 纸，大多最后都找不到，另外，逐渐的想减少手机使用时间，因此将一些功能迁移到笔记本是必由之路。这篇文章记录子弹笔记的一些基础知识，供之后查阅。 ","date":"2021-01-09","objectID":"/2021/the-bullet-journal-method/:0:0","tags":["杂谈"],"title":"子弹笔记详解","uri":"/2021/the-bullet-journal-method/"},{"categories":["我所热爱的生活啊"],"content":"1. 入门 建议先看一下 子弹笔记官网 的入门视频。 子弹笔记的核心概念有：Tasks、Notes、Events 和 Collections、Migration 等，下面分别介绍。 ","date":"2021-01-09","objectID":"/2021/the-bullet-journal-method/:1:0","tags":["杂谈"],"title":"子弹笔记详解","uri":"/2021/the-bullet-journal-method/"},{"categories":["我所热爱的生活啊"],"content":"1.1 核心符号 任务（Tasks）用小圆点「·」表示，之所以用小圆点，是因为最容易改变形状，在它上面进行改变不会出现涂抹痕迹。当任务完成时，就将小圆点改为「×」，当任务推迟时，就改为右箭头「\u003e」，当任务安排到日程表中时，就改为左箭头「\u003c」，简易图示如下。 除了任务之外，事件（Event）用圆圈「○」表示，是一些与日期有关的条目，比如妈妈的生日，也可以用来记录事件的发生，比如签订了租房合同。 笔记用短横线「-」表示，可以包括事实、想法、观察等，用来捕捉我们不想忘记的信息和数据，在会议、演讲、课堂笔记上尤为有用。 这三者也可以以层叠形式出现，代表事件的具体细节或者任务的分步执行。 还有两个增强符号，一般用于放在上面的符号之前，即重要事项「*」和灵感「！」 这里尤其需要注意的是这些符号法则不是限定死的，我们可以在此基础上构建自己的符号法则，只要自己看得懂用的方便就行。 ","date":"2021-01-09","objectID":"/2021/the-bullet-journal-method/:1:1","tags":["杂谈"],"title":"子弹笔记详解","uri":"/2021/the-bullet-journal-method/"},{"categories":["我所热爱的生活啊"],"content":"1.2 笔记的制作 主题（Collection）是子弹笔记的基本组成部分，简单的讲就是一个标题和它对应的内容，最常用的主题包括 Index、Future Log、Monthly Log、Daily Log、Custom Log等。 Index 是索引页，位于笔记本的开始，是后面很多内容（Future Log, Monthly Log, Collection等）的入口，是必须要不断地更新的一个内容。记录的方式一般是先写主题，然后在冒号后跟页码，页码可以连续，也可以分散，比如一个 Collection 占了很多页，可以用连续页码标注，又比如每周都有睡眠记录，可以用分散的页码标注。 Future Log 是一个全年性的日程表，主要是将当月无法完成或未完成的项目按截止日期记录到对应的月份。 Monthly Log 是月度日程表，包含本月的重要日子和待完成的任务。 Daily Log 就是每天的日常记录，使用第一部分提到的标准符号 Custom Log 是其它任何我们想要的记录，比如食物记录、睡眠记录、日记、年度计划、兴趣培养清单、旅行清单、书籍清单、微梦想清单等。 迁移是一种将之前未完成的任务放到当前，或者将当前任务放到之后的操作，比如每月未完成的任务迁移到下一个月，目的是为了使思路更清晰，用的符号是「\u003e」。当然，将任务迁移到之后的某个 Collection，也可以用这个符号。 ","date":"2021-01-09","objectID":"/2021/the-bullet-journal-method/:1:2","tags":["杂谈"],"title":"子弹笔记详解","uri":"/2021/the-bullet-journal-method/"},{"categories":["我所热爱的生活啊"],"content":"2. 自定义 这部分总结一下我想记录些什么内容，或者平时最常记录的是哪些 每周的睡眠记录，可以以分散页码的形式记录到 Future Log 中； 每天的时间记录，和 Daily Log 写到一起； 每天的整理和思考，以单独一个 Collection 的形式写到 Daily Log 里，然后页码添加到 Index； 年计划，写在 Index 和 Future Log 中间，以一个单独的 Collection 形式出现，索引在 Index 中； 月计划，写在 Monthly Log 中； 周计划，在 Monthly Log 中以分步的形式出现； 每周的饮食记录使用随手记和Keep； 书影音依然使用豆瓣记录，重要提醒依然使用手机日历（闹铃提醒） ","date":"2021-01-09","objectID":"/2021/the-bullet-journal-method/:2:0","tags":["杂谈"],"title":"子弹笔记详解","uri":"/2021/the-bullet-journal-method/"},{"categories":["我所热爱的生活啊"],"content":"3. 进阶 首先是 treading，一些项目有时候会持续很长时间，这时候可以在 Collection 的页码前后标明前一个或后一个相关 Collection 的页码，这样 Index 中就只需要记录第一个 Collection 的页码了。 未完待续…… ","date":"2021-01-09","objectID":"/2021/the-bullet-journal-method/:3:0","tags":["杂谈"],"title":"子弹笔记详解","uri":"/2021/the-bullet-journal-method/"},{"categories":["我所热爱的生活啊"],"content":"4. 目前的问题 当天无法完成的任务，且不知道推迟到什么时候 花费多天完成的任务，每天完成一部分 记录事件时的描述方式 一些工作/事情归类到事件还是待做 ","date":"2021-01-09","objectID":"/2021/the-bullet-journal-method/:4:0","tags":["杂谈"],"title":"子弹笔记详解","uri":"/2021/the-bullet-journal-method/"},{"categories":["平日里的白日梦"],"content":"B站纪录片，《致肥元凶》，2012年。 现代人普遍睡眠不足、工作时间过长，更重要的是，普遍肥胖。肥胖不仅仅是外部看到的那样，内脏脂肪远远比皮下脂肪更可怕，危害更大，很多表面看起来正常或比较瘦的人内脏脂肪却会超标。食品业将此归咎于我们摄入的总热量过多，而运动量不够，但真的只是如此吗？事实上，我们并没有更懒惰，但食品产业在过去的几十年中从根本上改变了我们所吃的食物，也改变了我们的体型。我们的基因没有变，但我们所处的环境以及便宜食品的供应改变了，我们每时每刻都处在食品产业的轰炸中，鼓励我们吃掉越来越多的食物。因此，减肥是一场战争，是一场我们的身体对抗现代社会提供的获取食物的便利条件的战争。 PS：不是要甩锅，就像甩锅给基因那样放弃治疗，而是理解造成肥胖的根本原因，从而分析应该从哪些方便改变现状。一味的将原因归咎于自己也是不理智的。 ","date":"2021-01-06","objectID":"/2021/the-man-who-make-you-fat/:0:0","tags":["杂谈"],"title":"《致肥元凶》观影笔记","uri":"/2021/the-man-who-make-you-fat/"},{"categories":["平日里的白日梦"],"content":"糖 大规模机械化生产使得农业生产力大幅提高（在中国也有杂交水稻的原因），但过剩的食物却被资本家用在了对我们有害的方面。 以美国为例，玉米收成提高后，养活了大量的牛，于是，大量廉价牛肉涌入市场。但玉米的产量依然在提高，为了解决这一问题，过剩的玉米被用于生产一种廉价的甜味剂—高果糖玉米糖浆（食品配料表可以找果葡糖浆），并成为了糖的第一替代品。1984年，可口可乐和百事可乐用玉米糖浆取代了蔗糖（因为成本低很多），不过，尽管高果糖玉米糖浆比蔗糖更甜，但生产商并没有少加，反而加的更多了，因为他们发现，这样能卖的更多。 事实上，玉米糖浆不仅被用于软饮料（碳酸饮料、果汁饮料、茶饮料、运动饮料、乳饮料等），也用于各类果酒、啤酒、香槟、雪糕、面包、大多数软糕点和夹心糕点、糖果、水果罐头、蜜饯果酱等等，几乎是所有加工食品的成分之一。玉米糖浆的大量添加直接导致了我们日常所摄入的糖（果糖）的严重过量，研究表明，美国人每年摄入的添加糖达到九十磅，是安全摄入量的两倍还多，从食物中获得的卡路里也从七八十年代到现在几乎翻倍。 PS：软饮料是西方人一天最大的热量来源，但对于中国人似乎并不是。 大量的糖进入人的身体还会带来一些其它的问题。首先，果糖在代谢中直接被肝脏吸收转化为脂肪，直接导致内脏脂肪过多，以及引起糖尿病和其它慢性疾病。其次，研究表明果糖所含的特殊成分能抑制一种重要荷尔蒙（凝集素）的活性。凝集素用于脂肪细胞传递给大脑信息，告诉大脑你吃够了，但当肝脏接收到超出负荷的糖分时，凝集素就会停止工作，我们会一直吃，身体不会发出停止的信号。 PS：相似的，很多标明“低糖”、“无糖”、“低热量”的甜味食品并不是真的无糖，它们所使用的某种代糖（甜味剂）虽然热量很低，但是大多数会增加食欲，反而使热量的摄入增大。 商家的营销手段是更重要的一个原因。在我们没想吃的时候，身边的商店就在不断地提醒我们这里有吃的。而且有些食品的设计刻意使人产生某种享乐反应，即给人瞬间的满足感。所以当我们吃到让人感到享乐的食物时，它就会控制你的大脑，而这种能带来极度愉悦感的食物通常都含有很高的糖分，经过高度加工。食品加工究竟在加工什么，添加的材料要么是为了延长保质期，要么是为了提升口感，其终极目的必然是吸引我们，使我们上瘾从而不断地买这个产品，因此，食品生产商和我们减肥或保持健康的个人目的是绝对相反的。 从科学的角度看，脂肪更容易停留在口中，因为它不能和水混合，所以吞咽食物时，有些脂肪会留在口中，我们就更容易尝到溶解在脂肪中的味道，所以我们会持续感受到美味食物留在嘴里的味道。但在政府发布饮食报告以及人们越来越意识到其危害后，食品业立马在这方面大作文章，他们立马推出低脂肪的产品，给这些产品贴上对心脏无害的标签，并在市场中为这些新产品赢得一定的份额，然后其他人一拥而上，很快就在超市看到一排排贴着低脂及对心脏有益的垃圾食品。食品行业善于将打击不健康食品的行动转化为商机。但是，人们不会因为政府发布的饮食指南开始多吃花椰菜、甘蓝和菠菜。 PS：资本就这样，就像 996，打工人这些都是自嘲，但里面就被资本用于宣传。 低脂食品的塑造并没有减少热量，为了维持口感，生产商加入了大量的糖，结果热量反而提升了。 ","date":"2021-01-06","objectID":"/2021/the-man-who-make-you-fat/:1:0","tags":["杂谈"],"title":"《致肥元凶》观影笔记","uri":"/2021/the-man-who-make-you-fat/"},{"categories":["平日里的白日梦"],"content":"食品份量 世界发展至今，时刻都有食物供应，不论白天黑夜，一天二十四小时，任何时候任何地方，只要想吃就能买到。但我们是从什么时候开始过度吃喝的，是谁认为我们的食量应该越来越大。 这个故事要从一个电影院讲起，电影院的管理者首先发现一份爆米花往往不够吃，但人们又不喜欢一次买好几份爆米花或饮料，增大份量可以解决这一点，而且因为爆米花本身非常便宜，主要的成本都在包装上，增加份量的成本很低，但电影院却可以收远多于所增加成本的钱。汽水也一样，因为它主要是用糖浆和水做的，成本很低。 这一策略紧接着被推广到麦当劳，随后被用于其它食品。对于商家来讲，尤其是快餐店，他们的成本是固定的，比如工资和租金，食物的成本非常低，增加一点份量的花费很少，但对增加的份量收取更多的价格却可以带来更大的利润。对于顾客来说，他们也会觉得这样很划算，因为份量加大了，但价格不是两份的价格，只是介于一份和两份中间。 同时出现的还有柜台服务模式，这种模式带来了更快的餐饮服务和更快的生活节奏，人们可以随时买到并带走便宜的食物。以前人们在街上吃饭是不礼貌的，但现在随时可以看到一边走路一边吃饭的人。但是柜台模式下，人们看菜单的效率很低，往往需要仰头看着菜单想很久吃什么，间接导致排队时间过长，从而导致顾客流失，于是商家又推出了套餐模式。套餐模式是同样的原理，提供一个套餐，比如一个汉堡、一份薯条、一杯饮料，成本会增加，比如增加两毛五，但价格提高五毛，商家就通过这种捆绑销售的思路将更多花样的餐点集合，提高了平均消费水平。对顾客而言，这种方式还变相的增加了卡路里摄入，因为顾客会觉得很划算，毕竟多花五毛就能吃到三样，托盘摆在你面前，你就会想，这是我花钱买的，于是你会把它吃完，即使你本来不需要吃那么多，长此以往，食品业就养成了我们的大胃口。 PS：事实上，餐厅还可以故意把商品单价提高，从而诱使我们买套餐，这样即使想买单个商品也会很吃亏。 PS：国家提倡节约，事实上更好的方式是提倡食品包装的小份，以及禁止套餐式的捆绑销售。而且中国人还是有不浪费的习惯的，很多时候都处于商家这种故意大份量的销售方式。而且，为什么很多政策都是提倡消费者怎么怎么样，而不让企业怎么怎么做呢。 人们吃超大份的时候可能还会抱着如下的心理，即下一顿可以少吃一点，这样的话这一次吃的太多就没有关系了，食品业也这么想，这是这种假设让他们安心地售卖超大份餐点。但科学研究表明，我们所想的是错误的，食物份量越大，我们的胃口反而会更大，从而吃更多的东西，摄入更多的热量。另一方面，高糖高脂最难让人抗拒，科学家用小白鼠研究食欲和行为的关系时发现，想让它们过度饮食，平时的食物是很难做到的，但是换了巧克力饼干、糖果、牛奶等高糖高脂食品，老鼠就开始暴饮暴食，直到身体肥胖。老鼠和人类有着相同的生物属性，这种属性决定了我们会去寻找那些能够储备能量的食物，从而保证食物短缺时也能维持生存。可惜的是这个结果没有得到人们的重视，反而被食品业利用。由于人们每餐所吃的食物在重量或体积上基本是不变的，食品业开始在相同体积或更小体积的食物中塞入更多的热量（即所谓的高能量密度或高卡路里），从而使我们不知不觉就会吃过量。所以两个因素共同导致了过量：高卡路里、超大份量。 PS：消耗大于摄入的原理有时候行不通的原因在于这里，高密度的食物导致很小的一块食物就需要大量的运动消耗，我们要么没有耐心，要么没有时间做这些运动。 PS：高脂肪低碳水的饮食减肥叫生酮饮食。不过我感兴趣的是，高糖高脂可能适合描述西方国家饮食，中国人则多油多盐，盐是不是也有同样的效果呢。 食品业始终认为人们肥胖的关键在于不运动，还制作广告声称孩子们在两餐间吃高脂零食是一件好事，这种广告给了孩子们一个每天随时随地吃零食的理由。但研究结果表明，孩子们的活动水平并不比三十年前低，并不是缺乏运动导致肥胖，反而是由于饮食不当造成的肥胖导致了体育活动的减少。只不过，对于任何政治体系来说，把体育活动定义为潜在原因比较容易，因为这个原因无关政治。 科学界做出了努力，他们令食品业减少了大份食品，但食品业随之想出了新的办法，他们开始推出成对的食物并利用分享的思想做营销，以及推出能重新封口的包装袋。但是，人们一旦打开了一包，一般不会留下下次再吃。可行的办法是对不健康食品和饮料征税，但正如 B站弹幕所说，靠商家只有胖死一条路，只能靠自己拒绝诱惑。 ","date":"2021-01-06","objectID":"/2021/the-man-who-make-you-fat/:2:0","tags":["杂谈"],"title":"《致肥元凶》观影笔记","uri":"/2021/the-man-who-make-you-fat/"},{"categories":["平日里的白日梦"],"content":"健康食品（伪） 肥胖问题大肆蔓延，我们归咎于吃了太多快餐、方便的加工食品和大量甜食，但如果市场上的健康食品也会让我们发胖呢。 那些被标为健康食品的东西改变了我们的饮食心理，当一种食品被标榜为健康食品，人们就会认为它的热量更低，于是觉得多吃一点也不会变胖，这就是健康光环。有些产品上标着，加入了水果或纤维成分，我们会直觉地认为它更健康，但它的饱和脂肪含量可能更高，所以健康食品和能减肥的食品两者是不一样的。 食品可以被包装的很健康，而不是真正健康。许许多多的产品都标着，含有水果成分，但其实可能只含有 0.1% 的水果味，而他们会把水果印在包装正面的醒目位置，然后说，绝对优质，肯定对健康有益，即使没这么说，也会有这种暗示（想想各种酸奶、饮料、奶茶），这么做是被允许的。 如果一家公司找不到办法，没法改变食品成分，因为人们都知道他们的产品会让人发胖，则往往会使用一些其它的手段，比如和政府建立合作关系，赞助一些体育设施计划，声称会协助解决问题。但这里面又隐藏陷阱，比如，一个篮球网在商店卖5英镑，但你必须花38英镑才能通过购买巧克力换得这个球，又比如一套板球装备，如果去商店买，只需花 150英镑，但如果通过换购计划，你需要花 1100 英镑，而在此过程中你可能需要摄入五十万卡热量。除了换购，还有免费送出主题公园和景点门票等措施。 有效的措施建立在立法和法规的基础上，食品业的法规和严格的广告法规。大家普遍承认，个人能发挥一定的作用，但最终，强有力的杠杆还是掌握在政府手中。 PS：以上分析对网游等行业同样适用，资本操作了很多东西，或者说，资本趋利的本性导致了很多事走向意外的方向。 ","date":"2021-01-06","objectID":"/2021/the-man-who-make-you-fat/:3:0","tags":["杂谈"],"title":"《致肥元凶》观影笔记","uri":"/2021/the-man-who-make-you-fat/"},{"categories":["平日里的白日梦"],"content":"启示 尽管我们已经知道了，全民肥胖的社会很大一部分原因在于食品业，需要政府的参与来规范，但是，如果真的靠他们就真的只能胖死了，这里列举一些看完这部纪录片扭转了观念后，发现的自己可以做的事。 高糖会增加食欲，同时抑制「我吃饱了」这个信号传递到大脑，所以可乐越喝越想喝、甜点越吃越想吃，因此不要买的时候想着会控制自己的，控制不住，我们唯一能做的就是不买，或者买的时候就计算好买多少，如果没有小分量，果断放弃； 大份量不一定值，吃完下一顿还是会吃很多，无形中增加摄入； 套餐也不一定值，你不一定需要那么多，或者不一定喜欢其中某样； 标注为健康的不一定健康，反而更贵，不要交智商税，最重要的还是控制摄入的量； ","date":"2021-01-06","objectID":"/2021/the-man-who-make-you-fat/:4:0","tags":["杂谈"],"title":"《致肥元凶》观影笔记","uri":"/2021/the-man-who-make-you-fat/"},{"categories":["我所热爱的生活啊"],"content":"最近发现自己整个生活有点混乱，屏幕使用时间过长，眼睛干涩，甚至有黑眼圈和血丝。为了理解这是怎么造成的以及做出针对性的改变，所以想做一个系统性的思考。 首先对整体的时间做一下划分。尝试了一下按「生命之花」理论划分时间，但有些内容归纳不进去。所以还是简单的划分为工作、学习、娱乐、生活四部分，每部分大致包含的内容如下： 工作：现阶段来讲，主要是论文阅读、实验、论文写作等工作； 学习：对所感兴趣的事物系统性的学习，比如为了健身系统的学习运动营养学，为了理财学习金融学知识等，手段包括看一些 MOOC 的视频，读一些专业性的书籍等； 娱乐：看电影、看网络小说、打游戏、逛商场、聚会、听音乐、打台球等等； 生活：洗漱、穿衣、做饭、打扫、整理、洗衣服、健身、通勤等。睡觉虽然也应该属于生活，但睡觉的时间通常会占到一天的三分之一，纳入生活会导致生活所占时间比重过高，显然是不合理的。 仔细看的话，发现工作、学习、娱乐三大块都需要使用电子屏幕，直接导致了屏幕使用时间过长。解决的手段可以从两方面看，一是减少屏幕使用时间，二是对眼睛做针对性的保护。 仔细回想一下自己的生活，使用电脑屏幕时大部分时候处于工作状态，剩下的是学习时看视频和娱乐时看电影。手机的屏幕使用时间大部分都在看网络小说上，甚至侵占了生活的部分时间，比如吃饭、走路、上厕所、睡觉等。不过很多时候同一时间会做多件事，所以一天的累积时间可能会超过24小时。 PS：突然想到，学生时代时间被娱乐侵占，上班以后时间被工作侵占，前者是资本家想尽办法让我们沉迷，后者是给资本家打工想尽办法让别人沉迷，真惨啊。 但是，网络小说这种让人沉迷的事，凭毅力是不靠谱的，最后系统的学习一下上瘾机制的相关知识。 对眼睛做保护的话，一个是选择好的屏幕，手机当然没得选，电脑显示器可以选防蓝光的，成本更低一点的做饭是眼镜选择防蓝光的。求助于外物的话，有眼贴和眼药水等缓解眼疲劳的产品，不过也避免交智商税。一劳永逸的办法是养成好习惯，比如周期性的离开屏幕远眺，做眼保健操等，不仅仅能防眼疲劳，还能防止久坐带来的其它危害。 ","date":"2021-01-04","objectID":"/2021/time-management-1/:0:0","tags":["杂谈"],"title":"屏幕使用时间的简单思考","uri":"/2021/time-management-1/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第十一期。 时隔大半年之后，生活周刊系列又重新被我捡起，因为我发现，每周接触的新知识需要一个系统的整理，每周的生活也需要一次记录，下周的计划同样需要列出，这些本来应该在日程类软件中完成，但是却不如简单的文档好用。 注1：文中图片大部分来自网络，侵删。 注2：由于之前删除了这个系列的所有文章，从第 7 期到第 10 期中的图片全部丢失。 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"时讯 1、月球车登月及撤回全程 嫦娥五号探测器在月球着陆，收集了约 2 公斤土壤或重碎石以带回地球，距离人类上一次实现这一目标已有 44 年，当时是苏联的月球 24 号（Luna24），带回了近 200 克岩石。 2、中国量子计算机研究成功 12.04，中国科学技术大学宣布，中国科学技术大学潘建伟、陆朝阳等组成的研究团队与中科院上海微系统所、国家并行计算机工程技术研究中心合作，构建了 76 个光子 100 个模式的量子计算原型机 “九章”。这一成果使得我国成功达到了量子计算研究的第一个里程碑：量子计算优越性（国外也称之为 “量子霸权”）。相关论文于 12 月 4 日在线发表在国际学术期刊《科学》。 3、熊爪咖啡店 上海永康路上一家特别的咖啡店，店员通过**“熊爪”**将做好的咖啡从墙上的“山洞”中递出，顾客在等待咖啡时还可以和**“熊爪”**互动。看到这个新闻觉得很治愈，了解到这背后是一群残障人士的救赎更加感动了。 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"小事 1、12.03，珂帧生日，在综合楼点了外卖吃串，大家玩的挺开心； 2、12.04，庆豪去沈阳参加博士考试去了，晚上和老妈提起，问我对博士的想法，但是，真的是不想读啊； 2、12.05，去中行领了学校办的社保卡，柜员说和家里办的卡不冲突，毕业也不用主动注销； 2、12.05，晚上发现《工作细胞》更新了，开心； 3、12.05，开始看番《万国志》，这番放在待看列表好久了； 4、12.04，整整一天，都在写面料和服装分类的文章，发在了少数派上，感觉整个人的精力被消耗光了。 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"视频 1、社会科学，消费资本主义：控制世界的新宗教 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"工具 1、网盘直链下载助手 (baiduyun.wiki) 百度网盘免登录下载，需要电脑中安装的下载软件配合。 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"概念 1、胶囊衣橱 胶囊衣橱（Capsule Wardrobe）也称极简主义衣橱，最早由伦敦一家名叫 「Wardrobe」的杂货店老板 Susie Faux 在 70 年代提出。大致的意思就是浓缩衣柜，只留下经典的必备单品，通过搭配来实现不同的穿搭效果。 因为这个月开始学习服装搭配，打算改善自己的形象，所以重新想起了这个概念，初次接触是在少数派的文章 让风格与穿搭都了然于心：极简实践者的「胶囊衣橱」 2、世界三大菜系 平时常听中国八大菜系的说法，世界三大菜系还是第一次接触。 世界三大菜系是指： 中国菜系，又称东方菜系，包括中国、朝鲜、日本、东南亚一些国家，以中餐为代表，这是世界人口最多的一个菜系； 法国菜系，包括欧洲、美洲、大洋洲等许多国家，占地面积最大，以西餐为主题； 土耳其菜系：又称为清真菜系，包括中亚、西亚、南亚及非洲一些国家。 3、Exchange 服务 Exchange ActiveSync 是一种 Microsoft Exchange 同步协议，可以同步移动设备的邮件、通讯录、日历、任务等。 Exchange 是微软开发的，但不仅限于微软邮箱使用，而可以被架构在很多邮箱系统上。大厂的邮箱例如，QQ邮箱、163邮箱就都支持 Exchange 协议。因为大多数人用的QQ较多，就写下用QQ邮箱的 Exchange 全平台同步联系人、日历提醒、邮箱。 4、土耳其卡帕多奇亚热气球 看到了国内某景区有热气球项目，评论区有人说谨慎考虑，和土耳其热气球不一样，去搜了搜，真想去一趟啊。 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"句子 1、不管是否熟人借款，在出借资金时，最好选择银行、网络转账等给付方式，转账凭证、业务回单上显示对方姓名、账户等信息；以现金方式出借时，应当避免大金额现金出借，同时应当要求借款人出具收条，载明收到借款的事实、金额、日期等内容，以便未来发生纠纷时用于证明交付借款事实。 2、学贯文理，不问中西。 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:3:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"文章 1、用了苹果八年，让我认识三件事：正视计划｜重视健康｜有趣生活 - 少数派 (sspai.com) 这篇文章是苹果生态的使用介绍，但是让我深有感触的是作者提到的正视计划、重视健康、有趣生活三件事，每件事都戳进了我的心里，甚至重新升起了买智能手表的想法，可惜家境贫寒…… 尤其是看到作者对于 Apple Watch 的充分利用，在计划的推送方面，在各种运动的尝试方面，做的真的很好。首先是计划在日历中制定，然后推送到智能设备，然后是对智能设备中提到的多种运动场景的尝试，最后是作者的马拉松经历和摄影记录。 看完文章后，我利用 Exchange 服务对日历做了一次全平台服务，然后开启了手环的日历推送，以后也打算尽量尝试一下手环的多种运动模式（相比手表非常少），至于马拉松，去年的理想，到今年连 5 公里都跑不了了，但是在工作解决后，以后有足够的时间。 2、怎样全平台同步联系人、日历、邮箱？用QQ邮箱的 Exchange 服务 - 知乎 (zhihu.com) 紧接上篇，在做日历的全平台同步时遵循的教程，事实上也是第一次接触 Exchange 服务这个概念，好在最后成功了。其实日历全平台同步是早就想做的事，这次做完也算了了一个心愿，希望以后用的顺手。 3、告别2020，这或许是最好的20个仪式 转眼 2020 就要结束了，这里列举了一些可以作为收尾的事，实际上，这些事每年都一样。 4、中东面面观丨伊朗重要人物屡次遇刺意味着什么？战争新形态？_新闻_央视网(cctv.com) 对于杀人这件事，人类永无止步。 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:3:5","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"思考 1、关于求偶、结婚、生育 不结婚或不生育要考虑：生病、养老、自我实现（用多余的时间做什么，来这个世界走一遭是为了什么），想清楚为什么不想结婚，不想生育，想清楚父母在担心什么，说服他们 现在谈不婚和丁克是口头的，如果到了40多依然坚持不婚，而且每天健身，有自己的事，整个人体态、样貌、气质、心理都很好，再谈不婚和丁克，别人才会认为你是真的选择了这条路，而不是找不到找不到或被迫的 可以阅读费孝通的《生育制度》一书了解婚姻和生育的本质，以及阅读更多的书籍，记得，做出这个选择一定是要深思熟虑的，也可以调查日本当前的不婚和丁克现状 2、各行各业都是加班加班，互联网、建筑业、底层工厂职工，中国人是勤劳，但这样应该属于剥削了吧，为什么不管呢，感觉工人阶级处境还是很不好。资本家提倡消费，国家也提倡消费，钱不够贷款来凑，一毕业就绑在了贷款的战车上，绑一个人不够，还要把全家人都绑上，人这一辈子活着就是为了给资本家赚钱吗。 3、法国国旗上的三种颜色宽度不一致，很有意思的问题，学习色彩学时发现的，是因为亮色有空间膨胀，如果宽度一致，视觉上反而感觉不一致。有个比较有意思的小故事：最初，人们在制作这面国旗时，三条色带的宽度是一样的。但旗子做好以后，大家都觉得蓝色部分看上去比红色部分宽一些，很影响观感，不符合国旗庄严肃穆的象征意义。于是，法国政府请来了一些光学专家，让他们解决这个问题。专家们通过研究发现，当蓝、白、红三色带以 30：33：37 的比例来裁量时，做出来的旗子上三条色带的宽度看上去就是一样的了。 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:3:6","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["日程及周刊"],"content":"Todo 学点社科学知识 将博客图床的演进过程写成文章 查阅蓝光对眼睛的危害以及每天面对屏幕多久最好 定期阅读国家地理杂志 查询如何练习英语听力 周期性查看少数派社区 ","date":"2020-12-06","objectID":"/2020/life-weekly-11/:3:7","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 11 期 (20201206)","uri":"/2020/life-weekly-11/"},{"categories":["我所热爱的生活啊"],"content":"电影、室内设计、服装搭配等等，色彩在我们的生活中实在是再寻常不过了，学习一些色彩学的基础知识相信在以后的生活中会非常有用。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:0:0","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"1. 基本概念 首先，有光线才有色彩。物体表面会吸收一部分光线，反射另一部分光线，反射的光线到达我们的眼睛，被视锥细胞（感知颜色的细胞）和视杆细胞（感知明暗的细胞）所接收，再通过神经传输到大脑，我们就产生了颜色的映像，从而具有色彩感。 我们已经知道，牛顿用三棱镜将光分成了七色，从红到紫正是我们人眼能感知到的颜色范围，从光学的角度看，就是波长从 380 纳米到 780 纳米的光线。低于 380 纳米的，叫做紫外线，高于 780 纳米的，叫做红外线，都是我们人眼无法看到的。 我们已经知道，光线具有波长和振幅，其中，光波的波长反映光波的频率，给人色彩感，光波的振幅反映光的强弱，给人明暗感。人眼中的两种细胞正是分别感知这两种参数，其中，视锥细胞感知波长，视杆细胞感知振幅。所以，我们看到的颜色，其实就是不同波长、不同振幅和不同比例的光线在人眼中的反映。 通常，我们所称的自然光都是指太阳光，物体在自然光下呈现的颜色我们称为物体的固有色。但是，自然界中还有其它的光源，比如月光、闪电、灯光、烛光等，而在其它光源的照射下，物体颜色会发生改变，所以，我们平常所看到的颜色都是物体固有色和光源色的结合。 如果照射到物体表面的全部光都被吸收，物体就呈现黑色，如果全部光都被反射，物体就呈现白色，不过，纯粹的黑白只存在于理论中，现实中没有物体可以全部反射或吸收光线。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:1:0","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"1.1 色彩的三要素 就像度量衡一样，色彩也需要一个标定体系，像红、黄、蓝、绿这样的简单命名是模糊的，不足以区分不同的色彩。色彩的标定体系就是色彩的三要素：色相（Hue）、明度（Value）、纯度（Chroma）。 色相 字面上理解，就是色彩的相貌，用来区分不同的颜色，比如牛顿分解的光谱色：红、橙、黄、绿、青、蓝、紫，就是七种不同的色相。在我们后面会学到的色相环中，色相包括三原色和由它们按不同比例混合成的各种间色和复色，理论上，色相的划分是没有极限的，但是人眼的感知有极限，人眼只能分辨出大约 180 种不同色相的颜色。还要注意的是，无论色相环包含的色块有多少，每两块之间都有本质的区别，色块越多，仅仅是色差越小。 从光学意义上讲，色相的不同是由光波波长的长短和不同光线的比例决定的。 明度 简单的理解，就是色彩的明暗程度。每一种色相都有自己的明暗度变化，而且都以白为最高明度，黑为最低明度。色彩的明度受两个因素影响：一是光源色的强弱，光线越强，色彩明度越高；二是黑与白的介入强度，加入黑色可以降低色彩明度，反之，加入白色可以提升色彩明度。 明度在光学角度的本质是光的振幅（即强弱），所以黑和白的介入也可以这样理解，加入黑增强了物体吸收光线的能力，因此降低了它的明度，而加入白增强了物体反射光线的能力，因此提升了它的明度。 除了色相本身的明度变化外，不同色相本身就有明度的差别，其中，黄色明度最高，紫红色明度最低。纯粹的黑白色也有明度的变化，这就是不同级别的灰色。 纯度 纯度指的是色彩的鲜灰程度或纯净程度，也叫做饱和度。意思是一个色彩包含该种色素成分的多少，当该色素成分为 100% 时，就是该色相的纯色，所以加入其它任何颜色都会导致纯度的下降，不过，通常降低某色彩的纯度，都是通过混入无彩色系列的黑白灰或混入该色的补色完成的。 从物理的角度讲，一个色相的纯色就是单一波长的光。 黑白灰这三种颜色没有纯度的概念，因此叫做无彩色，其它有纯度的颜色叫做有彩色。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:1:1","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"1.2 色彩混合 大部分的色彩都可以通过混合其它的色彩得到，但是，一定有几种是最基本的颜色，是不可拆分的，这就是原色。光的三原色是红、绿、紫，颜料的三原色是红、黄、蓝。 任意两种原色混合得到的颜色叫间色，颜料的三间色是橙、绿、紫。 将间色彼此混合，就形成了复色。由于间色本身就是原色混合而成的，复色就意味着是不同比例的原色混合，原色混合的不同比例加上纯度和明度的变化，就构成了我们所看到的丰富的颜色世界。 光线彼此混合，亮度会不断提升，最后形成白色光，这叫做加色混合，计算机的显卡就属于 RGB 加色配色系统。通过改变每种原色电子光束的强度，得到深浅不同的色彩，从而合成丰富的色彩； 颜料彼此混合，亮度会不断降低，最后形成黑色，这叫做减色混合。最后一种混合叫做中性混合，是利用人眼对空间的感知产生的一种混合方式，包括两种，一种是具有运动特点的旋转混合，比如具有两种颜色的陀螺旋转会呈现这两种颜色的复色，另一种是具有静止距离特点的空间混合，例如马赛克镶嵌画和点彩画。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:1:2","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"1.3 色相环 色相环也称色环，是将色相以一定的变化规律顺序排列形成的一个环，反映了色相之间的数理关系，对色彩的使用具有很大的指导意义。常用的是 RGB 的 3 色相环、瑞士约翰内斯·伊顿的 12 色相环、德国奥斯特瓦尔德和日本色彩研究所的 PCCS 色彩体系的 24 色相环、美国孟赛尔的 100 色相环。所有的色相环都是以 120⁰ 的三原色为基础，在一个完整的圆内等量分割，形成变化均匀的等量过渡色。 下面是伊顿的十二色相环，在 120° 的位置上是 3 个原色，每对原色中间加入一个间色，每对间色中间再加入一个复色，180°的直径两端叫做互补色。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:1:3","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"1.4 色立体 色立体是色彩理论的数学模型，是色相、明度和纯度三元素借助三维空间的表达，也是唯一区别每个颜色的标准。 目前，主要的色立体体系有美国的孟赛尔色立体、德国的奥斯瓦尔德色立体、日本色彩研究所 PCCS 色立体、国际照明委员会 CIE 色立体等。虽然各自之间有一定的区别，但是理解了其中一种，剩下的就都很容易理解了。 以如下的孟塞尔色立体为例，水平的圆环等量分成 10 份，分别是红、黄、绿、蓝、紫 5 个基色和它们的 5 个间色，共构成 10 个基础色域，每个色域再等分成 10 分，总计 100 个色相，这个圆环就是我们之前说的色相环；纯色在圆环的最外层，从最外层到圆心，纯度不断降低，直到变成圆心的灰色，纯度一共有 12 个等级；中间的轴代表无彩色，最下方是黑色，最上方是白色，黑白之间还有按明度变化的 9 个灰色，因此，纵轴就代表了明度的变化，每一种色相和纯度确定的色彩在纵向上都有明度的变化。 下面是构造出的完整孟塞尔色立体。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:1:4","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"2. 色彩的对比 色彩的对比是将两个以上的色彩放到一起，由于相互作用和相互影响而显现出差异的现象。事实上，对比是构成色彩的必要因素，如果整个世界只有一种颜色，没有彼此的对比，那也就失去了色彩的意义。 根据前面所学的一些概念，色彩的对比可以分为：明度对比、色相对比、纯度对比、冷暖对比、面积对比等。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:2:0","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"2.1 色相对比 因色相差别而形成的色彩对比称为色相对比。将不同色相的色彩并置在一起，可以使对方的特征更加突出。 根据各色相在色相环上距离远近的不同，可以形成不同的色相对比，距离越远，对比效果越强烈，相距 180° 的两个色相对比最为强烈 同类色对比：色相环上距离在 15° 以内的两个色相的对比，对比的效果一般比较弱，通常还需要拉大明度和纯度来进行区别； 邻接色对比：色相环上距离在 15°-30° 之间的两个色相的对比，这样的两个色相就有了一定的区别，对比效果一般比较统一、和谐、柔和，适合背景处理； 类似色对比：色相环上距离在 60°-90° 之间的两个色相的对比，类似色对比一般显得丰满、活泼，即保持了随和统一的优点，又克服了视觉上不够饱满的缺点； 中差色相对比：色相环上距离在 90° 的两个色相的对比，由于差别比较明确，对比效果比较明快； 对比色相：色相环上距离在 120° 左右的两个色相的对比，对比效果比较强烈、鲜明，但过于刺激易产生视觉疲劳，处理不好容易出现烦躁和不安定的感觉； 互补色相：色相环上距离在 180° 左右的两个色相的对比，是最强烈的对比关系，更富于刺激性，但是画面比较直白，不够含蓄和雅致，同意易导致视觉疲劳。 在我所阅读的几个材料中，对色相对比的分类和称呼各有不同，比如，在有的书籍中同类色指的就是距离 15° 的两个色相对比，因此，上述分类只能作为参考，唯一确定的是，距离越远，对比效果就越强烈。 除了以上的色相对比外，还有两种特殊的色相对比 全色相对比：指的是色相环上所有色相都出现，由于人的视觉系统需要全色刺激，这种对比比较协调； 有彩色和无彩色的对比：无彩色又可以称为万能色，无论什么样的有彩色，和无彩色对比都可以呈现和谐的视觉效果。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:2:1","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"2.2 明度对比 指因明度差别而形成的色彩对比。两种不同明度的色彩并列时，会使明色更亮，暗色更暗。 根据孟塞尔色立体，由黑到白等差分为 9 个等级，加上黑白两色一共 11 个等级。0 级为纯黑，明度最低，10级为纯白，明度最高。 我们将明度在 0-3 级的色彩称为低明度，明度在 4-6 级的色彩称为中明度，明度在 7-10 级的色彩称为高明度。以低明度色彩为主的构成低明度基调，以中明度色彩为主的构成中明度基调，以高明度色彩为主的构成高明度基调。 注：“……为主” 指该色彩在画面上的面积超过 70%，占绝对优势。 同时，我们将明度差在 5 个级别以外的对比称为强对比（长调对比），将明度差在 3-5 个级别内的对比称为中对比（中调对比），将明度差在 3 个级别以内的对比称为弱对比（短调对比）。 这样，不同的基调和明度对比程度就构成了一个 9 种明度对比方案，称为明度 9 调，分别是：高长调、高中调、高短调、中长调、中中调、中短调、低长调、低中调、低短调。举个例子，高长调指的就是主色调为中明度，明度差在 5 级以上的对比。一个明度 9 调的例子如下图： ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:2:2","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"2.3 纯度对比 因纯度差别形成的色彩对比叫纯度对比，不同纯度的色彩并置，鲜的更鲜，浊的更浊。 和明度相似，纯度也有 3 种色调和 3 中等级差： 高纯度色彩占 70% 左右叫鲜调（高彩对比） 中纯度色彩占 70% 左右叫中调（中彩对比） 低纯度色彩占 70% 左右叫低调（低彩对比） 纯度差为 8 级以上叫强对比 纯度差在 5-8 级叫中对比 纯度差在 4 级以内叫弱对比 因此，纯度也有九调，分别是：鲜强、鲜中、鲜弱、中强、中中、中弱、灰强、灰中、灰弱。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:2:3","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"2.4 冷暖对比 冷暖色形成的对比，关于冷暖色的定义可参考本文番外部分。根据孟塞尔色相环的十个主要色相，以最暖色橙为暖极，以最冷色蓝为冷极，可划分为 6 个冷暖区 其中，两个冷暖极的对比是最强的，剩下的分三种 强对比：冷极和暖色，暖极和冷色； 中等对比：暖极、暖色和中性微冷，冷极、冷色和中性暖色； 弱对比：暖极和暖色；冷极和冷色；暖色和中性微暖色；冷色和中性微冷色；中性微暖色和中性微冷色。 以暖色为主可构成暖色基调，以冷色为主可构成冷色基调，两者给人不同的感觉，如下表 冷 暖 阴影 阳光 透明 不透明 镇静 刺激 稀薄 稠密 空气感 土质感 远的 近的 轻的 重的 潮湿的 干燥的 理智的 感情的 流动的 静止的 冷静的 热烈的 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:2:4","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"2.5 面积位置对比 形态作为视觉色彩的载体，总有一定的面积，因此面积也会对色彩的表达产生重要影响。 色彩对比与面积的关系有： 色调组合，只有相同面积的色彩次啊能比较出实际的差别，互相之间产生抗衡，对比效果强烈； 对比双方的属性不变，一方增大面积，取得面积优势，而另一方缩小面积，将会削弱色彩的对比； 色彩属性不变，随着面积的增大，对视觉的刺激力量加强，反之削弱。因此，色彩的大面积对比可造成炫目效果； 相同性质与面积的色彩，大面积色稳定性较高，在对比中对它色的错视影响大，反之受它色的错视影响小。 色彩对比和位置的关系有： 对比双方的色彩距离越近，对比效果越强，反之越弱； 双方互相呈接触、切入状态时，对比效果强烈； 一色包围另一色时，对比效果最强； 在作品中，一般将重点色彩设置在视觉中心部位，最易引入注目，如井字形构图的四个交叉点。 注意，色彩对比从不是单一方面的，而是多个方面共同作用。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:2:5","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"3. 色彩的调和 对比是手段，调和是目的 色彩的调和是指两种或两种以上的色彩，有秩序、协调和谐的组织在一起，形成和谐统一的色彩搭配。色彩调和是色彩设计的基本法则，色彩调和有两层含义 使有明显差别的色彩经过调整，形成和谐而统一的完美整体； 合理的组织选择色彩搭配，使其形成具有目的性的美的色彩关系。 调和方式包括：同一调和、类似调和和对比调和。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:3:0","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"3.1 同一调和 同一调和指在色彩的三属性中保持一种属性相同，将另外两种属性进行变化，因此又可以分为同色相调和、同明度调和、同纯度调和，还有一种特殊的无彩色调和。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:3:1","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"3.2 类似调和 类似调和是类似要素的结合，与同一调和相比，具有稍多的变化，但并没脱离以统一为主的配色原则。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:3:2","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"3.3 对比调和 对比调和是以强调变化而组成的和谐色彩搭配。在对比调和中，明度、色相、纯度三种要素都处于对比的状态，因此色彩更富于活泼、生动、鲜明的效果。 对比调和的方法有：秩序调和、混入调和、分割调和、呼应调和和面积调和。 秩序调和 指在画面组织时时多种色彩呈现一定的秩序规律，常见的有 在伊顿色相环中选择位于等腰三角形、等边三角形、长方形、正方形等几何图形顶点上的色相来组织； 对色彩的色相、明度、纯度做渐变推移处理，使最强和最弱的色彩间呈多个梯次的等差、等比关系，弱化对比强度； 九宫调和，将 9 个按顺序排列好的色块放入九宫格中，源自我国传统的「明堂九室」，是多年累积的视觉经验。 混入调和 指遇到不和谐的色彩组合时，选择一个同化元素（色彩要素中的任何一个），将其加入到所有的不同色彩中，使之都含有共同的因素，从而达到和谐的目的。 对于色相，应使所有色彩都具有共同的色彩倾向，比如夕阳下的所有色彩都带有暖暖的橙色，可以看作色相混入的结果；对于纯度，可使所有色彩降低自己的纯度，形成统一的色彩饱和度，比如雨雾中的所有色彩都变得灰蒙蒙的；对于明度，可使所有色彩同时降低或提升明度。 混入调和一般用在色彩调配阶段。 分割调和 指遇到不和谐的色彩组合时，在它们之间嵌入金、银、黑、白、灰任何一种颜色，或者嵌入这几种对比色的中间色，使之产生过渡，从而缓解直接对比的强度，使配色达到调和。 分割调和主要用在画面的色彩组织中。 呼应调和 指将合适的色彩添加到原画面中，使新色彩和原有色彩达成彼此呼应的调和关系。呼应的内容同样可以从色彩各要素触发，最常用的是色相的呼应。 注意，呼应的色彩对象多为画面中的主体、中心色，起到呼应作用的色彩多在面积、位置、数量、形状等方面处于弱势。 面积调和 使某种色彩的面积占据支配地位，可以削弱对比关系。另外，伊顿根据歌德的色彩面积研究成果提出：相等面积比例的红色和绿色能够产生中性的灰色，而黄色和紫色、橙色和蓝色则需要不同的配色比例。用数学比例来显示它们的配比关系为红色:绿色=1:1、黄色:紫色=1/4:3/4、橙色:蓝色=1/3:2/3，这也是著名的“面积对比调和色轮图”。 红色和绿色，黄色和紫色、橙色和蓝色，不论哪一方超过这个比值，都将破坏两者间的调和关系，将两者转化到对比关系中。越接近这种调和比例，对比就越强烈，最终回到最熟悉的红花与绿叶的对比关系之中。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:3:3","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"番外 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:4:0","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"色彩的命名 千变万化的色彩必须有能够相互区别的名字，但是，由于历史原因，色彩在世界各地的名称数量繁多，有时候一种色彩会有不同的几种名字。人们给色彩命名的依据也多种多样，在色彩未形成理论系统时，有的根据植物、动物、矿物等物体色彩来给色彩命名，如玫瑰红、紫罗兰、柠檬黄、酞青蓝等；有的以地理命名，如印度红、普鲁氏蓝、那不勒斯黄等；有的以生活俗约命名，如天青、曙红、铁锈红、鸡血红、牙黄、本白、藕荷、藏青等，民间画工中还有固定名称，如豆绿、蚝白、京紫等；还有的以现代化工命名，如铬绿、镉红等，在现代，流行色协会还发布了文学化命名，如江南水乡、漂流木色、宇宙色等。 这些命名方式可以使一定地域内生活经历相同的人们对同一种色彩的名称产生共识，从而完成色彩的相互交流。但是，当交流距离超过人们的共识之外时，这种色彩信息的交流就会出现误差。例如红玫瑰色，红色玫瑰花的品种本身就有色彩的差异，红到什么程度，是深红、浅红，还是艳红，都是无法定论的，只能概括。 现代化的色彩命名是以色彩处于色立体中的位置决定的，因此，利用色立体可以确定一个唯一的颜色。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:4:1","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"冷暖色 色彩对我们具有一定的心理作用，冷暖色就是根据色彩的心理作用区分的，比如，红色可以联想到火焰、阳光，将温暖的体验感受积累转化成温暖的视觉经验；蓝色可以联想到海洋、月光，将寒冷体验感受积累转化成寒冷的视觉感受。 从色相环的分布看，红橙色类为暖色系，蓝紫色类为冷色系，黄绿色类为中性，黑色感觉为暖色，白色感觉为冷色。色彩明度和纯度的改变也会影响色彩的冷暖感，明亮色偏冷，深暗色偏暖，纯色保持原色的冷暖感，而纯度的降低会使冷暖感趋于中性化。对于太阳光而言，时间也是影响冷暖的因素，一般来讲，早晨的阳光色彩偏冷，傍晚的阳光色彩偏暖。各种不同的光源提供的颜色本身就有偏向，比如，白炽灯的光源色偏暖黄，荧光灯的光源色偏冷蓝。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:4:2","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"色调 我们常说一幅画、一张照片或一个场景是什么色调的，色调其实指的是占主导地位的一种视觉因素，色彩的三元素：色相、明度和纯度都可以作为色调，比如，从色相上，可以有红色调、蓝色调、黄色调、绿色调等；从色彩明度上，可以有明亮色调、暗色调等；从色彩纯度上，可以有清色调、浊色调、纯色调、灰色调；甚至从色彩的特性上，可以有暖色调、冷色调、中性色调。 一般情况下，当某种类型色彩占据超过 70% 时，就称为该色调。 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:4:3","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["我所热爱的生活啊"],"content":"参考 [1] 满懿，陈梦兮. 色彩构成艺术[M]. 电子工业出版社. 2011-08 [2] 张春蓉等. 色彩构成_安阳工学院_中国大学MOOC(慕课)[OL]. 2020-11-11 第 5 次开课 ","date":"2020-12-02","objectID":"/2020/basic-knowledge-of-colorology/:5:0","tags":["新知识学习"],"title":"色彩构成基础知识","uri":"/2020/basic-knowledge-of-colorology/"},{"categories":["平日里的白日梦"],"content":" 宁远，素与练：日常的衣服，北京时代华文书局，2020.10.01，豆瓣 好好穿衣服和好好吃饭、好好走路一样，都是日常中有意识地觉知「生活」这回事。 想法：吃饭、走路的时候玩手机，总是给自己找理由说无聊，看到这句话该清醒了，既然自诩为热爱生活，这两种场景不该好好感受生活吗。 从历史的维度去看，女性的身体拥有今天这样“想穿什么就穿什么”的自由，其实是历尽艰难。别忘了就在二十世纪初，中国女性为了能把自己的双脚放进三寸长的一双可怕的鞋子里，不得不从小用布带缠裹双脚，导致双脚扭曲变形。 在十九世纪的欧洲，有舞女为了让腰更细，通过手术切除好几根肋骨。更早一些的十六世纪，铠甲式的塑身衣是用铁条制作的，用来强制矫正女性的体型。 今天的女性可以穿裤装，这看起来再正常不过。但就在一战之前，穿裤子还只是男人的专利。那时候的女人们裹着厚重的布料，“活在层层叠叠的花边里，每走一步都能听见布料摩擦的响声”（深井晃子《二十世纪流行的轨迹》）。 想法：如果对生活失望，就想想这一点吧，世界依然是在变好的，你看得见看不见的地方无数人在为了世界更好努力，你可以对一些不公不忿，但请不要失望，你可以抗争的权利，有妥协的权利，只是不要加入就好，就算做不到让世界更好 只是不要让它更坏 感受你自己的需求，你的衣着应该与你的生活息息相关。想让自己开心时，我会用最高一级的认真打扮自己。挑选最喜欢的衣服，精心搭配，想象穿这身衣服出现的场合，说什么话，做什么事，见什么人，会不会大笑，或者被一朵路边小野花吸引、俯身观看，又或者为一部电影流泪……在行走坐卧中，衣服像一位忠诚的好朋友，时时陪伴着我们。 想法：瞬间被击中，买衣服的时候想的是穿着好不好看，其实应当想这些，去见什么人、做什么事…… 衣服服务的对象不是肉身，而是运动中的有机体。T台上行走的模特能让我们直观认识到这一点，但标准的身材、漠然的表情又在提醒我们，那是一个“Model”，不是一个鲜活的具体的人。凭空想象一下，更吸引我的应该是模特们从T台上走下去，在后台打闹、照镜子、换衣服、和好朋友分享零食、给自己心爱的人打电话……又或者是他们在换衣服时，那一瞬间的脆弱。 想法：确实啊，模特总是缺失了一份温度，我还专门去作者的淘宝店铺看了一眼，商品图确实都很充满生活气息。PS：作者的品牌名叫远家，淘宝店名叫远远的阳光房，女装专卖。 我们试着再加上下面的问题： 你喜欢听的音乐有哪些？ 你最爱读哪位作家的作品？ 你家里的装修是什么样子？ 你喜欢喝咖啡还是茶？ 你家床单的质地是什么？ 你出门喜欢骑车还是开车，会考虑坐地铁吗？ ………… 这个清单还可以一直列下去，但在这里我打算省略了。这是你自己需要提问并回答的部分，需要你“审视自己的生活”。 想法：按着这些问题审视自己的生活吧 需要振奋精神在人群中脱颖而出的时刻当然有，但也有很多时候，我们想通过穿衣服把自己藏起来。我们希望穿得和别人基本一样，这样能保证不引人注目地默默度日。可是我们又想追求一些不一样。那些属于自己才有的小心思，它温和无刺激，独立又谦逊。 穿衣服是在人群中、在环境中、在时间和空间里，追求那一点儿微妙的平衡。 想法：这几句话简直是我的心里话 优雅应该是先搞定了自己，再去处理自己和世界的关系吧。 现在各种仪式挤满我们的生活，某家店铺开业，某个电影节颁奖，某个人物的生日会，感动×××的人物评选……人们精心装扮外表、酝酿说辞，小孩子们唱着他们不太明白的颂歌。 但很少再有那种由仪式带来的庄重和敬畏了。虽然我们还有春节，但春节也只剩下大吃大喝了——早已过了物资匮乏的年代，却还没有建立起在精神世界里的秩序。 美不是说你要长得多完美、多漂亮，不是说你的身材要多好，而是由内而外生发出一种自信、一种对生活的爱、一种积极的东西。哪怕你是害羞的、紧张的，但是你也是真实的、真诚的，是在袒露自己。 ","date":"2020-11-29","objectID":"/2020/daily-clothes/:0:0","tags":["读书笔记"],"title":"素与练:日常的衣服","uri":"/2020/daily-clothes/"},{"categories":["研究生的区块链学习之路"],"content":"一些以前理解上出现偏差的地方，这里做校正或完善。研究过程中发现的问题，可作为下一步研究方向的，也总结在这里。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:0:0","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"1. 理解上的偏差 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:1:0","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"中心化 物联网由于入网设备的迅速增加导致中心化的服务器压力增大，企业维护成本增加，但区块链并不能算很好的解决方案。服务器的压力主要分两方面，一是存储海量数据的压力，二是海量交易处理的压力，对于前者，区块链的存储更加昂贵，对于后者，区块链的吞吐量不如传统的中心化系统。另外，区块链虽然可以解决传统中心化系统的单点瓶颈和故障，但这是分布式系统的固有属性，其他分布式系统也可以，现有的各种容灾方案已经很完善，可以应对各种情况。 区块链的优势应当是提供参与各方之间的信任，提高系统的安全性。可以用于减少各企业间的交接成本，减少欺诈风险，追溯出问题的地方等。另外，区块链和中心化的云存储不是相互对立的，两者可以同时使用，即用云存储数据，同时用区块链存储哈希保证数据的完整性和准确性。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:1:1","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"数据隐私 区块链很难提供身份隐私，它的公钥账户机制是一种伪匿名，可以被追溯到真实身份，尽管可以通过密码学各种混淆方式尽力实现真正的匿名，但容易沦落为洗钱的温床，不受监管的区块链无法得到发展和推广。 我们提到区块链的隐私应该更多的指数据的隐私，有两层含义： 用户拥有对自己数据的完全控制权，包括知晓被谁使用和如何被使用，同时可以随时撤回授权； 存在区块链中的数据由于是公开的，可能被竞争对手利用从而获得竞争优势，应当尽力阻止这一点。 Quorum 的隐私管理器主要是解决第二点，让数据只能被指定的账户看到。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:1:2","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"智能工厂 在寻找区块链和 IIoT 的结合场景时出于某种已忘记的原因选择了智能工厂。当时的重点放在了这种场景和区块链的可结合性分析上，虽然在 区块链和智能工厂 一文阐明了这种可结合性，但缺乏实质的设计和实现方案。 当时有一个半成品方案，但这个方案是现在的访问控制方案的原型，访问控制和这一方向的关系是：访问控制是区块链和智能工厂场景可结合性的一个方面。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:1:3","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"平台和共识选择 选择 Quorum 时关注的几个方面包括：共识、吞吐量、对智能合约的支持、对隐私管理的支持、构建和开发的难易程度、社区的活跃程度（决定了有问题是否可以及时得到解决）。 不选 Ethereum 是因为它使用 PoW 共识且吞吐量较小，不选 Hyperledger 是因为它没有隐私管理。当时坚定的认为平台本身提供的隐私保护比自己重新提出一个隐私保护要好的多，现在有所动摇。大量的论文采用了自己的密码学算法，也许这些方案有更好的性能，只是易用性不够高而已。 不选 Hyperledger 还有一个原因是对海量数据存储的支持，现在认为这并不重要，大多数的存储方案将数据存在链下，数据的哈希存在链上这种方式，通常对区块链本身没有特别的要求。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:1:4","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"基准测试工具 对各区块链平台和共识进行基准测试的工具和论文较少，当时想自己提出这样一个测试方案并实现，更多的出于保证工作量足够的目的。没有做下去是因为缺乏足够的认识和能力，也缺乏足够的时间和团队协作编写一个针对各个区块链平台和共识的测试框架，事实上，这件事只是做的人少，不是没有人做。 注：平台和共识选择是需要一些数据支撑的，比如吞吐量等，目前依然缺乏这方面的数据（指自己得到的而不是论文或网上看来的）。有时间可以借助这些工具自己做一下测试。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:1:5","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"访问控制 对场景的验证要求有一个可用的硬件平台， 网关、传感器等，实际上并没有，这种硬件平台对方案的验证不具备必要性，更多的是验证区块链终端软件在物联网终端设备上可运行的能力或对设备造成的压力。 我们假设的是供应链或其它场景中每一个参与方都拥有自己的验证者节点，但是具体为每一方分配多少验证者节点可以达到公平到现在还是无法确定。 IBFT 共识中，超过2/3的节点串通就可以控制整个共识过程，少于2/3但大于1/3的节点串通可以导致共识永远无法达成。因此，多数人攻击是一个潜在的安全问题，Roberto Saltini 分析了IBFT的安全性并给出了改进建议，最好看一看这个建议。 新的节点加入时，需要分配一定数量的 Ether 用于之后的合约部署或合约调用操作，我们曾设想的方案是，在合约中预存大量的 Ether，每个设备新入网时自行调用获取一定数目的余额，或者注册自身时由合约自动发送一定数量的余额。这种方案是不可行的，因为无论是自行调用合约还是注册自身的操作，都会改变合约状态，也就是说这个操作本身就需要有一定的 Ether 才能完成，这是一个鸡生蛋蛋生鸡的问题，唯一的办法是通过其他的方式发送余额，比如新的验证者、管理者入网时，由固定的某个账户给与一定数量的初始 Ether，新的设备入网时，由它的管理者为该账户分配一定数量的 Ether。 联盟里本身就带有准入机制，要理解这个机制和我们额外实现的访问控制之间的区别。 进行静态检查避免重复注册可以算一种工作内容。 Remix 编译时的一些 warning 可以总结一下作为一部分实现上的改进 绝大部分设计和合约实现的优化都是为了减少 Gas 消耗，但是要注意，我们的方案由于实现了更多的功能，不可避免的又增加了一部分消耗，真正评估时应评价在区块链的持续增长过程中总的 Gas 消耗。另外，由于 Quourm 区块链交易不消耗 Gas，因此这方面的优化其实没有在 Eethereum 中实现重要。 研究记录8 一文有大量的想法记录，值得多次查看，很多想法都忘了但是却很有意义。 架构设计上的一些想法与减少 Gas 消耗无关，比如 Quorum 区块链的选择，分层结构的设计。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:1:6","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"2. 未来的研究方向 目前的方案只下沉到了网关这一级，IoT设备只是用一个虚拟的区块链账户表示，返回的访问结果仅是一个字符串，网关往下的部分还有很多工作可以做 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:2:0","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"数据访问和命令执行 物联网终端设备的类型有很多种情况，对于 Always-on 的设备，比如智能家居中的温湿度传感器、摄像头等，收到数据访问或命令执行请求时，可以实时的返回结果，但对于不是一直在线的设备，比如广域网通信的 Zigbee设备，可能是周期性的启动侦听网关的指令，或者定时启动主动联系网关，还比如短距离通信的蓝牙，智能手环或智能手表只有在软件打开后才会主动进行一次数据同步。这些情况中，网关收到来自区块链的访问请求后，无法得到实时的结果返回，导致访问控制执行的时间具有不确定性。可选的解决方案有： 对于收集环境数据的传感器，设备与网关保持传统的协作模式，收集的数据存储在本地或云中，不同的是，每次数据提交的时间和数据的哈希等元数据信息要记录到区块链中（存储合约等），当发生数据访问时，将根据请求寻找链中的元数据信息，进而找到真实数据返回，亦或者直接返回元数据信息。另外，在网关中缓存最近一次提交的数据，可以有效减小访问操作完成的时间（时间局部性原理） 对于执行命令的执行器，可以转为异步模式处理，请求和返回的结果都用队列进行存储。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:2:1","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"结果可靠性的保证 在网关和网关所管理的设备构成的集合体中，网关处于一种中心化的地位，因此，如果网关由于受到攻击或其它的原因不可靠，那么网关所管理的所有设备也会变得不可靠，因为网关具有拒绝执行相关命令或者返回错误的执行结果的能力。这里如何判定网关的可信程度，可以利用传统的异常检测算法，同时，访问决策的逻辑中也可以加入对访问者归属网关状态的判断，网关的不可靠也可以标识为一种恶意行为，从而拒绝该次访问。 在网关可靠的情况下，结果的返回同样具有不确定性，是使用链下普通的通信方式返回结果，还是利用区块链返回结果（存储压力），仍需考虑。 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:2:2","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"访问控制的优化 我们曾提出过两个优化方式，虽然由于各种原因并没有实现，但是现在看具有一定的可行性。 通过定义设备的优先级，在未定义设备访问控制策略时自动的根据优先级判定； 当前的授权是即时的，应当可以自定义授权时间，使得在某段时间内重新访问不必重新发起访问（参考内存置换算法中访问的时间局部性原理）。 另外，诸如权限转移（有权限者将权限级联授权给其它用户）和自动属性发现机制等也值得继续研究 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:2:3","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"通信问题 P. Danzi, A. E. Kalor, C. Stefanovic and P. Popovski, “Analysis of the Communication Traffic for Blockchain Synchronization of IoT Devices,” 2018 IEEE International Conference on Communications (ICC), Kansas City, MO, USA, 2018, pp. 1-7, doi: 10.1109/ICC.2018.8422485. 一直记着上面这篇论文，想接着它的思路做，包括： 不同的无线和有线接入技术对区块链同步的影响（损耗和延迟）； 设备休眠对区块链同步的影响； 设备硬件平台的异构性对区块链软件的影响等。 该方向的论文较少，最后没有进一步研究下去的原因是这些内容更多的是关于通信的内容，对各种接入技术和通信性能评估方法都不够了解。 另外，本身小范围内设备通信，利用点对点、网状拓扑或星型拓扑延迟都还可以接受，但到区块链中走了一圈之后，通信延迟突然增加不少 ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:2:4","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"区块链压缩 成千上万的访问控制交互，对区块链存储造成的压力，在区块链不断延伸的过程中，应当可以对前面许多过时的或无效的信息进行压缩，甚至在上链阶段就添加某些源信息用于之后搜索进行压缩。思路启发自以下论文 T. Kim, J. Noh and S. Cho, “SCC: Storage Compression Consensus for Blockchain in Lightweight IoT Network,” 2019 IEEE International Conference on Consumer Electronics (ICCE), Las Vegas, NV, USA, 2019, pp. 1-4, doi: 10.1109/ICCE.2019.8662032. ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:2:5","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["研究生的区块链学习之路"],"content":"D2D访问 基于token的访问控制，用D2D等技术辅助某些终端问题的解决，思路启发自下面的论文，想接着做下去的 V. A. Siris, D. Dimopoulos, N. Fotiou, S. Voulgaris and G. C. Polyzos, “Trusted D2D-Based IoT Resource Access Using Smart Contracts,” 2019 IEEE 20th International Symposium on “A World of Wireless, Mobile and Multimedia Networks” (WoWMoM), Washington, DC, USA, 2019, pp. 1-9, doi: 10.1109/WoWMoM.2019.8793041. ","date":"2020-11-20","objectID":"/2020/some-problems-in-research/:2:6","tags":["科研记录"],"title":"研究记录15-研究过程中的问题总结","uri":"/2020/some-problems-in-research/"},{"categories":["爱编程爱技术的孩子"],"content":"Hugo 用到最后，终究还是免不了走上自己修改甚至开发主题的道路，本篇首先介绍 Hugo 的内容如何管理。 ","date":"2020-11-11","objectID":"/2020/hugo-develop-themes-1-content-management/:0:0","tags":["Hugo"],"title":"hugo开发主题1-内容管理","uri":"/2020/hugo-develop-themes-1-content-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 目录结构 Hugo 建立的项目根目录初始有如下几个子目录 $ ls archetypes/ config.toml content/ data/ layouts/ static/ themes/ 在使用过程中，我们书写的所有文章都应当放在 content 子目录下，其组织方式要参照博客网站的结构，因为 Hugo 会假设你在 content 目录中存放文件的结构就是你的网站结构，下面是一个例子： # 假设网站 baseURL 为 https://example.com . └── content └── 1-logo.png └── _index.md └── about | └── index.md // \u003c- https://example.com/about/ ├── posts | ├── firstpost.md // \u003c- https://example.com/posts/firstpost/ | ├── happy | | └── ness.md // \u003c- https://example.com/posts/happy/ness/ | └── secondpost.md // \u003c- https://example.com/posts/secondpost/ └── quote ├── first.md // \u003c- https://example.com/quote/first/ └── second.md // \u003c- https://example.com/quote/second/ 其中，content 根目录、about 目录、posts 目录和 quote 目录都是一个单独的页面，里面可以包含要显示的 markdown 文档，也可以包含图片等资源文件，这样一个子目录叫做一个 Page Bundles。 注：页面资源和图片如何在 HTML 中访问和处理可以参考第 2 节和第 3 节。 索引页面，即 _index.md 在 Hugo 中扮演一个特殊的角色，它可以定义大量网站 HTML 文件可访问的元数据，一般通过 .Site.GetPage 函数来获取。 ","date":"2020-11-11","objectID":"/2020/hugo-develop-themes-1-content-management/:1:0","tags":["Hugo"],"title":"hugo开发主题1-内容管理","uri":"/2020/hugo-develop-themes-1-content-management/"},{"categories":["爱编程爱技术的孩子"],"content":"Hugo 用到最后，终究还是免不了走上自己修改甚至开发主题的道路，本篇介绍 Hugo 的核心之一：模板。 ","date":"2020-11-11","objectID":"/2020/hugo-develop-themes-2-templates/:0:0","tags":["Hugo"],"title":"hugo开发主题2-模板","uri":"/2020/hugo-develop-themes-2-templates/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 基本介绍 模板指的是 HTML 的模板，是将 HTML 中的一些内容抽象为变量，在页面渲染时才进行替换的一种方法，如果学过 Go，会比较容易理解，因为 Hugo 的模板正式以 Go 的 html/template 和 text/template 两个库为基础的。 简而言之，Hugo 中提到模板就是提到 HTML，写模板就是写 HTML。 Hugo 主题中 HTML 的入口文件为 _default/baseof.html，这是所有页面渲染时的默认模板，除非你指定了在查找顺序上具有更高优先级的 baseof.html 文件。 注：查找顺序将在第 2 节介绍。 \u003c!--layouts/_default/baseof.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e {{ block \"title\" . }} \u003c!--Blocks may include default content. --\u003e {{ .Site.Title }} {{ end }} \u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!--Code that all your templates share, like a header --\u003e {{ block \"main\" . }} \u003c!--The part of the page that begins to differ between templates --\u003e {{ end }} {{ block \"footer\" . }} \u003c!--More shared code, perhaps a footer but that can be overridden if need be in --\u003e {{ end }} \u003c/body\u003e \u003c/html\u003e 上面的代码与普通 HTML 代码的区别就是以双大括号 {{ }} 包围的区域，这就是模板的写法。以 {{ .Site.Title }} 为例，在渲染时会用主题配置文件 config.toml 中定义的 title 字段替换，是不是就像被抽象而出的变量? {{ block \"title\" }} 是一种更大的抽象范围：代码块，我们会在其它的 HTML 文件中定义这段代码块，然后在渲染时替换这一部分内容，比如，我们在 layouts/_default/list.html 中定义了 title 和 main 代码块如下 {{ define \"title\" }} \u003c!--This will override the default value set in baseof.html; i.e., \"{{.Site.Title}}\" in the original example--\u003e {{ .Title }} \u0026ndash; {{ .Site.Title }} {{ end }} {{ define \"main\" }} \u003ch1\u003e{{ .Title }}\u003c/h1\u003e {{ .Content }} {{ end }} 渲染时会替换掉 baseof.html 文件中如下内容，注意，额外定义的这部分代码要以 {{ block “title”}} 开始，指明替换哪一段 block，所有的模板语法代码段都要以 {{ end }} 结束。 {{ block \"title\" . }} \u003c!--Blocks may include default content. --\u003e {{ .Site.Title }} {{ end }} 实际的操作是 list.html 从 baseof.html 继承所有代码，然后用自己定义的 title 和 main 代码段替换相关内容，是在 list.html 中操作的，不是在 baseof.html 中操作的。 ","date":"2020-11-11","objectID":"/2020/hugo-develop-themes-2-templates/:1:0","tags":["Hugo"],"title":"hugo开发主题2-模板","uri":"/2020/hugo-develop-themes-2-templates/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 页面查找顺序 Hugo 主题所有的 HTML 文件都位于主题目录下 layouts 目录中，我们所看到的博客的每个页面的渲染，都要首先从这里选择一个 HTML 文件作为模板，页面查找顺序指的是渲染页面时在 layouts 目录下的查找顺序。比如，Home Page 首先在 layouts 根目录下查找 index.html 文件，如果找不到，查找 home.html 文件或 list.html 文件，如果依然找不到，在 layouts/_default 目录下查找这三个文件。 与查找顺序相关的，除了上例提到的文件夹的不同，还和页面类型（Kind）、输出格式（Output Format）、语言（Language）等有关，我们主要关注的是页面类型 Kind。 页面类型有两种：single page 和 list page。前者用于单个页面渲染，后者用于在单个页面中渲染多个内容，举个例子，一个归档页面通常包含数十篇文章，这就属于 list page。其中，regular page 属于前者，section page、home page、taxonomy list page、taxonomy term page 属于后者。下面进行一一介绍。 注：home page 是个例外，它虽然属于 list page，但有自己的专用模板。 home page 网站首页通常和其它页面不同，因此有自己的专用模板，而且当网站只有一个页面时，home page 是唯一需要的文件。 home page 可以读取 config.toml 中定义的网站全局变量，也可以读取 content/_index.md 中的元数据（通常以 yaml/toml 格式定义在开头，称为 front matter）。 一些重要的文件查找顺序如下，其中 Home page 是主页面，Base template for home page 是主页面继承的模板，RSS home 是主页面的 RSS 文件。 Example OutputFormat Suffix Template Lookup Order Home page HTML html layouts/index.html layouts/home.html layouts/list.html layouts/_default/index.html layouts/_default/home.html layouts/_default/list.html Base template for home page HTML html layouts/index-baseof.html layouts/home-baseof.html layouts/list-baseof.html layouts/baseof.html layouts/_default/index-baseof.html layouts/_default/home-baseof.html layouts/_default/list-baseof.html layouts/_default/baseof.html RSS home RSS xml layouts/index.xml layouts/home.xml layouts/list.xml layouts/_default/index.xml layouts/_default/home.xml layouts/_default/list.xml 我们重点介绍一下 Base template for home page，在 Home page 中，定义的是一段代码块，正如我们在第一节中所述，它需要先继承一个 HTML 文件的结构，然后替换其中使用 {{ block \"name\" }} 定义的部分，这里所继承的文件就是 Base template for home page。下面是一个例子 \u003c!--layouts/index.html --\u003e {{ define \"main\" }} \u003cmain aria-role=\"main\"\u003e \u003cheader class=\"homepage-header\"\u003e \u003ch1\u003e{{.Title}}\u003c/h1\u003e {{ with .Params.subtitle }} \u003cspan class=\"subtitle\"\u003e{{.}}\u003c/span\u003e {{ end }} \u003c/header\u003e \u003cdiv class=\"homepage-content\"\u003e \u003c!--Note that the content for index.html, as a sort of list page, will pull from content/_index.md --\u003e {{.Content}} \u003c/div\u003e \u003cdiv\u003e {{ range first 10 .Site.RegularPages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/main\u003e {{ end }} section page section 是一组页面的集合，默认的，content 目录下每个一级目录都是一个 section，更深层次的目录，如果想成为 section，需要建立 _index.md 文件。一个例子如下 content └── blog \u003c-- Section, because first-level dir under content/ ├── funny-cats │ ├── mypost.md │ └── kittens \u003c-- Section, because contains _index.md │ └── _index.md └── tech \u003c-- Section, because contains _index.md └── _index.md section page 就是用来渲染 section 的模板，可以访问 section 中的所有内容和 front matter，其查找顺序如下 Example OutputFormat Suffix Template Lookup Order Section list for “posts” section HTML html layouts/posts/posts.html layouts/posts/section.html layouts/posts/list.html layouts/section/posts.html layouts/section/section.html layouts/section/list.html layouts/_default/posts.html layouts/_default/section.html layouts/_default/list.html 下面是一个 section page 的例子 \u003c!--layouts/_default/section.html --\u003e {{ define \"main\" }} \u003cmain\u003e {{ .Content }} \u003cul class=\"contents\"\u003e {{ range .Paginator.Pages }} \u003cli\u003e{{.Title}} \u003cdiv\u003e {{ partial \"summary.html\" . }} \u003c/div\u003e \u003c/li\u003e {{ end }} \u003c/ul\u003e {{ partial \"pagination.html\" . }} \u003c/main\u003e {{ end }} .Site.GetPage 函数可以用来获取一组给定类型的页面，假设 content 目录结构如下 . └── content ├── blog │ ├── _index.md # \"title: My Hugo Blog\" in the front matter │ ├── post-1.md │ ├── post-2.md │ └── post-3.md └── events #Note there is no _index.md file in \"events\" ├── event-1.md └── event-2.md 输出 blog section 的 title 可以使用如下语句 \u003ch1\u003e{{ with .Site.GetPage \"section\" \"blog\" }}{{ .Title }}{{ end }}\u003c/h1\u003e \u003c!--输出如下 --\u003e \u003ch1\u003eMy Hugo Blog\u003c/h1\u003e 如果是 event section，因为没有 _index.md 文件，会输出文件名 \u003ch1\u003e{{ with .Site.GetPage \"section\" \"events\" }}{{ .Title }}{{ end }}\u003c/h1\u003e \u003c!--输出如下 --\u003e \u003ch1\u003eEvents\u003c/h1\u003e taxonomy page 包括 taxonomy list pages 和 taxonomy terms pages，用于用户自定义的内容分组，比如分类和标签页面，展示了文章间的一种逻辑关系。下面解释几个术语 Taxonomy：对内容进行分类的字段 Term：分类的键 Value：分类的值，就是内容 举个例子，演员 是 Taxonomy，克里斯·埃文斯 是 Term，《美国队长》 是 Value，如果按 Taxonomy 组织页面，就是 taxonomy list pages，如果按 Term 组织页面，就是 taxonomy terms pages，如果是显示单个内容，那么使用 single pa","date":"2020-11-11","objectID":"/2020/hugo-develop-themes-2-templates/:2:0","tags":["Hugo"],"title":"hugo开发主题2-模板","uri":"/2020/hugo-develop-themes-2-templates/"},{"categories":["我所热爱的生活啊"],"content":"有时候走在路上，突然就想把某个看到的画面记录下来，物品整理的时候，也希望能拍摄一张好的静物照，还有和朋友、家人在一起的时候，比如元宵夜，拍一张黑咕隆咚的照片总归让人不开心，这三点就是我想学习手机摄影的主要原因。因为刚入门，看的书是电子工业出版社的《手机摄影必修课》，本篇先学一些摄影的基本概念。 摄影的基本原理是小孔成像。 胶片相机中，按下快门后，一个挡板结构快速开启和关闭，光线照射到底片上，让上面的化学物质发生反应，形成图像。而现代摄影设备，包括手机，已不存在底片这种结构，取而代之的是图像传感器，也叫感光元件，它可以将收集的光信号转变为数码信号，形成照片，相应的，快门也不再是传统意义的快门。 ","date":"2020-11-09","objectID":"/2020/basic-concepts-of-photography/:0:0","tags":["新知识学习"],"title":"新知识学习-手机摄影","uri":"/2020/basic-concepts-of-photography/"},{"categories":["我所热爱的生活啊"],"content":"1. 曝光 曝光就是通过镜头照射在感光元件上的光量（光的多少），曝光正常时照片就正好，曝光过高时照片就偏亮，叫做过曝，而曝光过低时照片偏暗，叫做欠曝。 有四个因素可以影响曝光：光圈、快门速度、感光度（ISO）和环境光线，都很容易理解。光圈是相机镜头上让光通过的孔径，光圈越大即孔径越大，一定时间通过的光就越多，曝光就越强；快门速度则控制曝光的时间，快门速度越快，快门打开的时间越短，通过的光越少，曝光就越弱；感光度是感光元件对光线的敏感程度，感光度越高，曝光越强；环境光线更容易理解，阳光明媚的白天环境光线较强，曝光就强，乌漆抹黑的晚上光线很弱，曝光就弱。 下面是曝光各项参数和最终曝光强度之间的关系，增加和减少曝光都可以由此考虑，但是要注意，调整某一要素可能对画面带来其它的影响。 光圈的不同会带来景深的变化，从而导致背景虚化的程度不一致。景深指的是对焦点前后相对清晰的成像范围，光圈越大，景深越小，背景和前景都会变模糊。不过，大部分手机的光圈值都无法调节，如果需要特定的景深效果，一般通过软件方式实现。 快门速度影响拍摄物体的清晰程度。这点根据生活经验也容易理解，快速运动的物体拍照时总会变模糊，因为当快门速度较慢时，快门开启和关闭的这段时间物体移动了一段距离，这个过程反映到照片上就是模糊。高速运动的物体我们通常使用较快的快门速度。 感光度会影响照片品质，使用较高的感光度会出现更多的噪点，即画面中出现许多粗糙的颗粒，因此一般使用较低的感光度。但是，当环境光线较弱，减慢快门速度又会导致模糊的情况下，只能增加感光度。 ","date":"2020-11-09","objectID":"/2020/basic-concepts-of-photography/:1:0","tags":["新知识学习"],"title":"新知识学习-手机摄影","uri":"/2020/basic-concepts-of-photography/"},{"categories":["我所热爱的生活啊"],"content":"2. 焦距 摄影中提到的焦距通常指 35mm 等效焦距，即镜头放在 35mm 底片相机上得到的等效视角。根据 35mm 等效焦距的程度，镜头大致分三类： 标准镜头：等效焦距在 50mm 左右，较符合人眼看到的景象； 广角镜头：等效焦距在 35mm 以下，视野更宽阔，能容纳更多的元素； 长焦镜头：等效焦距在 85mm 以上，视角狭窄，用于远距离拍摄。 还要注意的是，大部分手机都是定焦镜头，即焦距固定无法改变。 手机普遍都是广角镜头，视野比较宽阔，同样的情况会容纳更多的元素，为了突出拍摄主体，用手机拍照通常需要走近一点。广角镜头还会突出物体的纵向空间感，使「近大远小」关系更明显，因此如果用来拍人，如果离得太近，人物脸部鼻子和嘴会显得更大，眼睛外翻，脸的轮廓更瘦削，进而影响我们对人物性格的判断，因此手机拍照时最好不要把脸凑得太近。广角镜头的另外一个特点是画面边缘会被拉伸，特别是四个角落，比较严重，因此拍摄人物时，不要放在画面边缘，集体拍照时，也不要站到画面边缘。 当我们拍摄建筑时，由于使用广角镜头，需要走近物体，而为了使建筑大小不变，就得以仰视角度拍摄，这时就会造成建筑垂直的线条在画面中倾斜甚至成梯形，解决办法是后期处理或找一个较高的位置拍摄。 ","date":"2020-11-09","objectID":"/2020/basic-concepts-of-photography/:2:0","tags":["新知识学习"],"title":"新知识学习-手机摄影","uri":"/2020/basic-concepts-of-photography/"},{"categories":["我所热爱的生活啊"],"content":"3. 动态范围 拍摄时经常遇到光线强度在不同区域差别较大的情况，场景的动态范围就是环境中最亮部分和最暗部分之间的亮度，相机的动态范围就是相机能同时记录下的最亮部分和最暗部分之间的亮度，值得注意的是，手机相机的动态范围通常都不大，为了保留更多的细节，通常的方法是顺光拍摄、避免光线较强的场景，如果实在没有办法，就选择欠曝而保留暗部细节，因为欠曝可以通过后期提升亮度，过曝则无法处理。 一个有意思的小例子：逆光拍摄人脸，之所以拍不清细节，就是环境光线太强，人脸反射的光线太弱，所以一般要换成顺光拍摄。 ","date":"2020-11-09","objectID":"/2020/basic-concepts-of-photography/:3:0","tags":["新知识学习"],"title":"新知识学习-手机摄影","uri":"/2020/basic-concepts-of-photography/"},{"categories":["我所热爱的生活啊"],"content":"4. 手机摄影控制 一般情况下，手机的拍照应用会根据要拍摄的场景，自动调节曝光的各项参数，但还是有一些手动调节的小技巧值得我们学习。 以我所用小米手机为例，拍照时点击屏幕任意区域，会出现一个同心圆环，这个圆环叫做对焦环，对焦环所在区域就是对焦区域，对焦区域决定画面那部分最清楚。对焦区域同时也是测光区域。如果是上节所述动态范围较大的场景，对焦环最好位于较暗的部分，这样才能更多的保留细节， 对焦环出现后，在对焦环右侧上下滑动，还可以调整曝光强度，这种方式适用于画面焦点和测光区域分离的情况，把对焦环置于焦点，然后向下滑动减小曝光强度。 手机相机在每次拍摄完成后会再次变成自动调整曝光的模式，如果想保证原来的曝光参数不变，可以通过长按对焦环启用「曝光锁定」功能，解除该模式只需要再次点击屏幕任意区域即可。 遇到动态范围大的场景，如果不想这么麻烦，手机还提供一个叫做高范围动态成像（HDR）的功能，可以让画面显示更大的明暗差别，原理是快速拍摄多张照片进行合成。 光线其实具有不同的颜色和温度，同一件物体在不同光线条件下呈现的颜色是不同的，我们人眼会自动校正这种色彩改变，相机不会，因此我们需要调整白平衡来告诉相机正确的颜色。所谓调整白平衡，就是告诉相机什么是白色，然后以此为基础，相机就能确定其它的颜色。手机相机的白平衡一般是自动调整，如果出问题，很多时候会在后期做处理，不过，实际上也可以在拍摄时指定，相机一般会提供诸如 阴影、多云、日光、白炽灯、闪光灯等许多场景，每种场景的色调都有较大差别。 ","date":"2020-11-09","objectID":"/2020/basic-concepts-of-photography/:4:0","tags":["新知识学习"],"title":"新知识学习-手机摄影","uri":"/2020/basic-concepts-of-photography/"},{"categories":["我所热爱的生活啊"],"content":"少数派看到一篇 如何建立大学的信息管理体系？，其中提到了「想法、清单、日历」的日程规划体系，对我有一定的启发，结合阅读这篇文章的收获，写了一个日程规划体系的简单草稿。时间到 2021年02月，经历了长时间的实践尝试和多次总结，终于完善了我的日程规划体系，可以发布第一版正式的文章了，不过以后可能还会有适应性的调整。 ","date":"2020-10-28","objectID":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/:0:0","tags":["杂谈"],"title":"日程规划思考-便签待办清单和日历","uri":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/"},{"categories":["我所热爱的生活啊"],"content":"1. 待记录的内容和工具 工作、生活和学习中，会记录的内容，或者说需要记录的内容包括如下几方面 年、月、周、日的总结与计划； 待办，也就是真正的有 deadline 的需要去做的事，这些事又可分为两种 一次性的事件； 重复性的日程类任务； 待办，但是却是暂时还没有确定 deadline 的，灵活性较大的； 学习或工作时的思路梳理； 突然而来的灵感，偶然接触的某个概念等； 书籍、视频、文章阅读、收集、评论和摘录； 习惯记录，比如饮食、健身、睡眠、大小便、早睡、早起、玩手机等； 临时的无意义文字，比如单词背诵的记录、数学计算的草稿等； 可用的工具包括：邮箱、个人博客、笔记本、滴答清单或Microsoft Todo 等清单类软件、日历、便签、简悦、Edge集锦等。 ","date":"2020-10-28","objectID":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/:1:0","tags":["杂谈"],"title":"日程规划思考-便签待办清单和日历","uri":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/"},{"categories":["我所热爱的生活啊"],"content":"2. 日程类任务 日程主要是占据自己较长时间（几个小时）的一项任务事项。 日程类任务最重要的是有及时的提醒，从这方面来看，滴答清单、Microsoft Todo 等软件都不如系统自带的日历好用，而且，滴答清单的免费版受限比较多。一开始的时候，我强烈地追踪着全平台这个需求，但实际使用中发现这些软件在 windows 平台地效果并不像我想的那么好。系统自带的日历可以通过 Exchange 服务和电脑进行同步，但这种同步是单向的，即只能从电脑同步到手机，而不能从手机同步到电脑，于是瞬间就沦为了鸡肋。随后我开始思考我是否真的需要全平台同步这个功能，因为手机在绝大多数情况都在我们身边，并不太需要电脑重复进行提醒。有时候我会懒得拿起手机，这时候手环可以起到该起的作用，只要开启手环中关于日历的消息提醒就可以。 用 Outlook 可以实现 Windows 和 手机同步，通过颜色将日程分为两类：私人和学校 最近因为在努力的减少手机的使用时间，决心大多数情况使用笔记本解决，使用的记笔记方法是子弹笔记，因此，日程类任务的处理流程为 无论一次性任务还是重复性日程，只要确定日期，就用日历记录； 一次性任务，而且不确定日期的，记录到笔记本上，如果当时不方便，可以先记录到手机便签，晚上日总结的时候记录到笔记本； 举一些例子，一次性的任务可能包括取快递、打电话、交付文件、会议举行、笔试、机场接人等等，重复性的任务则可能包括洗衣服、家庭电话、照片和文章整理等等。 ","date":"2020-10-28","objectID":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/:2:0","tags":["杂谈"],"title":"日程规划思考-便签待办清单和日历","uri":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/"},{"categories":["我所热爱的生活啊"],"content":"3. 总结与计划 总结与计划的待选软件包括个人博客、QQ邮箱、笔记本。笔记本的缺点在于不易携带、不易搜索和易丢失，电子方式的缺点在于每次都需要打开专门的软件，而且隐私性无法保证。 我所做的选择是，月、周、日的计划和总结在笔记本上完成，年计划与总结写在博客上。很长一段时间日计划都是使用纸便签完成的，但这种方式的缺点在于撕掉后就没有了，周总结的时候不记得做了什么。为了笔记本的缺点，可以定期的将笔记本用白描扫描从而电子化，然后备份到电脑中。 ","date":"2020-10-28","objectID":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/:3:0","tags":["杂谈"],"title":"日程规划思考-便签待办清单和日历","uri":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/"},{"categories":["我所热爱的生活啊"],"content":"4. 书籍视频文章 规范化的手段是加入稍后读软件，在每天固定的时间段阅读，但是，如果没有看过，怎么知道应不应该加入稍后读软件呢，目前采用的办法是第一次粗略过一遍，如果里面的信息没有消耗完成，或者有些内容想摘录，或者想要对此做出评论等等需要二次处理，就加入稍后读，其它的可以不理会。 关于信息的阅读，很多东西都是只看标题就知道它要说什么的，这一类就不需要点开了，脑子里要有一个分类器在随时对这些东西做分类，这种思维我还在《逃避虽可耻但有用中》见到男主表现过。 之前使用的稍后读软件是 Pocket，但 Pocket 的问题一是登录不容易，二是没法对文章或单独的语句做评论，所以后来称少数派有简悦的打折，入了简悦，目前使用简悦的稍后读体系，但简悦的存在的问题是需要经常主动的备份文件，如果不主动备份，那么一旦丢失，是找不回内容的。简悦好像有自动同步的机制，但目前还没有去尝试。 稍后读的文章在每天固定时间进行详细的阅读，此时需要进行摘录、做出评论，或者永久收藏，一些处理的原则可以总结如下 常存浏览器书签的工具和网站，没有必要收藏 随手能查到，而且遇到时第一反应也是在网上搜索的，没有必要记录 可以确定只会使用一次，以后再也不会用到的，没有必要收藏和记录 频繁使用的，非常熟悉的，提到的第一时间就能想起的，没有必要记录 以上是没有必要收藏和记录的，哪些东西需要收藏和记录，原则如下 可能会用到，而且遇到时第一反应会是到自己的知识体系中去寻找的 比较珍贵的记录，不及时保存以后就再也找不到的 灵感，想法，所有个人产出的原创的东西 自己确实非常感兴趣的，不在乎是否重复 总之，做一个生产者而不是复制者，而且时刻保持极简主义的心态。 PC端当然可以直接加入稍后读，手机端的安卓阵营简悦并没有支持，目前使用的方法是用分享按钮加入QQ的收藏，然后晚上定期整理的时候从PC端QQ收藏中查找。这里因为我不使用手机上的 Edge，所以没法用集锦做同步，一直以来都觉得 via 比其它浏览器好用。 ","date":"2020-10-28","objectID":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/:4:0","tags":["杂谈"],"title":"日程规划思考-便签待办清单和日历","uri":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/"},{"categories":["我所热爱的生活啊"],"content":"5. 其它 首先是备忘类，比如需要马上记录的电话、人名、地名、会议摘要、聊天内容等，直接使用手机便签记录； 其次是突然而来的灵感，记录到便签中，有下面这些情况，但不限于这些 一直苦思冥想的问题有了点子 看到听到或遇到某件事某个物品，突然有了感触，想在这个点上写篇文章（针对于爱写作的人） 由于受到了安利或其它原因，想 看某个电影 读某本书 听某首歌 去某个地方旅行 吃某个食物 买某个东西 意识到了某个领域的痛点，自己又有一点初步的解决想法； 学到了一个新知识，想记录下来，或者遇到了一个新概念，想找时间查一查； 需要注意，便签中的内容在每天晚上记得整理迁移到笔记本上。 然后是思路整理，目前最常见的情况是阅读论文时论点和想法整理、写论文时列提纲、针对某件事情列清单（超市购物、旅行等），都记录到笔记本上； 习惯记录，单词背诵时写的单词，数学演算的草稿，都使用笔记本完成，子弹笔记的 Collection 配合 Index 确实非常好用。 有些人会把账号、密码等记录到便签随查随用，不过这类内容比较多，而且成体系，偏偏访问频率小，我觉得使用便签不合算，目前记录在 Notion 中，需要的时候从手机的 Notion 查看，注意包括账户体系、物品体系等。 ","date":"2020-10-28","objectID":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/:5:0","tags":["杂谈"],"title":"日程规划思考-便签待办清单和日历","uri":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/"},{"categories":["我所热爱的生活啊"],"content":"6. 周刊 每周重要的新闻、接触的新知识、完成哪些事、觉得哪些视频、文章等比较好，等等内容都整理到一份周刊中，发表到博客，示例可查看 书藏的生活周刊第 10 期 (20200306) ","date":"2020-10-28","objectID":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/:6:0","tags":["杂谈"],"title":"日程规划思考-便签待办清单和日历","uri":"/2020/%E6%97%A5%E7%A8%8B%E8%A7%84%E5%88%92%E6%80%9D%E8%80%83-%E4%BE%BF%E7%AD%BE%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95%E5%92%8C%E6%97%A5%E5%8E%86/"},{"categories":["爱编程爱技术的孩子"],"content":"最近在智能合约中实现信誉算法，但是 Solidity 不支持浮点数赋值和运算，好在有人写了一个库实现了 IEEE 754 浮点数标准，只不过输入输出都是二进制，所以回过头来仔细理解一下实数在计算机中的存储。 ","date":"2020-10-18","objectID":"/2020/storage-of-reals-in-computers/:0:0","tags":["计算机基础"],"title":"计算机基础-实数在计算机中的存储","uri":"/2020/storage-of-reals-in-computers/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 实数 实数就是带有整数部分和小数部分的数字。 ","date":"2020-10-18","objectID":"/2020/storage-of-reals-in-computers/:1:0","tags":["计算机基础"],"title":"计算机基础-实数在计算机中的存储","uri":"/2020/storage-of-reals-in-computers/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 实数的定点表示 定点表示就是固定小数点的表示法，比如 23.75，就可以表示为 $(10111.11)_2$ $$ 23.75 = 23 + 0.75 = (2^4 + 2^2 + 2^1 + 2^0) + (2^{-1} + 2^{-2}) $$ 但是，由于不确定整数部分和小数部分各需要多少位来存储，很容易出现精度的丢失。 小数部分精度受损：用 16 位二进制数表示一个实数，其中整数部分 14 位，小数部分 2 位，此时存储十进制数 1.00234 就会损失精度，最终存储在计算机中的结果是 1.00 整数部分精度受损：用 16 位二进制数表示一个实数，其中整数部分 2 位，小数部分 14 位，此时存储十进制数 10.00234 就会损失精度，最终存储在计算机中的结果是 2.00234 因此，为了维持精度，在计算机中存储实数通常采用的是浮点表示法。 ","date":"2020-10-18","objectID":"/2020/storage-of-reals-in-computers/:2:0","tags":["计算机基础"],"title":"计算机基础-实数在计算机中的存储","uri":"/2020/storage-of-reals-in-computers/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 实数的浮点表示 浮点的意思是允许小数点浮动，比如，当我们表示十进制数 7500.24 时，采用科学计数法可以将小数点左移 3 位，从而表示为 $7.50024 \\times 10^3$，写作 +7.50024E3。通过这种方式我们就可以控制小数点左右任一部分的数字个数，从而便于存储，一般情况我们会在小数点左边仅保留 1 位。 ","date":"2020-10-18","objectID":"/2020/storage-of-reals-in-computers/:3:0","tags":["计算机基础"],"title":"计算机基础-实数在计算机中的存储","uri":"/2020/storage-of-reals-in-computers/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 规范化 科学计数法用于十进制数，当这种小数点浮动的方法用于二进制数时，就叫做浮点表示法。 以上面的数字 23.75 为例，其二进制表示为 $(10111.11)_2$，采用浮点表示法，可以表示为 $1.011111 \\times 2^4$。我们通常将这样一个数字划分为三部分：符号 Sign，指数 Exponent 和 尾数 Mantissa。 + 2^4 × 1.011111 // 浮点表示 -------------------------- + 4 011111 // 拆分 ↑ ↑ ↑ sign Exponent Mantissa // 含义 符号位用一个二进制位表示，0 表示正，1 表示负；尾数指的是小数点右侧的二进制数，定义了该数的精度，小数点和小数点左侧的 1 没有存储，它们是隐含的；指数是小数点移动的位数，使用余码表示法存储，下面进行介绍。 余码表示法的出现是因为指数也有符号，比如 $(10111.11)_2$ 的浮点表示为 $1.011111 \\times 2^4$，此时指数为正整数 4，但是$(0.00101)_2$ 的浮点表示为 $1.01 \\times 2^{-3}$，此时指数为负整数 -3。如果不想在指数部分使用一个额外的符号位，就要想一种别的表示法，这就是余码表示法。下面我们通过一个例子来介绍它。 4 位的二进制数可以表示 16 个整数，即 -7 到 8，我们采用对它们统一加一个偏移量的方法来把这些数字全部变成非负整数，这个例子中，我们对所有的数字统一 +7，这样十六个整数就变成了 0 到 15，如下图 这种加一个偏移量的方法并没有改变数字之间的相对位置，因此当我们得到这样一个数字，又知道了它的偏移量，是可以转换回原本的数字的，这种方法就叫做余码表示法。上例中，偏移量为 7，所以更具体一点可以称为余7码。 ","date":"2020-10-18","objectID":"/2020/storage-of-reals-in-computers/:3:1","tags":["计算机基础"],"title":"计算机基础-实数在计算机中的存储","uri":"/2020/storage-of-reals-in-computers/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 IEEE 754标准 IEEE 制定的 754 标准是关于计算机软硬件浮点数表示和运算的标准，被各大硬件厂商和编程语言所采用。该标准的内容其实就是浮点表示法的三部分各占多少位，如下表 单精度(Single Precision) 双精度(Double Precision) 四精度(Quadruple Precision) 数字位数 32 64 128 符号位数 1 1 1 指数位数 8 11 15 尾数位数 23 52 112 偏移量 127 1023 16383 精度：当用 32 位二进制数表示时，我们称为单精度，当用 64 位表示时，我们称为双精度。 偏移量：偏移量的计算方法为 $2^{m-1}-1$，$m$ 是指数位数。偏移量是多少，就是余多少码，比如，单精度偏移量为 127，就是余127码。 一个实数转换为浮点数表示的步骤为 确定符号位 S； 将数的绝对值转换为二进制数； 规范化二进制数； 确定指数 E 和尾数 M，尾数不足在右侧补0； 将 SEM 相连。 下面用一些例子来说明该过程，以及给定一个浮点数的二进制表示表示如何反向计算出这个实数。 Example 1：写出十进制数 -0.0234375 的余127码（单精度）表示法 S = 1（符号位为负） 十进制转换二进制：$0.0234375 = (0.0000011)_2$ 规范化：$(0.0000011)_2 = (1.1)_2 \\times 2^{-6}$ 指数 $E = -6 + 127 = 121 = (01111001)_2$，尾数 $M = (1)_2$ 连接 SEM：$(10111100110000000000000000000000)_2$ 1 01111001 10000000000000000000000 S E M Example 2：位模式 $(11001010000000000111000100001111)_2$ 以余127码格式存储于内存中. 求该数字十进制计数法的值. 拆分：首位 S，接下来 8 位为 E，剩下的 23 位为 M 1 10010100 00000000111000100001111 S E M 符号为负号 指数 = E - 127 = 148 - 127 = 21 将 $(1.00000000111000100001111)_2 \\times 2^{21}$ 去规范化得到 $(1000000001110001000011.11)_2$ 得到的二进制数化为十进制为 2104378.75 最终的数字为 -2104378.75 Example 3：实数 0.0 的存储，这是特例，规定这种情况符号、指数和尾数都为0 后记：所找的的库实现 IEEE 754 标准时，输入输出都是二进制，因此，还需要自行实现两个算法从而实现和十进制实数的相互转换，算法就是上面两个例子的步骤。 ","date":"2020-10-18","objectID":"/2020/storage-of-reals-in-computers/:3:2","tags":["计算机基础"],"title":"计算机基础-实数在计算机中的存储","uri":"/2020/storage-of-reals-in-computers/"},{"categories":["爱编程爱技术的孩子"],"content":"区分 MySQL 中临时表与派生表的概念，明确它们的用途。 ","date":"2020-10-13","objectID":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/:0:0","tags":["计算机基础"],"title":"Mysql学习补充-临时表与派生表","uri":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 临时表 本节参考 易百教程-MySQL临时表 ","date":"2020-10-13","objectID":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/:1:0","tags":["计算机基础"],"title":"Mysql学习补充-临时表与派生表","uri":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 简介 就像它的名字，临时表是一个临时的结果集，一般在多表连接时使用，存储一个临时的结果以便另一个查询来处理。 临时表的一些注意如下 在 CREATE 和 TABLE 中间添加 TEMPORARY 关键字来创建临时表，即 CREATE TEMPOPARY TABLE； 连接结束时，临时表会被自动删除，当然，也可以使用 DROP TABLE 显式删除。注意，这里的连接结束指的是数据库连接，当开发时使用连接池或者持久连接时，无法保证临时表在程序终止时自动删除，因为程序结束时连接不一定结束，而是会放到连接池； 临时表只能被创建它的客户端看到和访问，因此不同的客户端可以创建具有相同名称的临时表，不会导致冲突； 临时表可以与数据库中的普通表（永久表）具有相同的名称，但会屏蔽掉永久表，只有临时表被删除后永久表才能再次访问。但不建议这样做，因为如果服务器断线重连，将无法区分临时表和永久表，此时发起 DELETE TABLE 可能会删除掉永久表。 ","date":"2020-10-13","objectID":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/:1:1","tags":["计算机基础"],"title":"Mysql学习补充-临时表与派生表","uri":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 创建 如上所述，使用 CREATE TEMPORARY TABLE 创建临时表。下例中创建了一个临时表，按照收入存储前 10 名客户 CREATE TEMPORARY TABLE top10customers SELECT p.customerNumber, c.customerName, FORMAT(SUM(p.amount),2) total FROM payments p INNER JOIN customers c ON c.customerNumber = p.customerNumber GROUP BY p.customerNumber ORDER BY total DESC LIMIT 10; 从创建的临时表中查询数据如下 SELECT * FROM top10customers; ","date":"2020-10-13","objectID":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/:1:2","tags":["计算机基础"],"title":"Mysql学习补充-临时表与派生表","uri":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 删除 使用 DROP TEMPORARY TABLE 删除临时表，如下 DROP TEMPORARY TABLE top10customers; 关键词 TEMPORARY 可以省略，但为了避免删除永久表的错误，最好还是加上该关键词。 ","date":"2020-10-13","objectID":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/:1:3","tags":["计算机基础"],"title":"Mysql学习补充-临时表与派生表","uri":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 派生表 本节参考 易百教程-MySQL派生 当在 SELECT 语句的 FROM 子句中使用独立子查询时，将其称为派生表。 SELECT column_list FROM ( # 圆括号中的子查询结果即为派生表 SELECT column_list FROM table_1 ) derived_table_name # 派生表必须具有别名 WHERE derived_table_name.c1 \u003e 0; 派生表必须具有别名，以便在稍后的查询中引用，否则，MySQL 将给出如下错误 Every derived table must have its own alias. 所以，我们可以看到，派生表不需要像临时表那样需要创建。 ","date":"2020-10-13","objectID":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/:2:0","tags":["计算机基础"],"title":"Mysql学习补充-临时表与派生表","uri":"/2020/mysql-learning-supplement-temporary-table-and-derived-table/"},{"categories":["Golang学习之路"],"content":"Go 实现一个命令行界面的 2048 游戏，仅涉及 Git 和 Go，用来熟悉基本语言特性。原型项目来自 https://github.com/chhabraamit/2048 ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:0:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"1. 环境准备 Win10 环境，go 1.14.3，编辑器为 VScode，使用 Github 管理代码。 首先在网页端建立 Github 仓库，选择 MIT 协议，然后克隆仓库到本地 $ git clone https://github.com/shuzang/2048.git 在项目根目录创建 main.go 文件 package main import \"fmt\" func main() { fmt.Println(\"Getting started!\") } 初始化项目 $ go mod init github.com/shuzang ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:1:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"2. 显示游戏面板 2048 的游戏界面是一个 4×4 的网格，我们使用一个二维切片作为底层结构存储数字，然后按照网格的形式输出到终端，数字随机生成。 // game/board.go package game import ( \"fmt\" \"math/rand\" \"time\" ) // 游戏界面规格 const _rows, _cols = 4, 4 type Board interface { Display() } type board struct { board [][]int } /* 显示 4×4 网格形式的游戏界面 */ func (b *board) Display() { b.board = generate() printHorizontalLine() for i := 0; i \u003c _rows; i++ { printVerticalLine() for j := 0; j \u003c _cols; j++ { // 每个数字占7个位置，如果为0，输出空字符 if b.board[i][j] == 0 { fmt.Printf(\"%7s\", \"\") } else {// 数字不为0，使其位于中间，方法是使其占4位，然后接着输出3个空字符 fmt.Printf(\"%4d%3s\", b.board[i][j], \"\") } printVerticalLine() } fmt.Println() printHorizontalLine() } } // 输出横线，4*7+5 = 33 func printHorizontal() { for i := 0; i \u003c 33; i++ { fmt.Printf(\"-\") } fmt.Println() } // 输出竖线 func printVertical() { fmt.Printf(\"|\") } // 生成所需的所有随机数 func generate() [][]int { // Store all available numbers from 2 to 2048 nums := make([]int, 0) nums = append(nums, 0) for i := 2; i \u003c= 2048; i *= 2 { nums = append(nums, i) } // generate random numbers for init board rand.Seed(time.Now().UnixNano()) matrix := make([][]int, _rows) for i := 0; i \u003c _rows; i++ { matrix[i] = make([]int, _cols) } for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { matrix[i][j] = nums[rand.Int()%len(nums)] } } return matrix } func NewBoard() *Board { return \u0026board{} } 然后修改 main.go 如下 // main.go package main import ( \"fmt\" \"github.com/shuzang/2048/game\" ) func main() { fmt.Println(\"Getting started!\") b := game.NewBoard() b.Display() } 运行 go run main.go 可以看到一个临时的游戏面板。 ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:2:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"3. 添加元素 上面的程序随机生成了 16 个数字填充游戏面板，但这只是初始测试，正式游戏的做法是：初始时随机填充两个数字，然后每个键盘输入新增一个数字。这里还要注意每一步生成的数字有两种选择，2 或 4，我们可以控制这两个数字生成的概率。 所以添加新元素被抽象为一个独立的函数，如下 // game/board.go type board struct { board [][]int nx, ny int } // 被折叠的代码... // 随机填充一个新数字 func (b *board) AddElement() { rand.Seed(time.Now().UnixNano()) // 随机选择一个空白位置 index := make([][2]int, 0) for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { if b.board[i][j] == 0 { index = append(index, [2]int{i, j}) } } } next := rand.Int() % len(index) nx, ny := index[next][0], index[next][1] // 按概率选择数字 2 和 4 var number int if rand.Int()%100 \u003c 80 { number = 2 } else { number = 4 } // 将数字填充到选择的位置 b.nx, b.ny = nx, ny b.board[nx][ny] = number } func NewBoard() *board { matrix := make([][]int, _rows) for i := 0; i \u003c _rows; i++ { matrix[i] = make([]int, _cols) } return \u0026board{board: matrix} } board 结构体新增了 nx,ny 两个字段，是为了标记新添加的元素在游戏面板中的位置，我们需要将新元素以不同的颜色表示，这里用到了 fatih/color 包。 $ go get -v github.com/gatih/color 导入该包后修改显示函数如下，用不同的颜色输出新添加的元素。 // game/board.go func (b *board) Display() { c := color.New(color.FgCyan, color.Bold) printHorizontalLine() for i := 0; i \u003c _rows; i++ { printVerticalLine() for j := 0; j \u003c _cols; j++ { if b.board[i][j] == 0 { fmt.Printf(\"%7s\", \"\") } else if i == b.nx \u0026\u0026 j == b.ny { c.Printf(\"%4d%3s\", b.board[i][j], \"\") } else { fmt.Printf(\"%4d%3s\", b.board[i][j], \"\") } printVerticalLine() } fmt.Println() printHorizontalLine() } } 相应的，主函数修改如下，添加 10 个元素并输出 // main.go func main() { fmt.Println(\"Getting started!\") b := game.NewBoard() for i := 0; i \u003c 10; i++ { b.Display() b.AddElement() } fmt.Println(\"Game over!\") } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:3:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"4. 先清屏后显示 上面的程序会把每一步的面板都输出到终端，我们应当添加的一个功能是，每一步只输出当前的游戏面板。该功能通过清屏函数实现，注意，清屏的实现在不同操作系统可能会有区别，下面的实现适用于 Windows 系统。 // game/board.go func (b *board) Display() { // clear screen, but only works on windows cmd := exec.Command(\"cmd\", \"/c\", \"cls\") cmd.Stdout = os.Stdout cmd.Run() c := color.New(color.FgCyan, color.Bold) printHorizontalLine() for i := 0; i \u003c _rows; i++ { printVerticalLine() for j := 0; j \u003c _cols; j++ { if b.board[i][j] == 0 { fmt.Printf(\"%7s\", \"\") } else if i == b.nx \u0026\u0026 j == b.ny { c.Printf(\"%4d%3s\", b.board[i][j], \"\") } else { fmt.Printf(\"%4d%3s\", b.board[i][j], \"\") } printVerticalLine() } fmt.Println() printHorizontalLine() } } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:4:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"5. 获取键盘输入 游戏的每一步操作肯定都是根据键盘的输入来的，可以使用 {W, A, S, D} 和 方向键，如果使用 fmt 包中的输入函数，那么每次输入后都需要手动按下回车。为了不必每次输入字符后都敲一下回车键，我们使用 eiannone/keyboard 包 $ go get -v github.com/eiannone/keyboard 将键盘输入对应的几个操作定义为几个常量，然后调用 keyboard 包中的 GetKeyStrokes() 函数接收键盘输入，返回对应的常量，最后在 TakeInput() 函数中根据不同常量交给对应的操作函数处理。 // game/board.go type Key int // 几个操作常量，向四个方向移动、退出和错误按键 const ( UP Key = iota DOWN LEFT RIGHT QUIT ERROR_KEY ) func (b *board) TakeInput() bool { key, err := GetKeyStrokes() if err != nil { fmt.Printf(err.Error()) } if key == ERROR_KEY { b.TakeInput() } switch key { case UP: b.moveUp() case DOWN: b.moveDown() case LEFT: b.moveLeft() case RIGHT: b.moveRight() case QUIT: fmt.Println(\"You press ESC, game exit!\") return false } return true } func GetKeyStrokes() (Key, error) { char, key, err := keyboard.GetSingleKey() if err != nil { return ERROR_KEY, err } //fmt.Printf(\"You pressed: %c, key %X\\r\\n\", char, key) if int(char) == 0 { switch key { case keyboard.KeyArrowUp: return UP, nil case keyboard.KeyArrowDown: return DOWN, nil case keyboard.KeyArrowLeft: return LEFT, nil case keyboard.KeyArrowRight: return RIGHT, nil case keyboard.KeyEsc: return QUIT, nil default: return ERROR_KEY, errors.New(\"Invalid key, please press again!\") } } else { switch char { case 119: return UP, nil case 97: return LEFT, nil case 115: return DOWN, nil case 100: return RIGHT, nil default: return ERROR_KEY, errors.New(\"Invalid key, please press again!\") } } } 游戏退出有两种情况，一个是上面程序中定义的 QUIT 操作，用于游戏过程中主动输入 ESC 按键退出，另一个是游戏面板 16 个数字已满，Game over，通过添加以下函数实现 // game/board.go func (b *board) IsOver() bool { blank := 0 for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { if b.board[i][j] == 0 { blank++ } } } return blank == 0 } 最后是程序开始的逻辑，即输入任意键开始。这部分逻辑在 main 函数中 // main.go func main() { fmt.Println(\"Use {W A S D} or Arrow keys to move the board\") fmt.Printf(\"Press and key to start\\n\") _, _, err := keyboard.GetSingleKey() if err != nil { log.Fatalln(\"error while taking input to start the game\") } b := game.NewBoard() b.AddElement() b.AddElement() for true { if b.IsOver() { break } b.AddElement() b.Display() res := b.TakeInput() if !res { return } } fmt.Println(\"game over\") } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:5:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"6. 数字移动合并 每个键盘输入都对应一个操作函数，四个方向的数字移动和合并是游戏的核心逻辑。如下，向左移动数字和合并单独实现，向右、向上和向下都能通过矩阵旋转转换为向左移动和合并的问题。 // game/board.go func (b *board) moveLeft() { for i := 0; i \u003c _rows; i++ { old := b.board[i] b.board[i] = moveRow(old) } } func (b *board) moveRight() { b.Reverse() b.moveLeft() b.Reverse() } func (b *board) moveUp() { b.leftRotate90() b.moveLeft() b.rightRotate90() } func (b *board) moveDown() { b.rightRotate90() b.moveLeft() b.leftRotate90() } func (b *board) rightRotate90() { matrix := make([][]int, _rows) for i := 0; i \u003c _rows; i++ { matrix[i] = make([]int, _cols) } for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { matrix[j][_cols-1-i] = b.board[i][j] } } b.board = matrix } func (b *board) leftRotate90() { matrix := make([][]int, _rows) for i := 0; i \u003c _rows; i++ { matrix[i] = make([]int, _cols) } for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { matrix[_cols-1-j][i] = b.board[i][j] } } b.board = matrix } func (b *board) Reverse() { for i := 0; i \u003c _rows; i++ { for j, k := 0, _cols-1; j \u003c k; j, k = j+1, k-1 { b.board[i][j], b.board[i][k] = b.board[i][k], b.board[i][j] } } } func moveRow(row []int) []int { index := 0 for i := 0; i \u003c len(row); i++ { if row[i] != 0 { row[index], row[i] = row[i], row[index] index++ } } for i := 0; i \u003c len(row)-1; i++ { if row[i] == row[i+1] { row[i] += row[i+1] row[i+1] = 0 i++ } } index = 0 for i := 0; i \u003c len(row); i++ { if row[i] != 0 { row[index], row[i] = row[i], row[index] index++ } } return row } 由于这部分逻辑比较复杂，需要测试一下 // game/board_test.go package game import ( \"reflect\" \"testing\" ) func TestMoveRow(t *testing.T) { tests := []struct { name string input []int want []int }{ { name: \"one\", input: []int{2, 2, 0, 0}, want: []int{4, 0, 0, 0}, }, { name: \"two\", input: []int{2, 2, 4, 8}, want: []int{4, 4, 8, 0}, }, { name: \"three\", input: []int{2, 4, 4, 8}, want: []int{2, 8, 8, 0}, }, { name: \"four\", input: []int{2, 4, 8, 8}, want: []int{2, 4, 16, 0}, }, { name: \"five\", input: []int{2, 2, 2, 2}, want: []int{4, 4, 0, 0}, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := moveRow(tt.input); !reflect.DeepEqual(got, tt.want) { t.Errorf(\"moveRow() = %v, want %v\", got, tt.want) } }) } } func TestLeftRotate90(t *testing.T) { type fields struct { matrix [][]int } tests := []struct { name string fields fields want [][]int }{ { name: \"one\", fields: fields{ matrix: [][]int{ {1, 2, 3, 9}, {4, 5, 6, 10}, {6, 7, 8, 11}, {16, 17, 18, 111}, }, }, want: [][]int{ {9, 10, 11, 111}, {3, 6, 8, 18}, {2, 5, 7, 17}, {1, 4, 6, 16}, }, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { b := \u0026board{board: tt.fields.matrix} b.leftRotate90() if !reflect.DeepEqual(b.board, tt.want) { t.Errorf(\"b.leftRotate90() = %v, want %v\", b.board, tt.want) } }) } } func TestRightRotate90(t *testing.T) { type fields struct { matrix [][]int } tests := []struct { name string fields fields want [][]int }{ { name: \"one\", fields: fields{ matrix: [][]int{ {1, 2, 3, 9}, {4, 5, 6, 10}, {6, 7, 8, 11}, {16, 17, 18, 111}, }, }, want: [][]int{ {16, 6, 4, 1}, {17, 7, 5, 2}, {18, 8, 6, 3}, {111, 11, 10, 9}, }, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { b := \u0026board{board: tt.fields.matrix} if b.rightRotate90(); !reflect.DeepEqual(b.board, tt.want) { t.Errorf(\"b.rightRotate90() = %v, want %v\", b.board, tt.want) } }) } } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:6:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"7. 分数计算 游戏正常结束后显示当前最大分数和总分数，算是一个小功能。 //game/board.go func (b *board) CountScore() (int, int) { total, max := 0, 0 matrix := b.board for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { total += matrix[i][j] max = maxInts(max, matrix[i][j]) } } return max, total } func maxInts(a, b int) int { if a \u003e b { return a } return b } //main.go func main() { fmt.Println(\"Use {W A S D} or Arrow keys to move the board\") fmt.Printf(\"Press and key to start\\n\") _, _, err := keyboard.GetSingleKey() if err != nil { log.Fatalln(\"error while taking input to start the game\") } b := game.NewBoard() b.AddElement() b.AddElement() for true { if b.IsOver() { break } b.AddElement() b.Display() res := b.TakeInput() if !res { return } } fmt.Println(\"\\n********** game over **********\") max, total := b.CountScore() fmt.Printf(\"Max Score: %v \\n\", max) fmt.Printf(\"Total Score %v \\n\", total) } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:7:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"8. 代码重构 所有功能完成后，对代码进行重构整理，包括 将数字移动合并的相关代码移动到单独的 move.go 源文件中； （可选）将输入和显示的相关函数都拆分到单独的源文件中； 为所有代码添加注释，并编写 README.md 文档； ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:8:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"9. 结果与收获 完整的项目代码可以查看我的 github 仓库，与原项目有一些实现上的区别，并完善了一些功能。 编写该项目的收获有 开源协议的选择； 对结构体和接口作用和意义的思考； 一个项目是从简单到复杂一步步建立的，不要想一步登天做的很完善； 方法中 (b *board) 和 (b board) 的区别； 一些重要的可定制的参数可以抽取作为为常量，比如面板规格，常量命名时前面最好加下划线 _ 加以区分； fmt.Printf 可以输出固定长度的空字符用于占位，fmt.Println() 可以用来换行； 随机数的生成方法，一个小技巧是使用数组存放待选择数字，然后随机生成数组长度范围内的数字作为索引进行选择； 结构体对象的生成可以使用工厂模式，比如 NewBoard 函数； 格式化输出的颜色控制（fatih/color包）； 清屏的实现方法； 无需回车不断读取键盘输入的实现方法（eiannone/keyboard包）; 矩阵旋转等大量关于二维切片的算法实现（PS：刷题还是有用的）； 测试用例的编写； 所有功能完成后，根据情况进行重构，比如代码的解耦等，然后完成添加注释、编写文档等工作； Go 文档的编写与使用； 日志系统的使用。 ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:9:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["爱编程爱技术的孩子"],"content":"Windows terminal 的安装配置和 winget 的基本使用，主要原因是 Powershell 不好看。 ","date":"2020-10-07","objectID":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/:0:0","tags":["win10"],"title":"win10效率优化7-终端和winget","uri":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/"},{"categories":["爱编程爱技术的孩子"],"content":"1. Windows terminal 界面友好的终端应用，凡是命令行程序都可以用它启动，可以将 win10 下的 cmd、Powershell 和 git bash 都集中在一起，当然，最重要的是好看。 基本上有什么问题都可以从 官方教程 里查到，这里只是介绍我的配置过程。 ","date":"2020-10-07","objectID":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/:1:0","tags":["win10"],"title":"win10效率优化7-终端和winget","uri":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 安装 我选择从 Microsoft Store 安装 Windows terminal。初始界面如下 ","date":"2020-10-07","objectID":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/:1:1","tags":["win10"],"title":"win10效率优化7-终端和winget","uri":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 快捷键启动 右键菜单已经有 git bash 了，不需要把它添加进去。 快捷键启动我没有采用网上流传的教程，而是把 Windows terminal 固定在了任务栏第一个，然后使用 Win+1 键打开。 ","date":"2020-10-07","objectID":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/:1:2","tags":["win10"],"title":"win10效率优化7-终端和winget","uri":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 添加 git bash 默认添加的应用包括 Powershell、cmd、Azure Cloud Shell 和我之前安装的 WSL（Ubuntu 20.04）。 这里将 git bash 添加进去，并设置为启动时默认使用的应用（之前启动 Windows termianl 默认打开 Powershell），并设置起始目录。最终效果如上图 点击标题栏的下箭头，点击「设置」，可以在上图中看到； 在打开的配置文件中 list 部分添加如下内容。其中，guid 是唯一标识符，注意不要和已有的四个应用相同即可；name 是应用名；commandline 设置 git bash 路径，根据自己的安装位置设置；icon 设置上图中显示的缩略图，自己从 网上 下载放到合适的位置并设置；startingDirectory 设置起始目录，我这里设置了我最常打开的目录。 { \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b9}\", \"name\": \"Git-bash\", \"commandline\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\", \"icon\": \"C:\\\\Program Files\\\\Git\\\\gwindows_logo.png\", \"startingDirectory\": \"F:\\\\OneDrive\\\\博客\" } 修改全局字段（在配置文件的最前面几行中找）中的 defaultProfile 为 Git-bash，这里可以使用上面的 name 或 guid 字段 \"defaultProfile\": \"Git-bash\", ","date":"2020-10-07","objectID":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/:1:3","tags":["win10"],"title":"win10效率优化7-终端和winget","uri":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 配色及背景图 大部分人用 Windows terminal 就是因为它可定制，所以出现了各种各样好看的配色和主题。 我从 主题网站 选择了 Builtin Tango Light 主题，配置代码如下，需要将这段代码复制到配置文件的 schemes 字段中。 { \"name\": \"Builtin Tango Light\", \"black\": \"#000000\", \"red\": \"#cc0000\", \"green\": \"#4e9a06\", \"yellow\": \"#c4a000\", \"blue\": \"#3465a4\", \"purple\": \"#75507b\", \"cyan\": \"#06989a\", \"white\": \"#d3d7cf\", \"brightBlack\": \"#555753\", \"brightRed\": \"#ef2929\", \"brightGreen\": \"#8ae234\", \"brightYellow\": \"#fce94f\", \"brightBlue\": \"#729fcf\", \"brightPurple\": \"#ad7fa8\", \"brightCyan\": \"#34e2e2\", \"brightWhite\": \"#eeeeec\", \"background\": \"#ffffff\", \"foreground\": \"#000000\" } 然后在 defaults 字段中添加 \"colorScheme\": \"Builtin Tango Light\" 为了不打扰正式内容的显示，我决定将背景图放在右下角，同时，由于终端主体颜色是白色，背景图除了主体的人或物，其它颜色也应该是白色，正好我有一张谏山黄泉的图是这样的。 由于要放在右下角，还要在图片左边和上边扩展大量的白色区域。我选择的方法是打开 Microsoft Whiteboard 应用，将背景颜色设置为白色，然后将图片放在右下角，导出此时的白板。 将导出的图片放在合适的位置，在配置文件的 defaults 字段中添加如下内容（和主体设置在一起），第一行设置背景图路径，第二行设置不透明度。此时打开终端发现图片显示可能有问题，无法正好在右下角显示整个人物，这时候通过裁剪背景图上方和左边的空白，不断调整和预览，可以获得想要的效果，最终效果就是本小节开头的图片。 \"backgroundImage\": \"F:\\\\OneDrive\\\\图片\\\\收藏\\\\谏山黄泉-背景图.png\", \"backgroundImageOpacity\": 0.8 注1：不少人喜欢下面这种标签式的效果，叫做 Powerline，但我没感觉，所以没添加，想使用可以参考 Windows 终端的 PowerShell 主题中的 Powerline 注2：官方提供了几种不错的主题，包括 毛玻璃效果 和 Raspberry Ubuntu 我都很喜欢，效果如下 ","date":"2020-10-07","objectID":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/:1:4","tags":["win10"],"title":"win10效率优化7-终端和winget","uri":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/"},{"categories":["爱编程爱技术的孩子"],"content":"2. winget win10 预览版用户直接就可以使用，是系统自带的，非预览版用户从 github仓库 自行下载安装。使用说明可以参考 官方文档，安装后可以直接在终端使用 ","date":"2020-10-07","objectID":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/:2:0","tags":["win10"],"title":"win10效率优化7-终端和winget","uri":"/2020/efficient-use-of-win10-7-windows-terminal-and-winget/"},{"categories":["爱编程爱技术的孩子"],"content":"时间和空间复杂度的分析是编制程序的一个基本能力，不过平时基本都是脑子里简单的估计，本篇文章打算回忆一下大 O 表示法和具体的时间复杂度的推导过程。 ","date":"2020-09-18","objectID":"/2020/algorithm-time-and-space-complexity/:0:0","tags":["数据结构与算法"],"title":"算法-时间复杂度和空间复杂度","uri":"/2020/algorithm-time-and-space-complexity/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 时间复杂度 算法的时间复杂度指的是算法运行所需要的时间的量，这个时间量不应该依赖外部因素，而应当只和问题规模 N、输入 I 以及算法 A 本身相关。如果用 T 表示时间复杂度，那么表达式为 $$ T = T(N,I,A) $$ 由于算法是通过一个或几个函数实现的，算法 A 本身通常就会隐含在函数名中，这样表达式可以简化为 $$ T = T(N,I) $$ 如果算法连输入都不依赖，那么表达式就可以进一步简化为 $T(N)$，但我们通常用 N 的小写形式，写作 $T(n)$ 那么我们如何来计算这个时间的量呢，通常，我们假设算法中每条语句的执行时间均为单位时间，这样，算法运行的总时间就是所有语句执行时间之和。以顺序查找为例 // 返回第一个与 k 相同的元素的下标，否则返回-1 Search(A[0...n], k) i = 0 // c1=1 while i \u003c n and A[i] != k do // c2 i = i + 1 // c3 if i \u003c n return i // c4=1 else return -1 // 或c5=1 注释中列出了每条语句的执行时间 $c_i$，那么 $\\sum_{i=1}^{n}c_i$ 就是算法运行的总时间。 但是，算法运行的总时间并不是算法的时间复杂度，我们通常说的时间复杂度完整的叫法应该是算法的渐进时间复杂度，是考虑当问题规模充分大时，算法运行时间的表达式在渐进意义下的阶。定义如下 设 $T(n)$ 是关于算法 A 的复杂性函数，如果存在 t(n)，使得 $\\lim\\limits_{N\\to\\infty} \\frac{T(n)-t(n)}{T(n)} = 0 $，则 t(n) 是 T(n) 是当 $n\\to\\infty$ 时的渐进表达式，也可以直接称作其渐进时间复杂度 具体而言，对于给定的 $T(n)$ 的表达式，算法的渐进时间复杂度是略去低阶项和常数因子留下的主项。例如，给定 $T(n) = 3n^3 + 90n^2 - 5n + 6040$，略去低阶项和常数因子，得到渐进时间复杂度 $t(n) = n^3$ ","date":"2020-09-18","objectID":"/2020/algorithm-time-and-space-complexity/:1:0","tags":["数据结构与算法"],"title":"算法-时间复杂度和空间复杂度","uri":"/2020/algorithm-time-and-space-complexity/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 大O表示法 通常用渐进上界 O 来表示渐进时间复杂度，也就是我们常说的大 O 表示法，其定义是 $$ O(g(n)) = {f(n) | 存在正常数 c 和 n_0使得对所有 n \\ge n_0 有：0 \\le f(n) \\le cg(n)} $$ 举个例子，$f(n) = 2n+3 = O(n)$，因为当 $n\\ge 3$ 时，$2n+3 \\le 3n$，这里的含义就是，当 $n \\ge 3$ 时，算法步骤不会超过 $3n$ 第二个例子，$f(n) = 10n^2 + 4n + 2 = O(n^2)$，因为当 $n \\ge 5$ 时，$10n^2 + 4n + 2 \\le 11n^2$ 最后给一个矩阵乘法的实例，总时间 $T(n) = 2n^3 + n^2 + 2n$，这样渐进时间复杂度就是 $O(n^3)$ for i := 0; i \u003c n; i++ { // n for j := 0; j \u003c n; j++ { // n c[i][j] = 0 // n^2 for k := 0; k \u003c n; k++ { // n^3 c[i][j] += a[i][k]*b[k][j] // n^3 } } } 最后声明两个大 O 的运算规则 $O(f) + O(g) = O(max(f,g))$ $O(f)O(g) = O(fg)$ 此外，有时候也会见到渐进下界 $\\Omega$ 和 渐进准确界 $\\Theta$，但很少或几乎用不到 ","date":"2020-09-18","objectID":"/2020/algorithm-time-and-space-complexity/:1:1","tags":["数据结构与算法"],"title":"算法-时间复杂度和空间复杂度","uri":"/2020/algorithm-time-and-space-complexity/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 对输入实例的依赖 有些时候需要考虑某类有代表性的输入实例，比如最坏情况、最好情况、平均情况，这几种情况的复杂度是不一样的，通常用如下符号表示 最好情况 $T_{min}(n)$ 最坏情况 $T_{max}(n)$ 平均情况 $T_{avg}(n)$ 对于前面提到的查找算法，第一个与 k 相同的元素可能是最后一个元素，这时循环执行 n 次，是最坏情况；也可能是第一个元素，这时循环只执行 1 次，是最好情况。 理解这三种情况下的算法性能都很重要，但应注意： 很多算法最好情况下的性能都差不多，O(1) 或者 O(n)，没有太大的影响，不能说明哪种算法更好； 算法的平均情况往往不是那么容易分析； 最坏情况可以告诉我们算法性能的上限，从而保证任何情况都不会比它差。 ","date":"2020-09-18","objectID":"/2020/algorithm-time-and-space-complexity/:1:2","tags":["数据结构与算法"],"title":"算法-时间复杂度和空间复杂度","uri":"/2020/algorithm-time-and-space-complexity/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 复杂度分析的步骤 复杂度分析的步骤如下 确定表示问题规模的变量； 确定占运行时间最大比例的语句； 确定算法是否依赖输入实例（决定了是否分最坏、最好、平均三种情况考虑）； 计算语句执行总次数； 确定时间复杂度； 以选择排序为例，用伪代码描述如下 SelectionSort(A[0...n-1]) for i = 0 to n-2 do min = i for j = i + 1 to n-1 do if A[j] \u003c A[min] { min = j swap A[i] and A[min] 问题规模为数组长度 n 占运行时间最大比例的语句是 $min = j$ 算法只依赖问题规模，不依赖输入实例 语句执行总次数 $T(n) = \\sum_{i=1}^{n}i = \\frac{n(n-1)}{2}$ 时间复杂度为 $O(n^2)$ 一个依赖输入实例的例子是插入排序 InsertSort(A[0...n-1]) for i = 1; i \u003c n; i++ a = A[i] j = i - 1 while j \u003e= 0 \u0026\u0026 A[j] \u003e a A[j+1] = A[j] j-- A[j+1] = a 问题规模为数组长度 n 占运行时间最大比例的语句是 $A[j] \u003e a$ 算法依赖输入实例 语句执行总次数： 最坏情况：$T(n) = \\frac{n(n-1)}{2}$ 最好情况：$T(n) = n-1$ 时间复杂度 最坏情况：$T(n)=O(n^2)$ 最好情况：$T(n) = O(n)$ ","date":"2020-09-18","objectID":"/2020/algorithm-time-and-space-complexity/:1:3","tags":["数据结构与算法"],"title":"算法-时间复杂度和空间复杂度","uri":"/2020/algorithm-time-and-space-complexity/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 常见时间复杂度 常见时间复杂度总结如下表 复杂度 出现情况 l 几乎不存在 logn 不能考虑全部输入 n 遍历、扫描全部输入 nlogn 许多分治算法 $n^2$ 两层循环 $n^3$ 三层循环 $2^n$ 一个集合的所有子集 $n!$ 一个集合中的元素的所有排列 我们可以按这些时间复杂度把算法分为两类 多项式时间算法 用多项式对运行时间限界的算法 $O(1) \u003c O(logn) \u003c O(n) \u003c O(nlogn) \u003c O(n^2) \u003c O(n^3)$ 指数时间算法 用指数函数对运行时间限界的算法 $O(2^n) \u003c O(n!) \u003c O(n^n)$ 对指数时间的算法应尽可能优化。 ","date":"2020-09-18","objectID":"/2020/algorithm-time-and-space-complexity/:1:4","tags":["数据结构与算法"],"title":"算法-时间复杂度和空间复杂度","uri":"/2020/algorithm-time-and-space-complexity/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 空间复杂度 空间复杂度是对算法所消耗的额外存储单元进行计数，这里注意是额外的存储单元，不包括 为容纳输入数据而分配的存储空间，比如输入数组 A[0…n] 占用的空间 实现该算法的程序代码和常数占用的空间 额外的意思是算法所需要的工作空间，比如交换两个变量值时分配了一个临时变量，这个变量占用的空间就属于空间复杂度分析的范围，再比如实现栈时为栈申请的空间也属于空间复杂度的分析范围，最后，递归函数使用的内部栈也属于空间复杂度的分析范围。 在很多问题中，时间和空间是一个对立面。为算法分配更多的空间，可以使算法运行的更快，反之，当空间是一个重要因素时，需要用算法的运行时间去换取空间。一个运行时间短、所需存储空间小、其它性能也好的算法是很难做到的。因此我们要根据具体情况进行算法设计。 对于使用次数较少的程序，力求算法简单易懂； 对于反复多次使用的程序，尽可能选用快速的算法； 若待解决的问题数据量极大，机器的存储空间较小，则相应算法主要考虑如何节省空间。 ","date":"2020-09-18","objectID":"/2020/algorithm-time-and-space-complexity/:2:0","tags":["数据结构与算法"],"title":"算法-时间复杂度和空间复杂度","uri":"/2020/algorithm-time-and-space-complexity/"},{"categories":["爱编程爱技术的孩子"],"content":"这篇文章用来仔细思考 MySQL 查询语句的执行顺序。 手写 MySQL 语句的顺序通常如下 select \u003cselect_list\u003e from \u003ctable_name\u003e \u003cjoin_type\u003e join \u003cjoin_table\u003e on \u003cjoin_condition\u003e where \u003cwhere_condition\u003e group by \u003cgroup_by_list\u003e having \u003chaving_condition\u003e order by \u003corder_by_condition\u003e limit \u003climt_number\u003e MySQL 语句的执行顺序如下 from \u003cleft table\u003e on \u003con_condition\u003e \u003cjoin_type\u003e join \u003cjoin_table\u003e where \u003cwhere_condition\u003e group by \u003cgroup_by_list\u003e \u003csum()avg()等聚合函数\u003e having \u003chaving_condition\u003e select \u003cselect_list\u003e distinct order by \u003corder_by_condition\u003e limit \u003climit_number\u003e 下面做一下解释 第一步：如果有连接运算，加载 from 子句指定的表中的前两个计算笛卡尔积，生成虚拟表 vt1； 第二步：对虚拟表 vt1 执行 on 表达式，筛选符合条件的元组，生成虚拟表 vt2，如果是外连接，基表中的数据会全部保留； 第三步：如果 from 子句中的表数量大于 2，则重复前两部，直至所有的表都连接完成，得到虚拟表 vt3； 第四步：执行 where 表达式，筛选符合条件的数据生成 vt4； 第五步：执行 group by 子句。group by 子句执行过后，会对子句组合成唯一值并且对每个唯一值只包含一行，生成 vt5,。一旦执行group by，后面的所有步骤只能得到 vt5 中的列（group by的子句包含的列）和聚合函数。 第六步：执行聚合函数，生成 vt6； 第七步：执行 having 表达式，筛选 vt6 中的数据，生成vt7。having是唯一一个在分组后的条件筛选; 第八步：执行 select 语句，从 vt7 中筛选列，生成 vt8； 第九步：执行 distinct，对 vt8 去重，生成 vt9。如果执行过 group by 就没必要再去执行 distinct，因为分组后，每组只会有一条数据，并且每条数据都不相同。 第十步：对 vt9 进行排序，此处返回的不是一个虚拟表，而是一个游标，记录了数据的排序顺序，此处可以使用别名； 第十一步：执行 limit 语句，将结果返回给客户端。 参考 [1] 樱桃mayue，51CTO博客，MySql学习笔记（二）：SQL执行顺序，2019.03.02 ","date":"2020-09-13","objectID":"/2020/mysql-learning-supplement-statement-execution-order/:0:0","tags":["计算机基础"],"title":"Mysql学习补充-语句执行顺序","uri":"/2020/mysql-learning-supplement-statement-execution-order/"},{"categories":["爱编程爱技术的孩子"],"content":"MySQL 作为关系数据库，关系数据理论是基础，本文进行补充学习，主要包括关系模型、关系代数和范式的相关知识。 ","date":"2020-09-11","objectID":"/2020/mysql-learning-supplement-relational-data-theory/:0:0","tags":["计算机基础"],"title":"Mysql学习补充-关系数据理论","uri":"/2020/mysql-learning-supplement-relational-data-theory/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 关系模型 ","date":"2020-09-11","objectID":"/2020/mysql-learning-supplement-relational-data-theory/:1:0","tags":["计算机基础"],"title":"Mysql学习补充-关系数据理论","uri":"/2020/mysql-learning-supplement-relational-data-theory/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 简介 模型就是描述数据的概念的集合。 数据库的本质作用是存储抽象自现实世界的数据，这一过程可以分为两个阶段 对现实世界进行抽象，强调语义的表达，这一阶段称为概念模型，一般使用线条、图形、文字等来进行描述，是用户和数据库设计人员的沟通语言，比如 E-R 图。 用计算机可理解的方式进行二次抽象，强调数据描述的确定性，这一阶段称作数据模型，包括遵循的数据结构、对数据的各种操作和数据的约束条件三部分。 关系模型正是当前广泛使用的一种数据模型，使用关系模型的数据库称为关系型数据库，MySQL 正是广为使用的一种关系型数据库。 ","date":"2020-09-11","objectID":"/2020/mysql-learning-supplement-relational-data-theory/:1:1","tags":["计算机基础"],"title":"Mysql学习补充-关系数据理论","uri":"/2020/mysql-learning-supplement-relational-data-theory/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 基本概念 域：域是一组具有相同类型值的集合，比如 MAN = {王兵，李平} 就是一个域，WOMAN = {丁梅，吴芳} 也是一个域。 笛卡尔积：给定一组域 $D_1,D_2,…,D_n$，它们的笛卡尔积就定义为 $$ D_1 \\times D_2 \\times … D_n={(d_1,d_2,…,d_n)|d_i \\in D_i,i=1,2,…,n} $$ 以上面的 MAN 和 WOMEN 域为例，$MAN \\times WOMEN = {(王兵,丁梅),(王兵,吴芳),(李平,丁梅),(李平,吴芳)}$，一个笛卡尔积可以表示为一个二维表，如下 MAN WOMAN 王兵 丁梅 王兵 吴芳 李平 丁梅 李平 吴芳 元组：笛卡尔积中的每个元素叫做一个元组，也就是二维表中的一行。 关系：$D_1 \\times D_2 \\times … D_n$ 的子集叫做在域 $D_1,D_2,…,D_n$ 上的一个关系，可以表示为 $R(D_1,D_2,…,D_n)$，n 叫做关系的目/度。关系是关系模型最核心的概念，一个关系数据库就是一组关系的集合，而一个关系就是一张二维表（笛卡尔积所代表的二维表的一个子集），比如，我们假设王兵的妻子是丁梅，李平的妻子是吴芳，则取笛卡尔积的一个子集就可以构造出一个关系 FAMILY husband wife 王兵 丁梅 李平 吴芳 关系具有一些规定（性质） 关系中不能存在完全相同的两个元组 关系中元组行的序不重要 关系中列的序不重要 属性：关系的每一列都有一个自己的名字，称为属性。这一，上面的关系就可以表示为 $FAMILY = {husband,wife}$ 候选码：能够唯一标识一个元组的最小属性组叫做候选码，在上面的例子中，需要丈夫和妻子两个人的名字才能区分每一对夫妻，因此其候选码为 (husband,wife)，但在其它例子比如学生名单中，学生学号可以唯一标识学生，因此学号可以单独作为候选码。 主属性：候选码中的属性叫做主属性。 非码属性：不包含在任何候选码中的属性叫做非码属性。 关系模式：对关系进一步抽象，表示所有关系的一个通用方法就是关系模式，表达为 $R(U,D,dom,F)$，其中 R 为关系名，U 是组成该关系的属性名集合，D 是属性组 U 中属性来自的域，dom 是属性到域的映射集合，F 为属性间数据的依赖关系集合。通常我们会简写为 $R(U)$，所以才有了上面的 $FAMILY = {husband,wife}$ 这种表示。 ","date":"2020-09-11","objectID":"/2020/mysql-learning-supplement-relational-data-theory/:1:2","tags":["计算机基础"],"title":"Mysql学习补充-关系数据理论","uri":"/2020/mysql-learning-supplement-relational-data-theory/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 关系代数 一个数据模型，不仅包含表达数据的数据结构，还包含可对数据进行的操作。关系模型中，每个关系看作一个集合，对关系的操作可以就归纳为对集合的操作，这就是本节要介绍的关系代数。 关系代数的运算分为：传统的集合运算和专门的关系运算。 ","date":"2020-09-11","objectID":"/2020/mysql-learning-supplement-relational-data-theory/:2:0","tags":["计算机基础"],"title":"Mysql学习补充-关系数据理论","uri":"/2020/mysql-learning-supplement-relational-data-theory/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 集合运算 就是指求交集、并集和差集，要求运算的两个关系具有相同的目，且相应的属性取自同一个域。 还有一个特别的集合运算叫做广义笛卡尔积。假设两个关系 R 和 S 分别为 n 和 m 目，则其广义笛卡尔积是一个 n + m 列的元组的集合。若 R 有 k1 个元组，S 有 k2 个元组，则广义笛卡尔积有 $k1 × k2$ 个元组，记作 $R \\times S$。通常我们在描述时一般直接称为笛卡尔积运算。 假设 R 关系如下 A B C a1 b1 c1 a2 b2 c2 S 关系如下 D E d1 e1 d2 e2 d3 e3 则 $R \\times S$ 如下 A B C D E a1 b1 c1 d1 e1 a1 b1 c1 d2 e2 a1 b1 c1 d3 e3 a2 b2 c2 d1 e1 a2 b2 c2 d2 e2 a2 b2 c2 d3 e3 ","date":"2020-09-11","objectID":"/2020/mysql-learning-supplement-relational-data-theory/:2:1","tags":["计算机基础"],"title":"Mysql学习补充-关系数据理论","uri":"/2020/mysql-learning-supplement-relational-data-theory/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 关系运算 选择：选择运算是在关系 R 中选择满足给定条件的元组，记作 $\\sigma_F(R) = {t \\in R \\and F(t) = true}$，其中 $\\sigma$ 为选择运算符，$F$ 为选择条件 选择运算 $\\sigma_{A='a1’}(R)$ 的结果为 A B C a1 b1 c1 投影：投影运算是在关系 R 中选出若干属性列组成新的关系，记作 $\\pi_A(R) = {t[A]|t \\in R}$，其中 $\\pi$ 为投影运算符，$A$ 为选择的属性列名。需要注意的是，投影运算可能缩减元组个数，因为要去重。 投影运算 $\\pi_{A,B}(R)$ 的结果为 A B a1 b1 a2 b2 连接：连接运算是从两个关系的笛卡尔积中选取属性间满足一定条件的元组，称为θ连接，记作 $R \\bowtie S$，$\\bowtie$ 下面应该有个θ连接的表达式，比如 $A = B$，当θ为等号时称作等值连接。 连接运算可以理解为笛卡尔积和选择两个运算的结合，下面是一个等值连接的例子 当等值连接中等于号的两端是相同的属性组时，称为自然连接，上图同时也是一个自然连接，可以直接表示为 $R \\bowtie S$ 左连接：左连接的意思是左表的记录会全部显示出来，而右表只会显示符合搜索条件的记录，右表记录不足的填充 NULL。 右连接：与左连接相反，右表的记录全部显示出来，左表只会显示符合搜索条件的记录，左表记录不足的填充 NULL。 象集：给定一个关系 R(X,Y)，X和Y为属性组，当 t[X]=x时，x在R中的象集为：$Y_x={t[Y]|t \\in R, t[X]=x}$ 除：给定关系 R(X,Y) 和 S(Y,X)，其中 X,Y,Z 为属性组。R中的Y和S中的Y可以有不同的名字，但必须取自同一个域，R与S除得到一个新关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X分量值x的象集$Y_x$包含S在Y上投影的集合，记作：$R \\div S = {t_r[X]|t_r \\in R \\land \\pi_y(S) \\subseteq Y_x }$ ","date":"2020-09-11","objectID":"/2020/mysql-learning-supplement-relational-data-theory/:2:2","tags":["计算机基础"],"title":"Mysql学习补充-关系数据理论","uri":"/2020/mysql-learning-supplement-relational-data-theory/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 约束 数据的约束条件是一组完整性规则的集合，这些规则用来限定数据模型中的数据，使其符合某种特征，比如对学生年龄的限定，奖金必须低于基本工资等。 关系模型的完整性约束主要包括 实体完整性：主码中的属性不可取空值 参照完整性：关系中的某个属性列与另一个关系的主码对应 用户自定义完整性：类似于学生年龄取值这种符合现实特征的 ","date":"2020-09-11","objectID":"/2020/mysql-learning-supplement-relational-data-theory/:3:0","tags":["计算机基础"],"title":"Mysql学习补充-关系数据理论","uri":"/2020/mysql-learning-supplement-relational-data-theory/"},{"categories":["平日里的白日梦"],"content":"今天的周六电影时间看的是一部韩国电影《铁线虫入侵》。可能电影本身质量不是顶尖，但结合今年的疫情和带给我的感触，看完之后我还是给了它五星。一部电影，要么能带给人们快乐，要么能带给人们反思，对我而言，这部电影做到了第二点。下面就写一写我的感受。 ","date":"2020-09-05","objectID":"/2020/anti-epidemic-and-worm-invasion/:0:0","tags":["杂谈"],"title":"抗疫与铁线虫入侵","uri":"/2020/anti-epidemic-and-worm-invasion/"},{"categories":["平日里的白日梦"],"content":"1. 我对疫情还不够重视 我的家在山西的一个小县城，虽然它偏僻而落后，却恰恰因为这点，今年完全没有被疫情波及。从年初开始，我也着急买过口罩，谢绝了正月走亲戚，严格遵守社区的隔离措施和每日测温，每天跟着大家关心疫情发展，但一天、两天、一个月、两个月，警惕心就慢慢放了下来，或者说，我曾经以为的重视，其实根本没有真正重视过。看不见的敌人本就最难防备。 八月末离家返校的时候，我听着妈妈的叮嘱，却并没有放在心上，虽然戴了口罩，上了火车在找到自己的铺位后右立马脱了下来，毕竟有点闷热。火车上的广播一遍一遍地提醒着大家在车厢内也要戴好口罩，我抬眼看了看周围的人，很好，没有人戴，于是我也停下了拿口罩的手。上车、下车、出入车站，转乘出租，手总是不由自主地就放到了把手上、扶梯上、各种各样的物品上，然后在出入卫生间的时候匆匆地用清水洗一下手，也不用洗手液，也不遵循七步洗手法。回到学校后，出入食堂要戴口罩和测温，但是，很多人都没有遵守这个规则，戴不戴口罩完全随性而为。 我写这些不是指责什么，只是提醒自己，还不到放松的时候，今天看《铁线虫入侵》让我意识到了这一点。在这部电影里，所有的患者都要经历和喝水这种欲望的对抗，要经历铁线虫破体的痛苦，死后还要被带走全身营养，变得狰狞而恐怖。真的，如果你不亲眼看看这一幕，你永远无法真正重视，而恰恰，新冠并不会像电影中展示的那样带给人那么直观的感受，新冠病毒是我们肉眼看不见的，病人的痛苦我们也从未真正目睹，而对我而言，新冠甚至一直都离我很远，我身边的亲人、同学、朋友没有一例新冠感染者，这天然就降低了我的警惕，像我这样的人，在返校返工后，最容易放松。 那些死亡人数不只是冰冷的数字，还代表这一个个家庭的破碎，代表着他们的亲人会为此悲痛欲绝，说实话，只是在看到电影里那些患者亲属的镜头后，我才意识到这一点。 还不到放松的时候，我要提醒自己，出入依然要戴口罩，依然要仔细的吸收，依然要尽量减少接触，返校的同学来自五湖四海，食堂也要每天采购大量的食材，谨慎、再谨慎，是我现在唯一能做的。我们嘲笑着视频里国外民众的愚蠢，也许也应该好好想想现在的自己。 ","date":"2020-09-05","objectID":"/2020/anti-epidemic-and-worm-invasion/:1:0","tags":["杂谈"],"title":"抗疫与铁线虫入侵","uri":"/2020/anti-epidemic-and-worm-invasion/"},{"categories":["平日里的白日梦"],"content":"2. 国家做了很多 电影里韩国政府其实做了不少事，但还是没有控制住情况的发展，越来越多的人死去，但我还是看到了警察在努力控制事态，医护人员在尽力急救，所有人都在尽自己的力。而今年疫情，虽然最先爆发在武汉，但国家能迅速的将疫情控制在湖北，我都想不到后面做了多少的努力，我之前也敬佩医护人员，也觉得钟南山院士很厉害，但看了电影才能联想到，面对着会感染的风险奋战在一线的医护人员具有怎样的精神，国家领导人和钟南山院士这些医药业的领导者面临着怎样的压力。 凡事最怕对比，看着电影里的韩国政府，看着现在世界上疫情依然肆虐的国家，我们的祖国即使在很多方面还有不足，但它依然在尽力为我们创造一个更好的未来。 ","date":"2020-09-05","objectID":"/2020/anti-epidemic-and-worm-invasion/:2:0","tags":["杂谈"],"title":"抗疫与铁线虫入侵","uri":"/2020/anti-epidemic-and-worm-invasion/"},{"categories":["平日里的白日梦"],"content":"3. 疫情从来不是一国之事 电影的最后，海面上漂浮着一具感染者尸体，我在网上搜了搜，才找到了这一幕的含义。铁线虫虽然发生了变异，可以在哺乳动物体内寄生，但不能在海水中生存，这意味着韩国的铁线虫事件得到控制，其实就相当于被平息。但海水中的尸体说明铁线虫很可能再次发生了变异，变得适应海洋环境，这样就会导致世界范围内的爆发。 由此我想到了新冠，尽管国内疫情已经得到了控制，但其它国家，尤其是美国和印度，依然在大规模肆虐。新冠病毒是不以人类的意志为转移的，否则早就得到了控制，我们现在在网络上对其它国家极尽嘲讽，但有没有相关，这样蔓延下去，新冠可能再次变异，产生更严重的后果。人类的希望永远不应该寄托于可能性。 ","date":"2020-09-05","objectID":"/2020/anti-epidemic-and-worm-invasion/:3:0","tags":["杂谈"],"title":"抗疫与铁线虫入侵","uri":"/2020/anti-epidemic-and-worm-invasion/"},{"categories":["研究生的区块链学习之路"],"content":"起源于老师提出的一个问题：区块链是如何处理同时发起的多个请求的。想了想觉得核心是交易池机制，因此准备看一下交易池的原理和实现。 针对这个问题其实我们要找以下几个问题的答案： 用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的； 产生的交易如果不能被及时处理，是如何进入交易池的； 本地产生的交易和从网络中接收到的交易进入交易池是否有区别； 交易池的基本数据结构是怎么样的（优先队列？） 从交易池中提取交易进行打包时顺序是怎么样的（调度算法） 入手主要是通过登链社区的 以太坊交易流程及交易池 Txpool 分析 这篇文章，通过它快速找到了源码中的相关函数，因为主要使用的是 Quorum，所以看的是 Quorum 的源码。 注：网络中很多文章提到内存池，指的也是txpool ","date":"2020-09-04","objectID":"/2020/transaction-and-txpool/:0:0","tags":["区块链"],"title":"区块链学习7-交易池底层实现","uri":"/2020/transaction-and-txpool/"},{"categories":["研究生的区块链学习之路"],"content":"1. 交易形成 我们的交易请求最终会赋值到 SendTxArgs 结构体的一个实例中 type SendTxArgs struct { PrivateTxArgs // Quorum From common.Address `json:\"from\"` To *common.Address `json:\"to\"` Gas *hexutil.Uint64 `json:\"gas\"` GasPrice *hexutil.Big `json:\"gasPrice\"` Value *hexutil.Big `json:\"value\"` Nonce *hexutil.Uint64 `json:\"nonce\"` Data *hexutil.Bytes `json:\"data\"` Input *hexutil.Bytes `json:\"input\"` } 这个实例被传递给 quorum/internal/ethapi/api.go 的 SendTransaction 函数用来创建一个交易。创建交易的过程如下 根据 From 字段找到当前账户 设置交易默认参数 对交易进行序列化，变为可存储和传输的形式。 根据 To 字段决定是创建部署合约交易还是调用合约交易 对交易进行 RLP 编码并根据之前获得的账户密钥对交易进行签名 提交交易到交易池 序列化主要处理 SendTxArgs 结构中的 Data 和 Input 字段，Data 字段主要用于向前兼容，应尽量使用 Input 字段。当部署合约的时候，Input 是合约代码，当发送交易的时候，Input 是交易的内容。 ","date":"2020-09-04","objectID":"/2020/transaction-and-txpool/:1:0","tags":["区块链"],"title":"区块链学习7-交易池底层实现","uri":"/2020/transaction-and-txpool/"},{"categories":["研究生的区块链学习之路"],"content":"2. 交易添加到交易池 SendTransaction 最后调用 SubmitTransaction 函数将交易提交到交易池，不过，更底层的调用是 quourm/core/tx_pool.go 的 AddLocals 函数，这里还应该提到，来自网络的交易会调用 AddRemotes 函数。 需要注意的是，调用这两个函数之前都应该验证交易的有效性。同时，这两个函数底层都调用 addTxs 函数，最终的调用是 add 函数。不过在介绍 add 函数前先了解一下交易池的结构。 交易池是一个非常复杂的结构体，但最核心的字段只有两个 pending 和 queue type TxPool struct { pending map[common.Address]*txList // All currently processable transactions queue map[common.Address]*txList // Queued but non-processable transactions } add 函数比较复杂，但添加交易到交易池的逻辑很简单 验证交易的有效性 如果 nonce 已存在，且 pending 中旧交易的 price 没有新交易高，会被新交易替换掉 如果 nonce 不存在，不可以替换 pending 中的任何交易，此时将新的交易插入 queue 的末尾 注：交易中的 nonce 指的是 from 账户发出交易的次数, 从0开始递增，同一账户的交易会被依次确认，所以同一个 nonce 代表是同一个交易，会优先选择 price 更高的交易。 ","date":"2020-09-04","objectID":"/2020/transaction-and-txpool/:2:0","tags":["区块链"],"title":"区块链学习7-交易池底层实现","uri":"/2020/transaction-and-txpool/"},{"categories":["研究生的区块链学习之路"],"content":"3. 清理交易池 交易池是完全存在内存中的，因此有大小限制，每当超过一定的阈值就需要清理。实际实现时，pending 的缓冲区容量默认为 4096，queue 的缓冲区容量默认为 1024。 清理的时机是交易池满的时候，清理的原则是价格较低的最先清理 调用清理函数依然是在 add 函数中 ","date":"2020-09-04","objectID":"/2020/transaction-and-txpool/:3:0","tags":["区块链"],"title":"区块链学习7-交易池底层实现","uri":"/2020/transaction-and-txpool/"},{"categories":["研究生的区块链学习之路"],"content":"4. 重构交易池 作为一个分布式系统，总是会出现一种情况：本地节点已经挑选好最优的交易，并准备好广播给整个网络，结果这个时候矿工已经打包好了一个区块，这时候本地节点的区块头就是旧的了，筛选好的交易也已经可能被打包，此时再广播这些交易就没了意义。 为了避免上述情况的发生，本地节点要随时监听是否有新区块产生，当监听到新区块产生这个事件后，无论是本地节点领先，还是网络上其它节点领先，都回退一个区块号， 本地节点回退时，把撤销的交易保持到 discarded 切片中，网络上其他节点的撤销交易保存在 included 切片中。 当区块号一致的时候，还需要进一步的比较区块的 Hash 来进一步确认区块里面的交易是否一致，如果不一致一致回退到区块 Hash 为止，回退撤销的交易依旧保存在 discarded 和 included 切片中。 等完全确认本地和网络的链没有分叉的时候，就需要比较 discarded 和 included 里面的交易，因为网络上区块的生成优先级高于本地，所以需要剔除 discarded 中 inclueded 的交易，生成 reinject 切片，剔除完以后还需要对 TXpool 按照网络新生成区块的信息设置世界状态等信息，设置完以后，重新将 reinject 加入 TXpool，加入以后在进行验证清理等流程。 ","date":"2020-09-04","objectID":"/2020/transaction-and-txpool/:4:0","tags":["区块链"],"title":"区块链学习7-交易池底层实现","uri":"/2020/transaction-and-txpool/"},{"categories":["研究生的区块链学习之路"],"content":"5. 问题回答 回答文章开头提出的几个问题 用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的； 所有与交易请求相关的参数被赋值到一个结构体中，然后进行序列化转变为可存储和传输的形式，最后生成交易并进行签名 产生的交易如果不能被及时处理，是如何进入交易池的 最终是调用一个 add 函数，添加到了一个队列里 本地产生的交易和从网络中接收到的交易进入交易池是否有区别； 没有区别，底层都是调用 add 函数 交易池的基本数据结构是怎么样的（优先队列？） 交易池是一个结构体，核心是 pending 和 queue 两个 map，map 的键是一个地址，值是一个交易链表形成的队列 从交易池中提取交易进行打包时顺序是怎么样的（调度算法） price 越高优先级越大 我们可以理解为区块链底层利用交易池对并发产生的请求做了异步化，交易产生的时刻和交易被打包的时刻是随机的。 这里面我们可以视作有一个排队论的问题，相关度比较高的论文有两篇 [1] J. Li, Y. Yuan, S. Wang and F. Wang, “Transaction Queuing Game in Bitcoin BlockChain,” 2018 IEEE Intelligent Vehicles Symposium (IV), Changshu, 2018, pp. 114-119, doi: 10.1109/IVS.2018.8500403. [2] Memon RA, Li JP, Ahmed J. Simulation Model for Blockchain Systems Using Queuing Theory. Electronics. 2019; 8(2):234. 后注1：在实现 TXpool 的时候为了保证数据的一致性会使用大量的锁 后注2：总结以下可以发现交易池中交易的顺序与以下几方面有关 交易费 交易哈希（重构交易池时区块相同会进行比较） 在交易池中的时间（时间过长可能会被清除） ","date":"2020-09-04","objectID":"/2020/transaction-and-txpool/:5:0","tags":["区块链"],"title":"区块链学习7-交易池底层实现","uri":"/2020/transaction-and-txpool/"},{"categories":["研究生的区块链学习之路"],"content":"6. 时间 更全面的描述可以参考 以太坊技术与实现：交易池 我们关心发起交易的时间和智能合约执行并返回结果的时间是否有区别 ","date":"2020-09-04","objectID":"/2020/transaction-and-txpool/:6:0","tags":["区块链"],"title":"区块链学习7-交易池底层实现","uri":"/2020/transaction-and-txpool/"},{"categories":["爱编程爱技术的孩子"],"content":"目前主流的操作系统就是 Windows、Linux 和 macOS，有时候我们也常听到 Unix。今天查一下资料看一看它们的区别。 详细的历史演进可以阅读脚本之家的 操作系统Unix、Windows、Mac OS、Linux的故事 这篇文章。 基本的关系可以看下图 Unix 可以算作操作系统的鼻祖，macOS 是 FreeBSD 的衍生，Linux 是 AT\u0026T System V 的衍生，Windows 和 Unix 没有什么关系，是另外一个派系，只是借鉴了一些特性。 类 Unix 系统是指继承 UNIX 的设计风格演变出来的系统，都相当程度地继承了原始 UNIX 的特性，并且都在一定程度上遵守POSIX规范，但是它们却并不含有UNIX的源代码，因为 UNIX 的源代码为 SCO公司所有，属于商业软件。 由于 UNIX 标准认定价格昂贵，目前只有苹果的 MacOS 获得了认定，可以称作 Unix 系统，Linux 只能称作类 Unix 操作系统。 ","date":"2020-09-02","objectID":"/2020/windows-linux-unix-and-macos/:0:0","tags":["计算机基础"],"title":"Windows、Linux、Unix和 macOS","uri":"/2020/windows-linux-unix-and-macos/"},{"categories":["爱编程爱技术的孩子"],"content":"正则表达式在字符串处理时使用的非常普遍，这次来学习正则的相关知识，分别结束通配符、正则及它们的区别。 ","date":"2020-09-02","objectID":"/2020/regular-expression-basic-syntax/:0:0","tags":["linux"],"title":"正则表达式与通配符","uri":"/2020/regular-expression-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 通配符 首先明确场景，通配符和正则表达式都是做匹配的，匹配常见的场景有 Office 系列，尤其是 Word 中的查找和替换； 常用的文本编辑器中的查找和替换，比如 Win10 下的记事本、VSCode、Typora 等 Win10 或 Linux 命令行输入各种命令时使用 编程时进行字符串匹配使用 Office 系列的查找和替换默认都是正则表达式，但可以在选项中勾选使用通配符，而且 Office 系列的通配符很简单，只有三种：问号（？）、星号（*）、波形符（~）。 使用问号（？）查找任何单个字符，例如 s?t 找到 “sat” 和 “set”。 使用星号（*）查找任意数量的字符，例如 s*d 可以找到 “sad”。 使用波形符（~），后跟？、* 或 ~ 查找问号、星号或其他波形符，其实就是用来转义。 常见的文本编辑器在尝试后发现基本都只能使用全字匹配，VSCode 可以勾选使用正则表达式。 命令输入是典型的通配符使用场景，比较出名的是 Linux 下的 glob，用来匹配文件路径名。glob 的语法也很简单 ？ 匹配任意单个字符 * 匹配任意字符串，包括空串 […] 匹配方括号中任意一个字符，比如[abc]匹配字符a, b, c中任意一个，方括号中不可为空。同时，可以使用 - 放在方括号中表示范围，使用! 放在方括号中表示非 基本上 glob 通配符可以算作正则的简化。 ","date":"2020-09-02","objectID":"/2020/regular-expression-basic-syntax/:1:0","tags":["linux"],"title":"正则表达式与通配符","uri":"/2020/regular-expression-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 正则表达式 正则的目的是字符串模式匹配，实现查找与替换，正则的基本原理是有限状态自动机。 一个正则表达式的基本组成元素包括字符和元字符 字符就是普通的计算机字符，比如字母、数字等 元字符是某类有特定含义的字符，比如 ^ 和 * 等 ","date":"2020-09-02","objectID":"/2020/regular-expression-basic-syntax/:2:0","tags":["linux"],"title":"正则表达式与通配符","uri":"/2020/regular-expression-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 字符 单个的字符比如字母、数字等，是它们原本的含义。 一些功能字符无法直接表示，比如换行、回车等，需要在普通字符前面加上转义元字符 \\ 来表示，比如 字符 字符描述 \\n 换行符 \\f 换页符 \\r 回车符 \\t 制表符 \\v 垂直制表符 [\\b] 回退符，之所以使用[]符号是避免和\\b重复 还有一部分是正则表达式特殊的规定，在普通字符前面使用转移字符表达特定含义，如下表 字符 描述 \\w 任意一个字母或数字或下划线 \\W 任意一个字母或数字或下划线以外的字符 \\s 空白字符，比如空格、tab、换行、换页 \\S 非空白字符 \\d 数字字符，0~9 \\D 非数字字符 \\b 单词边界 \\B 非单词边界 这里解释一下单词边界的含义，一般情况，单词指的是字母、数字、下划线构成的字符串，边界指的是一个具体的位置，而不是一个字符，比如对于字符串 example:a+b=3，用 | 表示位置，如下所示 |e|x|a|m|p|l|e|:|a|+|b|=|3| 单词边界指的就是下面几个位置 |example|:|a|+|b|=|3| 非单词边界就更好理解了，不是单词边界的就是非单词边界 e|x|a|m|p|l|e:a+b=3 ","date":"2020-09-02","objectID":"/2020/regular-expression-basic-syntax/:2:1","tags":["linux"],"title":"正则表达式与通配符","uri":"/2020/regular-expression-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 元字符 元字符是具有特定语义的字符，比如上面的转义字符 \\ 就是一个元字符，用于改变普通字符的含义。正则表达式中定义的常用元字符包括 元字符 描述 . 匹配除了换行符外的任意一个字符 ？ 匹配同一个字符出现 0 次或 1 次 + 匹配同一个字符出现 1 次或多次 * 匹配同一个字符出现 0 次或 1 次或多次 量词 ?, +, *三个元字符我们通常称作量词，因为它们的作用是表示某个字符出现了多少次，除此之外，还可以声明更具体的出现次数 {n} 表示字符出现 n 次，比如a{2}，匹配aa {m,n} 表示字符出现最少 m 次，最多 n 次，比如a{1,3}，可以匹配aaa、aa、a {m,} 表示字符出现 m-∞次，优先匹配∞次，比如a{1,}，可以匹配 aaaa… 注意正则默认是贪婪的，凡是表示范围的量词，都优先匹配上限而不是下限。比如 a{1, 3} // 匹配字符串'aaa'的话，会匹配aaa而不是a 取消贪婪模式可以在量词后加 ？ a{1, 3}? // 匹配字符串'aaa'的话，会匹配a而不是aaa 边界 边界的匹配是一个很重要的需求，主要包括三种 使用 ^ 匹配开头，比如 ^abc 表示以 abc 为开头的字符串 使用 $ 匹配结尾，比如 abc$ 表示以 abc 为结尾的字符串 使用 \\b 匹配单词边界，比如我们想搜索单词 cat，结果 scattered 也会被搜索到，这时候就可以使用 \\b 表示单词边界，使用方法为 \\bcat\\b 集合 很多时候我们还需要匹配一个字符集合，比如，匹配 a,b,c 这三个字符中的任意一个，这种需求通过一对方括号实现 [abc] 使用连字符可以表示一个范围 [0-9] // 等于[0123456789] 使用 ^ 可以表示除了方括号中的字符以外的其它字符 [^abc] // 表示除了 a,b,c 以外的其它字符 字符串的选择通过 | 来表达，实际上就是或的概念，比如 123|456 // 表示匹配 123 或者匹配456 修饰符 在正则表达式的末尾添加修饰符可以更改某些正则默认的规则 i ，正则默认区分大小写，i 可以忽略大小写 g，正则遇到第一个匹配的字符串就会结束，g 可以匹配所有符合条件的字符串 m，正则默认遇到换行结束，不匹配多行文本，m 可以匹配多行文本 举一个多行匹配的例子，在下面的文本中匹配 I am scq000 这个句子，使用的正则表达式为 /^I am scq000\\.$/m I am scq000. I am scq000. I am scq000. ","date":"2020-09-02","objectID":"/2020/regular-expression-basic-syntax/:2:2","tags":["linux"],"title":"正则表达式与通配符","uri":"/2020/regular-expression-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 子表达式 利用上面的语法可以构成基本的正则表达式，通过对基本正则表达式的组合，可以推导出无限复杂的正则表达式，使用的基本思想是嵌套递归和自身引用，涉及的概念包括分组、回溯引用、预搜索。 分组 就是利用成对的小括号 () 将一个正则表达式包围，包围以后就表示这是一个子表达式，子表达式是构成复杂正则表达式的基本单位。 一个简单的分组使用如下 (abc){2} // 匹配abcabc 回溯引用 回溯引用指的是整个正则表达式后面的部分引用前面子表达式匹配到的字符串，类似于将前面的子表达式看作了一个变量。基本结构如下 (子表达式1)(子表达式2)(子表达式3)\\1\\2\\3 \\1代表第一个子表达式、\\2代表第二个子表达式、\\3代表第三个子表达式。以此类推，\\0 一般表示整个表达式。 注：有些语言（比如JS）使用 $ 而不是 \\ 比如要在一段文本里匹配两个连续相同的单词，用简单的正则只能保证两个单词符号相同的规则，但不能保证它们相同 Hello what what is the first thing, and I am am scq000. 使用回溯就可以很容易的获得结果： \\b(\\w+)\\s\\1\\b，后面的 \\1 会再一次匹配前面的字符串本身。 如果某个子表达式不想被引用，可以使用 (?:regex)这样的表达方式，比如 \\b(?=\\w+)\\s\\1\\b 这样的表达式就无法匹配到之前获得的结果了 预搜索 预搜索是为了应对四种情况 要求字符串前面必须是另一个字符串，比如要求 ple 前面必须是 ap，正则表达式为 (?\u003c=ap)ple 要求字符串前面不能是另一个字符串，比如要求 ple 前面不能是 ap，正则表达式为 (?\u003c!ap)ple // 可能匹配到 people 要求字符串后面必须是另外一个字符串，比如要求 happ 后面必须是 ily，正则表达式如下 happ(?=ily) 要求字符串后面不能是另外一个字符，使用 ! 表示非的含义即可 happ(?!ily) // 表示happy 不能是 ily，可能匹配到 happy 还有一些正则可能用到的工具 Regulex：用有限状态自动机可视化正则表达式 OKTools：在线正则表达式测试 ","date":"2020-09-02","objectID":"/2020/regular-expression-basic-syntax/:2:3","tags":["linux"],"title":"正则表达式与通配符","uri":"/2020/regular-expression-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 区别 通配符和正则表达式的区别比较明显， 通配符语法比正则表达式简单很多 通配符一般用于文件路径名匹配，正则表达式一般用于字符串匹配 所以在命令行中，与路径相关的命令，比如 cp, ls, find 等，都使用通配符；而与字符串匹配相关的命令，比如 grep，使用正则表达式。 Office 或者编程基本上是对字符串的匹配，因此一般使用正则表达式。 ","date":"2020-09-02","objectID":"/2020/regular-expression-basic-syntax/:3:0","tags":["linux"],"title":"正则表达式与通配符","uri":"/2020/regular-expression-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"参考 [1] Office 支持，在搜索中使用通配符 [2] 掘金，正则表达式不要背 [3] 知乎，正则表达式教程-语法篇 [4] CSDN，通配符和正则表达式的区别 ","date":"2020-09-02","objectID":"/2020/regular-expression-basic-syntax/:4:0","tags":["linux"],"title":"正则表达式与通配符","uri":"/2020/regular-expression-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"做 Leetcode 每日一题的时候遇到了子串判断类的问题，想起一直没仔细的去看过 KMP 等字符串常用的算法，所以这里学习一下。 ","date":"2020-08-24","objectID":"/2020/algorithm-stings/:0:0","tags":["数据结构与算法"],"title":"算法-字符串类问题","uri":"/2020/algorithm-stings/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 重复的子字符串 这就是今天遇到的题目，题目描述为 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1: 输入: \"abab\" 输出: True 解释: 可由子字符串 \"ab\" 重复两次构成。 示例 2: 输入: \"aba\" 输出: False 示例 3: 输入: \"abcabcabcabc\" 输出: True 解释: 可由子字符串 \"abc\" 重复四次构成。 (或者子字符串 \"abcabc\" 重复两次构成。) 首先确认边界条件 字符串长度满足：0 \u003c len(s) \u003c= 10000，所以不需要考虑空字符串 字符串的子串不包括自己，也就是说，「一个字符串由自己重复 1 次构成」这种说法不成立，可由示例2得出 然后确认基本思路 遍历所有可能的子串长度，从 1 到 len(s)/2，然后判断这个长度的子串是否可能为结果。取 len(s)/2 是因为超过字符串长度一半的子串不可能通过重复构成原字符串； 字符串的长度一定是子串长度的倍数，否则也不可能是结果； 考虑如何取给定长度的子串，由于字符串由子串重复构成，那么只需要从第一个字符开始取即可，长度为 n 的子串就从第一个字符开始取 n 个字符构成子串； 最后根据该思路编写代码 func repeatedSubstringPattern(s string) bool { // 字符串长度可能是1到len(s)/2 for i := 1; i \u003c= len(s)/2; i++ { // 只有 len(s) 是子字符串长度的倍数才有可能 if len(s) % i != 0 { continue } // 子串为 s[:i]，然后对字符串的其它部分进行判断 var flag bool for j := i; j \u003c len(s); j += i { if s[j:j+i] != s[:i] { flag = true break } } // 中途没有跳出才说明整个字符串由子串重复构成 if !flag { return true } } // 所有长度的子串都无法重复构成原字符串 return false } 代码编写完成后要考虑最后一件事，就是条件和循环的边界条件，这是最容易产生错误的地方 i \u003c= len(s)/2：当 i == len(s)/2 的时候，子串为 s[:len(s)/2]，以字符串 abab 为例，子串为 ab，因为 Go 的切片不会取最后一个字符，所以必须添加 = 号，不然会漏掉一种情况； j \u003c len(s)：我们考虑最后一次循环的 j，此时 s[j:j+i] 中 j+i 可能会越界超出 len(s)，导致 panic。遇到这种情况我们最常用的做法是修改条件为 j + i \u003c len(s)，然后我们来考虑边界条件。 当 j + i == len(s) 的时候， s[j:j+i] 其实原本想表达的含义是最后一个字符串，是应该取的，但是 j + i 产生越界，所以要额外处理。 修改后的程序如下 func repeatedSubstringPattern(s string) bool { // 字符串长度可能是1到len(s)/2 for i := 1; i \u003c= len(s)/2; i++ { // 只有 len(s) 是子字符串长度的倍数才有可能 if len(s) % i != 0 { continue } // 子串为 s[:i]，然后对字符串的其它部分进行判断 var flag bool for j := i; j + i \u003c= len(s); j += i { var tmp string if j + i == len(s) { tmp = s[j:] }else{ tmp = s[j:j+i] } if tmp != s[:i] { flag = true break } } // 中途没有跳出才说明整个字符串由子串重复构成 if !flag { return true } } // 所有长度的子串都无法重复构成原字符串 return false } ","date":"2020-08-24","objectID":"/2020/algorithm-stings/:1:0","tags":["数据结构与算法"],"title":"算法-字符串类问题","uri":"/2020/algorithm-stings/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 模式匹配BF算法 上面的问题可以使用 KMP 算法解决，但解释 KMP 算法之前必须先了解 BF 算法。 模式匹配问题为：假设有两个字符串 S 和 T，设 S 为主串，判断 T 是否为 S 的子串，如果是，返回子串在主串中第一个出现的位置，如果不是，返回 -1。 示例 1: 输入: haystack = \"hello\", needle = \"ll\" 输出: 2 示例 2: 输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1 最笨的办法，也就是暴力法，是穷举 S 所有的子串，判断是否和 T 相同，该算法就称为 BF（Brute Force）算法。为了介绍通用的算法，这里放弃 Go 切片的优势，采用逐个字符匹配的方式。代码如下 func strStr(haystack string, needle string) int { // 子串为空，返回0 if len(needle) == 0 { return 0 } // = 号是考虑子串等于主串的情况 for i := 0; i + len(needle) \u003c= len(haystack); i++ { var flag bool for j := 0; j \u003c len(needle); j++ { if haystack[i+j] != needle[j] { flag = true break } } if !flag { return i } } return -1 } ","date":"2020-08-24","objectID":"/2020/algorithm-stings/:2:0","tags":["数据结构与算法"],"title":"算法-字符串类问题","uri":"/2020/algorithm-stings/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 模式匹配KMP算法 实际上，没有必要从主串 S 的每一个字符开始穷举每种情况。Knuth、Morris、Pratt 对该算法进行了改进，提出了 KMP 算法。 设 S = abaabaabeca，T = abaabe，KMP 的流程如下 从S第1个字符开始：i=1, j=1，比较两个字符是否相等，如果相等，则 i++, j++；等到第一次匹配不相等的时候，BF算法会继续从 S 第 2个字符开始和 T 第一个字符进行比较，但 BMP 的做法是：S 的索引不需要移动，T 的索引回退 3 个，如下图 这样做的原因是 T 串中 j 索引前面的两个字符和 S 串中 i 索引前面的两个字符相同，都是 ab，所以现在的关键变成了我们怎么知道 i 前面的字符和 j 前面的字符相同，有几个字符相同（这决定了 j 回退几个位置） 直观的想法是进行第二次的比较，比较 T 开头的字符和 i 前面的字符，但其实不需要，因为在 j 回退之前，i 前面的字符必然和 j 前面的字符相同，如下 所以问题转化成了 T 内部字符的比较，假设 T 中当前 j 指向的前面的所有字符为 $T'$，上图中 $T’ = abaab$，那么只需要比较 $T'$ 的前缀和后缀即可。判断其前缀后缀是否相等，并寻找相等前缀后缀的最大长度。 长度为1：前缀 a，后缀 b，不相等 长度为2：前缀 ab，后缀 ab，相等 长度为3：前缀 aba，后缀 aab，不相等 长度为4：前缀 abaa，后缀 baab，不相等 相等前缀后缀的最大长度为 2，则 j 可以回到 2+1=3 个位置继续比较。如果将这个回退的位置表示为 next[j]，令 $T’ = t_1t_2…t_{j-1}$，则可得公式 由于字符串 T 的长度有限，next[] 其实是一个固定的数组 j 1 2 3 4 5 6 T a b a a b e next[j] 0 1 1 2 2 3 假设 next[j] = k，$T’ = t_1t_2…t_{j-1}$，那么 T 的相等前缀、后缀最大长度为 k-1 我们在求 next[j+1] 的时候可以考虑动态规划递推的办法 $t_k = t_j$：那么 next[j+1] = k+1，即相等前缀和后缀的长度比 next[j] 多1，如下图 $t_k \\neq t_j$：那么回退找 next[k] = k’ 的位置，比较 $t_{k’}$ 和 $t_j$ 是否相等 如果相等，则 next[j+1] = k’’ + 1，如果不相等，继续向前找，直到找到 next[i] = 0 停止 求解 next 的代码实现如下 func getNext(T string, next []int) { j,k := 1,0 next[1] = 0 for j \u003c len(T) { if k == 0 || T[j] == T[k] { j,k = j+1,k+1 next[j] = k }else{ k = next[k] } } } KMP 算法的代码如下 func KMP(S,T string, pos int, next []int) int { i,j := pos, 1 for i \u003c= len(S) \u0026\u0026 j \u003c= len(T) { if j == 0 || S[i] == T[j] { i++ j++ }else{ j = next[j] } } if j \u003e len(T) { return i-len(T) }else{ return 0 } } ","date":"2020-08-24","objectID":"/2020/algorithm-stings/:3:0","tags":["数据结构与算法"],"title":"算法-字符串类问题","uri":"/2020/algorithm-stings/"},{"categories":["爱编程爱技术的孩子"],"content":"很多时候都要求能使用 Shell 脚本进行编程，本文是根据阮一峰大神的 系列教程 总结的基本知识。 ","date":"2020-08-21","objectID":"/2020/bash-script-grammer-2/:0:0","tags":["linux"],"title":"Bash脚本语法2","uri":"/2020/bash-script-grammer-2/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 条件判断","date":"2020-08-21","objectID":"/2020/bash-script-grammer-2/:1:0","tags":["linux"],"title":"Bash脚本语法2","uri":"/2020/bash-script-grammer-2/"},{"categories":["爱编程爱技术的孩子"],"content":"理解不同的 HTTP 方法的区别，主要参考 RFC 7231 ","date":"2020-08-20","objectID":"/2020/http-method/:0:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 方法的特性 首先是方法的三个属性：安全性、幂等性和可缓存。 ","date":"2020-08-20","objectID":"/2020/http-method/:1:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 安全性 安全性，safe，指的是该方法在语义上是只读的，不会修改服务器的数据。但即使是安全的方法，服务器也可以更改自己的数据，比如记录此次请求的日志。安不安全仅意味着客户端不需要服务端修改数据，因此不用考虑会对服务端造成危害。 安全的方法也不一定知识对服务端静态资源的请求，服务端可以在请求的时候返回即时生成的资源，只要生成资源的脚本保证是安全的即可：也就是说生成资源的时候没有额外影响。就像在一个电商网站添加删除购物车里的物品一样。 安全的方法有 GET，HEAD，OPTIONS，TRACE。 ","date":"2020-08-20","objectID":"/2020/http-method/:1:1","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 幂等性 幂等性，Idempotent，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说，幂等方法不应该具有副作用。 PUT、DELETE 是幂等的，所有安全的方法都是幂等的 幂等只与后端服务器的实际状态有关，比如，DELETE 删除资源后，第二次调用不应当删除另一个资源，否则服务器的状态将不一致，第一次调用会返回 200，但后续的调用就会返回 404。POST 则不一样，连续调用多次，会增加多个相同的资源。 ","date":"2020-08-20","objectID":"/2020/http-method/:1:2","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 可缓存 可缓存，Cacheable，指的是可以存储对这些方法的响应以便将来重用。GET、HEAD、POST 方法是可缓存的，不过一般只实现前两个。 ","date":"2020-08-20","objectID":"/2020/http-method/:1:3","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"2. GET GET 方法用于请求指定的资源，并且只用于获取数据。 使用 GET 方法时请求报文没有实体部分，但成功的响应有实体部分。 GET 方法是安全的、幂等的、可缓存的。浏览器会主动缓存 GET 方法的响应，如果下一次传输的数据相同，就返回缓存中的内容，以求更快的展示。 GET 方法请求的数据一般附在 URL 之后，以 ？分割 URL 和传输数据，多个参数以 \u0026 连接。由于 URL 一般有长度限制，所以即使 HTTP 并未规定 GET 请求的长度，但实际上受 URL 的长度限制。 ","date":"2020-08-20","objectID":"/2020/http-method/:2:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"3. HEAD HEAD 方法请求资源的头部信息，该头部信息与 GET 方法请求返回时的一致。常见的使用场景是在下载一个大文件前先获取其大小再决定是否下载，以此节约带宽资源。 如果 HEAD 请求的结果显示上一次 GET 请求后缓存的资源已过期，那么即使没有再次发出 GET 请求，该缓存也会失效。 HEAD 方法是安全的、幂等的、可缓存的。 ","date":"2020-08-20","objectID":"/2020/http-method/:3:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"4. POST POST 方法发送数据给服务器，因此请求和响应报文都有实体部分，请求报文实体的类型由 Content-Type 首部指定。 POST 请求通常通过表单来发送，此时 content-type 类型是通过在 \u003cform\u003e 元素中设置正确的 enctype 属性, 或是在 \u003cinput\u003e 和 \u003cbutton\u003e 元素中设置 formenctype 属性来选择的 application/x-www-form-urlencoded multipart/form-data text/plain 如果 POST 请求不是通过表单发送，那么实体部分可以是任意类型。 POST 方法不符合安全性和幂等性，但却可以是可缓存的。 由于 POST 方法将提交的数据放在报文的实体部分，因此没有长度的限制。 GET 与 POST 的区别很多都是由于 GET 拼接 URL，POST 传实体部分造成的，包括 收藏书签：GET可以，POST不可以，因为 URL 可收藏 保留浏览器历史记录：GET可以，POST不可以，因为 URL 可记录 安全性：GET 稍低，因为 URL 直接可见，可能被劫持 ","date":"2020-08-20","objectID":"/2020/http-method/:4:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"5. PUT PUT 方法使用请求报文中的实体部分创建或替换目标资源。它的请求报文有实体部分，但响应报文没有。 PUT 和 POST 的区别在于 PUT 是幂等的，即调用一次与连续调用多次是等价的。举个例子，对于订单提交，多次调用 POST 方法会重复产生多个订单，PUT 方法不会，而是会覆盖掉前一个订单。 使用 PUT 方法时，如果目标资源不存在，则服务器创建一份，并返回 201（Created），通知客户端已创建。如果目标资源已存在，则进行更新，服务器返回 200（OK）或者 204（No Content）表示请求处理成功。 ","date":"2020-08-20","objectID":"/2020/http-method/:5:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"6. DELETE DELETE 方法用于删除指定的资源，它是幂等的，第一次调用会返回指定资源，第二次会返回 404（Not Found），不会删除另一个资源。 ","date":"2020-08-20","objectID":"/2020/http-method/:6:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"7. CONNECT CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。 例如，CONNECT 可以用来访问采用了 HTTPS 协议的站点。客户端要求代理服务器将 TCP 连接作为通往目的主机隧道。之后该服务器会代替客户端与目的主机建立连接。连接建立好之后，代理服务器会面向客户端发送或接收 TCP 消息流。 ","date":"2020-08-20","objectID":"/2020/http-method/:7:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"8. OPTIONS OPTIONS 方法用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。 比如，检测服务器所支持的请求方法 curl -X OPTIONS http://example.org -i 响应报文首部的 Allow 字段值汇报课该服务器支持的所有 HTTP 方法 HTTP/1.1 200 OK Allow: OPTIONS, GET, HEAD, POST Cache-Control: max-age=604800 Date: Thu, 13 Oct 2016 11:45:00 GMT Expires: Thu, 20 Oct 2016 11:45:00 GMT Server: EOS (lax004/2813) x-ec-custom-error: 1 Content-Length: 0 ","date":"2020-08-20","objectID":"/2020/http-method/:8:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"9 .TRACE TRACE 方法使请求的接收者原样返回它收到的消息，一般用于测试或诊断 ","date":"2020-08-20","objectID":"/2020/http-method/:9:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"10. PATCH PATCH 用于资源的部分修改，不同于 PUT，它是非幂等的，连续多个相同请求会产生不同的效果。 要判断一台服务器是否支持 PATCH 方法，那么就看它是否将其添加到了响应首部 Allow或者 Access-Control-Allow-Methods（在跨域访问的场合，CORS）的方法列表中 。 ","date":"2020-08-20","objectID":"/2020/http-method/:10:0","tags":["计算机基础"],"title":"计算机网络-HTTP方法","uri":"/2020/http-method/"},{"categories":["爱编程爱技术的孩子"],"content":"很多时候都要求能使用 Shell 脚本进行编程，本文是根据阮一峰大神的 系列教程 总结的基本知识。 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:0:0","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"1. Shell 和 Bash Shell 是一个程序，为用户提供和内核的交互界面，一般由用户从键盘输入命令，然后送给操作系统指向，执行完毕将结果返回给用户，因此又称为命令行环境。 只要能给用户提供命令行界面用于和内核交互，就叫 Shell，因此 Shell 有很多种，比如 Bourne Shell（sh） Bourne Again shell（bash） C Shell（csh） Bash 是目前最常用的 Shell，一般也是默认的 Shell。 具有图形界面的 Linux 打开的命令行一般是终端模拟器，顾名思义，就是模拟命令行环境的，不是真正的命令行，但使用和直接使用非图形界面的命令行没有区别。因此我们随后不区分终端和命令行，全部使用命令行这个称呼。 图形界面下使用 Ctrl + Alt + T 打开命令行，默认位于用户主目录 ~，提示符为美元符号 $，输入 exit 命令或使用快捷键 Ctrl + D 退出当前命令行。 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:1:0","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 预备知识 使用 echo 命令可以在屏幕上输入文本，添加引号可以输出多行文本，添加 -e 参数会解释引号中的特殊字符。该命令经常使用。 $ echo hello world hello world $ echo \"hello world\" hello world $ echo -e \"hello\\nworld\" hello world Bash 单个命令一般都是一行，按下回车开始执行，比较长的命令可以写成多行，只需要在每一行的末尾加上反斜杠即可 $ echo foo \\ bar foo bar \u0026\u0026 和 || 用于连接两个命令，前者的含义是如果第一个命令执行成功，执行第二个命令；后者的含义是如果第一个命令执行失败，执行第二个命令，第一个命令执行成功就不会执行第二个命令了。 $ mkdir foo \u0026\u0026 ls foo $ mkdir foo || mkdir bar mkdir: 无法创建目录 “foo”: 文件已存在 $ ls foo bar Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。 还有一些实用的快捷键 Ctrl + L：清除屏幕并将当前行移到页面顶部。 Ctrl + C：中止当前正在执行的命令。 Shift + PageUp：向上滚动。 Shift + PageDown：向下滚动。 Ctrl + U：从光标位置删除到行首。 Ctrl + K：从光标位置删除到行尾。 ↑，↓：浏览已执行命令的历史记录。 Tab：补全未完全输入的命令或路径 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:2:0","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 模式扩展 用户输入的命令中有时包括一些特殊的字符，Shell 会先对这些字符进行替换，然后才开始执行，这个过程叫做模式扩展。Shell 提供 8 种模式扩展。 ~：用户主目录 ?：单个字符，但不包括空字符 *：任意数量的任意字符，包括 0 个 [...]：匹配方括号中出现的任意字符，如果前面加了 ^ 或 ! 表示匹配方括号中没有出现的字符 # 只存在文件 a.txt $ ls [ab].txt a.txt # 存在 aaa、bbb、aba 三个文件 $ ls ?[!a]? aba bbb [start-end]：匹配一个连续的范围，同样，实用 ! 可以匹配不属于该范围的字符 # 存在文件 a.txt、b.txt 和 c.txt $ ls [a-c].txt a.txt b.txt c.txt {...}：匹配大括号中的所有字符 $ echo d{a,e,i,u,o}g dag deg dig dug dog {start...end}：扩展成一个连续序列 $ echo {1..4} 1 2 3 4 $：将 $ 开头的变量替换为变量的值 $ echo $SHELL /bin/bash $(...)：扩展成另一个命令的运行结果，该命令所有输出都作为返回值 $ echo $(date) Tue Jan 28 00:01:13 CST 2020 $((...))：扩展成整数运算的结果 $ echo $((2 + 2)) 4 模式扩展先于正则表达式出现，可以看作原始的正则表达式，但没有正则表达式灵活。 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:3:0","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 变量 用env命令显示所有环境变量，echo命令查看单个环境变量的值 $ env $ echo $PATH BASH 的变量名区分大小写，由于环境变量一般使用全大写，用户自定义变量一般也使用全大写。 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:4:0","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 创建变量 变量声明语法如下，等号两边不可有空格 variable=value 如果变量的值中有空格，使用引号包围 myvar=\"hello world\" BASH 没有数据类型的概念，所有变量都是字符串。 下面是一些自定义变量的例子。 a=z # 变量 a 赋值为字符串 z b=\"a string\" # 变量值包含空格，就必须放在引号里面 c=\"a string and $b\" # 变量值可以引用其他变量的值 d=\"\\t\\ta string\\n\" # 变量值可以使用转义字符，echo 输出要加 -e 参数 e=$(ls -l foo.txt) # 变量值可以是命令的执行结果 f=$((5 * 7)) # 变量值可以是数学运算的结果 变量可以重复赋值，后面的赋值会覆盖前面的赋值。 $ foo=1 $ foo=2 $ echo $foo 2 上面例子中，变量foo的第二次赋值会覆盖第一次赋值。 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:4:1","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 读取变量 读取变量的时候，直接在变量名前加上$就可以了。 $ foo=bar $ echo $foo bar 如果变量不存在，Bash 不会报错，而会输出空字符。 读取变量的时候，变量名也可以使用花括号{}包围，比如$a也可以写成${a}。这种写法可以用于变量名与其他字符连用的情况。 $ a=foo $ echo $a_file $ echo ${a}_file foo_file ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:4:2","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"4.3 删除变量 unset命令用来删除一个变量。 unset NAME 这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使unset命令删除了变量，还是可以读取这个变量，值为空字符串。 所以，删除一个变量，也可以将这个变量设成空字符串。 $ foo='' $ foo= ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:4:3","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"4.4 输出变量 用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用export命令。这样输出的变量，对于子 Shell 来说就是环境变量。 export命令用来向子 Shell 输出变量。 NAME=foo export NAME 上面命令输出了变量NAME。变量的赋值和输出也可以在一个步骤中完成。 export NAME=value 上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量$NAME。 子 Shell 如果修改继承的变量，不会影响父 Shell。 # 输出变量 $foo $ export foo=bar # 新建子 Shell $ bash # 读取 $foo $ echo $foo bar # 修改继承的变量 $ foo=baz # 退出子 Shell $ exit # 读取 $foo $ echo $foo bar ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:4:4","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 脚本 脚本（script）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。 Bash 脚本使用 # 声明注释 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:5:0","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 Shebang行 脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以#!字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。 #!后面就是脚本解释器的位置，Bash 脚本的解释器一般是/bin/sh或/bin/bash。 #!/bin/sh # 或者 #!/bin/bash ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:5:1","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 执行权限和路径 指定了 Shebang 行的脚本，需要赋予执行权限才可以直接执行。 权限的设定有两种格式，一种是字母格式，（r, w, x）分别表示读、写、执行，（u, g, o）分别表示脚本所有者、同组用户、其它用户，（+, -, =）分别表示增加权限、取消权限和设置唯一权限。所有的权限设定命令都是这些参数的组合，举例 # 给所有用户执行权限 $ chmod +x script.sh # 只给脚本拥有者读权限和执行权限 $ chmod u+rx script.sh 权限还可以以数字方式设定，我们令 r=4, w=2, x=1，权限的组合就是这些操作权重的组合，权限授予的用户就是数字的位置，举例 # 给脚本所有者全部权限，给同组和其它用户读权限和执行权限 $ chmod 755 script.sh ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:5:2","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"5.3 脚本参数 调用脚本的时候，脚本文件名后面可以带有参数。 $ script.sh word1 word2 word3 脚本文件内部，可以使用特殊变量，引用这些参数。 $0：脚本文件名，即script.sh。 $1~$9：对应脚本的第一个参数到第九个参数。 $#：参数的总数。 $@：全部的参数，参数之间使用空格分隔。 $*：全部的参数，参数之间使用变量$IFS值的第一个字符分隔，默认为空格，但是可以自定义。 如果脚本的参数多于9个，那么第10个参数可以用${10}的形式引用，以此类推。 用户可以输入任意数量的参数，利用for循环，可以读取每一个参数。 #!/bin/bash for i in \"$@\"; do echo $i done 注1，如果命令是command -o foo bar，那么-o是$1，foo是$2，bar是$3。 注2，如果命令是./script.sh \"a b\"，即多个参数放在双引号里面，视为一个参数。 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:5:3","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"5.4 命令执行 exit命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。 $ exit 上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。 exit命令后面可以跟参数，该参数就是退出状态。 # 退出值为0（成功） $ exit 0 # 退出值为1（失败） $ exit 1 可以使用 $? 判断上一条命令的执行结果控制脚本的执行 cd $some_directory if [ \"$?\" = \"0\" ]; then rm * else echo \"无法切换目录！\" 1\u003e\u00262 exit 1 fi 使用 if 命令可以直接判断 if cd $some_directory; then rm * else echo \"Could not change directory! Aborting.\" 1\u003e\u00262 exit 1 fi 最简便的方法是使用逻辑连接符 # 第一步执行成功，才会执行第二步 cd $some_directory \u0026\u0026 rm * # 第一步执行失败，才会执行第二步 cd $some_directory || exit 1 source命令用于执行一个脚本，通常用于重新加载一个配置文件。 $ source .bashrc source命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，source命令执行脚本时，不需要export变量。 #!/bin/bash # test.sh echo $foo source有一个简写形式，可以使用一个点（.）来表示。 $ . script.sh 注意，要区分 . script.sh 和 ./script.sh ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:5:4","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"5.5 别名 alias命令用来为一个命令指定别名，这样更便于记忆。下面是alias的格式。 alias NAME=DEFINITION 上面命令中，NAME是别名的名称，DEFINITION是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。 一个常见的例子是为grep命令起一个search的别名。 alias search=grep alias也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个today的命令。 $ alias today='date +\"%A, %B %-d, %Y\"' $ today 星期一, 一月 6, 2020 有时为了防止误删除文件，可以指定rm命令的别名。 $ alias rm='rm -i' 上面命令指定rm命令是rm -i，每次删除文件之前，都会让用户确认。 ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:5:5","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 用户输入 有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用read命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。 read命令的格式如下。 read [-options] [variable...] 上面语法中，options是参数选项，variable是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量REPLY会包含用户输入的一整行数据。 下面是一个例子demo.sh。 #!/bin/bash echo -n \"输入一些文本 \u003e \" read text echo \"你的输入：$text\" 上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量text，在下一行显示出来。 $ bash demo.sh 输入一些文本 \u003e 你好，世界 你的输入：你好，世界 read可以接受用户输入的多个值。 #!/bin/bash echo Please, enter your firstname and lastname read FN LN echo \"Hi! $LN, $FN!\" 上面例子中，read根据用户的输入，同时为两个变量赋值。 如果用户的输入项少于read命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。 如果read命令之后没有定义变量名，那么环境变量REPLY会包含所有的输入。 #!/bin/bash # read-single: read multiple values into default variable echo -n \"Enter one or more values \u003e \" read echo \"REPLY = '$REPLY'\" 上面脚本的运行结果如下。 $ read-single Enter one or more values \u003e a b c d REPLY = 'a b c d' ","date":"2020-08-18","objectID":"/2020/bash-script-grammer-1/:6:0","tags":["linux"],"title":"Bash脚本语法1","uri":"/2020/bash-script-grammer-1/"},{"categories":["爱编程爱技术的孩子"],"content":"本篇介绍文件管理相关的内容。包括硬盘结构、文件和目录的概念，以及一个文件系统涉及的其它知识。 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:0:0","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 硬盘结构 硬盘是计算机最主要的外部存储设备，尽管常见的存储设备还有光盘、U盘等，但最常用的还是硬盘。目前，我们所见的硬盘主要有机械硬盘和固态硬盘两类，前者使用磁性盘片来存储数据，后者使用闪存颗粒存储数据。 机械硬盘主要的组成包括磁盘片、主轴、磁盘臂、磁头等。如下图所示，硬盘中有大量的磁盘片，所有的盘片通过主轴连接在一起，主轴连接到一个电机，以恒定的速率旋转。每个磁盘片有两面，数据在这两面上持久存储，通过磁头可以读取表面的数据。磁盘转动时，磁头所走过的路径会形成一个圆形，叫做磁道，每个磁盘片都有数百上千的磁道，另外，人们把所有磁盘片的相同磁道称作一个柱面。最后，为了便于读写，人们还将每个磁盘片划分为一些相等大小的扇区，一个扇区 512 字节。不过，操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个\"块”（block）。这种由多个扇区组成的\"块”，是文件存取的最小单位。“块\"的大小，最常见的是4KB，即连续八个 sector组成一个 block。 固态硬盘不再使用盘片，而是使用某种存储芯片作为存储介质，基本原理是对电荷的存储。固态硬盘在大部分方面都比机械硬盘表现好。固态硬盘已经没有了磁道、柱面等概念，物理单位是一个个的闪存颗粒，每个闪存颗粒由成千上万大小相同的块（Block）组成，块的大小一般为数百 KB 到数 MB，每一个块的内部又分为若干个大小相同的页（Page），页的大小一般为 4KB 或者 8KB。页是基本的读写单位，块是数据擦除的基本单位。 更大关于固态硬盘的知识可以参考 知乎，详解固态硬盘的有趣知识及其底层原理 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:1:0","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 文件与inode 可参考：阮一峰，理解inode 文件（file）是一个抽象的概念，最底层就是一串二进制0和1，高一点可以看作一个字节序列，其中每个字节都可以读取或写入。在更高一点的层次，我们用一个叫做 inode 的结构记录关于文件的一些元信息，这个结构的定义可以举个例子 struct stat { dev_t st_dev; // ID of device containing file ino_t st_ino; // inode number mode_t st_mode; // protection nlink_t st_nlink; // number of hard links uid_t st_uid; // user ID of owner gid_t st_gid; // group ID of owner dev_t st_rdev; // device ID(if special file) off_t st_size; // total size, in bytes blksize_t st_blksize; // blocksize for filesystem I/O blkcnt_t st_blocks; // number of blocks allocated time_t st_atime; // time of last access time_t st_mtime; // time of last modification time_t st_ctime; // time of last status change }; 我们可以看到主要包含的内容有：inode 号、保护信息（即文件权限）、链接数、文件拥有者的用户 ID 和所在的组 ID、文件总字节数、I/O 读取的单个 Block 大小、底层数据块的位置、实际信息等。 使用 stat 命令可以读取到这些信息 $ stat foo 文件：foo 大小：6 块：8 IO 块：4096 普通文件 设备：805h/2053d Inode：5767595 硬链接：1 权限：(0664/-rw-rw-r--) Uid：( 1000/ shuzang) Gid：( 1000/ shuzang) 最近访问：2020-08-22 19:00:39.660722364 -0700 最近更改：2020-08-22 19:00:29.121819131 -0700 最近改动：2020-08-22 19:00:29.121819131 -0700 创建时间：- 注意，inode 对底层数据块的引用一般是通过指针完成的，每个指针指向一个磁盘块，为了包含更多的数据，指针可以指向另一个完全由指针组成的块，使用间接指针的方式扩大包含的数据量。通常来讲，inode 中会设置一定数量的直接指针和一个间接指针。 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:2:0","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 inode大小 inode 本身的存储也占据硬盘空间，所以硬盘至少会有两个区：数据区存放文件数据，inode 区存放所有 inode。不过我们习惯将存放 inode 的区域称作 inode 表。 由于 inode 的内容不多且比较固定，所以其大小也是固定的， 一般是128字节或256字节。 使用 df 命令可以查看每个硬盘分区的 inode 总数和使用情况 $ df -i 文件系统 Inode 已用(I) 可用(I) 已用(I)% 挂载点 udev 493235 477 492758 1% /dev tmpfs 500276 938 499338 1% /run /dev/sda5 6520832 233720 6287112 4% / tmpfs 500276 1 500275 1% /dev/shm tmpfs 500276 5 500271 1% /run/lock tmpfs 500276 18 500258 1% /sys/fs/cgroup /dev/loop0 4338 4338 0 100% /snap/code/39 /dev/loop2 12796 12796 0 100% /snap/core/9804 /dev/loop3 10775 10775 0 100% /snap/core18/1885 /dev/loop5 10756 10756 0 100% /snap/core18/1880 /dev/loop1 12862 12862 0 100% /snap/core/9665 /dev/loop4 24339 24339 0 100% /snap/gnome-3-34-1804/33 /dev/loop6 24339 24339 0 100% /snap/gnome-3-34-1804/36 /dev/loop8 10206 10206 0 100% /snap/go/6123 /dev/loop12 463 463 0 100% /snap/snapd/8542 /dev/loop9 62342 62342 0 100% /snap/gtk-common-themes/1506 /dev/loop11 15827 15827 0 100% /snap/snap-store/467 /dev/loop13 465 465 0 100% /snap/snapd/8790 /dev/loop10 15827 15827 0 100% /snap/snap-store/433 /dev/sda1 0 0 0 - /boot/efi tmpfs 500276 89 500187 1% /run/user/1000 /dev/loop14 4303 4303 0 100% /snap/code/40 /dev/loop15 10206 10206 0 100% /snap/go/6274 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:2:1","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 inode号 每个 inode 都有一个 inode 号，它被操作系统用来识别文件。 我们应该清除的是，文件名只是为了方便用户使用，操作系统对文件的操作本质是通过 inode。举个例子，当我们打开文件的时候，系统首先通过文件名找到 inode 号，然后通过 inode 号获取 inode 信息，最后根据 inode 信息找到文件数据所在的 block，读取数据。 通过 inode 号找 inode 的例子如下图，假设 inode 表大小为 20KB，由 80 个 inode 组成，inode 区域从 12KB 开始（即超级块从 0KB 开始，inode 位示图在 4KB 位置，数据位示图在 8KB位置）。要读取 inode 号 32，文件系统首先计算 inode 区域偏移量（32×inode大小，即 8192），将它加上磁盘 inode 表的起始地址（12KB），从而得到希望的 inode 块的正确字节地址：20KB。 使用 ls -i 命令可以查看文件名对应的 inode 号 $ ls -i foo 5767595 foo ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:2:2","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 目录 目录也是一种文件，但它的内容比较具体，存储的是它所包含的文件的文件名和对应的 inode 号。该内容用抽象数据结构来表达如下 struct dirent { char d_name[256]; // filename ino_t d_ino; // inode number off_t d_off; // offset to the next dirent unsigned short d_reclen; // length of this record unsigned char d_type; // type of file } 举个例子，foo 文件的 inode 号为 10，则目录的内容中会有一条 （foo, 10） 的记录。但我们要记得，目录也是一个文件，因此目录也有自己的 inode。 注1：目录的层次结构从根目录（/）开始，由根文件系统产生。 注2：移动文件或重命名文件，只是改变文件名，不改变 inode 号。 注3：通常来说，系统无法从inode号码得知文件名 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:3:0","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 软链接和硬链接 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:4:0","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 硬链接 一般情况下，文件名和 inode 号之间是一一对应的关系，但我们可以令多个文件名指向同一个 inode 号。这种情况就叫硬链接。硬链接的本质是增加了一个对应关系，没有改变 inode 和底层数据，这意味着我们使用不同的文件名访问到的是同一个文件，修改和删除数据也会影响到所有文件名。 Linux 中使用 ln 命令建立硬链接。 inode 结构中有一项叫做链接数，每建立一个硬链接，该值就会加一，反过来，删除一个文件名，该值就会减一，只有减到零的情况下，系统才会回收该 inode 号和对应的数据。 系统创建目录时，默认会生成两个目录项：\".“和”..\"。前者的inode号码就是当前目录的inode号码，等同于当前目录的\"硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的\"硬链接”。所以，任何一个目录的\"硬链接\"总数，总是等于2加上它的子目录总数（含隐藏目录）。 硬链接的缺点是不能创建目录的硬链接，也不能链接到其它文件系统。 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:4:1","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 软链接 软链接，也叫符号链接，软链接可以为目录创建，也可以链接到其它文件系统。因为软链接的实质类似于指针，加上存在文件 B，为 B 建立软链接 A，实际上是建立了一个新的文件，A 有自己的 inode，只不过 A 的内容是 B 的路径。当我们访问 A 时，会自动导向文件 B。 因此，软链接 A 是依赖于 B 存在的，如果删除了文件 B，打开文件 A 就会提示指向的文件或目录不存在。 使用 ln -s 命令创建软链接。 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:4:2","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 文件系统实例 文件系统是操作系统中与管理文件有关的软件和数据，负责文件的建立、删除、读写、修改、复制以及按名存取和存取控制。 我们假设磁盘的基本读写单位是 4KB，每 4KB 为一块，一个磁盘可以分为若干块（假设为 N），这些块的地址从 0 到 N-1，下面的介绍以一个只有 64 块的磁盘为例。 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:5:0","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 基本结构 首先，磁盘中主要存放的一定是 用户数据，我们将存放用户数据的磁盘区域称为数据区域，假设将 64 个块的最后 56 个专门留给它们。 此外，文件系统还必须记录每个文件的基本信息，就是 inode，所有的 inode 存放在一个统一的区域，叫做 inode 表。由于 inode 大概 128 或 256 字节，所以不需要预留很大的空间，一个 4KB 的块就可以存放 16 个 inode，这里我们在 64 个块中留了 5 个块来存放 inode。 然后，我们还需要一个结构来记录 inode 和数据块空闲还是已分配。可选的方法很多，比如空闲块链表，将所有的空闲块链接在一起，当需要空闲块时从链头开始摘取并修改头指针，回收空闲块时插入链表尾。但通常使用的是一种简单有效的结构：位示图（inode）。位示图的原理是划分一部分空间，将每个比特位对应一个块，如果该位为0，说明对应的块空闲，如果该位为 1，说明对应的块已分配。数据区域和 inode 表通常使用不同的位示图。 最后还有一个结构叫做 超级块，包含文件系统的基本信息，比如有多少个 inode 和数据块、inode 表的起始位置、文件系统的类型等。 所以基本的结构有五部分，如下图：超级块、inode 位示图、数据区域位示图、inode表、数据区域。 可以通过 df 命令查看文件系统，然后使用 sudo dumpe2fs /dev/dsa* 查看超级块的信息 shuzang@ubuntu:~$ df 文件系统 1K-块 已用 可用 已用% 挂载点 udev 1972940 0 1972940 0% /dev tmpfs 400224 1892 398332 1% /run /dev/sda5 102168536 10744048 86191592 12% / ... $ sudo dumpe2fs /dev/sda5 dumpe2fs 1.45.5 (07-Jan-2020) Filesystem volume name: \u003cnone\u003e Last mounted on: / Filesystem UUID: 45e4318b-0433-4e09-a0ea-48e29ac60801 Filesystem magic number: 0xEF53 Filesystem revision #: 1 (dynamic) Filesystem features: has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum Filesystem flags: signed_directory_hash Default mount options: user_xattr acl Filesystem state: clean Errors behavior: Continue Filesystem OS type: Linux Inode count: 6520832 Block count: 26082560 Reserved block count: 1304128 Free blocks: 22924783 Free inodes: 6286837 First block: 0 Block size: 4096 Fragment size: 4096 Group descriptor size: 64 Reserved GDT blocks: 1024 Blocks per group: 32768 Fragments per group: 32768 Inodes per group: 8192 Inode blocks per group: 512 Flex block group size: 16 Filesystem created: Tue May 19 03:52:48 2020 Last mount time: Fri Aug 21 01:35:42 2020 Last write time: Fri Aug 21 01:35:35 2020 Mount count: 7 Maximum mount count: -1 Last checked: Tue May 19 03:52:48 2020 Check interval: 0 (\u003cnone\u003e) Lifetime writes: 26 GB Reserved blocks uid: 0 (user root) Reserved blocks gid: 0 (group root) First inode: 11 Inode size: 256 ... ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:5:1","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 挂载 磁盘通常会划分为不同的分区，每个分区可能使用不同的文件系统，挂载就是将该文件系统粘贴到整个操作系统的文件目录树上，挂载的位置是一个路径，进入该路径就相当于进入了该文件系统。 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:5:2","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5.3 文件读取 已知文件名，读取文件的过程我们大致已经熟悉，即通过文件名获得 inode 号，通过 inode 号获得 inode 信息，通过 inode 信息读取数据。 但这里还不清楚的一点是如何通过文件名找到 inode。文件系统采取的方式是遍历路径名，所有的遍历都从文件系统的根开始，即 / 。文件系统第一次读取根目录的 inode，根目录的 inode 号是众所周知的，一般是 2，因此文件系统就会读入 inode 号为2的块。一旦读入 inode，文件系统就可以查找指向数据块的指针，数据块中包含了根目录的内容。根目录的内容中存放了所有子文件的文件名和 inode 号的对应，所以根据路径可以找到下一级目录或文件的 inode 号，如果是目录，就继续遵循上面的过程进行递归的读取，最后读取得到文件的数据。 最后要注意的是，简单的读取并不会对位示图进行改变，只有创建或删除文件数据时才会改变位示图的内容。 ","date":"2020-08-18","objectID":"/2020/operate-system-6-file-management/:5:3","tags":["计算机基础"],"title":"操作系统6-文件管理","uri":"/2020/operate-system-6-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"本篇介绍设备管理的相关内容。最近发现本科用的教材内容非常陈旧，而且不是那么浅显易懂，于是找了一本国外的教材《操作系统导论》，主要根据这个来学习。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:0:0","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 系统架构 一个典型的系统架构如下。其中，CPU 通过某种内存总线或互联电缆连到系统内存，图像（比如显卡）或其它高性能 I/O 设备通过常规的 I/O 总线连到系统，可能是 PCI 或其衍生形式。最下面是外围总线，比如 SCSI、SATA 或者 USB，它们将最慢的设备连接到系统，包括磁盘、鼠标和其它类似设备。 采用这种分层架构的原因是物理布局和造价成本。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:1:0","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 标准设备 尽管设备可能分很多种，比如存储设备、输入输出设备、各种终端和脱机设备，但这里使用一种标准设备来介绍，这里提到的标准设备不是真实存在的，但它的组成和互操作可以代表大部分的设备。 如下图，一个标准设备主要包括两部分。一部分是对计算机其它部分展现的硬件接口，另一部分是这些设备的内部结构，一些简单的设备可能只有一个或几个芯片，但复杂一些的设备还会包括自己的 CPU 和内存。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:2:0","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 设备交互 一个简化的设备接口包括三个寄存器：状态寄存器读取并查看设备当前状态，命令寄存器通知设备执行某个任务，数据寄存器将数据传给设备或从设备接收数据。通过读写这些寄存器，操作系统可以控制设备行为。 最简单的交互逻辑如下 while Status == Busy // wait until device is not busy Write data to DATA register; Write command to COMMAND register; While Status == Busy // wait until device is done with your request 简单来说，就是操作系统不断读取状态寄存器（轮询），如果设备已经准备好了，就开始传输数据到数据寄存器，传输完成后将命令写入命令寄存器，这样设备就知道数据准备好了，开始执行命令。最后继续轮询，判断设备是否执行完命令。 这个协议简单有效，只是轮询过程比较低效，而且 CPU 需要等待设备执行，浪费大量的时间。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:3:0","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 中断 中断是指计算机执行期间，由于发生了某些非预期的紧急事件，计算机暂停当前进程而执行相应的事件处理程序，执行完毕后又返回执行暂停的进程的过程。中断可能来自 I/O 设备发出的信号、外部信号（比如键盘 Esc 输入）、定时器引起的时钟中断、调试程序的断点、程序运算产生的溢出、非法指令等等。 所有需要由硬件产生的中断叫硬中断，比如上面提到的这些。还有一种叫软中断，是进程模拟用来通信的，软中断不一定需要立即执行，可以由 CPU 选择合适的时机执行。 当我们用中断来替换设备交互中的轮询过程时，可以极大提升效率。过程如下： CPU 向设备发出一个请求，然后就可以让相关进程休眠，然后去执行其它任务； 设备完成自身操作后，产生一个硬中断，CPU 就会去执行对应的中断处理程序，也就是唤醒睡眠的 I/O 进程来继续执行； 但是，中断的高效建立在外围设备和 CPU 处理速度差异较大的情况下，如果外设处理速度比较快，那么轮询反而比中断更好。另外一个原因是，外设的数量比较多，而且是并行工作的，可能会造成中断数量急剧增加，极端的情况，网卡每收到一个数据包产生一个中断，就会导致系统无法响应。一种解决办法是合并多个中断为一个，统一处理。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:3:1","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 DMA 设备交互的简单协议还有一个问题，外设与内存的数据传输总是需要 CPU 调度，有时候对 CPU 是一个负担。解决方法是 DMA（Direct Memory Access），它的基本思想是在外设和内存之间开辟一个直接的数据通路。 DMA 工作过程如下。为了能够将数据传送给设备，操作系统会通过编程告诉 DMA控制器 数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以处理其他请求了。当 DMA 的任务完成后，DMA 控制器会抛出一个中断来告诉操作系统自己已经完成数据传输。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:3:2","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 通道 DMA 方式中，数据的传送方向、存放数据的内存地址、传送的数据块长度等还是需要 CPU 来控制。通道是一种专门的硬件，可以看作是一个专管输入输出的处理机，它会替代 CPU 完整所有这些工作，并且可以控制多台外设与内存交互，因此进一步减轻了 CPU 的负担。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:3:3","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 交互 系统与设备的交互主要由两种方式 明确的 I/O 指令，这些指令规定了操作系统将数据发送到特定设备寄存器的方法。比如，x86 中，in 和 out 指令可以用来与设备进行交互。当需要发送数据给设备时，调用者指定一个存入数据的特定寄存器及一个代表设备的特定端口。执行这个指令就可以实现期望的行为。这些指令通常是特权指令（privileged）。操作系统是唯一可以直接与设备交互的实体。 内存映射 I/O，即硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:3:4","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 设备驱动 设备驱动程序是驱动物理设备与 DMA 控制器或 I/O 控制器等直接进行 I/O 操作的子程序的集合，负责设置相应设备有关寄存器的值，启动设备进行 I/O 操作，指定操作的类型和数据流向等。 由于所有需要插入系统的设备都需要安装相应的驱动，所有一个系统的大部分代码其实都是各种驱动程序。当然，这些驱动一般都不是激活的，只有一小部分需要在系统刚开始就连接。另外一件事，驱动程序的开发者大部分不是全职的内核开发者，所以容易出现缺陷，也是内核崩溃的主要贡献者。 ","date":"2020-08-17","objectID":"/2020/operate-system-5-device-management/:4:0","tags":["计算机基础"],"title":"操作系统5-设备管理","uri":"/2020/operate-system-5-device-management/"},{"categories":["Golang学习之路"],"content":"本篇介绍如何分析 Go 的调用栈。 测试使用的版本是Go 1.14.3，下面介绍如何在Go调试的时候查看堆栈跟踪信息及识别传递的参数。 示例程序如下 package main import ( \"runtime/debug\" ) func main() { slice := make([]string, 2, 4) Example(slice, \"hello\", 10) } func Example(slice []string, str string, i int) { debug.PrintStack() } 在程序中我们使用了 runtime/debug 下的 PrintStack() 函数将调用栈的返回信息打印到标准错误输出，如下所示 goroutine 1 [running]: runtime/debug.Stack(0x0, 0x0, 0x0) c:/go/src/runtime/debug/stack.go:24 +0xa8 runtime/debug.PrintStack() c:/go/src/runtime/debug/stack.go:16 +0x29 main.Example(0xc000077f38, 0x2, 0x4, 0x4a8534, 0x5, 0xa) f:/Gotest/main.go:13 +0x2e main.main() f:/Gotest/main.go:9 +0xb1 Process exiting with code: 0 注意，在其它编程语言如C中，运行一个程序会启动一个线程来执行，在Go中，启动的是一个 Goroutine。上面第一行就说明了启动了一个 Goroutine，Goroutine ID 为1，其后各行是不同层次的调用，最深的调用最先打印，最浅的调用最后打印。各行说明如下 第8、9行：main package 的 main 函数，代码文件路径为 f:/Gotest/main.go，调用出现在 main.go 文件的第9行 第6、7行：main 函数调用 Example 函数 第4、5行：Example 函数调用 debug.PrintStack 函数 第2，3行：debug.PrintStack 函数调用 debug.Stack 函数 Example 函数传参信息如下 // 调用 slice := make([]string, 2, 4) Example(slice, \"hello\", 10) // 栈追踪 main.Example(0xc000077f38, 0x2, 0x4, 0x4a8534, 0x5, 0xa) 堆栈跟踪信息中，前三个参数分别代表切片的指针、长度、容量，第4和第5个参数代表字符串的指针和大小，最后一个参数指向整型数值 // 切片 Pointer: 0xc000077f38 Length: 0x2 Capacity: 0x4 // 字符串 Pointer: 0x4a8534 Length: 0x5 // 整数 base 16: 0xa 如果是调用方法，跟踪信息会显示接收者 // 程序 package main import ( \"fmt\" \"runtime/debug\" ) type trace struct{} func main() { slice := make([]string, 2, 4) var t trace t.Example(slice, \"hello\", 10) } func (t *trace) Example(slice []string, str string, i int) { fmt.Printf(\"Receiver Address: %p\\n\", t) debug.PrintStack() } // 堆栈信息 Receiver Address: 0x5781c8 goroutine 1 [running]: runtime/debug.Stack(0x15, 0xc000071ef0, 0x1) C:/Go/src/runtime/debug/stack.go:24 +0xae runtime/debug.PrintStack() C:/Go/src/runtime/debug/stack.go:16 +0x29 main.(*trace).Example(0x5781c8, 0xc000071f48, 0x2, 0x4, 0x4c04bb, 0x5, 0xa) D:/gopath/src/example/example/main.go:17 +0x7c main.main() D:/gopath/src/example/example/main.go:13 +0x9a 传递的参数全部为值类型时，可能会防止一个32位的字中 // 程序 import ( \"runtime/debug\" ) func main() { Example(true, false, true, 25) } func Example(b1, b2, b3 bool, i uint8) { debug.PrintStack() } // 堆栈信息 goroutine 1 [running]: runtime/debug.Stack(0x4, 0xc00007a010, 0xc000077f88) C:/Go/src/runtime/debug/stack.go:24 +0xae runtime/debug.PrintStack() C:/Go/src/runtime/debug/stack.go:16 +0x29 main.Example(0xc019010001) D:/gopath/src/example/example/main.go:12 +0x27 main.main() D:/gopath/src/example/example/main.go:8 +0x30 可以看到 Example 的参数只有一个，实际上底层四个参数放在一个字中 // Parameter values true, false, true, 25 // Word value Bits Binary Hex Value 00-07 0000 0001 01 true 08-15 0000 0000 00 false 16-23 0000 0001 01 true 24-31 0001 1001 19 25 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-9-call-stack/:0:0","tags":["Go语法"],"title":"Golang深入学习9-调用栈","uri":"/2020/golang-deep-learning-9-call-stack/"},{"categories":["Golang学习之路"],"content":"本篇介绍 Go 的堆栈和逃逸分析。 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:0:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"1. 堆栈 栈是一种后入先出的结构，计算机中也有一块满足该特性的动态内存区域，程序可以将数据压入栈中或者将数据从栈中弹出，从而使栈动态的增大或减小。 除此之外，堆也是计算机中的一中内存区域。堆与栈的区别如下 栈一般由操作系统来分配和释放，堆由程序员通过编程语言来申请创建与释放。 栈用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，堆用来存放全局变量。我们可以这样理解数据存放的规则：只要是局部的、占用空间确定的数据，一般都存放在stack 里面，否则就放在 heap 里面。 栈的访问速度相对比堆快。 一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack 是线程独占的，heap 是线程共用的。 stack 创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap的大小是不确定的，需要的话可以不断增加。 栈是由高地址向低地址增长的，而堆是由低地址向高地址增长的。 在 C/C++ 中，程序员申请的内存空间使用完毕后需要自己释放，在 Java、Go 等语言中，提供了一种主动释放申请的内存空间的功能，这就是垃圾回收机制。 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:1:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"2. Go的堆栈 首先，Go 是自己管理内存的，而不是交给操作系统，它每次从操作系统申请一大块内存，然后按照 Google 的 TCMalloc 算法进行内存分配，也划分为堆、栈等很多区域。 这里我们主要关心变量究竟放在堆还是栈里，官方有这么一段解释 只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用垃圾回收机制进行管理，从而避免指针悬空。此外，局部变量如果非常大，也会存在堆上。 在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。 总之，分配在堆还是栈完全由编译器确定。 所以 Go 里变量分配在由编译器决定，我们虽然无法通过变量的类型判断它的存储位置，但可以通过打印程序的汇编代码来查看，主要使用 go tool compile 命令，示例程序如下 package main import \"fmt\" func main() { var a [1]int c := a[:] fmt.Println(c) } 使用 -S 参数编译，可以输出详细内容。可以看到第 6 行代码出现了 runtime.newobject，这就说明 main.go 第6行 的数组变量 a 分配在堆上。反之，如果没有发现 runtime.newobject 调用，就说明分配在栈上。 $ go tool compile -S main.go ... 0x0028 00040 (main.go:6) PCDATA $0, $1 0x0028 00040 (main.go:6) PCDATA $1, $0 0x0028 00040 (main.go:6) LEAQ type.[1]int(SB), AX 0x002f 00047 (main.go:6) PCDATA $0, $0 0x002f 00047 (main.go:6) MOVQ AX, (SP) 0x0033 00051 (main.go:6) CALL runtime.newobject(SB) 0x0038 00056 (main.go:6) PCDATA $0, $1 0x0038 00056 (main.go:6) MOVQ 8(SP), AX 0x003d 00061 (main.go:8) PCDATA $0, $0 0x003d 00061 (main.go:8) MOVQ AX, (SP) 0x0041 00065 (main.go:8) MOVQ $1, 8(SP) 0x004a 00074 (main.go:8) MOVQ $1, 16(SP) ... 使用 -m 参数可以输出优化后的描述，这里就看起来很清楚了，可以看到 main.go 第 6 行的变量 a 分配到了堆上，在第 8 行时，变量 c 逃逸到了堆上。关于逃逸我们在下一小节介绍。 $ go tool compile -m main.go main.go:8:13: inlining call to fmt.Println main.go:6:6: moved to heap: a main.go:8:13: c escapes to heap main.go:8:13: []interface {} literal does not escape \u003cautogenerated\u003e:1: .this does not escape \u003cautogenerated\u003e:1: .this does not escape 也可以直接在 go build 命令中添加 -gcflag=-m 参数，意思是编译的同时以 -m 参数运行 go tool compile 命令，结果是相同的。 $ go build -gcflags=-m main.go # command-line-arguments .\\main.go:8:13: inlining call to fmt.Println .\\main.go:6:6: moved to heap: a .\\main.go:8:13: c escapes to heap .\\main.go:8:13: []interface {} literal does not escape \u003cautogenerated\u003e:1: .this does not escape \u003cautogenerated\u003e:1: .this does not escape ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:2:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"3. 逃逸分析 前面已经提到，Go 中变量分配在栈还是堆上完全由编译器决定，而原本看起来应该分配在栈上的变量，如果其生命周期获得了延长，被分配在了堆上，就说它发生了逃逸。编译器会自动地去判断变量的生命周期是否获得了延长，整个判断的过程就叫逃逸分析。 package main func main() { a := test() println(a) } func test() *int { b := 2 return \u0026b } 举个例子，上面的程序中 b 作为局部变量，如果是在 C 语言中，return \u0026b 这样的写法无法通过，因为 b 在函数返回后已经消失了，但在 Go 中，编译器做了一下逃逸分析，发现返回 \u0026b 说明之后 b 还要用，于是就把 b 分配在了堆上。 $ go tool compile -m main.go main.go:8:6: can inline test main.go:3:6: can inline main main.go:4:11: inlining call to test main.go:9:2: moved to heap: b 然后我们举另外一个例子如下，一个最简单的输出 package main import \"fmt\" func main() { a := 1 fmt.Println(a) } 结果发现变量 a 依然逃逸了 $ go tool compile -m main.go main.go:7:13: inlining call to fmt.Println main.go:7:13: a escapes to heap main.go:7:13: []interface {} literal does not escape \u003cautogenerated\u003e:1: .this does not escape \u003cautogenerated\u003e:1: .this does not escape 这是因为输出其实是调用了 fmt 包的 Println 函数，变量的生命周期依然得到了扩展，如果我们使用 println 函数，就不会发生逃逸 package main func main() { a := 1 println(a) } $ go tool compile -m main.go main.go:3:6: can inline main 所以现在我们可以更好的理解官方说明中的这句话：如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。 变量发生逃逸的情况可以总结如下 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。 发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。 slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。 在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:3:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"参考 [1] Go堆栈的理解 [2] 阮一峰，栈的三种含义 [3] 官方关于变量分配在堆还是栈上的说明 [4] Young，CSDN，Go 的变量到底在堆还是栈中分配 [5] 胖虎，微信公众号，简单聊聊内存逃逸 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:4:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"一直都比较纠结这个问题，所以搜了一下答案，记录在这里。 变量的声明有两种情况： 需要建立存储空间，这种称为定义性声明（defining declaration），简称定义 不需要建立存储空间，这种称为引用性声明（referncing declaration） 所以广义的讲，声明包含定义，定义是声明的一个特例。 在 Go 中，基本变量类型在声明时都会分配存储空间并分配默认值，因此都属于定义性声明 var ( a int b float32 c bool ) 但是，像切片、映射、通道等，声明时不会分配存储空间，要分配空间还必须使用 make 内置函数，因此它们是引用性声明 var a []int a = make([]int,3) 在 Go 的官方文档中，使用的也都是 declaration 这个词，统一用「声明」来描述 ","date":"2020-08-15","objectID":"/2020/golang-supplement-the-difference-between-definition-and-declaration/:0:0","tags":["Go语法"],"title":"Golang查漏补缺-定义与声明的区别","uri":"/2020/golang-supplement-the-difference-between-definition-and-declaration/"},{"categories":["爱编程爱技术的孩子"],"content":"本文介绍操作系统另一个重要功能：存储管理。包括存储管理的基本功能，以及分区、页式、段式与段页式三种存储管理方法的具体细节。 首先记住，用户程序生成的每个地址都是虚拟地址，只有进程执行时，才会把这些虚拟地址转换为真实的物理地址。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:0:0","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 存储管理的功能 指的是进行存储管理时涉及的一些技术和必须完成的工作，包括虚存、地址变换技术、内外存数据传输的控制、内存的分配与回收、内存信息的共享与保护五部分。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:1:0","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 虚存 计算机中的存储器可以分为几个层次：外存—\u003e内存—\u003e高速缓存—\u003e寄存器。这个顺序是容量由大到小，但访问速度由快到慢的。划分为多个层次的原因是计算机的各部分，从 CPU 到外设，处理的速度是不同的，使用这种分层结构可以使各部分处于均衡的繁忙状态。 进程在执行时访问的是内存中的指令与数据，但由于内存的容量较小，一些进程的内存需求甚至可能超过内存的实际容量，即使是可容纳的进程，计算机也难以支撑多个并发进程的同时执行。解决办法是将一些不常访问的数据和程序段存放在外存中，需要时再调入内存。这种情况下，需要统一管理内外存进程所需的程序和数据，使用内存实际物理地址的方法变得不再可行，因此操作系统使用了一种名为虚拟内存的技术。 虚拟内存，也叫做虚拟存储器，可以简称为虚存。其原理是使用一个一维或多维的虚拟地址空间存放进程所需的所有资源的方法，不论指令和数据是位于内存还是外存，它们在虚拟地址空间中都有一个确定的地址，称为虚拟地址。虚拟地址与实际物理地址有一个确定的变换关系，进程运行时，可以主动将虚拟地址变换为实际物理地址，然后对指令和数据进行操作。 每个进程都拥有这样一个虚拟地址空间，这个虚拟地址空间就叫做虚存（进程管理中我们也将其称作进程空间）。虚存不考虑内存大小，因为使用虚存技术时进程所需容量理论上只受内外存容量之和限制；虚存也不考虑信息的实际存储位置，只关注每个进程相关的指令和数据的相对位置。 虚存的实际大小仅与处理器的位数有关，以 x86 体系 32位 Linux 为例，其虚存为 $2^{32} = 4G$。 实际上，虚存在使用时会划分为不同的区域，分布存放程序、数据、堆栈、控制信息等，以上面提到的 32位 Linux 的 4G 虚存为例，空间划分的方式如下： 首先，整体将虚存划分位了内核空间和用户空间两部分，这是由于某些指令比较危险，错用会导致系统崩溃，某些数据也需要限制访问权限，因此不同的进程限制在不同的空间进行，而且，当进程运行在内核空间时就称其处于内核态，当进程运行在用户空间时则处于用户态。上图中，内核空间是高地址的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），用户空间是较低的 3G 字节。 注意，低地址的 3G 字节用户空间每个进程是独立的，而高地址的 1G 字节内核空间是所有进程共享的。 用户空间的不同部分说明如下 .text段（代码段）存放程序运行时产生的指令和只读数据（read only data） .data存放了初始化了的且初始化的值不为0的数据 .bss存放未初始化及初始化为0的数据 堆由编程语言分配，由低地址向高地址增长 栈由操作系统分配，由高地址向低地址增长 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:1:1","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 地址变换技术 采用虚存后面临的一个重要问题就是进行虚拟地址和物理地址的变换。 我们把内存的每一个存储单元用一个编号标识，这一编号就是物理地址，也叫做内存地址。内存地址的集合就叫做内存空间，或者叫做物理地址空间。 虚拟地址向物理地址的变换就叫做地址重定位，主要分为静态地址重定位和动态地址重定位两种。 静态地址重定位指的是在程序执行前由装配程序完成地址映射，不需要硬件支持，但程序一旦装入内存就不能再移动，并且必须在程序执行前全部装入，这种方法无法实现虚存。 动态地址重定位指的是在程序执行过程中，在 CPU 访问时完成地址映射。该工作需要硬件的支持，主要是基地址寄存器 BR 和程序虚拟地址寄存器 VR，BR 存放程序或数据在内存的首地址，VR 由虚存得到的相对地址，因此，实际的物理地址与它们的关系为 $MA = BR + VR$。只需要使用多个 BR 存储不同区域的首地址，就可以实现对内存进行非连续的分配。动态地址重定位可以实现虚存。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:1:2","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 内外存数据传输 实现虚存时，需要经常进行内外存之间的数据交换，比如将即将执行的程序和数据段调入内存，将处于等待状态的程序和数据段调出内存。 控制这种数据交换的方法有两种，用户程序自己控制和操作系统控制。 用户程序自己控制使用的技术叫覆盖。覆盖技术将程序划分为若干个功能相对独立的程序段，然后让那些不会同时执行的程序段共享同一块内存区域，假如程序段 A 正在运行，和它共享内存的程序段 B 开始调度时， A 一定已经执行完毕，那么 B 就可以调度到 A 原本占用的内存区域。这一，用户看起来，就好像内存扩大了。 操作系统控制又可以进一步分为两种方式：交换、请求调入和预调入。 交换技术考虑到内存中的进程可能处于执行、就绪或等待状态，处于等待状态的进程驻留内存会造成存储空间的浪费，因此由操作系统将处于等待状态的进程换出内存，而将那些等待事件已经发生、处于就绪态的进程换入内存。 请求调入是在程序执行时，如果所要求访问的程序段或数据段不在内存中，由操作系统自动从外存调入的方式；预调入是由操作系统预测在不远的将来会访问到的程序段和数据段，并在它们被访问前寻找合适的时机调入内存的方式。 请求调入和预调入是唯一可以实现虚存的控制方法。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:1:3","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 内存分配与回收 内存分配与回收是内存管理的主要功能之一，为了将外存中的程序和数据调入内存，需要事先为它们分配内存空间，进程执行结束时，还要及时地回收进程所占用的内存空间。 内存分配与回收算法的涉及要考虑如下的事情： 分配结构：登记内存使用情况，提供分配程序使用的数据结构 放置策略：确定调入内存的程序和数据在内存中的位置 交换策略：在需要将某个程序段和数据调入内存时，若内存无足够空间，使用交换策略 调入策略：决定外存中程序段和数据段调入的时间和控制方式 回收策略：回收的时机和空闲区的调整 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:1:4","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.5 内存信息保护 进程执行时要保护系统程序区不被用户侵犯（有意或无意的），也不应该允许用户程序读写不属于自己地址空间的数据（系统区地址空间，其他用户程序的地址空间），这就是内存信息的保护。 常用的内存信息保护方法有三种：硬件法、软件法和软硬结合法。 硬件法指的是使用寄存器保持程序段或数据段的起始和终止地址，进程访问前进行合法性检查 软件法指的是为每个存储区域设置一个标志位，不同的标志代表不同的读写权限的方法 软硬结合指用户态进程只能访问寄存器限制的内存，而核心态进程可以访问整个内存空间 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:1:5","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.6 存储管理方法 介绍分区、页式、段式与段页式三种存储管理方法，每种包括虚存的划分方式、页面置换算法、内存分配与回收算法等内容。不过，由于分区管理存在很多缺点，而且不被当前系统普遍使用，下面不进行介绍，仅在最后总结时放入表中。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:1:6","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 页式管理 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:2:0","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 基本原理 页式管理的基本原理是将虚存划分为若干长度相等的页（page），页长与内外存数据传输的速度和内存大小有关，一般约 1K~4K。经过页划分后，进程的虚拟地址就变成了页号 P 和页内地址 W 的组合，地址的高位部分是页号，低位部分是页内地址。 此外，页式管理还把内存空间也按页的大小划分为片或页面（page frame），操作系统为进程分配内存时，是以页面为单位的，页面内的地址连续，但不同的页面间不一定连续。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:2:1","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 地址变换 地址的转换和内存页面的分配使用页表、请求表和存储页面表三种表完成。 页表存放页号和与之对应的页面号，每个进程都有一个页表，对于一个大小为 20K，页长为 1K 的进程而言，只需要存放二十个页表项即可。页表在内存中有一块固定的存储区。 请求表描述系统内各进程的页表起始地址和长度，用来进行内存分配和地址转换。整个系统只需要一张请求表。页表和请求表的一个示例如下 存储页面表也是整个系统一张，它指出内存各页面是否已被分配出去，以及未分配页面的总数。它有两种表示方法 位示图法：在内存划分一块固定的区域，每个单元的比特代表一个页面，页面已分配则对应比特位置1，否则置0； 空闲页面链：队首页面第一个单元和第二个单元分别放入空闲页面总数和指向下一个空闲页面的指针，其它页面的第一个单元放入指向下一个页面的指针。 根据页号和页内相对地址变换得到内存物理地址的方法如下。 以一个例子来说明，设一个3页长的进程具有页号0、1、2，但其对应的页面号为2、3、8。设每个页面长度为1K，指令 LOAD 1，2500 的虚地址为100，地址转换过程为： 系统将所调度进程的页表始址和页表长度从请求表取出放入控制寄存器； 根据控制寄存器中的页表始址找到页表所在的位置，并由虚地址 100 得知指令在第 0 页的第 100 单元； 查页表得知第 0 页与 第 2 个页面对应，因此该指令在内存中的地址为 2048 + 100 = 2148； 当执行到第 2148 单元的指令，也就是 LOAD 1，2500，需要从有效地址 2500 中取数据放入 1 号寄存器。地址变换机构可以将 2500 转换为页号 2 和页内相对地址 452； 查页表得知第 2 页和第 8 个页面对应，因此数据在内存中的地址为 1024*8+452 = 8644. 整个变换的过程可以总结如下图 上述地址变换过程全部由硬件地址变换机构自动完成。另外，由于页表位于内存的某个固定区域，而取数据或指令又必须经过查询页表才能得到物理地址，因此取一个数据或指令至少要访问内存两次以上。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:2:2","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 页面置换算法 动态的页面管理使用前面提到的请求调入和预调入的办法，当硬件变换机构发现所要求的页不在内存时，产生缺页中断信号，有中断处理程序做出相应的处理。而如果内存没有空闲的页面还需要选择一定的置换算法淘汰已占据内存的页面。页面置换算法的选择直接影响内存利用率和系统效率。 页面置换算法的实质是将访问概率低的页面移出内存，常用算法有 随机淘汰算法：无法确定哪些页面访问概率较低，则随机选择一个页面淘汰； 轮转法：循环换出内存可用区内一个可以被换出的页，无论该页是刚被换进或已换进内存很长时间； 先入先出：总是选择在内存驻留时间最长的一页将其淘汰； 最近最久未使用：当需要淘汰某一页时，选择离当前时间最近的一段时间内最久没有使用过的页先淘汰。该算法的出发点是：如果某页被访问了，那么它可能马上还要被访问； 最不经常使用：最近最久未使用算法实现比较困难，因为要维护每个页面的访问记录，最不经常使用是一种简化，思路是淘汰到当前为止被访问次数最少的那一个，只需要在页表为每一页增加一个访问计数器即可； 最近没有使用：也是最近最久未使用的简化，思路是从最近一个时期内未被访问的页中随机选择一页淘汰，只需要在页表中增加一个访问标志即可。 理想算法：最理想的算法是淘汰再也不会出现或在离当前最远位置上的页，但这种无法实现。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:2:3","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 存储保护 页式管理可以为内存提供两种方式的保护。 地址越界保护可由地址变换机构中的控制寄存器的值—页表长度和所要访问的虚地址进行比较完成； 存取控制保护通过在页表中增加相应的保护位完成。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:2:4","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 段式管理 分区式和页式的虚存结构都是一维线性的，对程序或数据段的共享不友好，程序链接时 CPU 和 存储空间的开销也比较大，因此提出了段式管理。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:3:0","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 基本原理 段式管理的基本思路是：将程序的地址空间按内容或函数关系划分为若干个段(segment) ，每段有自己的名字。段与段之间没有顺序关系，也不要求连续，每一段的长度都是不固定的。 常见的逻辑段有四种，如下表 段名称 段的作用 段基地址 偏移地址 代码段 存放程序的指令序列 CS IP 堆栈段 确定堆栈所在的主存区域 SS SP 数据段 存放当前运行程序所用的数据 DS EA 附加段 附加的数据段，也用于保存数据 ES EA 程序的指令代码必须存放在代码段，否则将无法正常执行。程序利用代码段寄存器 CS获得当前代码段的段基地址，指令指针寄存器IP保存代码段中指令的偏移地址。处理器利用CS:IP取得下一条要执行的指令。 程序使用的堆栈（临时存放数据的区域）一定在堆栈段。程序利用SS获得当前堆栈段的段基地址，堆栈指针寄存器SP保存堆栈栈顶的偏移地址。处理器利用SS:SP操作堆栈数据。 一个程序可以使用多个数据段，便于安全有效地访问不同类型的数据。例如，程序的主要数据存放在一个数据段，只读的数据存放在另一个数据段，动态分配的数据安排在第3个数据段。 下面是一个简单的图示 每个段是一个首地址为零的，连续的一维线性空间，根据需要，段长可动态增长。对段式虚地址空间访问包括两个部分：段名（段号）和段内地址。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:3:1","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 地址变换 段式管理进行地址变换时，需要将段号和段内地址变换为实际物理地址，一般使用一种名为段表的数据结构。 一个考虑了缺段处理和段式访问控制的段表包括：段号、始址（段基址）、长度、存取方式、内外和访问位。其中段号与用户指定的段名对应，段基址是该段在内存的起始地址，长度是该段在外存的实际长度，存取方式用来进行存取保护，内外指该段出现在内存还是外存，访问位用于最近没有使用置换算法。 根据上图，过程可以描述如下 在内存分配一段固定的区域存放段表； 进程开始执行时，管理程序首先将该进程的段表始址放入段表地址寄存器，通过访问该寄存器开始访问段表； 由虚地址中的段号 1 查段表，得知该段在内存，然后判断存取控制方式是否匹配； 从段表中查到段基址位 3400，然后和段内地址 120 相加，得到实际内存地址 3520； 如果该段不在内存，就会产生缺段中断，将 CPU 交给内存分配程序。内存分配程序检查空闲区链，确定是否有足够长的空闲区来装入所需的段，如果不够，检查段表中的访问位，利用最近没有使用置换算法淘汰访问概率低的段，然后将需要的段调入。 和页式管理一样，由于段表的存在，也需要两次以上内存访问。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:3:2","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 段的共享与保护 段式管理可以方便的实现内存信息的共享与保护，因为段是按逻辑意义划分的，可以根据段名访问。 很多程序段和数据是被多个进程共享的，如果每个进程都保留它们的一个副本，就会造成极大的浪费，最好的办法就是只保留一个副本，供多个进程使用。这种共享在段式管理中可以很容易的使用相同的段名实现，在段表中填入已存在内存中的段的起始地址，并赋给适当的读写控制权，就可以共享该段的内容，而不是创建一个新的副本。注意，段式管理中有一部分段是共享的。 但是，共享段会面临进程同时执行该段的情况和置换到外存的需求，这两种情况通过设置相应的共享位实现。 段式管理对内存的保护和页式相同，也是使用地址越界保护法和存取方式控制保护法。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:3:3","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 段页式 段页式是将页式和段式管理相结合，充分利用它们的优点，不过，系统开销也更大。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:4:0","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 基本原理 段页式使用和段式相同的分段方式，但是，对每个段内的程序和数据按一定的大小划分成页。因此，段页式管理进程的虚地址由三部分组成：段号 s、页号 p 和页内相对地址 d。 段页式中，程序员可见的只有段号 s 和段内相对地址 w，p 和 d 是地址变换结构把 w 的高几位解释成页号 p，把剩下的低位解释成页内地址 d 而得到的。 由于虚存的最小单位是页而不是段，因此，内存的划分是以页为单位的。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:4:1","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 地址变换 段页式同时使用段表和页表，不过，页表不再归属某个进程，而是属于某个段。地址变换时，首先根据段表地址寄存器得到段表始址去访问段表，取出相应段的页表地址；然后访问页表得到所要访问的物理地址，最后才能访问真正的物理单元。因此，段页式存取内存中的指令和数据需要访问3次以上内存。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:4:2","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 局部性原理和抖动 程序的局部性原理：在一定时间内，进程集中在一组子程序或循环中执行，导致所有的存储器访问局限于进程地址空间的一个固定子集 时间局部性：一条指令的一次执行和下次执行以及一个数据的一次访问和下次访问都集中在一个较短的时间内 空间局部性：在一段时间内，程序和数据的访问都集中在一个较小区域内 抖动：置换算法选择不当，刚被调出内存的段或页马上又被调入内存，调入内存不久又被调出，如此反复。这使得整个系统的调度非常频繁，以致大部分时间都花费在内外存之间的来回调入调出上，这种现象被称为抖动。 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:5:0","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 总结 ","date":"2020-08-13","objectID":"/2020/operate-system-4-memory-management/:6:0","tags":["计算机基础"],"title":"操作系统4-存储管理","uri":"/2020/operate-system-4-memory-management/"},{"categories":["爱编程爱技术的孩子"],"content":"本文介绍操作系统最重要的一部分功能之一：进程管理，从进程的概念到进程的通信，再到死锁问题，最后结束进程的调度。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:0:0","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 进程与线程 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:1:0","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 进程 进程一个最简单的理解就是正在运行的程序，但与静态的程序只是简单的一段代码不同，进程在运行过程中会访问和影响系统的许多不同部分，这些部分包括 内存：进程对应的代码，它要读取和写入的数据都在内存中 寄存器：进程在执行指令时需要读取和更新寄存器 CPU：指令的执行需要 CPU 完成 其它：I/O 设备、文件句柄等 所有的这些统一构成了进程这个概念。我们可以很容易的理解，进程作为一个动态的概念，就需要完成创建、销毁、调度等许多工作，这些工作都由操作系统完成。操作系统完成这些工作依靠的是一个名为进程控制块（PCB）的结构，它是进程静态描述的一部分。 进程的静态描述分为三部分：程序、数据集、进程控制块（PCB）。 PCB 是进程动态特征的集中反映，也是系统感知进程的唯一途径，主要包括四部分： 进程描述信息：进程名、进程标识符、用户名、用户标识符，进程间的关系等 进程控制信息：进程当前状态，进程优先级，程序开始地址，各种计时信息，进程通信信息等 资源管理信息：内存管理、输入输出设备和文件系统的相关信息 CPU 现场保护结构 由于 PCB 包含的信息较多，其本身也不是常驻内存的，常驻内存的只有进程描述信息、控制信息和 CPU 现场保护等。 一开始的时候代码和数据位于外存，但进程创建时，操作系统就会把它们读入内存（尽管以前是一次性读入，但现在都是需要的时候才读入），然后为程序的运行时栈分配一些内存，用于存放局部变量、函数参数和返回地址，再为程序的堆分配一些内存，用于显式的内存申请。最后执行一些其它的初始化任务，比如与输入输出相关的，这些工作都完成后，操作系统开始启动程序并从入口处运行，将 CPU 的控制权移交新创建的进程，然后一条一条的执行对应的指令。 进程是资源分配的一个基本单位，但不是处理器调度的基本单位，调度的基本单位是线程。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:1:1","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 线程 每个进程的创建都要涉及大量的内存分配和初始化任务，进程之间的切换需要保持寄存器、堆栈、PCB等相关信息，当进程数量较多时，这部分开销会明显增大。为了减少进程创建和切换的开销，提高执行效率和节省资源，人们在操作系统中引入了「线程」的概念。 线程是进程的一部分，这一句话理解如下： 一个进程可以拥有一个或多个线程 线程自己不拥有资源，而是共享进程的地址空间和资源，它仅拥有一些控制信息、栈和寄存器状态信息，如下图 线程是计算机调度的基本单位。与进程相似的是，操作系统通过线程控制块（TCB）来管理线程。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:1:2","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 比较 拥有资源：进程是资源分配的基本单位，线程不拥有资源，但可以访问其所隶属的进程的资源（比如进程的代码段、数据段、打开的文件、I/O设备等） 调度：线程是处理器调度的基本单位。同一进程中，线程的切换不会引起进程切换，但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换 系统开销：进程创建、撤销、切换的开销显著大于线程。 通信：由于同进程内线程间共享进程的代码、数据、内存和文件资源，因此可以通过共享内存通信；而进程间的通信需要内核提供保护和通信所需机制 并发性：进程间可并发执行，同一进程的线程间也可以并发执行 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:1:3","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 进程状态及其转换 在进程的生命周期内，至少有5种基本状态：初始状态、执行状态、等待状态、就绪状态和终止状态。如下图 进程创建方式有两种：由系统根据任务统一创建和由父进程创建，创建的进程随后进入就绪态。 处于就绪状态的进程已经得到除 CPU 之外的所有其它资源，只要得到调度，就可以开始执行。 处于执行状态的进程由于时间片到期会转为就绪状态，继续等待调度，但如果产生了事件等待（比如键盘输入数据、其它进程产生的结果等），就会进入等待状态（也叫做阻塞状态）。 处于等待状态的进程等到自己需要的资源后，由系统或事件发生进程唤醒，进入就绪状态。 处于执行状态的进程可能由于如下几种原因终止：已完成所有的要求而正常终止、由于某种错误非正常终止、祖先进程要求终止。 终止状态完成如资源回收等后续处理工作。 注意：只有就绪态和运行态可以相互转换，其它都是单向的。 进程的状态信息记录在 PCB 中，另外，可以很清楚的看到，进程间的切换是一个必要的过程，进程从执行态离开意味着另一个进程开始了执行，而它本身可能并没有完成的所有的任务，这时候就需要保持进程离开前的执行状态。这就涉及到了进程上下文的概念。 进程的上下文是一个抽象的概念，指的是每个进程执行过的、执行时的以及待执行的指令和数据，在寄存器和堆栈中的内容。我们将已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为上文，正在执行的指令和数据在寄存器与堆栈中的内容称为正文，待执行的指令和数据在寄存器与堆栈中的内容称为下文。 当进程不发生调度时，上下文的切换是由线程产生的，仅包括指令寄存器、程序计数器、栈指针等，当发生进程间调度时，上下文的切换就会包括代码段、数据、PCB等。所以进程上下文主要分为三种 用户级上下文：代码、数据、栈 寄存器级上下文：PC、PSW的值、栈指针、通用寄存器的值 系统级上下文：PCB 结构 当进程从执行态换出时，其上下文被保持到内存中，当进程重新被调度时，就可以从内存读取这些值进行恢复。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:2:0","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 进程调度 进程调度的主要任务是按照某种策略和方法选取一个处于就绪状态的进程占用处理机。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:3:0","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 先来先服务 先来先服务（First Come First Serve, FCFS）的含义很容易理解，就像它的名字，先转换成就绪状态的进程在就绪队列中占据更靠前的位置，也先被调度。 但是，执行时间短的进程如果排在执行时间长的进程之后，可能会等待很长时间，这是不公平的。 FCFS 是一种非抢占式的调度。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:3:1","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 最短任务优先 可以用一种很简单的方式解决 FCFS 中的不公平现象，那就是让运行时间短的任务排在就绪队列的前面，先被调度。这叫做最短任务优先（Short Job First，SJF）。 这种方法的缺点是，执行时间长的进程可能永远得不到调度。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:3:2","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 最高响应比优先 最高响应比优先（Highest Response-ratio Next, HRN）是对 FCFS 和 SJF 的平衡，它同时考虑每个进程的等待时间长短和执行时间长短，从中选出响应比最高的进程投入执行。 响应比 R 定义为 $R = (W+T)/T = 1 + W/T$，其中 $T$ 是执行时间，$W$ 是等待时间。 这样，即使是长作业，随着等待时间的增加，优先级也会增加，从而得到调度机会。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:3:3","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 轮转法 前面三种算法的基本思路都是进程被调度后一直执行到任务完成，但我们通常还要考虑响应时间的问题，即要让所有执行的进程的响应时间都尽可能的良好。 轮转法（Round robin）用来解决响应时间问题，其基本思路是将 CPU 的处理时间划分为固定大小的时间片，如果一个进程在被调度选中后用完了自己的时间片还没有完成任务，就转为就绪状态并添加到就绪队列的末尾，同时，调度程序调度就绪队列的第一个进程。 轮转法的效率和时间片的长短有很大关系，时间片太短，频繁的上下文切换会影响系统性能，时间片过长，响应时间问题就不会得到改善。 轮转法可以看作一种基于CPU时间进行抢占的算法。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:3:4","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.5 优先级法 优先级算法是指系统或用户按某种原则为进程定义优先级，然后根据优先级决定进程的调度优先权。优先级的选取有两种类型 静态法：即根据进程的静态特征，在进程开始前就确定优先级，在进程执行时优先级不改变。有以下几种方法 由用户根据紧急情况给与优先级 由系统或管理员根据进程类型给与优先级，比如，可以分为 I/O 繁忙的、CPU繁忙的、两种均衡的等 系统根据资源需求的情况确定优先级，比如，根据预估的处理时间、内存大小等确定 动态法：将进程的静态和动态特征结合起来确定优先级，在进程执行过程中优先级会不断变化，由以下几种办法 根据进程占有 CPU 时间的长短来确定 根据就绪进程等待 CPU 时间的长短来确定 注意，动态法需要不断计算进程的优先级，所以具有一定的开销。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:3:5","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.6 多级反馈队列 前后的一些算法，如 FCFS、SJF 都需要知道进程将会运行多久，但实际上操作系统无法知道这一点。多级反馈队列（Multi-level Feedback Queue, MLFQ）采用的是一种根据历史数据缺点优先级的办法。 MLFQ 有多个独立的队列，每个队列有不同的优先级。任何时刻，一个进程只能存在于一个队列中，MLFQ 总是执行较高优先级队列中的进程。而且，同一队列的不同进程优先级是相同的。 进程可以简单的分两种：运行时间很短、频繁放弃 CPU 的交互型工作和需要很多 CPU 时间、响应时间不重要的长时间计算密集型工作。我们需要根据一些规则来调整它们的优先级 新加入的进程放在最上层的队列（具有最高的优先级） 进程用完一个时间片后，优先级降低一级（移入下一个队列） 如果进程在时间片未用完之前主动释放 CPU，优先级保持不变 这种设计对 长作业比较公平，又能给短作业和交互型工作很好的响应时间，但是一些进程可能被动或主动的经常提前释放 CPU 从而一直占据较高的优先级，解决办法是 经过一段时间，就将系统中的所有工作重新假如最高优先级 一旦进程用完了其在某一层的时间配额，就降低其优先级 多级反馈队列是一种较好的调度算法，对各种情况都有比较好的性能，也是大多数系统目前使用的调度算法。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:3:6","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 进程的同步与互斥 由于计算机资源的有限，进程之间存在资源竞争和共享的情况。 如果多个不同进程访问同一段数据，那么把访问公共数据的这段程序叫做临界区。 互斥就是多个进程在同一时刻只有一个能进入临界区，同步就是并发执行的进程的执行条件与对方的执行结果有关，从而产生的执行的先后顺序。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:4:0","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 互斥 互斥的实现办法一般是对临界区加锁，从而保证同一时间只有一个进程处于临界区。 然而，加锁法需要进程自己判断是否存在锁，这样可能出现不公平。举个例子说明，加入某个学生想使用某个人人都可以借用，且不规定使用时间的教室，他必须首先申请获得使用该教室的权利，然后再到教室看看教室是不是被锁上了，如果被锁上，他只好下次再来观察，这种观察持续到它进门为止。然而，两次观察期间，可能被其它获得申请的学生抢占，可能永远得不到使用权。 一种方法是设置一个管理员，记录所有获得申请在等待的学生名字，一旦教室空闲，就通知学生，这样就减少了学生多次检查的时间，也避免了可能出现饥饿情况。操作系统中，这个管理员就是信号量（Semaphore）。 在操作系统中，信号量 sem 是一个整数，在 sem 大于等于零的时候代表可供并发进程使用的资源实体数，在 sem 小于零的时候代表正在等待使用临界区的进程数。当信号量用于互斥时，应声明其所代表的含义，并设置一个大于零的初值。 信号量的数值仅能通过 P、V 原语改变，这两个原语操作的过程如下 P 原语 sem 减 1 若 sem 减 1 后仍大于或等于零，则 P 原语返回，该进程继续执行 若 sem 减 1 后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转进程调度 V 原语 sem 加 1 若相加结果大于零，V 原语停止执行，该进程返回调用除，继续执行 若相加结果小于或等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转进程调度 可以看到，P、V 原语使用队列避免了加锁法不断的尝试操作，但要注意的是，P 原语的操作持续到进程从等待队列中被取出执行后才完成。最后，P、V 使用原语实现，是因为 P 和 V 的操作都是一系列步骤，如果中间被打断，比如减 1 后为调入队列，就会导致不一致性。 原语特性的实现可以使用加锁法。以 P 原语为例 begin 封锁中断 lock(lockbit) val[sem] = val[sem]-1 if val[sem] \u003c 0 保护当前进程 CPU 现场 当前进程状态置为“等待” 将当前进程插入信号 sem 等待队列 转进程调度 fi unlock(lockbit) 开放中断 end 假设信号量的取值范围为 -1, 0, 1，实现两个并发进程 $P_A$ 和 $P_B$ 互斥的描述如下：信号量初值设为 1 表示没有并发进程使用该临界区，当一个进程想要进入临界区时，执行 P 原语操作将信号量减 1，此时信号量为 0，所以进程进入临界区开始执行。在该进程未执行 V 原语操作释放资源前，如果另一个进程想进入临界区，同样限制性 P 原语操作，将信号量减1，此时等于 -1，因此被阻塞进入等待队列。当第一个进程执行完毕，调用 V 原语操作将信号量加1，信号量的值变为0，第二个进程就被唤醒进入就绪队列，然后经由调度开始执行。第二个进程执行完 V 原语操作后，如果没有其它进程申请进入临界区，则信号量恢复到初始值。 typedef int semaphore; semaphore sem = 1; void PA() { P(sem); // 临界区 V(sem); } void PB() { P(sem); // 临界区 V(sem); } ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:4:1","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 同步 互斥是进程间对公共资源的竞争，同步则是进程间的另一种制约关系，比如一个进程的输出结果是另一个进程的执行条件，而且这种情况在操作系统中是普遍存在的。 一种解决办法是相互制约的进程互相给对方进程发送执行条件已具备的信号，这个信号被称为消息或事件，也可以当作信号量看待。但这里的信号量与互斥使用的信号量不同的是，它仅与相互制约的两个进程有关，而不是和所有并发执行的进程有关。 假设计算进程 $P_c$ 和 打印进程 $P_p$ 合作完成计算和打印任务，它们使用一个缓冲区队列来传递数据，数据的发送和接收满足如下条件 $P_c$ 至少送一块数据进入缓冲区前，$P_p$ 不可能从缓冲区取出数据 $P_c$ 往缓冲队列送数据时，至少有一个缓冲区是空的 由 $P_c$ 发送的数据块在缓冲区队列中按 FIFO 方式排列 我们设信号量 Buffull 表示缓冲队列满，初始值为 n（缓冲队列的缓冲区长度）；设信号量 Bufempty 表示缓冲队列空，初始值为 0。那么进程同步的过程可以描述如下 #define N 100typedef int semaphore; semaphore Buffull = N; semaphore Bufempty = 0; void PC() { P(Bufempty); 按 FIFO 方式选择一个空缓冲区 数据送入缓冲区 V(Buffull); } void PP() { P(Buffull); 按 FIFO 方式选择一个装满数据的缓冲区 数据取出缓冲区 V(Bufempty) } ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:4:2","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.3 生产者-消费者问题 将并发进程的互斥与同步问题一般化，就可以得到一个抽象的一般模型，即生产者-消费者问题（producer-consumer problems）。 计算机系统中，每个进程都申请使用和释放各种不同类型的资源，这些资源可以是外设、内存及缓冲区等硬件资源，也可以是临界区、数据和例程等软件资源。我们把系统中使用资源的进程称为该资源的消费者，而把释放资源的进程称为资源的生产者。 在计算进程 $P_c$ 和打印进程 $P_p$ 共用缓冲区的例子中，计算进程把数据送入缓冲区，是生产者，打印进程从缓冲区取数据打印输出，是消费者。4.2 节已经给出了同步的例子，在此基础上，我们假设有界缓冲区是临界资源，那么生产者进程和消费者进程就必须互斥执行，因此我们添加一个互斥信号量 mutex。将整个过程描述如下 #define N 100typedef int semaphore; semaphore Buffull = N; semaphore Bufempty = 0; semaphore mutex = 1; void PC() { P(Bufempty); P(mutex); 按 FIFO 方式选择一个空缓冲区 数据送入缓冲区 V(Buffull); V(mutex); } void PP() { P(Buffull); P(mutex); 按 FIFO 方式选择一个装满数据的缓冲区 数据取出缓冲区 V(Bufempty); V(mutex); } 注：多个信号量的 P、V 原语操作次序很重要，次序混乱可能造成死锁。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:4:3","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 进程通信 进程间通信指的是进程间控制信息或大批量数据的传送，控制信息一般只传送一个或几个字节，因此也叫做低级通信，数据传送则需要进行大量数据交换，叫做高级通信。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:5:0","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 信号量 进程间互斥与同步使用的信号量是通信方式的一种，而且是低级通信。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:5:1","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 共享存储区 系统在存储中划出一块共享存储区，各进程间可通过对共享存储区中的数据进行读或写来实现通信 进程在通信之前应向系统申请共享存储区中的一个分区，并指定该分区的关键字，若系统已经给其他进程分配了这样的分区，则将该分区的描述符返回给申请者。接着，申请者把获得的共享存储区连接到本进程上，此后就像读写普通存储器一样。 共享存储区不要求数据移动，因此通信比较快。 共享存储区是一种高级通信。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:5:2","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5.3 消息缓冲 系统设置一组缓冲区，其中每个缓冲区可以存放一个消息。 当发送进程需要发送消息时，执行 send 系统调用，操作系统为发送进程分配一个空缓冲区，并将所发送的消息从发送进程 copy 到缓冲区中，然后将该载有消息的缓冲区连接到接收进程的消息链链尾，如此就完成了发送过程。 在以后某个时刻，当接收进程执行到receive接收原语时，由操作系统将载有消息的缓冲区从消息链中取出，并把消息内容copy到接收进程空间，之后收回缓冲区，如此就完成了消息的接收。 缓冲区应当是一个公共资源，因此，应当设立信号量来实现进程间的互斥操作。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:5:3","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"5.4 管道 管道（pipe）是一条在进程间以字节流方式传送消息的通信通道。 逻辑上，我们可以将管道看作一个文件；物理上，管道利用文件系统的高速缓冲区来实现。 使用管道前必须建立管道，然后由发送进程调用文件系统的系统调用 write(fd[1], buf, size) 将 buf 种长度为 size 的消息送入管道入口 fd[1]，由接收进程使用系统调用 read(fd[0], buf, size) 从管道入口 fd[0] 读出 size 个字符到 buf 中。 我们可以举一个父进程和子进程利用管道通信的例子 #include\u003cstdio.h\u003emain() { int x,fd[2]; char buf[30],s[30]; pipe(fd); // 创建管道 while((x=fork())==-1); // 创建子进程失败则循环 if(x==0){ sprintf(buf,\"this is an example\\n\"); write(fd[1],buf,30); // 把 buf 中的字符写入管道 exit(0) }else{ // 父进程返回 wait(0); read(fd[0],s,30); // 父进程读管道中的字符 printf(\"%s\",s); } } 管道按 FIFO 方式传送消息，而且只能是单向的。 上面描述的管道叫做无名管道，只能用于父子进程之间或父进程安排的各个子进程之间，还有一种叫做命名管道，用于 Server-Client 模式的通信。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:5:4","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 死锁 死锁是指各并发进程互相等待对方所拥有的资源，且这些并发进程在得到对方的资源之前不会释放自己所拥有的资源，从而造成大家都想得到但都得不到资源的情况。 死锁的起因是并发进程的资源竞争，产生死锁的根本原因是系统提供的资源个数少于并发进程所要求的该类资源数。 解除死锁的方法一般分为预防、避免、检测和恢复三种 预防：预防是采用某种策略，限制并发进程对资源的请求，从而使得死锁产生的条件在任何时刻都不满足； 避免：避免是指系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生； 检测和恢复：设置专门的机制，在死锁发生时检测发生的位置和原因，然后通过外力破坏死锁条件，解除死锁的方式。 一般来说，通过预防和避免的手段解除死锁比较困难，而且需要较大的系统开销，实际通常使用检测与恢复的方法。 ","date":"2020-08-10","objectID":"/2020/operate-system-3-process-management/:6:0","tags":["计算机基础"],"title":"操作系统3-进程管理","uri":"/2020/operate-system-3-process-management/"},{"categories":["爱编程爱技术的孩子"],"content":"本文介绍操作系统的一个重要功能：提供用户接口。 作业是批处理系统的一个概念，指的是从输入开始到输出结束计算机所做的关于该任务的所有工作，作业由作业步组成，作业步是一个作业的处理过程中计算机所做的相对独立的工作。目前的系统中，可以使用批处理文件或 shell 程序的方式控制产生并控制作业的执行。 计算机系统有三种用户：普通用户使用系统，管理员用户管理计算机，程序开发人员使用系统提供的功能开发新的应用。 操作系统为用户提供两种接口。一个是命令接口，用户使用它们控制和组织作业的执行或管理计算机系统；另一个是系统调用，编程人员使用它们请求操作系统提供服务。 用户与系统主要有两种交互方式。脱机方式指实现利用批处理文件等对作业执行顺序和出错处理方式等进行说明，然后一次性执行，执行过程用户无法干涉，对 windows 就是 bat 文件或 powershell 脚本，对 Linux 就是 shell 文件；联机方式是指用户通过键盘等输入命令，交互式地控制操作系统，windows 使用 cmd 或 powershell，linux 使用 bash。 图形界面并不是一种新的交互方式，其实质是将一系列鼠标和键盘操作转换为各种操作系统命令，和直接执行各种命令并无区别，只是对用户更友好。 系统调用是操作系统提供给编程人员的唯一接口，编程人员通过系统调用使用操作系统内核所提供的各种功能。一般来说，系统调用在核心态下执行，用户程序在用户态下执行，可以通过下图简单理解 以前，操作系统的功能全部位于内核中，是一个整体，称为大内核。但由于操作系统不断复杂，逐渐将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立，这就是微内核结构。在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。 ","date":"2020-08-09","objectID":"/2020/operate-system-2-user-interface/:0:0","tags":["计算机基础"],"title":"操作系统2-用户接口","uri":"/2020/operate-system-2-user-interface/"},{"categories":["爱编程爱技术的孩子"],"content":"本文介绍操作系统的概念、历史、分类、功能及理解这些功能的必备基础知识。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:0:0","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 概念 计算机是硬件与软件的统一，没有任何软件的计算机称为裸机，在裸机上运行的是操作系统，在操作系统上运行的是各种应用软件。理解操作系统只需要理解两件事 操作系统用于向用户提供服务，构建一个用户和计算机之间的交互环境； 操作系统可以合理的组织计算机工作流程，管理和分配计算机系统软硬件资源； 这两点一个从用户的角度看，一个从管理员的角度看，但操作系统的所有功能都与此息息相关，后面会意识到。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:1:0","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 历史与分类 随着计算机的发展，操作系统也经历了一个发展过程：手工操作（无操作系统）、批处理、执行系统、多道程序系统、分时系统、实时系统、通用操作系统、网络操作系统和分布式操作系统。 从手工操作到多道程序系统的演进都是由于对 CPU 使用效率提高的追求，从分时系统开始，操作系统开始步入了应对不同使用场景而发展的时代，比如，分时系统是为了在保证 CPU 利用率的同时方便用户的使用，实时系统是为了保证计算机的快速处理和响应，通用操作系统则是为了减少开发成本，适用于大多数情况。 网络操作系统和分布式操作系统都是随着大规模集成电路的发展而出现的。前者的目的是将物理上分散的多个计算机系统联合起来，实现信息交互、资源共享、互操作等功能，但在互联网普及后，以及不再具有单独的网络操作系统分类，理论上，我们使用的可以上网的计算机都可以称作网络操作系统。后者指的是对网络中计算机进行统一管理的网络管理系统。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:2:0","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 功能 根据我们的理解，操作系统的职能就是管理和控制计算机的软硬件资源，合理组织计算机工作流程，并向用户提供交互接口。而计算机的硬件资源注意包括处理机、存储器、输入输出设备，软件和信息往往以文件形式存储在存储器中，所以操作系统的功能主要包括 处理机管理 存储管理 设备管理 文件管理 用户接口 注意，处理机是计算机存储程序和数据，并按步骤执行程序所涉及的各部分硬件的总和，包括CPU、主存储器、输入输出接口等，不是单纯的CPU，不过，在介绍处理机管理时，通常介绍的都是进程、线程及他们的调度。所以我们之后直接将处理机管理称为进程管理和调度，不再用处理机管理这个名词。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:3:0","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 基础知识 这些基础知识是之后理解操作系统五大功能的前提。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:4:0","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 计算机基本硬件 构建计算机的基本元素包括：处理器、存储器、输入输出设备与总线、外部设备，如下图 处理器控制和执行计算机的指令操作，存储器存储数据和程序，输入输出控制器与缓冲器用于控制和暂时存储外部设备和计算机内存之间交换的数据和程序，总线连接各种设备。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:4:1","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 寄存器 寄存器在操作系统的运行过程中非常重要，它们可分为用户可编程寄存器和控制与状态寄存器两类。 用户可编程寄存器又可分为： 数据寄存器：一般用于临时存储计算过程中涉及的数据； 地址寄存器：存放内存中某个数据或指令的地址，或者存放某段数据或指令的入口地址，以及用于地址计算，下面几种都属于地址寄存器 地址标识位寄存器 内存管理用各种始地址寄存器 堆栈指针 设备地址寄存器 标志寄存器：存放计算产生的正、负、零、溢出等标志信息 控制与状态寄存器又可分为 程序计数器（PC）：存放下一周期被执行的指令地址 指令寄存器（IR）：存放当前待执行的指令 程序状态字寄存器（PSW）：各比特位代表不同状态，比如是否允许中断 中断现场保护寄存器：如名，允许中断时保持被中断的程序现场 过程调用堆栈：存放过程调用时产生的调用名、调用参数和返回地址等 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:4:2","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"4.3 存储器 计算机的存储器并不是单一的，从寄存器到高速缓存，再到内存、硬盘缓存、硬盘、可移动存储介质，虽然不断离开计算机系统的核心，访问速度逐渐变慢，但是单位存储的成本也越来越低。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:4:3","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"4.4 指令执行与中断 若论计算机最基本的执行单位，那就是指令，所有的程序最终都会转换为一条条的指令来执行。指令的执行过程分两步：读指令和执行指令。读指令是根据程序计数器存储的地址从内存读入，执行指令是执行指令寄存器中的内容。指令的读入与执行称为一个指令周期。 另外，在指令的执行过程中或一条指令执行结束时，尽管指令地址计数器中已指明下一条被访问指令的地址，但是，计算机外部或内部可能会发来亟待处理的数据或其它紧急事件处理信号。这就需要处理机暂停正在执行的程序，转去处理相应的紧急事件，待处理事件完毕后再返回原处继续执行，这一过程叫中断。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:4:4","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"4.5 并发与并行 并发是指宏观上在一段时间同时运行多个程序，但在微观上仍然是串行的，各道程序轮流使用 CPU，交替执行。 并行是指同一时刻能运行多个程序，并行需要多核等硬件支持 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:4:5","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"4.6 操作系统启动 计算机电源启动时，硬件自动触发一个中断信号，这个中断信号使得 CPU 中一段指令开始执行，这段指令的作用是找到外部存储设备中操作系统的引导区，然后引导区的代码被自动导入内存并开始执行。引导区代码的作用是将操作系统加载到内存的指定区域，并初始化计算机的相关硬件如寄存器、终端设备等。当操作系统全部加载到内存后，操作系统就开始启动，为用户提供相应的操作界面和功能。 ","date":"2020-08-09","objectID":"/2020/operate-system-1-overview/:4:6","tags":["计算机基础"],"title":"操作系统1-概述","uri":"/2020/operate-system-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"win10 一些重复操作的自动化，主要利用 Powershell 和windows任务计划程序，运行环境为 Windows 10 和 PowerShell 7.1，低版本 PowerShell 可能有中文路径无法识别问题。 ","date":"2020-08-08","objectID":"/2020/efficient-use-of-win10-7-automation/:0:0","tags":["Win10"],"title":"win10效率优化8-自动化","uri":"/2020/efficient-use-of-win10-7-automation/"},{"categories":["爱编程爱技术的孩子"],"content":"照片备份 手机拍摄的照片会在每月末保存到电脑中，为了进行备份，我希望照片能将照片进行加密压缩并替换Onedrive中的旧版本。 考虑使用 7zip 的命令行工具 7z进行加密压缩，在每月初备份一次，创建名为 Backup-photos.ps1 的文件，写入如下命令 if (Test-Path D:/OneDrive/图片/照片.7z) { Remove-Item D:/OneDrive/图片/照片.7z } 7z a \"D:/OneDrive/图片/照片.7z\" \"D:/照片/*\" -r -mhe=on -p3BB82427 脚本编写完成后，右键开始菜单，选择「计算机管理」，进入任务计划程序，执行如下步骤 创建名为「备份照片」的任务，填入任务描述； 新建触发器，选择「按预定计划」，勾选「每月」，然后选择所有月份的第一天； 新建操作，选择「启动程序」，在「程序和脚本」栏中写入「pwsh.exe」，「添加参数」中写入「-nop -w hidden -file “D:\\OneDrive\\应用\\Powershell\\Backup-photos.ps1”」。-w hidden 会让脚本执行时终端只闪烁出现一次立刻消失。注意，如果提示无法找到文件，那么输入 pwsh.exe 在C盘的完整路径； 取消勾选条件中的「只有计算机使用交流电源时才启动任务」，在设置中勾选「允许按需运行任务」和「如果过了计划时间，立即启动任务」，使错过设定的时间时任务也可以运行。 随后的几种场景的 windows 计划任务设置与之相似，周期任务一类不再重复介绍，如果出现定时任务和事件任务会介绍其不同。 ","date":"2020-08-08","objectID":"/2020/efficient-use-of-win10-7-automation/:1:0","tags":["Win10"],"title":"win10效率优化8-自动化","uri":"/2020/efficient-use-of-win10-7-automation/"},{"categories":["爱编程爱技术的孩子"],"content":"电影重命名 从电影天堂下载的电影总是带有 [电影天堂www.dytt89.com] 的前缀，希望能够将这个前缀删除掉。 因为目前没有找到办法检测指定文件夹的文件变化，所以依然采用定期重命名的方式，脚本如下 $curPath = \"D:\\电影\" Get-ChildItem $curPath | Rename-Item -NewName {$_.Name -replace '\\[电影天堂www.dytt89.com\\]',''} 其中，Get-ChildItem 可以获取当前文件夹中所有文件，然后将它们通过管道传递给 Rename-Item。NewName 的值是一个脚本块，在将值提交给 NewName 参数之前运行。在脚本块中，$ _ 自动变量代表每个文件对象，它们通过管道传递给命令。脚本块使用 -replace 运算符将每个文件的前缀替换为空。请注意，使用 -replace 运算符进行的匹配不区分大小写。 ","date":"2020-08-08","objectID":"/2020/efficient-use-of-win10-7-automation/:2:0","tags":["Win10"],"title":"win10效率优化8-自动化","uri":"/2020/efficient-use-of-win10-7-automation/"},{"categories":["爱编程爱技术的孩子"],"content":"windows聚焦壁纸保存 每天换一次的windows聚焦的锁屏壁纸非常好看，希望能定期将这些壁纸保存到 Onedrive 的壁纸文件夹，主要使用 Powershell 的 Copy-Item 和 Rename-Item 命令，脚本如下 $temPath = \"C:\\Users\\shuzang\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\\LocalState\\Assets\\*\" Get-ChildItem $temPath | Rename-Item -NewName {$_.BaseName + \".jpg\"} Copy-Item -Path $temPath -Destination \"D:\\OneDrive\\图片\\壁纸\\wallpaper\" Get-ChildItem $temPath | Rename-Item -NewName {$_.Name -replace \".jpg\",\"\"} ","date":"2020-08-08","objectID":"/2020/efficient-use-of-win10-7-automation/:3:0","tags":["Win10"],"title":"win10效率优化8-自动化","uri":"/2020/efficient-use-of-win10-7-automation/"},{"categories":["爱编程爱技术的孩子"],"content":"参考文献 [1] 少数派，Windows 本地自动化工具，任务计划程序应用举例，Accessed: 2021-05-07. [2] 7-Zip manual，a (Add) command，Accessed：2021-05-07. [3] Microsoft Doc，Rename-Item (Microsoft.PowerShell.Management)，Accessed：2021-05-07. ","date":"2020-08-08","objectID":"/2020/efficient-use-of-win10-7-automation/:4:0","tags":["Win10"],"title":"win10效率优化8-自动化","uri":"/2020/efficient-use-of-win10-7-automation/"},{"categories":["爱编程爱技术的孩子"],"content":"奇安信的笔试遇到了完全背包问题，结果写的时候按 0-1 背包写的贪心，最后没 AC，因此本篇对所有的背包问题做一次整理。 ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:0:0","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 0-1 背包 问题描述如下 有 n 个物品和一个容量为 W 的背包，每个物品有重量 $w_i$ 和价值 $v_i$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。 解决该问题实际上可以用我们学到的所有算法，下面做一点解释 ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:1:0","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 递归 选择装入背包的物品时，每种物品 $i$ 只有两种选择：装入或不装入。不能将物品 $i$ 装入背包多次，也不能只装入部分物品，我们用 $x_i$ 表示对第 $i$ 个物品的选择，$x_i=1$ 表示选择该物品，$x_i=0$ 表示不选择该物品。这样，对所有的物品，我们就有了一个解集 $(x_1,x_2,……,x_n)$，最终的目标是求得 $max \\sum_{i=1}^n v_i x_i$，并且可以将问题写成如下的数学形式 $$ \\sum_{i=1}^n w_i x_i \\leq c \\\\ x_i \\in \\{0,1\\}, 1 \\leq i \\leq n $$ 接下来定义子问题，假设 $m(i,j)$ 代表当前背包剩余容量为 $j$ 时，可选物品为 $i,i+1,…,n$ 时的最大总价值，那么对于第 i 个物品，有两种可能 背包剩余容量不足以容纳该物品，此时背包总价值不会变，$m(i,j) = m(i+1,j)$ 背包剩余容量可以装下该物品，此时如果装物品，总价值会变为 $m(i+1,j-w_i)+v_i$，如果不装该物品，总价值为 $m(i+1,j)$，需要选择两者中总价值更大的那一个 综上我们就得到了递推关系式，然后我们还可以确定边界条件为剩余物品只有一个，也就是 $m(n,j)$，如果能装下第 $n$ 个物品，$m(n,j)=v_n$，否则 $m(n,j)=0$，这样就得到了下面的程序 package main import ( \"fmt\" ) func main() { var ( v = []int{12, 10, 20, 15} w = []int{2, 1, 3, 2} ) var Knapsack_Recurrence func(i, j int) int Knapsack_Recurrence = func(i, j int) int { res := 0 // 边界条件：只有一个物品 if i == len(v)-1 { if w[i] \u003e j { res = 0 } else { res = v[i] } } else if w[i] \u003e j { // 装不下当前物品 res = Knapsack_Recurrence(i+1, j) } else { // 可以装下当前物品 t1 := Knapsack_Recurrence(i+1, j) t2 := Knapsack_Recurrence(i+1, j-w[i]) + v[i] if t1 \u003e t2 { res = t1 }else{ res = t2 } } return res } fmt.Println(Knapsack_Recurrence(0, 5)) } // Output: 37 这里时间复杂度为 $O(2^n)$，空间复杂度为 $O(n)$ ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:1:1","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 动态规划 动态规划解法与递归法的区别在于使用数组来存储计算的中间值，从而减少重复计算，上面的递推关系式就是现成的状态转移方程。那上面程序中的输入举例，物品数量为 4，背包容量为 5，问题分析和绘制的动态规划数组如下 编写程序如下 package main import ( \"fmt\" ) var ( v = []int{12, 10, 20, 15} w = []int{2, 1, 3, 2} ) func main() { fmt.Println(Knapsack_dp(4, 5)) } func Knapsack_dp(N, C int) int { // 状态数组初始化 dp := make([][]int, N) for i := 0; i \u003c N; i++ { dp[i] = make([]int, C+1) } // 边界条件 for i, j := N-1, 1; j \u003c= C; j++ { if w[i] \u003e j { dp[i][j] = 0 } else { dp[i][j] = v[i] } } // 填写状态数组, 自底向上，自左到右 for i := N - 2; i \u003e= 0; i-- { for j := 1; j \u003c= C; j++ { if w[i] \u003e j { dp[i][j] = dp[i+1][j] } else { dp[i][j] = max(dp[i+1][j], dp[i+1][j-w[i]]+v[i]) } } } return dp[0][C] } func max(a, b int) int { if a \u003e b { return a } return b } // Output: 37 动态规划的时间复杂度为 $O(NC)$，空间复杂度为 $O(NC)$，如果背包容量很大，比如达到了 $2^N$ 基本，性能反而会不如递归方法。 动态规划数组可以进一步优化，主要是因为我们在计算时实际上只用到了前一行的数据，因此二维数组可以简化为一维数组，空间复杂度可以缩减到 $O(C)$ ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:1:2","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 贪心 贪心解背包问题就是另一种思路了，核心是选择贪心的策略，这里主要使用价值重量比策略。我们可以将过程总结为三步 计算每种物品单位重量的价值 $v_i/w_i$，$O(n)$ 将计算得到的价值重量比按降序排列 将尽可能多的单位重量价值最高的物品装入背包，$O(nlogn)$ 下面解决的问题实际上是背包的一种情况，即物品装入背包时可以选择背包的一部分，而不是必须全部装入。程序实现如下 package main import ( \"fmt\" \"sort\" ) type item [][3]int func (this item) Len() int { return len(this) } func (this item) Swap(i, j int) { this[i], this[j] = this[j], this[i] } func (this item) Less(i, j int) bool { return this[j][0] \u003c this[i][0] } var ( v = []int{12, 10, 20, 15} w = []int{2, 1, 3, 2} ) func main() { fmt.Println(Knapsack_greedy(4, 5)) } func Knapsack_greedy(N, C int) int { res, i := 0, 0 // 计算价值重量比，并存入解数组，解数组每个元素是长度为3的数组 // 其中，第一个为比值，第二个为物品价值，第三个为物品重量 x := make(item, 0) for i = 0; i \u003c N; i++ { x = append(x, [3]int{v[i] / w[i], v[i], w[i]}) } // 对价值重量比进行降序排列 sort.Sort(x) // 按序装入背包 for i = 0; i \u003c N; i++ { if x[i][2] \u003e C { break } res += x[i][1] C -= x[i][2] } // 装入第 i 个物品的一部分 if i \u003c N { res += C * x[i][0] } return res } // Output: 37 时间复杂度为 $O(N)$，空间复杂度为 $O(N)$ ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:1:3","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 回溯 回溯也是解背包问题的一种方法，可以和递归法进行对比，递归法其实就相当于对解空间树进行了一次搜索，回溯的目的是减小搜索空间。 设物品重量为 $w=[16,15,15]$，物品价值为 $v=[45,25,25]$，背包容量 $c=30$。定义 $r$ 为当前背包的剩余容量，$v$ 为当前背包的价值。因为物品有 3 个，所以树深为 3+1=4，又因为每个解元素有两种取值，1为放入背包，0为不放入，所以每个结点有两棵子树，最终解空间树绘制如下 约束和限界函数描述如下 约束函数：就是不可行的解，比如上图第二层第一个结点，r=14，小于当前物品重量 15，因此所有子树都不可行； 限界函数：就是非最优解，比如上图虚线框起来的结点，因为之前得到的最大价值为 v=50，这里出现的 v 都小于该值，所以不是最优解。右子树价值上界的判断使用的是价值重量比的贪心策略。 算法如下 ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:1:4","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["爱编程爱技术的孩子"],"content":"1.5 分支限界 如果回溯能解，那么分支限界就能解 首先检查当前扩展结点的左儿子结点(x[i]=1)的可行性。 如果该左儿子结点是可行结点，则将它加入到子集树 和活结点优先队列中。 当前扩展结点的右儿子结点(x[i]=0)一定是可行结点，仅 当右儿子结点满足上界约束时才将它加入子集树和活 结点优先队列。 节点的优先级由上界函数来决定，即已装袋的物品价值与剩下 的最大单位重量价值的物品装满剩余容量的价值之和。 当扩展到活结点优先队列中的叶结点时得到问题的最 优解。 ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:1:5","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 完全背包 完全背包问题相比于01背包的区别就是，只要背包装的下，每个物品可以选任意次，而不是只有一次。 此时解向量的值不再是0或者1，而是有了多种可能，注意的是，这里物品不能只装入一部分，因此贪心算法是不可用的。举个反例也非常简单：假设有两个物品A和B，价值分别为5和8，重量分别为5和7，背包容量为10，物品B的价值重量比显然更高，所以贪心算法会放入一个物品B，此时剩余容量不足以放下 A或者B，得到的总价值为8，但实际上，放入两个 A 可以得到更高的价值10。 我们用动态规划求解，$m(i,j)$ 依然代表当前背包剩余容量为 $j$ 时，可选物品为 $i,i+1,…,n$ 时的最大总价值，对于第 $i$ 中物品，我们有 $k$ 种选择，这样得到状态转移方程 $$ m(i,j) = max{m(i+1,j-w_ik)+v_ik}; 0 \\le w_ik \\le j $$ 实质就是0-1背包加一层选择物品数量的循环，程序如下 package main import ( \"fmt\" ) var ( v = []int{12, 10, 20, 15} w = []int{2, 1, 3, 2} ) func main() { fmt.Println(Knapsack_dp(4, 5)) } func Knapsack_dp(N, C int) int { // 状态数组初始化 dp := make([][]int, N) for i := 0; i \u003c N; i++ { dp[i] = make([]int, C+1) } for i, j := N-1, 1; j \u003c= C; j++ { k := 0 for k*w[i] \u003c= j { k++ } dp[i][j] = (k - 1) * v[i] } // 填写状态数组, 自底向上，自左到右 for i := N - 2; i \u003e= 0; i-- { for j := 1; j \u003c= C; j++ { for k := 0; k*w[i] \u003c= j; k++ { dp[i][j] = max(dp[i+1][j], dp[i+1][j-k*w[i]]+k*v[i]) } } } return dp[0][C] } func max(a, b int) int { if a \u003e b { return a } return b } // Output: 50 拿上面程序中的测试用例来看，dp 数组绘制如下，数组的格式也是相同的，不同的就是填充每一个元素时是挑选了可得到的最大值填充的。 和01背包一样，dp 数组也可以优化为一维数组。 ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:2:0","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 多重背包 多重背包问题是在完全背包的基础上又加了一个条件，那就是每个物品的数量是有限制的，不再是只要背包放得下，就可以无限地往里放。 很容易我们就会发现，解题的程序基本和完全背包没什么区别，只是在填充元素选择最优值时要对物品数量进行判断，不能超过物品数量上限，这里就写程序了。 https://www.cnblogs.com/mfrank/p/10533701.html ","date":"2020-08-06","objectID":"/2020/algorithm-knapsack-problem/:3:0","tags":["数据结构与算法"],"title":"算法-背包问题","uri":"/2020/algorithm-knapsack-problem/"},{"categories":["Golang学习之路"],"content":"调度器和垃圾回收都属于 runtime 的一部分，本文我们介绍 Go 中 runtime 的含义，然后再来分析 Go 的调度器和垃圾回收策略。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:0:0","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"1. runtime runtime，直译为运行时，之前只听说过这个概念，但要解释 runtime 究竟是什么，还是说不出口。我从 Go 官方文档的问答里找到了下面这段话，可以作为一个很好的开始。 Go does have an extensive library, called the runtime, that is part of every Go program. The runtime library implements garbage collection, concurrency, stack management, and other critical features of the Go language. Although it is more central to the language, Go’s runtime is analogous to libc, the C library. It is important to understand, however, that Go’s runtime does not include a virtual machine, such as is provided by the Java runtime. Go programs are compiled ahead of time to native machine code (or JavaScript or WebAssembly, for some variant implementations). Thus, although the term is often used to describe the virtual environment in which a program runs, in Go the word “runtime” is just the name given to the library providing critical language services. Go 的运行时是每个 Go 程序的一部分，负责实施垃圾回收、并发、栈管理以及其它 Go 的一些核心特性。但是，尽管这些都是一个语言的核心，runtime 在 Go 中实际上是一个库（标准库的一个）。理解这一点很重要，因为在其它一些语言中，比如 Java，runtime 实际上包含一个虚拟机的概念，是程序运行的环境，但在 Go 中 runtime 就仅仅是一个包含一些关键特性的库。 这里已经说的比较清楚了，接下来我们来看 runtime 库包含哪些东西，实际上，runtime 库下面还有几个子库 runtime/cgo：用来支持 C 语言函数的调用 runtime/debug：进行问题排查 runtime/msan runtime/pprof：进行性能分析 runtime/race：实现了数据静态检测逻辑 runtime/trace：执行跟踪器，捕获各种执行时的事件，比如 goroutine 的创建/阻塞/解除阻塞、系统调用的进入/退出/阻塞、垃圾回收相关的事件、堆大小的改变、处理器的启动和停止等，并将它们写入 io.writer 中 需要知道的是，调度器、垃圾回收、各种数据类型的定义和操作(比如切片、接口等)都位于 runtime 库，而不是这几个子库，在电脑中的位置为 $GOROOT/src/runtime Go 的可执行文件一般比相应的源码文件大很多，这是因为 runtime 潜入了每一个可执行文件中，因此，Go 运行不依赖于其它任何文件。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:1:0","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"2. 调度器 这部分关于调度器的介绍，主要翻译自 The Go scheduler 这篇文章，写的非常容易理解。 在操作系统中，调度主要是对 CPU 时间片的分配策略，为了充分利用 CPU，将时间划分为一系列的时间片，然后遵循某种最优的策略（总执行时间最短或其它）将进程分配到某个时间片执行的过程。Go 中的调度做的也是类似的事，也就是如何分配 Goroutine 的执行，做这件事的工具就是调度器，而且我们也可以看出，调度器和 Go 的并发是息息相关的。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:2:0","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"2.1 设计理念 我们首先来理解为什么 Go 需要一个自己的调度器，而不是使用操作系统的调度器。首先，在操作系统中，线程的上下文切换也需要一定的资源，其中很多开销对 Go 的运行来说是不必要的，而且线程数量越多，这部分开销越大。另外一个重要的原因是交给操作系统调度无法基于 Go 当前的情况做出最优的调度决策，比如 Go 进行垃圾回收的时候，需要暂停正在运行的 Goroutine 和线程，并使内存保持在一个一致的状态，如果交给操作系统的调度器，就失去了对一致性状态的把握，并且需要等待所有相关线程停止工作，正在运行的线程越多，达到这个目的越难。如果 Go 使用自己的调度器，就知道什么时候内存状态是一致的（只针对 Go 程序分配的内存），它会在这些已知的内存一致性的时刻开始垃圾回收，并且此时只需要等待当前正在 CPU 核上执行的那个线程，而不是等待所有的线程。 有三种常见的线程模型，第一种是 N:1，也就是多个用户空间线程运行在一个 OS 线程上，其优点是上下文切换快速，缺点是不能充分利用多核系统的优点；第二种是 1:1，也就是一个用户空间线程对应一个 OS 线程，其优点是充分利用了系统的多个核，缺点是上下文切换的开销有点大。 Go 采用的是一种折衷的办法，即 M:N，也就是将任意数量的 Goroutine 对应到任意数量的 OS 线程，OS 线程的数量通常取决于 CPU 核的数目，这种方式保持了较低的上下文切换开销，并且充分利用了多核系统的优点，它主要的缺点是增加了调度器的复杂性。 Go 的调度器定义在 runtime 包中，具体的文件是 src/runtime/proc.go，最主要的概念有三个：P，M，G。其定义如下 // Goroutine scheduler // The scheduler's job is to distribute ready-to-run goroutines over worker threads. // // The main concepts are: // G - goroutine. // M - worker thread, or machine. // P - processor, a resource that is required to execute Go code. // M must have an associated P to execute Go code, however it can be // blocked or in a syscall w/o an associated P. // // Design doc at https://golang.org/s/go11sched. 用图形描述更直观一点 M 是 OS 线程，由操作系统管理，是实际的执行者，M 是 Machine 的首字母大写。 G 是 Goroutine，它包括堆栈，指令指针和其他对调度 Goroutine 重要的信息。 P 是调度的上下文，可以看作 Go 自己的调度器，负责将 Goroutine 调度到具体的 OS 线程上执行，他是实现 M:N 模型的关键，P 是 Processor 的首字母大写。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:2:1","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"2.2 调度策略 我们基于上面的三个概念来描述 Go 的调度策略。 上图中有两个 M，每个线程 M 都持有一个调度器 P，并且运行着一个 G。调度器的数目可以通过设置 GOMAXPROCS 环境变量或者调用 runtime.GOMAXPROCS 函数来设定，通常在设定好后，程序运行期间该值不会改变。事实上，该值的设定是充分利用多核的关键，比如，如果有一个 4 核的计算机，我们通常将 GOMAXPROCS 设定为 4，这样操作系统中会同时有 4 个线程运行 Goroutine。 灰色的 G 意味着 Goroutine 没有在运行，而是处于等待被调度的状态，这里使用了一个队列来存放它们，称为运行队列(runqueue)。每当使用 go 关键字启动一个 Goroutine 时，它就被加入运行队列的尾部，当 P 到达某个调度的时刻，就从运行队列首部取出一个 Goroutine ，设置好堆栈和指令指针，然后分配给关联的 M 运行。为了减少争用，每个 P 都有自己的运行队列。 注：早期的时候所有 P 公用一个运行队列，但这种情况下调度时需要加解锁，线程经常被阻塞。 运行队列不空，P 有用来调度的 Goroutine，那么就不会发生意外，调度会处于一个稳定的状态。但实际环境下是会产生意外的，我们介绍如下： 线程出于某些原因需要阻塞。这时候 P 无法再将 Goroutine 交给自己的 M 运行，然后就会将 Goroutine 移交给其它的 M 运行。 如上图，我们可以看到 M0 由于系统调用（syscall）发生了阻塞，与之相关的 P （实际上是下文）就被移交给了 M1（这里我们可以更好的理解为什么 P 的本质是上下文，只是可以看作调度器）。调度程序会确保有足够的 M 来运行 P，上面的 M1 可能仅为了处理移交的 P 和对应的 Goroutine创建，也可能来自线程池。M0 将保留正在执行的 Goroutine，因为实质上它仍然在执行，只是在 OS 中被阻塞。 当 syscall 返回时，M0 必须尝试获取一个 P 用来执行未执行完的 G0，一般情况是从其它线程窃取一个 P，如果无法窃取到，就会把 G0 放到全局的运行队列中，然后把自己放到线程池进入睡眠状态。 全局的运行队列是 P 从自己的运行队列无法获取到 G 时读取的地方，P 会定期检测全局运行队列，防止全局运行队列中的 Goroutine 始终得不到执行。 这种处理过程说明了为什么即使 GOMAXPROCS=1，Go 程序运行也会涉及到多个线程，G0 会停留在syscall 线程上。 运行队列中的 Goroutine 被用尽了。如果每个 P 的运行队列上 Goroutine 的数量不平衡，就可能发生这种情况 前面已经提到，P 本身的运行队列空了的时候，会从全局运行队列获取 Goroutine，那么，如果全局运行队列也为空呢。P 就会从其它 P 那里窃取 Goroutine，一般情况下会窃取大约一半的运行队列，这样可以保证两个 P 一直有 Goroutine 可调用，也就是保持平衡，从而保证所有的线程不处于空闲状态。上图中空闲 P 从其它 P 窃取了两个 Goroutine，一个直接开始执行，剩下的放入运行队列，此时两个 P 的运行队列大小相同。 所以，在操作系统层面，Go 采用的是抢占式调度，如果 M 陷入了阻塞，那么会导致当前在它上面的 Goroutine 长时间占用 M，这时候就会发生抢占， P 会寻找其它的 M，然后把 G 交给新的 M 调度。但是在语言层面，后来的 Goroutine 永远假如运行队列的末尾，不会抢占 P。 非抢占式调度是进程/线程交给 CPU 后，会一直执行完毕，不会被中断； 抢占式调度是 CPU 正在执行的进程/线程会被具有更高优先级的进程/线程抢占掉（可以防止单一进程长时间独占 CPU）。 其它参考：说说Golang的runtime ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:2:2","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"3. 垃圾回收 垃圾回收（Garbage Collection，GC），是一种存储管理机制。我们编写的程序中，变量、函数参数等在内存通常存放在两个不同的区域：栈和堆。栈的分配由操作系统管理，而堆的分配由程序员管理，在 C 和一些语言中，程序员使用 malloc 申请空间后，最后还需要自己使用 free 释放空间，编译器不会辅助完成这个过程，如果忘记释放，就可能造成不可预知的后果（内存泄漏等）。而在 Go 和另一些编程语言中，主动提供了一种机制，它会在后台持续的运行，监控各个变量和参数的状态，识别那些不再使用的对象并释放掉它们的内存空间，这种机制（或者说这个后台进程）叫做垃圾回收。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:3:0","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"3.1 常见的GC算法 有很多用于垃圾回收的算法。 第一个叫做引用计数，方法是为每个对象添加一个引用计数器，每当有引用指向该对象，计数器+1，释放时计数器-1，当 GC 检测到计数器为 0 时，说明该对象不再被使用，就回收为它分配的内存。其缺点是无法检测到循环引用，因为循环引用的引用计数永远不可能为 0。 第二个叫做根搜索算法，Java 和 C# 使用了这种办法。原理是通过一系列称为 GC Root 的对象作为起点，从这些节点向下搜索，所走过的路径称为引用链（Reference Chain），如果一个对象到 GC Root 没有任何引用链相连，那么就说明该对象的内存可以被回收。Java 中可以作为 GC Root 的对象包括虚拟机栈中的引用对象、类静态属性引用的对象、常量引用的对象和本地方法栈中的引用对象。 第三种叫做标记-清除算法。它将垃圾回收划分为两个阶段，在标记阶段标记所有可回收的对象，然后在回收阶段回收被标记对象占用的空间。其缺点主要有两个，第一个是标记时需要暂停整个程序的运行，第二个是会产生大量的内存碎片，如下图，碎片比较多的话后续可能没有足够的连续内存分配给需求较多的对象。 第四种是复制算法。复制算法是标记-清除算法的改进，它将内存分为两个相等的区域，每次只使用其中一个区域，进行垃圾回收时，会把当前存活的所有对象复制到另一个空间，然后堆当前空间进行回收。如下图，这种算法解决了内存碎片的问题，代价是可使用的内存为原理的一半，并且由于额外的复制操作，效率会有一定的影响。 第五种是标记-压缩算法。标记-压缩算法与复制算法思路相似，都是将内存分两块，不同在于，标记完可回收的对象后，标记-压缩算法会将存活的对象压缩到内存的一端，让它们紧凑的排列在一起，然后对边界以外的空间进行回收，回收后，已用和未用的内存各自在一边。如下图，标记压缩算法解决了内存碎片问题和回收效率低的问题。 第六种是分代收集。分代收集是一种思路，研究发现，程序中大部分对象的生命周期都很短，所以根据对象生命周期的长短，使用不同的垃圾回收算法。生命周期比较长的叫做老年代，通常使用标记-压缩算法，生命周期比较短的叫做新生代，通常使用复制算法。 本节主要参考：简书，顾林海，垃圾回收算法有哪些 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:3:1","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"3.2 Go的垃圾回收 Go 的垃圾回收经历了一个比较长的演变过程，具体可以参考 The Journey of Go’s Garbage Collector 这篇文章。 目前 Go 使用的是三色标记法。三色标记法是标记-回收算法的一种改进，它将所有的对象用白色、灰色、黑色三种颜色表示，基本步骤如下 开始时将所有对象标记为白色； GC 从根结点开始扫描，下图中，A 和 F 是根结点，所以将它们标记为灰色（注意这一步标记为灰色的是根结点集合的所有对象） 遍历灰色节点，将灰色节点所引用的节点也标记为灰色，这里 A 引用了 B、C、D，F 没有引用，然后将分析过的灰色节点标记为黑色，如下图 循环遍历灰色节点，直到灰色节点的个数为 0，下图中，B、C、D都没有引用的白色节点，所以这一轮都标记为了黑色 此时对白色节点对应的内存空间进行垃圾回收 最后，GC 将黑色节点再次重置为白色，供下一次垃圾回收使用。 除了三色标记的主过程外，还需要写屏障（Write Barrier）的配合。由于三色标记是可并发执行的，运行过程中就可能出现新分配的对象，对于这些对象如何处理就需要写屏障参与。写屏障类似于写锁，主要用于保证并发的一致性。写屏障在标记开始时打开，在标记结束后关闭。（需要进一步理解） 另外一个概念是 STW（Stop the world），这是标记阶段产生的一种行为，意思是停止所有的 Goroutine。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:3:2","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"3.3 其它 有 GC 不意味着高枕无忧，也可能发生内存泄漏，所以要养成一些良好的习惯，比如不使用的指针置为 Nil。 runtime包有两个关于垃圾回收的 API runtime.GC：手动触发 GC runtime.ReadMemStats：读取内存相关的统计信息，其中包含部分 GC 相关的统计信息 自动垃圾回收触发的条件有两个： 超过内存大小阈值 达到定时时间（默认2min触发一次） 如果想知道当前的内存状态，可以使用 // fmt.Printf(\"%d\\n\", runtime.MemStats.Alloc/1024) // 此处代码在 Go 1.5.1下不再有效，更正为 var m runtime.MemStats runtime.ReadMemStats(\u0026m) fmt.Printf(\"%d Kb\\n\", m.Alloc / 1024) 上面的程序会给出已分配内存的总量，单位是 Kb。进一步的测量参考 package runtime 垃圾回收参考： [1] 简书，Go垃圾回收之三色标记算法 [2] 博客园，搞懂Go垃圾回收 [3] 知乎专栏，张三毛，Go垃圾回收系列 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:3:3","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"pprof 用来做 Go 程序的性能监控，让我们知道在什么地方耗费了多少 CPU、memory。 pprof 关注的方面有： CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据 Memory Profile（Heap Profile）：报告程序的内存使用情况 Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈 Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的 ","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:0:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"1. 引入 pprof 可以从以下两个包中引入： import \"net/http/pprof\" import \"runtime/pprof\" 其中 net/http/pprof 底层使用 runtime/pprof 包，只是进行了一下封装，并在 http 端口上暴露出来。 如果我们的服务是一直运行的，如 web 应用，通过简单的导入 import _ \"net/http/pprof\"，就可以在运行 web 应用后在浏览器 http://localhost:port/debug/pprof 直接看到当前 web 服务的状态，包括 CPU 占用情况和内存使用情况等。 如果我们的程序不是 web 应用，而是一个服务进程，那么可以导入 net/http/pprof 包，然后主动开启一个 Goroutine 在端口进行监听 go func() { log.Println(http.ListenAndServe(\"localhost:6060\", nil)) }() 如果我们的程序只是简单的 Go 程序，那么只能使用 runtime/pprof 包，具体做法是在代码中加入下面这段程序，然后在运行时（go run 或 go build等命令）加入 –cpuprofile 参数，比如 go run demo.go --cpuprofile=demo.prof var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to file\") func main() { flag.Parse() if *cpuprofile != \"\" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } ... 命令执行完后当前目录会生成 demo.prof 文件，其中记录了 CPU 运行的信息，下一步就可以利用该文件查看相关的信息，使用 go tool pprof 命令来执行，如果要进行可视化，需要安装 graphviz win10 下可以使用 chocolatye 或 winget 安装，如下 \u003e choco install graphviz # 或 \u003e winget install graphviz ","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:1:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"2. 分析普通程序 主要参考的文章是 Go Post 中的 Profiling Go Programs 测试代码来自于 https://github.com/rsc/benchgraffiti/tree/master/havlak 我们使用 go mod 建立了一个测试项目文件夹，第一次使用测试代码中的 havlak1.go 文件，将该文件复制到测试项目根目录。由于其中已经引入了 runtime/pprof 包并包含了如下代码，我们不需要做修改，执行执行 var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to file\") func main() { flag.Parse() if *cpuprofile != \"\" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } ... 执行时加入 –cpuprofile=havlak1.prof 参数 $ go build havlak1.go $ ./havlak1 --cpuprofile=havlak1.prof # of loops: 76000 (including 1 artificial root node) $ ls go.mod havlak1.exe havlak1.go havlak1.prof 然后运行 go tool pprof 命令与 profile 交互 $ go tool pprof havlak1.exe havlak1.prof File: havlak1.exe Type: cpu Time: Jul 25, 2020 at 7:23pm (CST) Duration: 21.52s, Total samples = 34.77s (161.56%) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) 最主要的命令是 topN ，用来输出最耗 CPU 的前N个调用 (pprof) top10 Showing nodes accounting for 21340ms, 61.37% of 34770ms total Dropped 168 nodes (cum \u003c= 173.85ms) Showing top 10 nodes out of 89 flat flat% sum% cum cum% 5340ms 15.36% 15.36% 12320ms 35.43% runtime.scanobject 3190ms 9.17% 24.53% 3650ms 10.50% runtime.mapaccess1_fast64 2650ms 7.62% 32.15% 16670ms 47.94% main.FindLoops 2240ms 6.44% 38.60% 3320ms 9.55% runtime.findObject 1800ms 5.18% 43.77% 2920ms 8.40% runtime.greyobject 1490ms 4.29% 48.06% 6540ms 18.81% runtime.mallocgc 1480ms 4.26% 52.32% 4230ms 12.17% main.DFS 1230ms 3.54% 55.85% 3510ms 10.09% runtime.mapassign_fast64ptr 1000ms 2.88% 58.73% 1450ms 4.17% runtime.heapBitsSetType 920ms 2.65% 61.37% 1050ms 3.02% runtime.spanOf (inline) (pprof) flat、flat% 表示函数在 CPU上运行的时间及百分比 sum% 表示列表中自己包括前面的函数CPU使用比例的累积，比如第三行 main.FindLoops 显示的 32.15% 其实就等于前面三个调用的比例之和 15.36% + 9.17% + 7.62% = 32.15% cum、cum% 表示该函数及其子函数运行所占的时间总和及比例总和，应该大于等于自己执行所占的时间和比例，也就是最前面两列 添加 -cum 参数可以按照 cum 来排序 (pprof) top5 -cum Showing nodes accounting for 2.67s, 7.68% of 34.77s total Dropped 168 nodes (cum \u003c= 0.17s) Showing top 5 nodes out of 89 flat flat% sum% cum cum% 0 0% 0% 16.79s 48.29% main.main 0 0% 0% 16.79s 48.29% runtime.main 0 0% 0% 16.67s 47.94% main.FindHavlakLoops (inline) 2.65s 7.62% 7.62% 16.67s 47.94% main.FindLoops 0.02s 0.058% 7.68% 15.16s 43.60% runtime.systemstack (pprof) 实际上 main.FindLoops 和 main.main 的总和应当为 100%，但是 pprof 不会统计所有的调用，递归调用层次过深的一些执行会被忽略。 另外，使用 web 命令可以生成调用关系图，是一个 svg 文件，可视化的方式可以帮助我们更好的理解，该命令需要 graphviz 工具的支持，这也是为什么前面要安装它 (pprof) web 执行该命令后图片会自动打开 图片中每个方框都代表一个函数，方框的大小根据 CPU 占用比例确定，箭头表示调用关系，从上到下调用层次逐渐加深，表示调用的线条上出现的数字表示调用次数，递归调用自身会有一个自己指向自己的箭头。 从图中看到 mapaccess 占用比例较大，我们可以只显示与它相关的调用，从而使图片逻辑更清晰。可以看到 mapaccess1 主要由 main.FindLoops 和 main.DFS 调用。 我们还可以通过指定函数进入某个函数的细节，DFS逻辑比较简单，以它为例 (pprof) web DFS 也可以使用命令 (pprof) list DFS Total: 34.77s ROUTINE ======================== main.DFS in F:\\Go-web\\havlak1.go 1.48s 8.38s (flat, cum) 24.10% of Total . . 233: return false . . 234:} . . 235: . . 236:// DFS - Depth-First-Search and node numbering. . . 237:// 30ms 30ms 238:func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int { 20ms 240ms 239: nodes[current].Init(currentNode, current) 20ms 340ms 240: number[currentNode] = current . . 241: . . 242: lastid := current 1.02s 1.02s 243: for _, target := range currentNode.OutEdges { 190ms 1.73s 244: if number[target] == unvisited { 80ms 4.23s 245: lastid = DFS(target, nodes, number, last, lastid+1) . . 246: } . . 247: } 80ms 750ms 248: last[number[currentNode]] = lastid 40ms 40ms 249: return lastid . . 250:} . . 251: . . 252:// FindLoops . . 253:// . . 254:// Find loops and build loop forest using Havlak's algorithm, which (pprof) 前两列分别是 flat 和 cum，也就是该行执行占用的时间和该行及该行调用的函数执行占用的总时间，第三列是源码行数。所以我们看到第 245 行由于出现了 DFS 这个递归函数，总占用时间为 4.23s，是最多的。除了该行之外，占用最多的就是第239、240、248三行，主要原因是映射的使用占用了大量时间，所以我们在使用中应尽可能使用数组和切片，而减少使用映射。 ","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:2:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"2. 时间与存储优化 将 DFS 函数参数中的 number 由映射更改为切片，可以将运行时间减少两倍，我们使用测试文件列表中的 havlak2.go，执行同样的测试过程可以验证这一点，原先的 DFS cum 是 4230ms，现在已经只有 830ms。 $ go build havlak2.go $ ./havlak2 --cpuprofile=havlak2.prof # of loops: 76000 (including 1 artificial root node) $ go tool pprof havlak2.exe havlak2.prof File: havlak2.exe Type: cpu Time: Jul 25, 2020 at 8:51pm (CST) Duration: 12.36s, Total samples = 22.91s (185.34%) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top10 Showing nodes accounting for 14360ms, 62.68% of 22910ms total Dropped 132 nodes (cum \u003c= 114.55ms) Showing top 10 nodes out of 85 flat flat% sum% cum cum% 4130ms 18.03% 18.03% 9810ms 42.82% runtime.scanobject 1850ms 8.08% 26.10% 2570ms 11.22% runtime.findObject 1800ms 7.86% 33.96% 11070ms 48.32% main.FindLoops 1530ms 6.68% 40.64% 2510ms 10.96% runtime.greyobject 1450ms 6.33% 46.97% 5940ms 25.93% runtime.mallocgc 950ms 4.15% 51.11% 1290ms 5.63% runtime.heapBitsSetType 680ms 2.97% 54.08% 830ms 3.62% main.DFS 670ms 2.92% 57.01% 670ms 2.92% runtime.memclrNoHeapPointers 670ms 2.92% 59.93% 670ms 2.92% runtime.nextFreeFast 630ms 2.75% 62.68% 630ms 2.75% runtime.arenaIndex (partial-inline) 附： diff between havlak1 and havlak2 现在，DFS 不再是时间瓶颈，取而代之的是内存分配与垃圾回收，上面的结果中 runtime.mallocgc 占了一大部分。为了找出为什么垃圾回收时间占用这么多，我们来分析内存占用，这时候使用 memprofile ，不再是 cpuprofile。首先在主函数中替换如下部分 var memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to this file\") ... FindHavlakLoops(cfgraph, lsgraph) if *memprofile != \"\" { f, err := os.Create(*memprofile) if err != nil { log.Fatal(err) } pprof.WriteHeapProfile(f) f.Close() return } 然后使用 –memprofile 标志编译源码，此时使用测试文件列表中的 havlak3 附：diff from havlak2 $ go build havlak3.go $ ./havlak3 --memprofile=havlak3.mprof $ go tool pprof havlak3.exe havlak3.mprof $ go tool pprof havlak3.exe havlak3.mprof File: havlak3.exe Type: inuse_space Time: Jul 25, 2020 at 9:07pm (CST) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top5 Showing nodes accounting for 53.39MB, 100% of 53.39MB total Showing top 5 nodes out of 13 flat flat% sum% cum cum% 33.10MB 62.00% 62.00% 33.10MB 62.00% main.FindLoops 11.50MB 21.54% 83.54% 11.50MB 21.54% main.NewBasicBlock (inline) 4.50MB 8.43% 91.96% 4.50MB 8.43% main.(*BasicBlock).AddInEdge 2.29MB 4.29% 96.25% 13.79MB 25.83% main.(*CFG).CreateNode 2MB 3.75% 100% 2MB 3.75% main.(*BasicBlock).AddOutEdge (pprof) flat 和 cum 已经从时间占用变成了存储占用，可以看到 main.FindLoops 占用最多，达到了 62.00%，使用 list 命令查看具体情况 (pprof) list FindLoops Total: 53.39MB ROUTINE ======================== main.FindLoops in F:\\Go-web\\havlak3.go 33.10MB 33.10MB (flat, cum) 62.00% of Total . . 261: return . . 262: } . . 263: . . 264: size := cfgraph.NumNodes() . . 265: 1.97MB 1.97MB 266: nonBackPreds := make([]map[int]bool, size) 5.77MB 5.77MB 267: backPreds := make([][]int, size) . . 268: 1.97MB 1.97MB 269: number := make([]int, size) 1.97MB 1.97MB 270: header := make([]int, size, size) 1.97MB 1.97MB 271: types := make([]int, size, size) 1.97MB 1.97MB 272: last := make([]int, size, size) 1.97MB 1.97MB 273: nodes := make([]*UnionFindNode, size, size) . . 274: . . 275: for i := 0; i \u003c size; i++ { 11MB 11MB 276: nodes[i] = new(UnionFindNode) . . 277: } . . 278: . . 279: // Step a: . . 280: // - initialize all nodes as unvisited. . . 281: // - depth-first traversal and numbering. . . 282: // - unreached BB's are marked as dead. . . 283: // . . 284: for i, bb := range cfgraph.Blocks { . . 285: number[bb.Name] = unvisited 4.50MB 4.50MB 286: nonBackPreds[i] = make(map[int]bool) . . 287: } . . 288: . . 289: DFS(cfgraph.Start, nodes, number, last, 0) . . 290: . . 291: // Step b: (pprof) 瓶颈依然在于 UnionFindNode 结构体的初始化和映射。 另外，如果我们执行 go tool pprof 加入 --inuse_objects ，看到的不是内存使用而是调用计数 $ go tool pprof --inuse_objects havlak3.exe havlak3.mprof File: havlak3.exe Type: inuse_objects Time: Jul 25, 2020 at 9:07pm (CST) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) list FindLoops Total: 1171490 ROUTINE ======================== main.FindLoops","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:3:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"3. 分析网络程序 就像我们一开始说的，分析一个网络程序更加的简单，只需要导入 net/http/pprof 包即可，不需要在程序中使用，只需要添加这一条导入语句。 import _ \"net/http/pprof\" 导入该包会添加一些 /debug/pprof/ URL 下面的一些处理器函数，之后简单的运行 go tool pprof 然后添加服务器 URL就会实时的检查配置文件。 以我们之前写的一个文件上传下载应用为例，端口使用 8090，添加导入语句后，打开浏览器 http://localhost:8090/debug/pprof/，显示如下 或者在命令行使用 go tool pprof 命令 go tool pprof http://localhost:8090/debug/pprof/profile # 30-second CPU profile go tool pprof http://localhost:8090/debug/pprof/heap # heap profile go tool pprof http://localhost:8090/debug/pprof/block # goroutine blocking profile 进入 pprof 命令行界面后就和前面的使用没有区别了，这几个文件简单介绍如下 /debug/pprof/profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载 /debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件 /debug/pprof/block：block Profiling 的路径 最后，上面的导入形式是基于我们使用默认的 http.DefaultServeMux 的情况，如果使用了其它的包，比如 Mux，需要手动添加路由规则 r.HandleFunc(\"/debug/pprof/\", pprof.Index) r.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline) r.HandleFunc(\"/debug/pprof/profile\", pprof.Profile) r.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol) r.HandleFunc(\"/debug/pprof/trace\", pprof.Trace) 之后的使用就没有区别了。 ","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:4:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"在C/C++中，使用 GDB 调试程序，但在Go中，看过网上的一些文章后，发现 dlv 是个更好的选择，本文进行介绍。 实际上，delve 才是全称，dlv 只是启动命令，如果使用 VScode，默认使用的调试器就是基于 delve 的。 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:0:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"1. 基本命令 使用如下命令安装 go get github.com/go-delve/delve/cmd/dlv 安装后执行 dlv 命令查看基本信息 $ dlv Delve is a source level debugger for Go programs. Delve enables you to interact with your program by controlling the execution of the process, evaluating variables, and providing information of thread / goroutine state, CPU register state and more. The goal of this tool is to provide a simple yet powerful interface for debugging Go programs. Pass flags to the program you are debugging using `--`, for example: `dlv exec ./hello -- server --config conf/config.toml` Usage: dlv [command] Available Commands: attach Attach to running process and begin debugging. connect Connect to a headless debug server. core Examine a core dump. debug Compile and begin debugging main package in current directory, or the package specified. exec Execute a precompiled binary, and begin a debug session. help Help about any command run Deprecated command. Use 'debug' instead. test Compile test binary and begin debugging program. trace Compile and begin tracing program. version Prints version. Flags: --accept-multiclient Allows a headless server to accept multiple client connections. --api-version int Selects API version when headless. (default 1) --backend string Backend selection (see 'dlv help backend'). (default \"default\") --build-flags string Build flags, to be passed to the compiler. --check-go-version Checks that the version of Go in use is compatible with Delve. (default true) --headless Run debug server only, in headless mode. --init string Init file, executed by the terminal client. -l, --listen string Debugging server listen address. (default \"127.0.0.1:0\") --log Enable debugging server logging. --log-dest string Writes logs to the specified file or file descriptor (see 'dlv help log'). --log-output string Comma separated list of components that should produce debug output (see 'dlv help log') --only-same-user Only connections from the same user that started this instance of Delve are allowed to connect. (default true) --wd string Working directory for running the program. (default \".\") Additional help topics: dlv backend Help about the --backend flag. dlv log Help about logging flags. Use \"dlv [command] --help\" for more information about a command. 进入调试模式有以下几种办法 dlv attach pid：对正在运行的进程直接进行调试（pid 为进程id）； dlv debug：编译源文件并开始调试，这里应和 main 函数位于同一目录，或者指定完整的 main 函数路径 dlv exec filename：从二进制文件启动调试 我们以下面的程序为例进行说明，使用 dlv debug 进入调试 package main import \"fmt\" func main() { a := 10 fmt.Println(a) } 进入调试，使用 help 可以查看所有可用命令 $ dlv debug main.go Type 'help' for list of commands. (dlv) help The following commands are available: args ------------------------ Print function arguments. break (alias: b) ------------ Sets a breakpoint. breakpoints (alias: bp) ----- Print out info for active breakpoints. call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!) clear ----------------------- Deletes breakpoint. clearall -------------------- Deletes multiple breakpoints. condition (alias: cond) ----- Set breakpoint condition. config ---------------------- Changes configuration parameters. continue (alias: c) --------- Run until breakpoint or program termination. deferred -------------------- Executes command in the context of a deferred call. disassemble (alias: disass) - Disassembler. down ------------------------ Move the current frame down. edit (alias: ed) ------------ Open where you are in $DELVE_EDITOR or $EDITOR exit (alias: quit | q) ------ Exit the debugger. frame ----------------------- Set the current frame, or execute command on a different frame. funcs ----------------------- Print list of functions. goroutine (alias: gr) ------- Shows or changes current goroutine goroutines (alias: grs) ----- List program goroutines. help (alias: h) ------------- Prints the help message. libraries ------------------- List loaded dynamic libraries list (alias: ls | l) -------- Show source code. locals ---------------------- Print local variables. next (alias","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:1:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2. 命令使用 下面通过实践说明这些简单命令的使用 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.1 断点设置 (dlv) b main.go:6 Breakpoint 1 set at 0x4bd2f8 for main.main() F:/Gotest/main.go:6 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:1","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.2 打印断点信息 (dlv) bp Breakpoint runtime-fatal-throw at 0x4377e0 for runtime.fatalthrow() c:/go/src/runtime/panic.go:1162 (0) Breakpoint unrecovered-panic at 0x437860 for runtime.fatalpanic() c:/go/src/runtime/panic.go:1189 (0) print runtime.curg._panic.arg Breakpoint 1 at 0x4bd2f8 for main.main() F:/Gotest/main.go:6 (0) ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:2","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.3 运行直到断点处 (dlv) c \u003e main.main() F:/Gotest/main.go:6 (hits goroutine(1):1 total:1) (PC: 0x4bd2f8) 1: package main 2: 3: import \"fmt\" 4: 5: func main() { =\u003e 6: a := 10 7: fmt.Println(a) 8: } ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:3","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.4 下一步 (dlv) n \u003e main.main() F:/Gotest/main.go:7 (PC: 0x4bd301) 2: 3: import \"fmt\" 4: 5: func main() { 6: a := 10 =\u003e 7: fmt.Println(a) 8: } ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:4","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.5 查看局部变量 (dlv) locals a = 10 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:5","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.6 查看当前调用栈 (dlv) bt 0 0x00000000004bd301 in main.main at F:/Gotest/main.go:7 1 0x0000000000439cfa in runtime.main at c:/go/src/runtime/proc.go:203 2 0x00000000004643d1 in runtime.goexit at c:/go/src/runtime/asm_amd64.s:1373 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:6","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.7 打印源代码 (dlv) list \u003e main.main() F:/Gotest/main.go:7 (PC: 0x4bd301) 2: 3: import \"fmt\" 4: 5: func main() { 6: a := 10 =\u003e 7: fmt.Println(a) 8: } ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:7","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.8 运行到断点处执行某个命令 1 是断点ID，p a 代表指定到断点处打印变量 a 的值 (dlv) on 1 p a (dlv) c 10 Process 6540 has exited with status 0 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:8","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"3. Goroutine 调试 Go 的优势在协程，dlv 相比 GDB 的优点也在于对协程调试的支持，我们以下面的程序为例，给出示例 package main import ( \"fmt\" \"time\" ) func main() { a := 10 go printA(a) time.Sleep(1e9) } func printA(a int) { fmt.Println(a) } 设置断点并启动运行 \u003e b main.go:12 Breakpoint 1 set at 0x4bd5be for main.main() F:/Gotest/main.go:12 (dlv) c \u003e main.main() F:/Gotest/main.go:12 (hits goroutine(1):1 total:1) (PC: 0x4bd5be) 7: 8: func main() { 9: a := 10 10: go printA(a) 11: =\u003e 12: time.Sleep(1e9) 13: } 14: 15: func printA(a int) { 16: fmt.Println(a) 17: } 查看当前启动的协程，其中 Goroutine 1 是主协程，Goroutine 6 是自行启动的子协程 (dlv) goroutines * Goroutine 1 - User: F:/Gotest/main.go:12 main.main (0x4bd5be) (thread 11412) Goroutine 2 - User: c:/go/src/runtime/proc.go:305 runtime.gopark (0x43a092) Goroutine 3 - User: c:/go/src/runtime/proc.go:305 runtime.gopark (0x43a092) Goroutine 4 - User: c:/go/src/runtime/proc.go:305 runtime.gopark (0x43a092) Goroutine 5 - User: c:/go/src/runtime/proc.go:305 runtime.gopark (0x43a092) Goroutine 6 - User: F:/Gotest/main.go:15 main.printA (0x4bd5e0) [6 goroutines] 打印主协程当前的变量 (dlv) locals a = 10 如果要查看子协程的情况，需要先切换到子协程 (dlv) goroutine 6 Switched from 1 to 6 (thread 11412) (dlv) bt 0 0x00000000004bd5e0 in main.printA at F:/Gotest/main.go:15 1 0x0000000000464621 in runtime.goexit at c:/go/src/runtime/asm_amd64.s:1373 (dlv) args a = 10 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:3:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"4. 后记 写到这里好像没发现直接使用 dlv 有什么优势，VScode 在 delve 基础上完成的调试功能更方便，比自己使用命令逐步执行好多了。 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:4:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"本文关心 map 的底层实现、map 的扩容机制和 map 遍历的随机性。 先解答问题 map 是实现是哈希表+链地址法解决冲突； map 扩容每次增加一倍的空间； map 遍历具有随机性，不要主观地认为遍历的顺序就是插入的顺序。 实际上，除了基本的结构定义，map 的初始化、访问、删除、扩容、遍历等操作并没有完全理解，留待之后再说，先占坑。 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:0:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"1. 实现 Go 中映射（map）的底层实现是哈希表，位于 src/runtime/map.go 中，数据被放到一个 buckets 数组里，每个 bucket 包含最多 8 个键值对。key 的哈希值低 8 位用于选择 bucket，高 8 位用于区分 bucket 中存放的多个键值。如果超过 8 个键被放到同一个 bucket，使用一个额外的 bucket 来存储。 核心的结构体主要是 hmap 和 bmap，前者就是这个 bucket 数组，后者就是单个 bucket 的结构。 // map的基础数据结构 type hmap struct { count int // map存储的元素对计数，len()函数返回此值，所以map的len()时间复杂度是O(1) flags uint8 B uint8 // buckets数组的长度，也就是桶的数量为2^B个 noverflow uint16 // 溢出的桶的数量的近似值 hash0 uint32 // hash种子 buckets unsafe.Pointer // 指向2^B个桶组成的数组的指针，数据存在这里 oldbuckets unsafe.Pointer // 指向扩容前的旧buckets数组，只在map增长时有效 nevacuate uintptr // 计数器，标示扩容后搬迁的进度 extra *mapextra // 保存溢出桶的指针数组和未使用的溢出桶数组的首地址 } type mapextra struct { overflow *[]*bmap // overflow contains overflow buckets for hmap.buckets. oldoverflow *[]*bmap // oldoverflow contains overflow buckets for hmap.oldbuckets. // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap } // 桶的实现结构, hmap的buckets指针指向该结构 type bmap struct { // tophash存储桶内每个key的hash值的高字节 // tophash[0] \u003c minTopHash表示桶的疏散状态 // 当前版本bucketCnt的值是8，一个桶最多存储8个key-value对 tophash [bucketCnt]uint8 // 下面紧跟存放的键值对，存放的格式是所有的 key，然后是所有的 value， // 之所以不是一个 key 跟随一个 value，是为了消除填充所需要的间隙，因为 // key 与 value 的类型不一致，占用的内存大小不一致 // 最后是一个溢出指针 } hmap 是哈希表的基础结构，hmap.buckets 实际指向 buckets 数组，hmap.oldbuckets 和 hmap.nevacuate 用于扩容，之后介绍，hmap.extra 保存溢出桶的地址的数组以及未使用的溢出桶数组的首地址。 bmap 是单个桶的结构，是一个长度为 8 的数组，数组每个元素的值是 key 的哈希值的高 8 位，数组之后是 8 个 key，然后 8 个 value，最后一个溢出指针，溢出指针指向额外的桶链表，用于存储溢出的数据。用图描述如下 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:1:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"2. 访问 主要是 map.go 文件中的几个 mapaccess 函数，基本逻辑为 找不到 key，就返回该类型的零值。 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:2:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"3. 分配 分配的意思是向 map 中添加新值，主要是 mapassign 函数，基本逻辑与查找相似，但多了写保护和扩容的内容 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:3:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"4. 删除 删除主要是 mapdelete 函数，逻辑如下，删除操作的实质是将值置空，并没有减少内存 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:4:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"5. 遍历 Go 中 map 遍历的一个突出特征就是元素顺序的随机化，即每次遍历得到的元素的顺序不一定相同，和元素的插入顺序无关。 Go 中遍历的基本逻辑是先调用 mapiterinit 初始化 hiter 结构体，然后利用 该结构体进行遍历。 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:5:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"6. 扩容 首先，判断是否需要扩容的逻辑是 func (h *hmap) growing() bool { return h.oldbuckets != nil } 何时h.oldbuckets不为nil呢？在分配assign逻辑中，当没有位置给key使用，而且满足测试条件(装载因子\u003e6.5或有太多溢出通)时，会触发hashGrow逻辑： func hashGrow(t *maptype, h *hmap) { //判断是否需要sameSizeGrow，否则\"真\"扩 bigger := uint8(1) if !overLoadFactor(h.count+1, h.B) { bigger = 0 h.flags |= sameSizeGrow } // 将buckets复制给oldbuckets oldbuckets := h.buckets newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil) flags := h.flags \u0026^ (iterator | oldIterator) if h.flags\u0026iterator != 0 { flags |= oldIterator } // 更新 hmap 结构 h.B += bigger h.flags = flags h.oldbuckets = oldbuckets h.buckets = newbuckets h.nevacuate = 0 h.noverflow = 0 // 设置溢出桶 if h.extra != nil \u0026\u0026 h.extra.overflow != nil { // Promote current overflow buckets to the old generation. if h.extra.oldoverflow != nil { throw(\"oldoverflow is not nil\") } h.extra.oldoverflow = h.extra.overflow h.extra.overflow = nil } if nextOverflow != nil { if h.extra == nil { h.extra = new(mapextra) } h.extra.nextOverflow = nextOverflow } // the actual copying of the hash table data is done incrementally // by growWork() and evacuate(). } 这里需要明白，map 扩容时每次增大一倍，方法是分配一个新的 Bucket 数组，然后将就数组复制过去。 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:6:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"参考 [1] 简书，Love语鬼，Golang map的底层实现 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:7:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"本篇理解切片的底层实现和扩容方式。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-3-slice/:0:0","tags":["Go语法"],"title":"Golang深入学习3-切片","uri":"/2020/golang-deep-learning-3-slice/"},{"categories":["Golang学习之路"],"content":"1. 实现 切片的定义位于 src/runtime/slice.go，如下 type slice struct { array unsafe.Pointer // 用来存储实际数据的数组指针，指向一块连续的内存 len int // 切片中元素的数量 cap int // array数组的长度 } 所以可见切片和字符串很相似，实质都是一个指针，只不过除了长度 len 还有一个容量字段 cap。一个简单的图解如下 图中的 x 和 y 都是从数组 [5]int{2,3,5,7,11} 上获取的切片，也就是指向该数组的不同位置。 上篇介绍字符串的时候提到字符串虽然底层是指针，但不允许等于 nil，它的空值是空字符串 \"\"。但切片是可以等于 nil 的，只要其底层指针等于 nil，一般情况是切片声明而未初始化的时候出现该情况，这个时候因为没有指向任何内存区域，切片的长度和容量信息都是无效的，不过还是可以获取到。 注：因为切片等于 nil 一般意味着没有初始化，也就没有使用的价值，所以很少将切片直接和 nil 作比较，使用更多的还是判断切片的长度是否为0（len(s) == 0） func main() { var s []int fmt.Println(s, len(s), cap(s)) fmt.Println(s == nil) } // Output [] 0 0 true 切片一旦初始化，底层指针就指向了一个确定的内存区域，但指向的内存区域大小可以为0，也就是切片中没有任何元素，此时切片的长度也是 0，但和未初始化时得到的长度绝不是一个含义。 func main() { var s []int s = []int{} fmt.Println(s, len(s), cap(s)) fmt.Println(s == nil) } // Output [] 0 0 false ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-3-slice/:1:0","tags":["Go语法"],"title":"Golang深入学习3-切片","uri":"/2020/golang-deep-learning-3-slice/"},{"categories":["Golang学习之路"],"content":"2. 扩容 切片的长度是当前所包含的元素个数，容量是可容纳的最大元素个数。这里的含义是，初始化时指定的容量就代表在内存已经预分配了与容量相等的空间，其后访问、添加、删除切片的元素都和数组相似，只操作指针，不会造成内存重新分配。 func main() { s := make([]int, 0, 3) fmt.Printf(\"%p \", s) fmt.Println(s, len(s), cap(s)) s = append(s, 1) fmt.Printf(\"%p \", s) fmt.Println(s, len(s), cap(s)) } // Output 0xc000124180 [] 0 3 0xc000124180 [1] 1 3 但是，如果追加的元素数量超过了容量，那么会导致内存的重新分配。 func main() { s := make([]int, 0, 3) fmt.Printf(\"%p \", s) fmt.Println(s, len(s), cap(s)) s = append(s, 1, 2, 3, 4) fmt.Printf(\"%p \", s) fmt.Println(s, len(s), cap(s)) } // Output 0xc000124180 [] 0 3 0xc000146030 [1 2 3 4] 4 6 内存的重新分配就是切片的扩容，其逻辑是，为切片分配一块更大的内存，然后将旧切片的元素复制到新切片中。 一个很有意思的情况如下，将切片 s 赋值给一个新的切片 l，然后对原切片 s 进行扩容和修改，不会影响到切片 l func main() { s := make([]int, 3, 3) fmt.Printf(\"%p %v\\n\", s, s) l := s[:] s = append(s, 1) s[0] = 1 fmt.Printf(\"%p %v\\n\", s, s) fmt.Printf(\"%p %v\", l, l) } // Output 0xc000124180 [0 0 0] 0xc000146030 [1 0 0 1] 0xc000124180 [0 0 0] 最后一个值得注意的问题是切片每次扩容会扩大多少，这个逻辑位于 src/runtime/slice.go 文件中的 growslice 函数中，其中 old.len 是旧长度，old.cap 是旧容量，newcap 是新容量，cap 是需要的容量， // ...省略 newcap := old.cap doublecap := newcap + newcap if cap \u003e doublecap { newcap = cap } else { if old.len \u003c 1024 { newcap = doublecap } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. for 0 \u003c newcap \u0026\u0026 newcap \u003c cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = cap } } } // ...省略 简单描述就是： 如果需要的容量超过原切片容量的两倍，直接使用需要的容量作为新容量； 如果原切片的长度小于 1024，新切片的容量翻倍； 如果原切片的长度大于1024，则每次增加25%，直到新容量超过所需要的容量； 第二条的翻倍倒是可以确认，但第一条和第三条经验证却不太符合 func main() { // 1. 需要的容量超过原切片容量的两倍，新容量应为需要的容量5 s1 := make([]int, 2) fmt.Printf(\"%p %v\\n\", s1, cap(s1)) s1 = append(s1, 3, 4, 5) fmt.Printf(\"%p %v\\n\", s1, cap(s1)) // 2. 原切片长度小于1024，新容量应当翻倍为4 s2 := make([]int, 2) fmt.Printf(\"%p %v\\n\", s2, cap(s2)) s2 = append(s2, 3) fmt.Printf(\"%p %v\\n\", s2, cap(s2)) // 3. 原切片长度大于1024，新容量递增25%1次，应当为1500 s3 := make([]int, 1200) fmt.Printf(\"%p %v\\n\", s3, cap(s3)) s3 = append(s3, 3) fmt.Printf(\"%p %v\", s3, cap(s3)) } // Output 0xc0000120b0 2 0xc00000a390 6 0xc0000120f0 2 0xc0000104c0 4 0xc000100000 1200 0xc00010c000 1536 这是因为扩容的那一段核心源码后面还有一段新容量的处理过程，如下 var overflow bool var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don't need any division/multiplication. // For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. switch { case et.size == 1: lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) \u003e maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) \u003e maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if sys.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026 63 } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026 31 } lenmem = uintptr(old.len) \u003c\u003c shift newlenmem = uintptr(cap) \u003c\u003c shift capmem = roundupsize(uintptr(newcap) \u003c\u003c shift) overflow = uintptr(newcap) \u003e (maxAlloc \u003e\u003e shift) newcap = int(capmem \u003e\u003e shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } 其中 et 是切片中的元素类型，sys.PtrSize 是一个指针的大小，64位系统中为8，主要调用的处理函数 roundupsize 来自 src/runtime/msize.go 文件，如下 // Returns size of the memory block that mallocgc will allocate if you ask for the size. func roundupsize(size uintptr) uintptr { // _MaxSmallSize = 32768 if size \u003c _MaxSmallSize { // smallSizeMax = 1024 if size \u003c= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSiz","date":"2020-07-24","objectID":"/2020/golang-deep-learning-3-slice/:2:0","tags":["Go语法"],"title":"Golang深入学习3-切片","uri":"/2020/golang-deep-learning-3-slice/"},{"categories":["Golang学习之路"],"content":"Go 中字符串虽然作为基本数据类型，但本质依然是字符数组，本篇文章理解 Go 底层 string 类型是如何实现的，以及探讨它与 []byte 之间的关系。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:0:0","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"1. string 标准库 builtin 声明了 Go 所有的预定义标识符，其中对 string 的描述如下 string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable. 意思是字符串是字节的一个序列，约定但不必须是 UTF-8 编码的文本。字符串可以为空但不能是nil，其值不可变。Go 中字符串的源码定义在 src/runtime/string.go 中，如下 type stringStruct struct { str unsafe.Pointer len int } 所以 Go 中字符串是一个结构体，其中包含两个字段，第一个字段 str 是个指针，第二个字段 len 是字符串长度。str 指针虽然是 unsafe.Pointer 类型，但它最后其实指向了一个 byte 类型的数组，如下 //go:nosplit func gostringnocopy(str *byte) string { ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)} s := *(*string)(unsafe.Pointer(\u0026ss)) return s } 所以我们理解了字符串的赋值其实是指针的复制，同时我们还注意到字符串长度其实调用了 findnull 函数 func findnullw(s *uint16) int { if s == nil { return 0 } p := (*[maxAlloc/2/2 - 1]uint16)(unsafe.Pointer(s)) l := 0 for p[l] != 0 { l++ } return l } 在 findnull 的实现中，maxAlloc 是允许用户分配的最大虚拟内存空间。在 64 位，理论上可分配最大 1 \u003c\u003c heapAddrBits 字节。在 32 位，最大可分配小于 1 \u003c\u003c 32 字节。所以，求长度的逻辑是：如果指针悬空，那么字符串长度为0，否则将指针转换为一个字符数组的指针，然后判断这个字符数组的每个值是否存在，第一个为0的值对应的索引就是字符串的长度。 字符串的值不可改变这个特性是通过禁止访问 str 指针指向的内存的值实现的，但 str 指针本身的值是可以改变的，也就是说它指向的内存区域可以改变，所以字符串可以重复赋值 s := \"hello\" // str 指针指向\"hello\"的内存 s = \"world\" // str 指针指向\"world\"的内存 字符串同时也支持切片操作，我们可以理解为 str 的重新赋值和 len 的重新计算，比如下面的语句中，hello 和 world 其实都指向 s 所指向的内存区域，只是指针的位置不一样。 s := \"hello, world\" hello := s[:5] world := s[7:] 最后，虽然字符串底层指向一个 byte 数组，单独访问其元素得到的类型也是 byte，但使用 for range 语法遍历时，单个值的类型却是 rune。 func main() { s := \"hello\" fmt.Printf(\"%T \", s[1]) for _, v := range s { fmt.Printf(\"%T\", v) break } } // Output uint8 int32 这里主要是因为 Go 专门做了一个解码操作，如下，注意这里的代码不是真的底层实现，只是用来说明逻辑的 func forOnString(s string, forBody func(i int, r rune)) { for i := 0; len(s) \u003e 0; { r,size := utf8.DecodeRuneInString(s) forBody(i,r) s = s[size:] i += size } } ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:1:0","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2. 转换 由以上可知字符串单个字符可能是 byte 或 rune，这也是我们使用字符串时经常做的强制类型转换。它们隐含者内存的重新分配，代价可能是不一样的，所以这里研究一下。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:0","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2.1 string-\u003e[]byte string 转换 []byte，源码实现如下 func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026\u0026 len(s) \u003c= len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { b = rawbyteslice(len(s)) } copy(b, s) return b } // rawbyteslice allocates a new byte slice. The byte slice is not zeroed. func rawbyteslice(size int) (b []byte) { cap := roundupsize(uintptr(size)) p := mallocgc(cap, nil, false) if cap != uintptr(size) { memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size)) } *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, int(cap)} return } 我们可以看到其实做了一次内存的重新分配，得到了新的字符数组 b，然后将 s 复制给 b。至于 copy 函数可以直接把 string 复制给 []byte，是因为 go 源码单独实现了一个slicestringcopy函数来实现，具体可以看src/runtime/slice.go。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:1","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2.2 []byte-\u003estring []byte 转换 string，源码如下 func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) { if n == 0 { // Turns out to be a relatively common case. // Consider that you want to parse out data between parens in \"foo()bar\", // you find the indices and convert the subslice to string. return \"\" } if raceenabled { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), funcPC(slicebytetostring)) } if msanenabled { msanread(unsafe.Pointer(ptr), uintptr(n)) } if n == 1 { p := unsafe.Pointer(\u0026staticuint64s[*ptr]) if sys.BigEndian { p = add(p, 7) } stringStructOf(\u0026str).str = p stringStructOf(\u0026str).len = 1 return } var p unsafe.Pointer if buf != nil \u0026\u0026 n \u003c= len(buf) { p = unsafe.Pointer(buf) } else { p = mallocgc(uintptr(n), nil, false) } stringStructOf(\u0026str).str = p stringStructOf(\u0026str).len = n memmove(p, unsafe.Pointer(ptr), uintptr(n)) return } func stringStructOf(sp *string) *stringStruct { return (*stringStruct)(unsafe.Pointer(sp)) } 该转换的思路是新分配 s，然后将 b 复制给它，所以依然有内存的重新分配。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:2","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2.3 string-\u003e[]rune 源码如下，由于 byte 和 rune 类型的差异，比如进行内存的重新分配。 func stringtoslicerune(buf *[tmpStringBufSize]rune, s string) []rune { // two passes. // unlike slicerunetostring, no race because strings are immutable. n := 0 for range s { n++ } var a []rune if buf != nil \u0026\u0026 n \u003c= len(buf) { *buf = [tmpStringBufSize]rune{} a = buf[:n] } else { a = rawruneslice(n) } n = 0 for _, r := range s { a[n] = r n++ } return a } // rawruneslice allocates a new rune slice. The rune slice is not zeroed. func rawruneslice(size int) (b []rune) { if uintptr(size) \u003e maxAlloc/4 { throw(\"out of memory\") } mem := roundupsize(uintptr(size) * 4) p := mallocgc(mem, nil, false) if mem != uintptr(size)*4 { memclrNoHeapPointers(add(p, uintptr(size)*4), mem-uintptr(size)*4) } *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, int(mem / 4)} return } ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:3","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2.4 []rune-\u003estring 源码如下，内存分配没得跑。 func slicerunetostring(buf *tmpBuf, a []rune) string { if raceenabled \u0026\u0026 len(a) \u003e 0 { racereadrangepc(unsafe.Pointer(\u0026a[0]), uintptr(len(a))*unsafe.Sizeof(a[0]), getcallerpc(), funcPC(slicerunetostring)) } if msanenabled \u0026\u0026 len(a) \u003e 0 { msanread(unsafe.Pointer(\u0026a[0]), uintptr(len(a))*unsafe.Sizeof(a[0])) } var dum [4]byte size1 := 0 for _, r := range a { size1 += encoderune(dum[:], r) } s, b := rawstringtmp(buf, size1+3) size2 := 0 for _, r := range a { // check for race if size2 \u003e= size1 { break } size2 += encoderune(b[size2:], r) } return s[:size2] } func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) { if buf != nil \u0026\u0026 l \u003c= len(buf) { b = buf[:l] s = slicebytetostringtmp(\u0026b[0], len(b)) } else { s, b = rawstring(l) } return } func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false) stringStructOf(\u0026s).str = p stringStructOf(\u0026s).len = size *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, size} return } ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:4","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"3. 总结 string 和 []byte，string 和 []rune 的转换都会进行内存的重新分配，有一定代价； 直接访问 string 中的成员，类型为 byte，使用 for range 结构，类型为 rune； 需要修改 string 中的成员时，需要转换 []byte； ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:3:0","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"本篇介绍 Go 中的指针、uintptr 和 unsafe.Pointer 三个概念。 ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:0:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"1. 指针 Go 中指针的概念与 C 相同，只是指针本身不能进行运算。 任何一个变量在运行时都有一个地址，这个地址代表它在内存中的位置，在变量名前使用取地址符 \u0026 可以获取该变量的内存地址，比如 ptr := \u0026v 其中 v 是一个变量，ptr 用来保存它的内存地址，ptr 就是指针。当然，准确的来说，ptr 是一个指针变量，作为变量，仍然是用来保存数据，只不过这里它特别用来保存一个内存地址而已。 一个指针变量需要使用 * 来声明，如下 var ptr *int * 代表 ptr 保存一个地址，而 int 代表这个地址指向的内存所保存的数据是 int 类型。这里要注意，*int 和 *string 是不同的指针类型，不能相互赋值，如下例，指针的类型与它所指向的内存地址保存的数据类型有关。 func main() { var a *int b := \"hello\" a = \u0026b } // Output .\\main.go:6:4: cannot use \u0026b (type *string) as type *int in assignment 指针在声明但未赋值时其值为 nil，不指向任何内存 func main() { var a *int fmt.Println(a) } // Output \u003cnil\u003e 将一个变量的地址赋值给指针后，进行使用要利用 * 符号，否则其值就是所保存的内存地址 func main() { var a *int b := 10 a = \u0026b fmt.Println(a, *a) } // Output 0xc000012098 10 ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:1:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"2. unsafe.Pointer 我们已经知道不同的指针类型间不能相互赋值，另外，它们也不能进行类型转换 func main() { var a *int b := 10 a = \u0026b c := (*float64)(a) } // Output .\\main.go:7:17: cannot convert a (type *int) to type *float64 unsafe.Pointer 是特别定义的一种指针类型，它可以包含任意类型变量的地址，也就是说无论 int、float64 还是其它类型的变量，内存地址都可以交给它保存。 package main import ( \"fmt\" \"unsafe\" ) func main() { b := 10 var a *int = \u0026b c := unsafe.Pointer(a) fmt.Println(c) } // Output 0xc000012098 从上面的程序注意到两点 unsafe.Pointer 来自 unsafe 包，不是内置类型； unsafe.Pointer 一般作为指针类型转换的桥梁使用 unsafe.Pointer 本质是一个 *int，在 unsafe 包中定义如下 type ArbitraryType int type Pointer *ArbitraryType unsafe.Pointer 的使用说明如下 任意类型的指针可以转换为一个Pointer类型值 一个Pointer类型值可以转换为任意类型的指针 一个uintptr类型值可以转换为一个Pointer类型值 一个Pointer类型值可以转换为一个uintptr类型值 下面是一个使用 unsafe.Pointer 作为桥梁进行类型转换的例子 func main() { b := 10 var a *int = \u0026b c := (*float64)(unsafe.Pointer(a)) } ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:2:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"3. uintptr uintptr 确确实实是 Go 的基本类型，属于整型的一种，被设计为足够容纳一个指针。在 Go 中指针是不允许进行运算的，但 uintptr 可以，所以它的意义在于将其它类型的指针转换成它进行运算，然后再转换回原本的类型。 type User struct { Name string Age int } func main() { u := new(User) name :=(*string)(unsafe.Pointer(u)) *name = \"test\" age := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(u)) + unsafe.Offsetof(u.Age))) *age = 18 fmt.Println(u) } 思路: 如果想对 Name 和 Age 进行赋值，那首先应该先拿到相应的地址，然后对地址内容修改，所以我们可以分别定义一个 string 和 int 分别指向 Name 和 Age的地址 对于 u 这个结构体，u 的首地址就是 Name 的地址，但是 u 是结构体指针，所以只需要将u转换成 *string 即可 对于 Age，我们已经拿到了Name的地址，在此基础上进行偏移即可，也就是 unsafe.Offsetof(u.Age) 的偏移量， 但是 Pointer不能进行指针运算，随意需要将 Pointer 转换成 uintptr ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:3:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"4. 说明 这里有两点要说明。 第一，理解 unsafe.Pointer 和 uintptr 是因为 Go 源码中很多实现都使用了这两个概念，比如接口类型的定义 type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter *interfacetype _type *_type hash uint32 _ [4]byte fun [1]uintptr } 第二，使用 unsafe.Pointer 和 uintptr 要非常注意，因为它们绕过了类型系统直接操作内存地址。 ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:4:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["爱编程爱技术的孩子"],"content":"分支限界和回溯都是有效搜索解空间树的方法，不同的是，分支限界使用广度优先或最小耗费/最大效益优先的方式。 ","date":"2020-07-23","objectID":"/2020/algorithm-branch-and-bound/:0:0","tags":["数据结构与算法"],"title":"算法-分支限界","uri":"/2020/algorithm-branch-and-bound/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 基本思想 首先介绍几个概念 活结点：自身已生成但其儿子节点还未全部生成的结点 扩展结点：当前正在处理的结点 死结点：所有儿子已经生成 叶结点：可行解 知道了这几个概念后，分支限界的思想可以描述为：在扩展结点处，先生成其所有儿子结点（分支），在每一个活结点处，估算目标函数的界（限界）。那些导致不可行解或非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中，然后根据已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进。当一个叶结点称为扩展结点时（此时活结点表中其它结点的函数值均不超过该叶结点的函数值），该叶结点相应的解即为问题的最优解。 所以可以看出，剪枝的方法和回溯基本相同，不同的是，同一层的所有可行结点组成了一个活结点列表，每次需要在活结点列表中寻找最优的解，实现活结点列表主要有两种方式 队列 优先队列 ","date":"2020-07-23","objectID":"/2020/algorithm-branch-and-bound/:1:0","tags":["数据结构与算法"],"title":"算法-分支限界","uri":"/2020/algorithm-branch-and-bound/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 旅行旅行商问题 某售货员要到若干城市去推销商品，已知 各城市之间的路程(或旅费)。他要选定一条从驻地出发，经过每个城市一次，最后回到驻地的路线，使总的路程(或总旅费)最小。 旅行商问题的解空间树中，从根结点到任一叶结点就是一条售货员的行走路径，所以我们要做的就是构建这棵树然后找到根结点到叶子结点的最小路径和。 如下，假设有一个在 4 个城市推销商品的例子，构建解空间树如下 我们选择第 1 个城市作为起点，所以把它加入活结点列表，由于当前只有它一个活结点，将其作为扩展结点。此时当前路程费用为 0 （因为还没开始走），限界函数 rcost 的值为 18，这个数字是这样得到的 rcost 代表限界函数，其作用应当是找到可行的最优解，这里的最优解就是剩下的路程费用之和最低； 剩下的路程费用之和的下界应当这样来计算：所有没有走过的城市相邻边的最小值之和，也就是还没有访问的所有结点的最小出边费用之和，在当前，还位于起点，这就意味着所有的城市都还没走出去，那么四个城市相邻的边的最小值之和就是 rcost = 4(第一个城市) + 5（第2个城市）+ 5（第三个城市）+ 4（第4个城市）= 18 我们应当对活结点列表中所有活结点的 cc 值进行比较（cc 是当前路程费用），选择值最小的那个结点作为扩展结点，不过此时活结点列表只有第一个城市，所以只能选择它。 接下来就构建当前扩展结点的儿子结点，遍历所有其它节点，所有与当前扩展结点相邻的城市加入活结点列表，然后计算所有活结点的 cc 值，选择值最小的那一个，这里是第四个城市，以此类推，最终到达叶节点，此时得到了第一个 rcost 值，也就是当前最短回路的费用，其后只要选择 rcost 最小的那个就好。 算法思想可以描述如下 //初始化。s：结点在排列树中的层次，cc：当前费用，rcost：x[s:n-1]中顶点,最小出边费用和， bestc：当前最优值 s=0;x[0]=1;x[1:n-1+=(2,3,…,n);cc=0;rcost=Minout*1++Minout*2++…+Minout*n+ bestc=NoEdge //搜索排列树 While 当前扩展结点非叶结点 if 当前扩展结点是叶结点的父结点 if 叶结点存在一条可行回路且该回路的费用小于当前最优值 bestc = 该回路的费用 将叶结点插入活结点优先队列（最小堆） else 舍弃该扩展结点 else 产生当前扩展结点的儿子结点 for i=s+1 to n do 更新可行儿子结点的状态：cc, rcost b = cc + rcost //更新子树的下界 if b \u003c bestc //子树可能含最优解 将结点插入活结点优先队列（最小堆） // 从活结点优先队列中取下一扩展结点 ","date":"2020-07-23","objectID":"/2020/algorithm-branch-and-bound/:2:0","tags":["数据结构与算法"],"title":"算法-分支限界","uri":"/2020/algorithm-branch-and-bound/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 最大团问题 给定一个无向图G=(V,E)。如果U包含于V，且对任 意u,v属于U有(u,v)属于E，则称U是G的一个完全子 图。G的完全子图U是G的一个团当且仅当U不包含 在G的更大的完全子图中。G的最大团是指G中所 含顶点数最多的团。 例如，子集{1,2}是G的一个大小为2的完全子图，但不 是一个团，因为它包含于G的更大的完全子图{1,2,5}中。 {1,2,5}、{1,4,5}和{2,3,5}都是G的最大团。 上面的问题其实是图G的顶点集V的子集选取问题，解空间树可以看作一个子集树，剪枝的方法总结如下 左子树：从顶点i到已选入的顶点集中每一个顶点都有边， 否则剪枝 右子树：顶点数上界小于当前最优值时剪枝，顶点数上界 = 已确定的顶点数 + 未确定的顶点数的上界 ","date":"2020-07-23","objectID":"/2020/algorithm-branch-and-bound/:3:0","tags":["数据结构与算法"],"title":"算法-分支限界","uri":"/2020/algorithm-branch-and-bound/"},{"categories":["爱编程爱技术的孩子"],"content":"两台主机间的数据传输，通常不是直达的，而是分成一段一段的链路。两个相邻节点间如何传输数据，是数据链路层关心的事情。 由于物理层已经完成了比特流的传输，数据链路层考虑的就是上一层的事情：如何将网络层交下来的数据报组装成基本传输单位帧，然后将帧发送出去，或者将物理层交上来的比特流划分成帧，取出数据部分后上交给网络层。 尽管传输媒体和通信手段的差异已经被屏蔽，数据链路层依然要考虑两种不同类型的信道： 点对点信道：一对一的通信方式； 广播信道：一对多的广播通信方式，同时与多台主机通信。 此外，关于传输的基本单位：帧，还要考虑如何对帧进行划分、如何完成差错检测等各种事情。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:0:0","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 帧 链路层的基本传输单位叫做帧，帧是在网络层交付的 IP 数据报的基础上添加帧头帧尾构成的，然后移交物理层，由物理层作为纯粹的比特流传输给目标主机，目标主机物理层收到后，根据首尾标记，对比特流重新划分形成帧，校验后无差错则去除帧头帧尾交付网络层。 所以数据链路层考虑如何封装成帧，从比特流解析出帧以及进行差错检测，前面两件事是相反的过程。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:1:0","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 封装成帧 封装成帧(framing)就是在一段数据（网络层的 IP 数据报）的前后分别添加首部和尾部，这样就构成了一个帧。 帧所携带的数据长度有一个上限，叫做最大传输单元MTU（Maximum Transfer Unit）。帧首部和尾部的主要作用是进行帧定界（确定帧的界限）以及包括许多控制信息。 对于点对点协议 PPP（Point-to-Point Protocol）来说，帧格式如下 首部和尾部分别为四个字段和两个字段。 首部的第一个字段和尾部的第二个字段都是标志字段F (Flag)，规定为0x7E（十六进制的7E的二进制表示是01111110）。标志字段表示一个帧的开始或结束，也就是定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃 首部中的地址字段A规定为0xFF（即11111111），控制字段C规定为0x03（即00000011）。至今没有实际的意义。首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是 IP 数据报。若为0xC021,则信息字段是 PPP 链路控制协议 LCP 的数据，而 0x8021 表示这是网络层的控制数据。 尾部中的第一个字段（2字节）是使用CRC的帧检验序列 FCS。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:1:1","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 透明传输 透明传输的意思是不管什么样的数据都能通过数据链路层，实现这一点解决的主要是一个问题，即帧的数据部分出现了和帧定界符相同的编码，导致无法正确的划分帧。 这种情况广泛出现在传输程序或图像等非 ASCII 码串时，解决方法是在数据中出现帧定界符时在前面加一个转义字符 0x7D（即01111101），如果要传输的字段本身就是转义字符，那么将其变成（0x7D, 0x5D）来传输，接收端在将数据送往网络层前会把转义符删掉。这种方法称为字节填充或字符填充。 上面提到的办法是异步传输时实用的方法，同步传输时采用零比特填充。即在发送端，先扫描整个信息字段，只要发现有5个连续1，则立即填入一个0，从而保证在信息字段中不会出现6个连续1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:1:2","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 差错检测 差错检测是指检测传输的数据中 0 变成 1，1 变成 0 的情况，使用的方法是循环冗余检验。 在发送端，先把数据划分为组，假定每组 k个比特。现假定待传送的数据 M = 101001 （k =6）。CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位冗余码，然后构成一个帧发送出去，一共发送(k + n)位。这n 位冗余码可用以下方法得出：在 M 后面添加 n 个0，得到的 k + n 位的数除以收发双方事先商定的长度为 n + 1 位的除数P，得出商是 Q 而余数是 R（n 位，比P少一位），这个余数就是冗余码。 下图所示的例子中，M = 101001（即k= 6），假定除数P = 1101（即n = 3），经模2除法运算后的结果是：商Q = 110101（这个商并没有什么用处），而余数 R = 001。这个余数 R 就作为冗余码拼接在数据 M 的后面发送出去。这种为了进行检错而添加的冗余码常称为帧检验序列 FCS(Frame Check Sequence)。 在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一个帧都除以同样的除数P（模2运算），然后检查得到的余数 R。如果无差错，那么余数应当为 0。 除数 P 的生成一般使用多项式，如给定多项式 $P(X) = x^3 + x^2 +1$，那么除数 P = 1101 但链路层的差错检测只检测比特的错误变动，对于 帧丢失、帧重复、帧失序 这些情况不做检测，这些问题由运输层的 TCP 保证。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:1:3","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 以太网 对使用广播信道的数据链路层，主要讨论的是局域网，而由于现在局域网中以太网占主流，实际讨论内容是以太网。另外要注意的是，局域网工作的层次跨越了数据链路层和物理层。由于局域网技术中有关数据链路层的内容比较丰富，因此把局域网的内容放在数据链路层中讨论。但这并不表示局域网仅仅和数据链路层有关。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:2:0","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 适配器 两台计算机除了需要物理线路（有线或无线）来连接，还必须有一些规范定义这些数据如何传输，实现这些规范的通常是网络适配器（有硬件和软件两方面的含义） 计算机与外界局域网的连接主要是通过适配器，就是我们说的网卡。适配器与局域网的通信是通过双绞线以串行方式进行的，而适配器与计算机的通信是通过主板上的 I/O 总线以并行方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。若在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。 适配器接收和发送各种帧时不使用计算机的CPU。这时CPU可以处理其他任务。当适配器收到有差错的帧时，就把这个帧丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机并交付协议栈中的网络层。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。我们特别要注意，计算机的硬件地址（MAC地址）在适配器的ROM中，而计算机的软件地址（IP地址）则在计算机的存储器中。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:2:1","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 CSMA/CD 在以太网中所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。以太网采用的协议叫做 CSMA/CD，意思是载波监听多点接入/碰撞检测(Carrier SenseMultiple Access with Collision Detection)。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:2:2","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 集线器 集线器工作在物理层，它的每个接口仅仅简单地转发比特——收到1就转发1，收到0就转发0，不进行碰撞检测。若两个接口同时有信号输入（即发生碰撞），那么所有的接口都将收不到正确的帧。 集线器的主要作用是扩展一个以太网的覆盖范围。如下图，使用多个集线器可以构成一个覆盖更大范围的局域网。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:2:3","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 MAC层 数据链路层分为上层LLC（Logical Links Control，逻辑链路控制），和下层的MAC（媒体访问控制），MAC主要负责控制与连接物理层的物理介质。 IEEE802 标准为局域网规定了一种48位（6字节）的全球地址，这种地址固化在适配器的ROM中，叫做 MAC 地址，除非更换适配器，其它的操作都不会对计算机的 MAC 地址产生影响，因此，MAC 地址实际上可以看作计算机的名字。 48位的 MAC 地址可组成 $2^{46}$ 个地址，超过 70万亿，足够区分全世界所有的计算机。 MAC地址的前三字节由 IEEE 的注册管理机构 RA 分配给世界上所有生产适配器的厂家，后三个字节由厂家自行指派，只要没有重复地址即可。 当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。 常用的以太网 MAC 帧标准为以太网 V2 标准，帧格式如下 目的地址和源地址指的都是 MAC 地址，类型指上层使用的协议，比如 IP。以太网 MAC 帧的最小长度为 64字节，因此数据部分最小长度为 64-18 = 46 字节，数据部分最大长度为 1500 字节。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:2:4","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"2.5 网桥 集线器工作在物理层，只对数据进行简单转发，网桥工作中数据链路层，会根据 MAC 地址进行针对性转发，这种针对性转发是通过维护一个路由表完成的，路由表中存在网桥接口和MAC地址的对应关系。 两层交换机的本质就是一种多接口网桥。 注意，路由器实际上不属于网桥，它包括网络层，和三层交换机一样，是一个三层设备，不是根据 MAC 地址转发，而是根据网络层的 IP 地址转发。 ","date":"2020-07-19","objectID":"/2020/data-link-layer/:2:5","tags":["计算机基础"],"title":"计算机网络-数据链路层","uri":"/2020/data-link-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"物理层是 OSI 体系最下面的一层，涉及的多数是关于传输媒体和数据通信的知识，概念居多，本篇不详细解释，仅分辨物理层的主要任务。 物理层考虑的问题是如何传输比特流，它要负责向数据链路层屏蔽掉传输媒体和通信手段的差异，从而使上层能专注自己的协议和服务。 物理层虽然名字中带有「物理」，但并不是指具体的传输媒体，比如各种线缆和硬件接口，而是考虑如何在这些传输媒体上传输数据比特流。 如果我们更具体地阐述物理层的任务，那么包括： 机械特性：定义各种接口所用接线器的形状、尺寸、引脚数目和排列、固定和锁定装置等； 电气特性：定义在接口电缆的各条线上出现的电压的范围； 功能特性：定义某条线上出现的某一电平的电压的意义； 过程特性：定义对于不同功能的可能事件的出现顺序； 最后，由于传输媒体中数据的传输一般是串行的，计算机中数据的传输一般是并行的，物理层还要完成数据的串并转换。 因此，我们提到物理层协议的时候，一般是对各种有线传输媒体（双绞线、同轴电缆、光纤等）的接口标准定义和各种无线通信方式的标准定义。此外，介绍物理层还经常介绍一些通信知识，比如信道和各种复用技术。 ","date":"2020-07-19","objectID":"/2020/physical-layer/:0:0","tags":["计算机基础"],"title":"计算机网络-物理层","uri":"/2020/physical-layer/"},{"categories":["爱编程爱技术的孩子"],"content":"本文学习 Nginx 的相关知识。 ","date":"2020-07-17","objectID":"/2020/nginx-learning/:0:0","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 相关概念 代理服务器：用户浏览器与 Web 服务器之间的服务器，用于代替浏览器向目标服务器发出请求，主要作用是缓存服务器内容，但也可以用作流量控制、安全管理等。基本的工作过程是，用户在本地设定代理服务器地址后，所有的访问请求都会转交到代理服务器，如果代理服务器本地有这些内容，就会直接返回，如果没有，就向真正的目标服务器发出请求，获取到内容后再向用户返回。众所周知的 VPN 其实也是代理服务器的应用，我们使用服务商提供的或自己购买的服务器来访问其它网络，而不是使用自己的本地机器。 反向代理服务器：反向代理服务器和代理服务器所处的位置相同，都是用户浏览器和目标服务器中间，但它不是为用户服务的，而是作为目标服务器的辅助。其存在价值在于，将真正的服务器放在一个内网中，由防火墙保护，所有访问真正服务器的请求，都会交给反向代理服务器来处理，因为数据本身还是存放在真正的服务器上，对代理服务器的攻击并不会产生影响。实际上，对用户来说，反向代理服务器外在表现就是一台真正的 Web 服务器，和直接访问目标服务器没有太大区别。最后，当请求量比较大时，还可以设置多台反向代理服务器，来分担目标服务器的压力。 Nginx：反向代理服务器并不是说服务器本身有区别，而是其承担的功能有区别，这些功能由某些特定的软件来完成，Nginx 就是一种这样的软件，它可以作为 HTTP 服务器、反向代理服务器以及邮件代理服务器（IMAP/POP3/SMTP）。Nginx 由俄罗斯程序员 Igor Sysoev 开发，最初是作为邮件代理服务器使用的。Nginx 最大特点就是资源消耗低、稳定、支持高并发，因此得到了广泛的使用。 Apache 也是我们常提的 Web 服务器，它和 Nginx 的主要区别是： Apache 一个连接对应一个进程，而 Nginx 可以多个连接（万级别）对应一个进程，因此 Nginx 更轻量，对并发的支持更好； Apache 在处理动态请求方面更有优势，而 Nginx 处理静态请求性能更高；这里静态请求指的是返回的页面是固定的，不管谁访问都一样，动态请求指的是需要服务端根据请求做处理，填充完页面后再返回，返回的内容是根据用户或请求的不同而不同的； Nginx 使用 C 编写，同样的 Web 服务，占用更少的内存和资源； Nginx 配置简介，启动方便，运行稳定，几乎可以做到 7*24 不间断运行，连续运行数月也不需要重新启动。 总之，一般来说，需要性能的 web 服务，用 Nginx 。如果不需要性能只求稳定，更考虑 Apache 。更为通用的方案是，前端 Nginx 抗并发，后端 Apache 集群，配合起来会更好。 Tomcat 是另一个常听的名词，这是一个 Web 应用服务器，本质和 Apache 以及 Nginx 是不冲突的，可以这样理解，服务端的应用在 Tomcat 中保持运行，为 Apache 或 Nginx 提供服务，而 Apache 或 Nginx 代理用户的请求，它们本身并不对请求做处理，只是转发。Tomcat 一般只用作 Java 的应用服务器，当然，某种程度上也可以代理 Apache 或 Nginx 的功能，但显然性能不如这两者。 ","date":"2020-07-17","objectID":"/2020/nginx-learning/:1:0","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 安装 官方下载地址为 http://nginx.org/en/download.html，共提供了三个版本 Mainline version：可以理解为开发版 Stable version：稳定版 Legacy version：曾发布的老版本的稳定版 Nginx 提供 windows 版本，下载解压后是 exe 格式，可以双击安装，不过，考虑到它本身是用作服务器的，所以只介绍 Linux 的安装使用。 ","date":"2020-07-17","objectID":"/2020/nginx-learning/:2:0","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 源码安装 Nginx 可以从源码编译安装，教程参考 Building nginx from sources ","date":"2020-07-17","objectID":"/2020/nginx-learning/:2:1","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 二进制包安装 这里只介绍 Ubuntu，其它 Linux 系统的下载安装参考 nginx:Linux packages， 安装依赖 $ sudo apt install curl gnupg2 ca-certificates lsb-release 为安装包建立 apt 仓库 $ echo \"deb http://nginx.org/packages/ubuntu 'lsb_release -cs' nginx\" \\ | sudo tee /etc/apt/sources.list.d/nginx.list | 是管道符，将前面命令的输出作为后面命令的输入，tee 将内容同时输出的文件和当前终端，如果文件不存在，则创建，如果已存在，则覆盖。 导入官方的验证签名，从而使系统可以自动的验证包的正确性 $ curl -fsSL https://nginx.org/keys/nginx_signing.key | sudo apt-key add - 验证 $ sudo apt-key fingerprint ABF5BD827BD9BF62 pub rsa2048 2011-08-19 [SC] [expires: 2024-06-14] 573B FD6B 3D8F BC64 1079 A6AB ABF5 BD82 7BD9 BF62 uid [ unknown] nginx signing key \u003csigning-key@nginx.com\u003e 安装 Nginx $ sudo apt update $ sudo apt install nginx 验证 $ nginx -v nginx version: nginx/1.18.0 $ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu Focal Fossa (development branch) Release: 20.04 Codename: focal ","date":"2020-07-17","objectID":"/2020/nginx-learning/:2:2","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 使用 本节描述如何启动和停止 nginx 服务，重新加载配置，解释配置文件的结构，描述如何设置 nginx 使其服务于静态内容，以及如何配置其作为一个代理服务器。 nginx 有一个 master 进程和多个 worker 进程，master 进程的主要作用是读取和评估配置，以及维护 worker 进程。worker 进程对请求进行实际的处理。nginx使用基于事件的模型和依赖于操作系统的机制来有效地在 worker 进程之间分配请求。worker 进程的数量在配置文件中定义，可以固定，也可以自动调整为可用CPU内核的数量。 nginx 及其模块的工作方式在配置文件中定义。默认情况下，配置文件名为 nginx.conf，并放置在目录 /usr/local/nginx/conf，/etc/nginx或/usr/local/etc/nginx 中。 ","date":"2020-07-17","objectID":"/2020/nginx-learning/:3:0","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 启动和停止 直接执行 nginx 命令即可启动，此时由 root 用户启动了 master 进程，然后自行创建 nginx 用户创建 worker 进程 $ sudo nginx 启动后就可以使用 -s 参数发送信号到 master 进程进行控制 $ nginx -s signal 其中，signal 为参数，可选的有四种 stop：快速停止 quit：正常停止 reload：重新加载配置文件 reopen：重启打开日志文件 在重新加载配置文件或重新启动前，配置文件不会被应用。而一旦 master 进程接收到 reload 信号，就会检查新配置文件的语法有效性，并尝试应用其中提供的配置。如果成功，则主进程将启动新的工作进程并将消息发送到旧的工作进程，以要求它们关闭。否则，主进程将回滚更改并继续使用旧配置。旧的工作进程接收到关闭命令，停止接受新的连接并继续为当前请求提供服务，直到为所有此类请求提供服务。之后，旧的工作进程退出。 也可以借助 Unix工具（例如kill工具）将信号发送到 nginx 进程。在这种情况下，将信号直接发送给具有给定进程ID 的进程。默认情况下，nginx 主进程的进程ID写入目录 /usr/local/nginx/logs 或 /var/run 中的nginx.pid。例如，如果主进程ID为1628，要发送 QUIT 信号导致 nginx 正常关闭，请执行： $ kill -s QUIT 1628 为了获取所有正在运行的nginx进程的列表，可以使用ps实用程序，例如，通过以下方式： $ ps -ax | grep nginx ","date":"2020-07-17","objectID":"/2020/nginx-learning/:3:1","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 配置文件结构 nginx 由模块组成，这些模块受配置文件中指定的指令控制。指令分为简单指令和块指令。一个简单指令由名称和参数组成，名称和参数之间用空格分隔，并以分号（;）结尾。块指令同样由名称和参数组成，但它的参数就是一批简单指令，并用大括号包围。块指令内的内容称为上下文（比如事件，http，服务器和位置）。初始的配置文件内容如下，我们可以看到上述描述的基本结构 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } 上下文外的指令（及块指令外的简单指令，比如上面第一行的 user nginx;）被视为位于主上下文中。事件 和 http指令位于主上下文中，服务器位于 http 中，位置位于服务器中。 # 后的内容视为注释 ","date":"2020-07-17","objectID":"/2020/nginx-learning/:3:2","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 服务于静态内容 Web服务器的一项重要任务是分发文件（例如图像或静态HTML页面）。这里将实现一个示例，其中根据请求从不同的本地目录提供文件：/data/www（可能包含HTML文件）和 /data/images（包含图像）。这一任务需要编辑配置文件，在服务器块指令下的 http 块中使用两个 位置块。 创建 /data/www 目录，将 index.html 文件放入其中， 创建 /data/images 目录，放一些图片进去。 打开配置文件，在 http 块中增加 server 块，结构如下 http { server { } } 通常，配置文件会包含多个服务器块，这些服务器块以服务器名和它们监听的端口号来区分。服务器处理的请求在下面的 location 子块中定义，如下 location / { root /data/www; } 接收到的请求会与 location 后的 / 进行匹配，如果匹配，则到块内部的位置寻找文件，继续举例，下面的例子中与 /images/ 路径匹配，然后到 root /data 中寻找文件 location /images/ { root /data; } 还会发现的是，如果 /images/ 请求传进来，实际上上面两个块都会匹配成功，在 nginx 中，如果有多个匹配成功的位置块，将会选择前缀最长的那个，也就是 /images/ 一个完整的结构如下 server { location / { root /data/www; } location /images/ { root /data; } } 到现在为止，这就是一个可用的服务器配置了，它会监听标准的 80 端口，并且在本地计算机的 http:/localhost/ 上相应服务。以 /images/ 开头的 URL 请求，服务器将从 /data/images 目录查找文件并返回，例如，收到的请求为 http://localhost/images/example.png ，nginx 将返回 /data/images/example.png 文件，如果文件不存在，将返回 404 错误。 要应用上述配置文件，执行重新加载配置文件命令 $ nginx -s reload 如果不起作用，可以从 /usr/local/nginx/logs 或 /var/log/nginx 目录下的 access.log 和 error.log 文件中查找原因。 ","date":"2020-07-17","objectID":"/2020/nginx-learning/:3:3","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 设置简单的代理服务器 nginx的一种常用用法是将其设置为代理服务器，这意味着服务器可以接收请求，将请求传递给代理服务器，从请求中检索响应并将它们发送给客户端。 我们将配置一个基本的代理服务器，该服务器为图像请求和本地目录中的文件提供服务，并将所有其他请求发送到代理服务器。在此示例中，两个服务器都将在单个nginx实例上定义。 首先，通过向nginx的配置文件中添加一个包含以下内容的服务器块来定义代理服务器： server { listen 8080; root /data/up1; location / { } } 这将是一个简单的服务器，它在端口8080上侦听（以前，由于使用了标准端口80，所以未指定listen指令），并将所有请求映射到本地文件系统上的/ data / up1目录。创建此目录，并将index.html文件放入其中。请注意，根指令位于服务器上下文中。当选择用于服务请求的位置块不包含自己的根指令时，将使用这种根指令。 接下来，使用上一部分中的服务器配置并对其进行修改以使其成为代理服务器配置。在第一个位置块中，将proxy_pass指令与参数中指定的代理服务器的协议，名称和端口放在一起（在本例中为http：// localhost：8080）： server { location / { proxy_pass http://localhost:8080; } location /images/ { root /data; } } 我们将修改第二个位置块，该位置块当前将带有/ images /前缀的请求映射到/ data / images目录下的文件，以使其与具有典型文件扩展名的图像的请求匹配。修改后的位置块如下所示： location ~ \\.(gif|jpg|png)$ { root /data/images; } 该参数是一个正则表达式，它匹配所有以.gif，.jpg或.png结尾的URI。正则表达式应以〜开头。相应的请求将映射到/ data / images目录。 当nginx选择一个位置块来服务请求时，它首先检查指定前缀的位置指令，记住最长的前缀位置，然后检查正则表达式。如果与正则表达式匹配，则nginx会选择此位置，否则，它将选择之前记住的位置。 代理服务器的最终配置如下所示： server { location / { proxy_pass http://localhost:8080/; } location ~ \\.(gif|jpg|png)$ { root /data/images; } } 该服务器将过滤以.gif，.jpg或.png结尾的请求，并将它们映射到/ data / images目录（通过将URI添加到root指令的参数中），并将所有其他请求传递给上述配置的代理服务器。 要应用新配置，请按照前面几节的说明将重新加载配置文件。还有许多其他指令可用于进一步配置代理连接。 更多的内容可以查看 nginx documentation，本文主体都翻译自该文档。 ","date":"2020-07-17","objectID":"/2020/nginx-learning/:3:4","tags":["计算机基础"],"title":"Nginx说明","uri":"/2020/nginx-learning/"},{"categories":["爱编程爱技术的孩子"],"content":"存储过程是在数据库中定义一些 SQL 语句的集合，可以直接调用这些存储过程来执行已经定义好的 SQL 语句。避免了开发人员重复编写相同 SQL 语句的问题。 触发器和存储过程相似，都是嵌入到 MySQL 中的一段程序。触发器是由事件来触发某个操作。当数据库执行这些事件时，就会激活触发器来执行相应的操作。 本篇介绍这两个概念 ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:0:0","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 存储过程 数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。例如，为了确认学生能否毕业，需要同时查询学生档案表、成绩表和综合表，此时就需要使用多条 SQL 语句来针对这几个数据表完成处理要求。存储过程就是这样一组为了完成特定功能的 SQL 语句的集合。 使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成 常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。 一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。 MySQL 5.0 版本以前并不支持存储过程，这使 MySQL 在应用上大打折扣。MySQL 从 5.0 版本开始支持存储过程，既提高了数据库的处理速度，同时也提高了数据库编程的灵活性 存储过程是数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以随时被调用，完成指定的功能操作。 使用存储过程不仅可以提高数据库的访问效率，同时也可以提高数据库使用的安全性。 对于调用者来说，存储过程封装了 SQL 语句，调用者无需考虑逻辑功能的具体实现过程。只是简单调用即可，它可以被 Java 和 C# 等编程语言调用。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:1:0","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 创建存储过程 创建存储过程使用 CREATE PROCEDURE 语句，语法格式如下 CREATE PROCEDURE \u003c过程名\u003e ( [过程参数[,…] ] ) \u003c过程体\u003e 其中，过程参数是存储过程的参数列表。MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入/输出参数既可以充当输入参数也可以充当输出参数。格式如下 [ IN | OUT | INOUT ] \u003c参数名\u003e \u003c类型\u003e 过程体是存储过程的主体部分，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 BEGIN 开始，以关键字 END 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。 在 MySQL 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符，那么 MySQL 服务器在处理时会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的结束符，而不再去处理存储过程体中后面的 SQL 语句，这样显然不行。为解决以上问题，通常使用 DELIMITER 命令将结束命令修改为其他字符。语法格式如下： DELIMITER $$ 语法说明如下： $$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个“?”或两个“￥”等。 当使用 DELIMITER 命令时，应该避免使用反斜杠“\\”字符，因为它是 MySQL 的转义字符。 在 MySQL 命令行客户端输入如下 SQL 语句。 mysql \u003e DELIMITER ?? 成功执行这条 SQL 语句后，任何命令、语句或程序的结束标志就换为两个问号“??”了。 若希望换回默认的分号“;”作为结束标志，则在 MySQL 命令行客户端输入下列语句即可： mysql \u003e DELIMITER ; 注意：DELIMITER 和分号“;”之间一定要有一个空格。在创建存储过程时，必须具有 CREATE ROUTINE 权限。 假如创建名称为 GetScoreByStu 的存储过程，输入参数是学生姓名。存储过程的作用是通过输入的学生姓名从学生成绩信息表中查询指定学生的成绩信息，输入的 SQL 语句和执行过程如下所示。 mysql\u003e DELIMITER // mysql\u003e CREATE PROCEDURE GetScoreByStu -\u003e (IN name VARCHAR(30)) -\u003e BEGIN -\u003e SELECT student_score FROM tb_students_score -\u003e WHERE student_name=name; -\u003e END // Query OK, 0 rows affected (0.01 sec) ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:1:1","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 查看存储过程 创建好存储过程后，可以使用 SHOW CREATE 语句查看存储过程的定义，语法格式如下 SHOW PROCEDURE STATUS LIKE 存储过程名; 举例如下 mysql\u003e SHOW PROCEDURE STATUS LIKE 'showstuscore' \\G *************************** 1. row *************************** Db: test Name: showstuscore Type: PROCEDURE Definer: root@localhost Modified: 2020-02-20 13:34:50 Created: 2020-02-20 13:34:50 Security_type: DEFINER Comment: character_set_client: gbk collation_connection: gbk_chinese_ci Database Collation: latin1_swedish_ci 1 row in set (0.01 sec) 也可以查看存储过程的定义，语法格式如下 SHOW CREATE PROCEDURE 存储过程名 举例 mysql\u003e SHOW CREATE PROCEDURE showstuscore \\G *************************** 1. row *************************** Procedure: showstuscore sql_mode: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `showstuscore`() BEGIN SELECT id,name,score FROM studentinfo; END character_set_client: gbk collation_connection: gbk_chinese_ci Database Collation: latin1_swedish_ci 1 row in set (0.01 sec) ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:1:2","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 修改存储过程 使用 ALTER PROCEDURE 语句修改存储过程，语法格式如下 ALTER PROCEDURE 存储过程名 [ 特征 ... ] 特征指定了存储过程的特性，可能的取值有： CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句。 NO SQL 表示子程序中不包含 SQL 语句。 READS SQL DATA 表示子程序中包含读数据的语句。 MODIFIES SQL DATA 表示子程序中包含写数据的语句。 SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行。 DEFINER 表示只有定义者自己才能够执行。 INVOKER 表示调用者可以执行。 COMMENT ‘string’ 表示注释信息。 下面修改存储过程 showstuscore 的定义，将读写权限改为 MODIFIES SQL DATA，并指明调用者可以执行，代码如下： mysql\u003e ALTER PROCEDURE showstuscore MODIFIES SQL DATA SQL SECURITY INVOKER; Query OK, 0 rows affected (0.01 sec) ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:1:3","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 删除存储过程 存储过程被创建后，就会一直保存在数据库服务器上，直至被删除。当 MySQL 数据库中存在废弃的存储过程时，我们需要将它从数据库中删除。 使用 DROP PROCEDURE 语句删除存储过程，语法格式如下 DROP PROCEDURE [ IF EXISTS ] \u003c过程名\u003e 注意：存储过程名称后面没有参数列表，也没有括号，在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。 下面删除存储过程 ShowStuScore，SQL 语句和运行结果如下： mysql\u003e DROP PROCEDURE ShowStuScore; Query OK, 0 rows affected (0.08 sec) ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:1:4","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 触发器 MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，而是通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（INSERT，DELETE 或 UPDATE）时就会激活它执行。 触发器与数据表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系的时候，触发器能够让不同的表保持数据的一致性。 在 MySQL 中，只有执行 INSERT、UPDATE 和 DELETE 操作时才能激活触发器，其它 SQL 语句则不会激活触发器。 那么为什么要使用触发器呢？比如，在实际开发项目时，我们经常会遇到以下情况： 在学生表中添加一条关于学生的记录时，学生的总数就必须同时改变。 增加一条学生记录时，需要检查年龄是否符合范围要求。 删除一条学生信息时，需要删除其成绩表上的对应记录。 删除一条数据时，需要在数据库存档表中保留一个备份副本。 虽然上述情况实现的业务逻辑不同，但是它们都需要在数据表发生更改时，自动进行一些处理。这时就可以使用触发器处理。例如，对于第一种情况，可以创建一个触发器对象，每当添加一条学生记录时，就执行一次计算学生总数的操作，这样就可以保证每次添加一条学生记录后，学生总数和学生记录数是一致的。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:2:0","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 优缺点 触发器的优点如下： 触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。 触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。 触发器可以实现表数据的级联更改，在一定程度上保证了数据的完整性。 触发器的缺点如下： 使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，会使后期维护变得困难。 大量使用触发器容易导致代码结构被打乱，增加了程序的复杂性， 如果需要变动的数据量较大时，触发器的执行效率会非常低。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:2:1","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 MySQL支持的触发器 在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。 INSERT 触发器 在 INSERT 语句执行之前或之后响应的触发器。 使用 INSERT 触发器需要注意以下几点： 在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。 在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。 对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。 UPDATE 触发器 在 UPDATE 语句执行之前或之后响应的触发器。 使用 UPDATE 触发器需要注意以下几点： 在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。 在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。 在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。 OLD 中的值全部是只读的，不能被更新。 注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许。 DELETE 触发器 在 DELETE 语句执行之前或之后响应的触发器。 使用 DELETE 触发器需要注意以下几点： 在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。 OLD 中的值全部是只读的，不能被更新。 总体来说，触发器使用的过程中，MySQL 会按照以下方式来处理错误。 对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。 若 BEFORE 触发程序失败，则 MySQL 将不执行相应行上的操作。 若在 BEFORE 或 AFTER 触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。 仅当 BEFORE 触发程序和行操作均已被成功执行，MySQL 才会执行 AFTER 触发程序。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:2:2","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 事件 在数据库管理中，经常要周期性的执行某一命令或 SQL 语句，于是 MySQL 5.1 版本以后就提供了事件，它可以很方便的实现 MySQL 数据库的计划任务，定期运行指定命令，使用起来非常简单方便。 事件（Event）也可称为事件调度器（Event Scheduler），是用来执行定时任务的一组 SQL 集合，可以通俗理解成 MySQL 中的定时器。一个事件可调用一次，也可周期性的启动。 事件可以作为定时任务调度器，取代部分原来只能用操作系统的计划任务才能执行的工作。另外，更值得一提的是，MySQL 的事件可以实现每秒钟执行一个任务，非常适合对实时性要求较高的环境，而操作系统的计划任务只能精确到每分钟一次。 事件和触发器类似，都是在某些事情发生时启动。当数据库启动一条语句的时候，触发器就启动了，而事件是根据调度事件来启动的。由于他们彼此相似，所以事件也称为临时性触发器。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:3:0","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 查看事件是否开启 在 MySQL 中，调度器 event_scheduler 负责调用事件。我们可以通过以下几种命令查看事件是否开启，一般情况下默认值为 OFF。SQL 命令和运行结果如下： mysql\u003e SHOW VARIABLES LIKE 'event_scheduler'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | event_scheduler | OFF | +-----------------+-------+ 1 row in set, 1 warning (0.02 sec) mysql\u003e SELECT @@event_scheduler; +-------------------+ | @@event_scheduler | +-------------------+ | OFF | +-------------------+ 1 row in set (0.00 sec) mysql\u003e SHOW PROCESSLIST; +----+------+-----------------+------+---------+------+----------+------------------+ | Id | User | Host | db | Command | Time | State | Info | +----+------+-----------------+------+---------+------+----------+------------------+ | 2 | root | localhost:56279 | NULL | Query | 0 | starting | SHOW PROCESSLIST | +----+------+-----------------+------+---------+------+----------+------------------+ 1 row in set (0.01 sec) 从结果可以看出，事件没有开启。因为参数 event_scheduler 的值为 OFF，并且在 PROCESSLIST 中查看不到 event_scheduler 的信息。如果参数 event_scheduler 的值为 ON，或者在 PROCESSLIST 中显示了 event_scheduler 的信息，则说明事件已经开启。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:3:1","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 开启事件 开启事件主要通过以下两种方式实现。 通过设置全局参数修改 可以使用 SET GLOBAL 命令设定全局变量 event_scheduler 的值，开启或关闭事件。将 event_scheduler 参数的值设置为 ON，表示开启事件；设置为 OFF，则关闭事件。 例如，要开启事件可以在命令行窗口中输入以下命令。 mysql\u003e SET GLOBAL event_scheduler = ON ; Query OK, 0 rows affected (0.06 sec) mysql\u003e SHOW VARIABLES LIKE 'event_scheduler'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | event_scheduler | ON | +-----------------+-------+ 1 row in set, 1 warning (0.01 sec) 结果显示，event_scheduler 的值为 ON，表示事件已经开启。 通过 SET GLOBAL 命令开启或关闭事件，MySQL 重启服务后事件又会回到原来的状态，如果想要始终开启或关闭事件，可以修改 MySQL 配置文件。 更改配置文件 在 MySQL 配置文件中找到 [mysqld] 选项，然后在下面添加以下代码开启事件。 event_scheduler = ON 在配置文件中添加代码并保存文件后，重启 MySQL 服务才能生效。 通过该方法开启或关闭事件，重启 MySQL 服务后，不会回到原来的状态。例如，此时重启 MySQL 服务器，然后查看事件是否开启。 mysql\u003e SHOW VARIABLES LIKE 'event_scheduler'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | event_scheduler | ON | +-----------------+-------+ 1 row in set, 1 warning (0.01 sec) 结果显示，参数 event_scheduler 的值为 ON，表示已经开启。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-8-procedure-trigger-and-event/:3:2","tags":["计算机基础"],"title":"Mysql学习8-存储过程、触发器和事件","uri":"/2020/mysql-learning-8-procedure-trigger-and-event/"},{"categories":["爱编程爱技术的孩子"],"content":"视图在数据库中的作用类似于窗户，用户可以通过这个窗口看到只对自己有用的数据。既保障了数据的安全性，又大大提高了查询效率。 索引是提高数据库性能的重要方式，用来快速找出数据表中的特定记录。如果在表中查询的列有一个索引，MySQL 能快速到达一个位置去搜寻数据，而不必查看所有数据。 本文介绍这两个概念。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:0:0","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 视图 之后介绍… ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:1:0","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 索引 索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，用来快速查询数据表中是否有某一特定值的记录。其原理类似于书籍的目录，使用索引的好处是可以极大地提高数据库的查询速度。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:2:0","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 优缺点 在 MySQL 中，通常有以下两种方式访问数据库表的行数据： 顺序访问：在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。当表中有大量数据时，效率非常底下。 索引访问：通过遍历索引来直接访问表中的记录行。使用这种方法的前提是对表建立了一个索引，索引存储了指定记录行的指针，根据指定的排序顺序对这些指针排序。例如，在学生基本信息表 tb_students 中，如果基于 student_id 建立了索引，系统就建立了一张索引列到实际记录的映射表。当用户需要查找 student_id 为 12022 的数据的时候，系统先在 student_id 索引上找到该记录，然后通过映射表直接找到数据行，并且返回该行数据。因为扫描索引的速度一般远远大于扫描实际数据行的速度，所以采用索引的方式可以大大提高数据库的工作效率。 根据以上描述，我们可以总结索引的优缺点 优点 缺点 可以大大加快数据的查询速度 创建和维护索引需要耗费时间，并且随着数据量的增加所耗费的时间也会增加 通过创建唯一索引可以保证数据库表中每一行数据的唯一性 索引需要占磁盘空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸 在实现数据的参照完整性方面可以加速表与表之间的连接 在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间 所以，索引虽然可以提高查询速度，但会影响插入记录的速度，当插入大量数据时，最好先删除表中的索引，然后插入数据，插入完成后，再创建索引。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:2:1","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 索引类型 如果按底层实现分，MySQL 的索引可以分为 B+ 树索引和 Hash 索引两类。 B+树索引又称为 BTREE 索引，主要采用B+ 树结构，基于这种结构构建索引，表中每一行都会在索引上有一个对应值，B+树的查找时间复杂度为 O(H)，H为树高，且可以保证树高始终处于可能的最小值。B+树可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY 排序，主要是得益于倒数第二条特性，所有的值在倒数第二层以升序排列，且有指针连接。 哈希索引又称为散列索引，使用哈希表作为存储结构，哈希索引最大的特点是访问单条记录速度快，但也存在一些缺点： MySQL 需要读取表中索引列的值来参与哈希计算，而哈希计算是一个比较耗时的操作，也就是说，相比 B+ 树索引，建立哈希索引需要耗费更多的时间； 不能使用哈希索引排序； 哈希索引只支持等值查询，比如 “=”，“IN()”，“\u003c=\u003e” 哈希索引不支持键的部分匹配，因为在计算哈希值的时候是通过整个索引值来计算的。 如果按存储方式分，可以分为聚簇索引和非聚簇索引 找到了索引就找到了需要的数据，那么这个索引就是聚簇索引 索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。 如果按逻辑区分，MySQL 的索引可以分为5类 普通索引：MySQL 中最基本的索引类型，没有任何限制，唯一任务就是加快系统对数据的访问速度。普通索引允许在定义索引的列中插入重复值和空值。创建普通索引时，通常使用的关键字是 INDEX 和 KEY。比如，在 tb_student 表中的 id 字段上建立名为 index_id 的索引，语句如下 CREATE INDEX index_id ON tb_student(id); 唯一索引：与普通索引类似，不同的是创建唯一性索引的目的不是为了提高访问速度，而是为了避免数据出现重复。唯一索引列的值必须唯一，允许有空值，如果是组合索引，则列值的组合必须唯一。创建唯一索引通常使用 UNIQUE 关键字。比如，在 tb_student 表中的 id 字段上建立名为 index_id 的索引，SQL 语句如下： CREATE UNIQUE INDEX index_id ON tb_student(id); 主键索引：专门为主键字段创建的索引，是一种特殊的唯一索引，不允许值重复或者值为空。创建主键索引通常使用 PRIMARY KEY 关键字，不能使用 CREATE INDEX 语句创建主键索引。 空间索引：空间索引是对空间数据类型的字段建立的索引，使用 SPATIAL 关键字进行扩展。创建空间索引的列必须将其声明为 NOT NULL，空间索引只能在存储引擎为 MyISAM 的表中创建。空间索引主要用于地理空间数据类型 GEOMETRY。对于初学者来说，这类索引很少会用到。下面在 tb_student 表中的 line 字段上建立名为 index_line 的索引，SQL 语句如下，其中，tb_student 表的存储引擎必须是 MyISAM，line 字段必须为空间数据类型，而且是非空的。 CREATE SPATIAL INDEX index_line ON tb_student(line); 全文索引：用来查找文本中的关键字，只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。在 MySQL 中只有 MyISAM 存储引擎支持全文索引。全文索引允许在索引列中插入重复值和空值。对于大容量的数据表，生成全文索引非常消耗时间和硬盘空间。创建全文索引使用 FULLTEXT 关键字。在 tb_student 表中的 info 字段上建立名为 index_info 的全文索引，SQL 语句如下，其中，index_info 的存储引擎必须是 MyISAM，info 字段必须是 CHAR、VARCHAR 和 TEXT 等类型。 CREATE FULLTEXT INDEX index_info ON tb_student(info); 如果按实际使用区分，索引通常被分为单列索引和组合索引 单列索引就是索引只包含原表的一个列，仅根据该列的值进行索引。单列索引可以是普通索引，也可以是唯一索引或全文索引。下面在 tb_student 表中的 address 字段上建立名为 index_addr 的单列索引，address 字段的数据类型为 VARCHAR(20)，索引的数据类型为 CHAR(4)。SQL 语句如下： CREATE INDEX index_addr ON tb_student(address(4)); 这样，查询时可以只查询 address 字段的前 4 个字符，而不需要全部查询。 组合索引又称为符合索引或多列索引，是将原表的多个列共同组成一个索引，可以通过这几个字段进行查询，但是，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用。例如，在表中的 id、name 和 sex 字段上建立一个多列索引，那么，只有查询条件使用了 id 字段时，该索引才会被使用 下面在 tb_student 表中的 name 和 address 字段上建立名为 index_na 的索引，SQL 语句如下： CREATE INDEX index_na ON tb_student(name,address); 该索引创建好了以后，查询条件中必须有 name 字段才能使用索引。 一个表可以有多个单列索引，但这些索引不是组合索引。一个组合索引实质上为表的查询提供了多个索引，以此来加快查询速度。比如，在一个表中创建了一个组合索引(c1，c2，c3)，在实际查询中，系统用来实际加速的索引有三个：单个索引(c1)、双列索引(c1，c2)和多列索引(c1，c2，c3)。 每种存储引擎所支持的索引类型不一定完全相同，如下 InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引； ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:2:2","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 创建索引 MySQL 提供了三种创建索引的办法。 第一种是上一小节提到的使用 CREATE INDEX 语句，语法格式如下 CREATE INDEX \u003c索引名\u003e ON \u003c表名\u003e (\u003c列名\u003e [\u003c长度\u003e] [ASC|DESC]) \u003c长度\u003e：可选项。指定使用列前的 length 个字符来创建索引。使用列的一部分创建索引有利于减小索引文件的大小，节省索引列所占的空间。在某些情况下，只能对列的前缀进行索引。索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。 ASC|DESC：可选项。ASC指定索引按照升序来排列，DESC指定索引按照降序来排列，默认为ASC。 第二种是在创建表（CREATE TABLE）的同时建立索引，只需要在建表语句中添加下面的语句即可 CONSTRAINT PRIMARY KEY [索引类型] (\u003c列名\u003e,…) # 表示在创建新表的同时创建该表的主键 KEY | INDEX [\u003c索引名\u003e] [\u003c索引类型\u003e] (\u003c列名\u003e,…) # 创建新表的同时创建该表的索引 UNIQUE [ INDEX | KEY] [\u003c索引名\u003e] [\u003c索引类型\u003e] (\u003c列名\u003e,…) # 创建新表的同时创建该表的唯一性索引 FOREIGN KEY \u003c索引名\u003e \u003c列名\u003e # 创建新表的同时创建该表的外键 一个在创建表时建立普通索引的例子如下 mysql\u003e CREATE TABLE tb_stu_info -\u003e ( -\u003e id INT NOT NULL, -\u003e name CHAR(45) DEFAULT NULL, -\u003e dept_id INT DEFAULT NULL, -\u003e age INT DEFAULT NULL, -\u003e height INT DEFAULT NULL, -\u003e INDEX(height) -\u003e ); Query OK，0 rows affected (0.40 sec) 一个在创建表时建立唯一索引的例子如下 mysql\u003e CREATE TABLE tb_stu_info2 -\u003e ( -\u003e id INT NOT NULL, -\u003e name CHAR(45) DEFAULT NULL, -\u003e dept_id INT DEFAULT NULL, -\u003e age INT DEFAULT NULL, -\u003e height INT DEFAULT NULL, -\u003e UNIQUE INDEX(height) -\u003e ); Query OK，0 rows affected (0.40 sec) 第三种是在利用 ALTER TABLE 语句修改表的时候向该表添加索引，方法是添加下面的语句 ADD INDEX [\u003c索引名\u003e] [\u003c索引类型\u003e] (\u003c列名\u003e,…) # 修改表的同时为该表添加索引 ADD PRIMARY KEY [\u003c索引类型\u003e] (\u003c列名\u003e,…) # 表示在修改表的同时为该表添加主键 ADD UNIQUE [ INDEX | KEY] [\u003c索引名\u003e] [\u003c索引类型\u003e] (\u003c列名\u003e,…) # 修改表的同时为该表添加唯一性索引 ADD FOREIGN KEY [\u003c索引名\u003e] (\u003c列名\u003e,…) # 修改表的同时为该表添加外键 ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:2:3","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 查看索引 索引创建完成后，使用 SHOW INDEX 语句可以查看表中创建的索引，语法格式如下 SHOW INDEX FROM \u003c表名\u003e [ FROM \u003c数据库名\u003e] 一个例子如下 mysql\u003e SHOW INDEX FROM tb_stu_info2\\G *************************** 1. row *************************** Table: tb_stu_info2 Non_unique: 0 Key_name: height Seq_in_index: 1 Column_name: height Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: YES Index_type: BTREE Comment: Index_comment: 1 row in set (0.03 sec) 其中各参数说明如下表 参数 说明 Table 表示创建索引的数据表名，这里是 tb_stu_info2 数据表。 Non_unique 表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。 Key_name 表示索引的名称。 Seq_in_index 表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。 Column_name 表示定义索引的列字段。 Collation 表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。 Cardinality 索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。 Sub_part 表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。 Packed 指示关键字如何被压缩。若没有被压缩，值为 NULL。 Null 用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。 Index_type 显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。 Comment 显示评注。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:2:4","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"2.5 修改和删除索引 删除索引是指将表中已经存在的索引删除掉。不用的索引建议进行删除，因为它们会降低表的更新速度，影响数据库的性能。对于这样的索引，应该将其删除。 在 MySQL 中修改索引可以通过删除原索引，再根据需要创建一个同名的索引，从而实现修改索引的操作。 删除索引使用 DROP INDEX 语句，语法格式如下 DROP INDEX \u003c索引名\u003e ON \u003c表名\u003e 也可以使用 ALTER TABLE 语句，方法是在该语句中添加下面的某个子句 DROP PRIMARY KEY #表示删除表中的主键。一个表只有一个主键，主键也是一个索引。 DROP INDEX index_name #表示删除名称为 index_name 的索引。 DROP FOREIGN KEY fk_symbol # 表示删除外键。 注意：如果删除的列是索引的组成部分，那么在删除该列时，也会将该列从索引中删除；如果组成索引的所有列都被删除，那么整个索引将被删除。 删除索引的一个例子如下 mysql\u003e DROP INDEX height -\u003e ON tb_stu_info; Query OK, 0 rows affected (0.27 sec) Records: 0 Duplicates: 0 Warnings: 0 # 或者 mysql\u003e ALTER TABLE tb_stu_info2 -\u003e DROP INDEX height; Query OK, 0 rows affected (0.13 sec) Records: 0 Duplicates: 0 Warnings: 0 ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:2:5","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"2.6 索引的设计原则 索引的设计可以遵循一些已有的原则，创建索引的时候应尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。本节将介绍一些索引的设计原则。 选择唯一性索引：唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。 为经常需要排序、分组和联合操作的字段建立索引：经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。 为常作为查询条件的字段建立索引：如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。 限制索引的数目：索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。 尽量使用数据量少的索引：如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。 数据量小的表最好不要使用索引：由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。 尽量使用前缀来索引：如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。 删除不再使用或者很少使用的索引：表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。 总之，选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能只拘泥于上面的准则。应该在学习和工作中不断的实践，根据应用的实际情况进行分析和判断，选择最合适的索引方式。 ","date":"2020-07-15","objectID":"/2020/mysql-learning-7-view-and-index/:2:6","tags":["计算机基础"],"title":"Mysql学习7-视图与索引","uri":"/2020/mysql-learning-7-view-and-index/"},{"categories":["爱编程爱技术的孩子"],"content":"HTTP 和 HTTPS 是最常用的两个协议，本篇对它们进行介绍。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:0:0","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"1. HTTP ","date":"2020-07-09","objectID":"/2020/http-and-https/:1:0","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 HTTP的概念 HTTP 全称为超文本传输协议（HyperText Transfer Protocol），它定义了浏览器（客户端进程）如何向网络上的服务器请求网络文档，以及服务器如何将文档传送给浏览器。从层次角度看，HTTP 是一个应用层协议，使用网络层的 TCP 进行可靠传输。 一个大致的工作过程如下所述。每个网络节点都有一个服务器进程，它在后台不间断地监听着 TCP 的 80 端口，以便发现是否有来自浏览器的连接建立请求。一旦监听到连接请求并遵照握手协议建立 TCP 连接后，浏览器就会向该服务器发出浏览某个页面的请求，服务器就返回对应的页面作为响应。最后，TCP 连接被释放掉。 HTTP 就是浏览器和服务器之间请求和响应的交互需要遵循的格式与规则。它规定浏览器与服务器的交互是一个 ASCII 码串，这段字符串的格式就是 HTTP 报文格式。因为 HTTP 是建立在 TCP 上的协议，因此这段字符串也是 TCP 报文的数据部分。 无论是用户主动在浏览器地址栏输入了某个 URL，还是在页面上点击了某个元素，在背后都会转化为一个链接，然后浏览器就会在网络上找到链接对应的页面。假设我输入的 URL 或点击的元素指向了「清华大学院系设置」页面，具体的链接为 http://www.tsinghua.edu.cn/chn/yxsz/index.htm，之后发生的事情如下所述： 浏览器向 DNS 请求解析 www.tsinghua.edu.cn 的 IP 地址； 域名系统返回清华大学服务器的地址 166.111.4.100； 浏览器与服务器建立 TCP 连接； 浏览器发出取文件命令：GET /chn/yxsz/index.htm； 服务器给出响应，把文件 index.htm 发给浏览器； 释放 TCP 连接； 浏览器渲染并显示 index.htm 文件，显示的页面就是「清华大学院系设置」页面 数据的可靠性由底层的 TCP 保证，HTTP 本身是无连接的。从上面的过程也可以看出，通信双方并不需要建立和释放 HTTP 连接。同时 HTTP 也是无状态的，无状态的含义是，如果此时浏览器再次访问「清华大学院系设置」页面，服务器会执行一遍重复的过程，再返回一次 index.htm 页面，因为服务器不记得这个浏览器曾经访问过。这种无状态特性既有好处也有坏处，我们以后会介绍这部分内容。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:1:1","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 HTTP报文结构 HTTP 有两类报文： 请求报文—从客户向服务器发送请求报文； 响应报文—服务器向客户返回响应； 上一小节已经提到过，HTTP 是面向文本的，本质上是一串 ASCII 码字符串，报文的格式就是对字符串的各部分含义进行规定，各部分长度也是不固定的。 HTTP 请求与响应报文都是由三个部分组成：开始行、首部行和实体主体。 实体主体就是数据部分，请求报文一般都不用，响应报文中也可能没有这个字段。 首部行不一定是一行，可能有多行，也可能没有，每行都是「键：值」形式，其中键叫做首部字段名，每一行结束都要跟一个回车和换行。整个首部行部分结束，还要加一个空行和实体主体分开。首部行的作用是说明浏览器、服务器或报文主体的一些基本信息，首部字段名大都是规定好的。 开始行是请求和响应报文唯一不同的地方。请求报文的开始行可以叫做请求行，响应报文的开始行叫做状态行，开始行的三个部分都以空格分开，末尾要添加 回车+换行 与首部行部分区分。 请求报文 请求报文的第一行请求行包括三部分：方法、URI和版本。 方法是浏览器希望执行的操作，其实就是一些命令，比如提到的 GET，请求报文的类型一般根据方法的类型进行区分，到 HTTP 1.1共有 9 种方法，如下： 方法 意义 OPTION 请求一些选项的信息 GET 请求指定的页面信息，并返回实体主体 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改 PUT 从客户端向服务器传送的数据取代指定的文档的内容 DELETE 请求服务器删除指定的页面 TRACE 回显服务器收到的请求，主要用于测试或诊断 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 通常，最容易混淆使用的是 PUT 和 POST 两个方法，这里进行说明 PUT 和 POST在使用效果上的区别在于幂等性，幂等性是指，如果一个方法执行多次，产生的效果是一样的，这里 PUT 方法是幂等的，更通俗的解释为 PUT：如果两个请求相同，后一个请求会把前一个请求覆盖掉； POST：后一个请求不会把前一个请求覆盖掉 更多的看RFC：https://tools.ietf.org/html/rfc7231#section-4.3 URI 是请求资源的 URI，版本是指 HTTP 协议的版本，现在一般是 HTTP/1.1。以前面 1.1 小节提到的例子来说明，请求「清华大学院系设置」页面，其 HTTP 请求报文的开始行应当是 GET http://www.tsinghua.edu.cn/chn/yxsz/index.htm HTTP/1.1 这里给出一个完整的请求报文的例子，注意这里请求行使用相对 URL ，这是因为首部行给出了主机域名。 GET /chn/yxsz/index.htm HTTP/1.1 Host: www.tsinghua.edu.cn // 主机域名 Connection: close // 告诉服务器发送完请求的文档后就可以释放连接 User-Agent: Mozilla/5.0 // 表明用户代理是使用 Netscape 浏览器 Accept-Language: cn // 表示用户希望优先得到中文版本的文档 // 这里有一个空行，后面的实体主体部分为空 响应报文 响应报文的状态行同样分三部分：版本，状态码和短语。 版本依然是 HTTP 协议版本，状态码用来说明不同的响应情况，短语是对状态码的简单说明。状态行的示例如下 HTTP/1.1 202 Accepted HTTP 状态码(tatus Code)都是三位数字，分为 5 大类共 33 种（见RFC 2616），大类的含义如下表。关于更具体地状态码信息，见 附录1。 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 继续举例，假设请求的网页从 http://www.ee.xyz.edu/index.html 转移到了一个新的地址，则响应报文的状态行和一个首部行就是下面的形式： HTTP/1.1 301 Moved Permanently Location: http://www.xyz.edu/ee/index.html 首部行地键值定义很多都有固定的含义，可以参考附录2。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:1:2","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 HTTP版本 HTTP 从诞生到现在一共 4 个版本，第一个版本 HTTP/0.9 诞生于1991年，目前已过时，剩下的三个协议比较如下表 HTTP1.0 HTTP1.1 HTTP2.0 诞生时间 1992-1996 1997-1999 2012-2014 Host头 ✗ ✔ ✔ Range头 ✗ ✔ ✔ 长连接 ✗ ✔ ✔ request method GET HEAD POST 以上+ OPTIONS PUT DELETE TRACE CONNECT 以上全部 cache Expire Last-Modefied Pragma 以上+ETag Cache-Control 以上全部 header压缩 ✗ ✗ ✔ 多路复用 ✗ ✗ ✔ 服务器推送 ✗ ✗ ✔ 目前多数都已经切换到了 HTTP/1.1，但由于现在的网页元素越来越丰富（文字、图片、视频等等），使用 HTTP/2.0 会有更低的延迟和更快的加载效果。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:1:3","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"2. HTTPS HTTPS 全称为安全超文本传输协议（Secure Hypertext Transfer Protocol），主要是为了解决身份认证和 HTTP 明文传输的问题。 本质上，HTTPS 是在 HTTP 的基础上添加了 SSL/TLS 协议，因此接下来我们先介绍 SSL/TLS 协议。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:2:0","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 SSL/TLS 协议 SSL 全称为安全套接字层（Secure Socket Layer），是网景公司在1994年开发的安全协议，是一个运输层协议（实际上是位于运输层和应用层之间）。1995年 SSL 就被转交给了 IETF（互联网工程任务组），开始进行标准化。IETF 在 SSL 3.0 的基础上设计了 TLS 协议，现在使用的基本都是2008年发布的 TLS 1.2，不过在2018年已经发布了最新的 TLS 1.3。F12打开浏览器控制台，在安全选项卡可以看到当前网页使用的 TLS 版本。至此我们知道，SSL和TLS不是两个协议，而是一个协议的不同阶段。 SSL/TLS 协议主要是解决 HTTP 身份认证和明文传输问题，以网上购物为例，假如购物网站使用 HTTP 协议，那么可能出现如下问题 浏览器无法确认访问的服务器确实是销售商的，销售商也无法对客户进行鉴别； 顾客的浏览器和销售商的服务器间进行数据交互（比如账单传输）是明文的，可以被别人抓取查看甚至更改。 SSL/TLS 通过证书机制进行身份鉴别，通过协商一个对称会话密钥来进行安全的数据传输。下面通过 HTTPS 的通信过程进行详细解释。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:2:1","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 HTTPS 通信过程 一个比较清晰的流程说明图片如下 第一部分是证书验证过程，服务端的公司需要首先向专门的数字证书认证机构申请数字证书，获得证书的同时会得到一对公私钥，私钥自己保存，公钥放在证书里。另外，证书里除了公钥外，还包含证书颁发机构信息、公司信息和证书有效期等字段。客户端通过 HTTPS 协议进行请求时，服务器就会把证书传给客户端。注意，证书颁发机构颁发证书时，已经用自己的私钥进行了签名，公钥公开在网络中，所以客户端收到证书后，就可以利用网络中的证书颁发机构的公钥来验证证书的合法性，这就是验证服务端身份的过程。我们点击浏览器搜索栏的锁图标，可以查看网站证书，下面是B站的证书。 接下来是协商会话密钥的过程，协商好的对称会话密钥会用于之后的通信进行数据加解密。之前我们提到，客户端收到的证书里包含一份公钥，客户端验证了服务端的合法性后，就会将证书里的公钥提取出来，同时自己生成一串随机数，然后利用该公钥对随机数进行加密，这串随机数就是之后的会话密钥。客户端将加密的随机数发回给服务器，服务器利用自己保存的私钥进行解密，就可以得到该随机数，此时，会话密钥的协商就完成了。 最后，服务器和客户端之间会利用协商好的密钥进行一次数据传输进行验证。服务器使用密钥（随机数）对数据进行加密并发送给客户端，客户端同样使用该随机数进行解密，自此通信完成。 这是一个大致的过程，实际的请求与响应如下，这里借用了《图解HTTP》的图，还要注意的一点是，TLS 的通信过程是在建立 TCP连接后开始的。 客户端发送 Client Hello 报文，开始SSL通信，报文中包含客户端使用的 TLS 协议版本，加密组件列表（支持的加密算法和密钥长度）； 服务器以 Server Hello 报文作为应答，同样包含 TLS 协议版本，并从客户端发来的加密组件中选定一种，放在报文中发回去； 服务器发送 Certificate 报文，报文包含数字证书； 服务器发送 Server Hello Done 报文，表明初始的协商结束； 客户端验证证书合法性，利用证书中的公钥对随机数进行加密，然后放在 Client Key Exchange 报文中发回去； 客户端发送 Change Cipher Spec 报文，提示服务端之后以协商好的会话密钥通信； 客户端发送 Finished 报文，将包含连接至今所有的报文的加密值，如果之后服务端能成功解析才能说明成功； 服务端同样发送 Change Ciphper Spec 报文，表明之后用协商好的会话密钥通信； 服务端发送 Finished 报文； 客户端和服务端的 Finished 报文交换完毕后，实际上 TLS 连接就算建立完成了，之后的所有通信都使用会话密钥加密； 最后关闭连接时，客户端发送 close_notify 报文断开 TLS； TLS 关闭后才会完成四次握手关闭 TCP 连接。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:2:2","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"3. HTTP和HTTPS 大家最常问的一个问题还是 HTTP 和 HTTPS 的区别，这里做一下总结 HTTP 使用 80 端口，HTTPS 使用 443 端口； HTTPS 可以保证身份合法以及数据传输的安全； HTTPS 建立连接的过程比 HTTP 复杂很多； HTTPS 通信更慢，因为要进行数据的加解密； 实际上，不是所有的信息都使用 HTTPS，一是因为加解密对资源的消耗比较大，普通的非敏感信息不需要加密传输，另一方面是 HTTPS 证书价格太贵。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:3:0","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"附录1 HTTP状态码 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 308 Permanent Redirect 永久重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 ","date":"2020-07-09","objectID":"/2020/http-and-https/:4:0","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"附录2 HTTP响应头 应答头 说明 Allow 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path”)让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh” CONTENT=\"5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。 注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面”，而不是\"每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh” …＞。 注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼“executives＼\"\")。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 ","date":"2020-07-09","objectID":"/2020/http-and-https/:5:0","tags":["计算机基础"],"title":"计算机网络-HTTP与HTTPS协议","uri":"/2020/http-and-https/"},{"categories":["爱编程爱技术的孩子"],"content":"本篇介绍计算机网络运输层的的 TCP 和 UDP 协议，主要是过一遍，加深理解，以及方便以后查看，毕竟不是每次都带着书。 ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:0:0","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 运输层 五层体系结构中，运输层是从上往下的第二层，主要是 TCP 和 UDP 两个协议。 运输层的作用是为相互通信的应用进程提供逻辑通信，因此，运输层的端点是主机中的进程。而网络层为主机间提供通信，因此端点则是网络中的主机。数据在网络中传输时，路由器转发分组都只会用到下三层的功能，与运输层无关，因此，运输层仅在主机的协议栈中起作用。下面的图片比较清楚的说明了这一点 根据应用程序的不同需求，运输层有两种不同的协议，即用户数据报协议 UDP（User Datagram Protocol）和传输控制协议 TCP（Transmission Control Protocol）。这两种协议是我们在运输层需掌握的主要内容，它们在整体的协议栈中的位置如下所示 网络层的端点是主机，采用 IP 来标识，运输层的端点是应用进程，使用协议端口号（protocol port number）标识，通常简称为端口。不同的操作系统实现端口的方法可能是不同的，但其作用是相同的。传输层协议定义一个端口号为 16 位，仅在本地主机具有实际意义，目的是标识各应用进程与传输层交互的接口，因此不同的主机间相同的端口号没有关联。 16 位的端口号允许 65535 个不同的端口号。服务端使用的端口主要分为两类。一类叫做熟知端口或系统端口，数值为 0~1023，这些端口号被指派给了固定的某类应用，其它的应用不得使用。另一类叫做登记端口号，数值为 1024~49151，主要为没有熟知端口号的应用使用，但也有进行登记防止重复。常用的熟知端口号如下 应用程序 FTP TELNET SMTP DNS TFTP HTTP SNMP SNMP(trap) 熟知端口号 21 23 25 53 69 80 161 162 客户端使用的端口号数值为 49152~65535，仅在客户进程运行时才动态选择，存在周期较短，又叫做短暂端口号。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以将数据发送给客户进程，通信结束后，该客户端端口就被释放。 最后要注意的是，对所传输的数据单元，TCP叫做报文段，UDP叫做用户数据报。 ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:1:0","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"2. UDP UDP 仅在 IP 的基础上增加了很少的功能，关于 UDP 的特点介绍如下 UDP 是无连接的。无连接的含义是发送数据前不需要建立连接，发送结束后不需要释放连接； UDP 尽最大努力交付。尽最大努力的意思是不保证可靠； UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，添加首部后直接交付 IP 层，不做合并或拆分处理，一次发送一个报文，接收方的 UDP 对 IP 层交上来的报文，去除首部后直接交付应用进程，一次接受一个报文。简单的逻辑图如下 UDP 支持一对一、一对多、多对一和多对多的交互通信； UDP 首部只有 8 个字节，比 TCP 的20 个字节小的多； UDP 没有拥塞控制，这意味着网络上的拥塞不会影响源主机的发送速率，这种特性使其适合于一些实时的应用，如 IP电话、实时视频会议等，这些应用允许一定的数据丢失，却不允许太大的时延。 UDP 的数据报非常简单，除了 8 个字节的首部，剩下的全是数据部分，首部格式如下图所示 首部共分四个字段，每个字段两个字节，具体解释如下 源端口：源端口号，需要对方回复时使用，不需要时置全 0； 目的端口：目的端口号，接收端交付报文必须的； 长度：这里的长度是 UDP 整个报文的长度，最小为 UDP 首部 8 个字节 校验和：UDP 校验和的计算包括整个 UDP 数据报，除此之外和 IP 首部校验和计算很相似。发送端首先将校验和字段置0，然后在 UDP 首部前加 12 个字节的伪首部，再按 16 位进行划分，最后一行不足16位补 0，写成一串竖式，进行求和计算，对和取反码，从而得到校验和。过程如下图所示 将得到的结果填入校验和字段，并发送出去，接收方收到报文后，添加 12 个字节的伪首部然后继续 16 位划分求和，结果取反码后应该为 1，否则就表明有差错，接收方就会丢弃该报文。 最后要注意的是，UDP 在 IP 报文中的协议字段为 17. ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:2:0","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3. TCP TCP 协议要复杂很多，我们仍然先介绍其特点 TCP 是面向连接的，使用前必须先建立连接，使用后释放连接； TCP 保证可靠，可靠的含义是通过 TCP 传输的数据无差错、不丢失、不重复、按序到达； TCP 是面向字节流的，其含义是 TCP 将应用层交下来的数据看作一连串无结构的字节流，而不是看作一个整体，TCP 不知道所传输的字节流的含义，也不保证接收与交付的数据具有对应大小的关系，仅保证接收方收到的字节流和发送方发出的字节流完全一致，这里的完全一致指的是字节的顺序一致和每个字节的内容没有差错。当然，接收方的应用是一定有能力识别这一连串字节流的含义，这就是应用层的功能了。整个过程可以用下图简单的说明，虽然图中仅仅涉及几个字节，但实际上每个 TCP 报文涉及成百上千字节是很常见的。 TCP 仅支持一对一的通信，不同于 UDP，TCP 连接是点对点的； TCP 提供全双工通信，通信双方的应用进程在任何时候都能发送数据。事实上，TCP 连接的两端都设有发送缓存和接收缓存，发送时应用将数据交给发送缓存后就不管了，由 TCP 在合适的时候将数据发出去，接收时把收到的数据放入缓存，上层的应用在合适的时候读取缓存中的数据。 TCP 连接的端点叫做套接字（socket），其实就是 IP 地址和端口号的拼接，尽管 socket 在其它地方还有很多含义，但在这里就这么简单。 套接字 socket = (IP地址：端口号) ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:3:0","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 超时重传 TCP 可靠传输主要靠下面几个机制保证 确认应答和序列号 超时重传 校验和 流量控制 拥塞控制 流量控制和拥塞控制需要理解 TCP 报文，放在后面介绍，校验和在 TCP报文中介绍，现在先介绍前两个机制。 首先，理想的情况下，也就是信道不出差错，接收的速度永远跟得上发送的速度，此时数据的发送和接收遵循简单的停等协议。由于全双工通信的双方既是发送方也是接收方，下面为了讨论方便，仅考虑 A 发送数据而 B 接收数据，而且将一个 TCP 报文包含的数据称为一个分组。 停等协议的过程如下所示，简单地讲，就是发送方发送分组，接收方接收后返回确认，发送方收到确认后再发送下一个分组，如此循环。 但我们知道现实是不可能出现这种理想情况的，我们必须考虑数据可能出差错，可能丢失，可能不按序到达等许多情况。因此必须采取一定的措施避免这些情况的出现或出现时进行纠正。 首先是发送方发送的数据出现差错。差错可以通过校验和的计算检测出来，当检测的差错后，接收方只做一件事，就是丢弃该分组（不通知发送方分组出错），可靠传输的保证是，A 在发送数据后设置了一个超时计时器，如果计时器到期前收到了确认，就撤销该计时器，而此时由于 B 丢弃了分组且没有返回确认，计时器到期后 A 仍然无法收到确认，就会重传前面发送过的分组。这一过程在上图中同样有所说明。 超时重传机制的设定还会同时引入另外两个机制： A 发送完分组后，必须暂时保留已发送的分组的副本（为发生超市重传时使用），只有在收到确认后才能清除保留的副本； 发送的分组和返回的确认分组都必须进行编号，这样才能明确是哪个发送出去的分组收到了确认，哪个没有收到确认。而由于 TCP 是面向字节流的，编号实际上也是针对字节的，也就是说每个字节一个编号。 因此我们可以看到，确认应答、序列号、超市重传实际上是协同工作的，一起来保证 TCP 连接的可靠。最后还要注意的一点是，超时计时器的重传时间应当稍微比分组传输的平均往返时间多一点点，从而确保正常网络情况下足已收到确认。 其次是发送方发送的分组丢失，丢失的后果是 B 收不到任何数据，同样也不会发送确认，之后触发的超时重传就和出现差错完全相同了。 再然后是确认丢失，确认丢失指的是 B 所发送的对分组 $M_1$ 的确认丢失了，此时 A 无法收到确认，依然会触发超时重传，但接下来我们就会注意到 B 再次收到了同样的分组，面对同样的分组 B 所作的事情是：丢弃整个重复的分组，然后向 A 发送确认，丢弃是因为分组已经在缓冲区存在，重新发送确认是因为先前的确认 A 没有收到。整个过程如下图所示 最后一种情况是确认重复。我们考虑一种可能，那就是 B 对分组 $M_1$ 的确认并不是丢失了，而是由于种种原因迟到了，当 A 收到该确认的时候，已经触发了超时重传重新发送了分组，此时 B 所作的事没有区别，依然是丢弃分组然后回复确认，A 所做的事情则是对收到的第二个确认分组进行丢弃。如上图 (b) 所示。 这些机制保证了 A 总能收到对所有发出的分组的确认，如果 A 不断重传而一直收不到确认，那么只能说明一件事，那就是信道质量太差。添加了这一系列机制的协议就叫做 自动重传请求 ARQ（Automatic Repeat reQuest）。 ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:3:1","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 滑动窗口 无论是停等还是 ARQ，信道的利用率都比较低，主要是因为只有在收到上一个分组的确认后才会发送下一个分组，优化的办法就是使用流水线传输，即发送方连续发送多个分组，不必等待上一个分组的确认，从而使信道上一直有数据在传送。 当使用流水线传输时，就需要连续 ARQ 协议和滑动窗口协议。这里先介绍连续 ARQ 协议，滑动窗口之后介绍。 如下图所示，发送方维持一个发送窗口，其含义是位于发送窗口内的5个字节可以连续的发出去，不必等待对方的确认。一般我们在讨论时，默认理解为下面图中箭头所示的时间流动方向，向前就指向着时间增大的方向，向后就是向着时间减少的方向。字节的发送是按照序号从小到大的方向。 连续 ARQ 协议规定，发送方每收到一个确认，发送窗口就向前移动一格，上图中发送方收到了对第1个字节的确认，因此发送窗口向前移动了1个字节，现在可以发送第6个字节了。另外，由于发送和接收都是面向字节流的，一次发送接收很可能涉及很多字节，所以接收方一般采用累积确认的方式，也就是说，接收方不必对收到的每个字节都发送确认，而是只对按序到达的最后一个字节发送确认，这一动作就表示到该字节为止前面所有的字节都正确收到了。 累积确认尽管提高了传输效率，减少了网络中的数据，但可能会造成回退 N 问题（Go-back-N）。该问题描述如下，加入发送方发送了 5 个字节，第 3 个字节丢失了，此时接收方只能对前两个字节发送确认，发送方无法知道后面 3 个字节的下落，此时尽管第 4 和第 5 个字节接收方都已经收到了，发送方还是需要对第 3 个字节开始的数据都重传一次，回退 N 的含义就是退回来重传已发送过的 N 个数据。所以在信道质量不好时，连续 ARQ 具有较大的副作用。 ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:3:2","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 TCP 报文 TCP 是面向字节流的，但意思仅限于逐字节编号，交付网络层的实际上是报文段。TCP 报文段首部有 20 个字节是固定的，后面还可以添加 40 个字节，首部最大 60 字节，再往后就是 TCP 的数据部分。TCP 报文格式如下 源端口和目的端口：含义同 UDP 序号：所传输的数据的第一个字节的编号，也就是本报文段数据部分的第一个字节，序号一共四个字节，意味着可编号范围为 $[0, 2^{32}-1]$ 确认号：期望收到的对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发过来的报文段，序号字段值为 501，数据部分共 200字节，所以 B 收到的最后一个字节序号为 700，那么 B 期望收到的 A 的下一个报文段的第一个字节序号就是 701，所以在确认报文中将 确认号字段置为 701。 总之，要明白：若 确认号 = N，就说明到序号 N-1 为止的所有数据都正确收到了。 数据偏移：占4位，指 TCP 报文段数据部分距离报文段起始处有多远，简单来说就是 TCP 首部长度。单位是 4 字节，因此最大值为 15 * 4 = 60 字节，这就是 TCP 首部最大长度。 保留：共6位，当前没有使用，全部置0。 控制位：共6位，每位的作用不一样，如下 紧急URG (URGent) ：当URG = 1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（Control + C）。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了许多时间。当URG置1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针(UrgentPointer)字段配合使用。 确认ACK (ACKnowlegment) ：仅当ACK = 1时确认号字段才有效。当ACK = 0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。 推送 PSH (PuSH)：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送(push)操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH = 1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付 复位RST (ReSeT)：当RST = 1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。 同步SYN (SYNchronization)： 在连接建立时用来同步序号。当SYN = 1而ACK = 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN = 1和ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。关于连接的建立和释放，在本章的5.9节还要进行详细讨论。 终止FIN (FINis，意思是“完”、“终”) ：用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。 窗口：16位，指的是发送本报文段的一方的接收窗口，目的是告诉对方自己还能收多少数据。例如，设确认号是701，窗口字段是1000。这就表明，从701号算起，发送此报文段的一方还有接收1000个字节数据（字节序号是701～1700）的接收缓存空间。 校验和：TCP 校验和的计算方式和 UDP 相同。 紧急指针：占2字节。紧急指针仅在URG = 1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。 选项：长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节。 ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:3:3","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 流量控制 流量控制主要依靠滑动窗口，为了方便说明，假定数据传输只在一个方向进行，即 A 发送数据，B 给出确认。 首先，假定 A 收到了 B 发来的确认报文段，其中窗口是20（字节），确认号是31（即期望收到的B发送的下一个序号是31），根据这两个值，A 构造自己的发送窗口如下 此时 A 可以将序号 31 起连续 20 个字节都发送出去，但在未收到确认前都必须保留，以便超时重传使用。因此，发送窗口中的数据表示允许发送的数据，后沿后面的数据表示已收到确认的数据，前沿前面的数据表示不允许发送的数据。如果没有收到新的确认，后沿不可移动，收到新的确认后，后沿向前移动，而如果收到的确认中对方通知的窗口缩小了，使得发送窗口前沿正好不动，那么前沿也不动，否则前沿根据通知的窗口大小向前移动。当然，前沿也可以向后收缩，但 TCP 强烈不赞成这么做。 TCP 的流量控制指的是通过窗口和确认号来调整发送速率，让发送方的发送不要太快，从而使接收方来得及接收。 除此之外，流量控制还包括两个问题。 第一个问题是由于发送方应用层交付过慢造成的，假如发送方应用层每次交付1个字节，那么就需要加上 20 个字节的 TCP 首部，再加上 20 字节的 IP 首部，然后发送出去，每次为了1字节的数据，要多发送远大于数据部分的 40 个字节，效率非常低。应对这种情况主要使用 Nagle 算法，算法如下：若发送方应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来，当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组成一个报文发送出去，同时继续对随后到达的数据进行缓存，只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用地网络带宽。Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。 另一个问题叫做糊涂窗口综合症（silly window syndrome），是由于接收方接收过慢造成的。设想一种情况：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节（这样就使接收缓存空间仅腾出1个字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报是40字节长）。接着，发送方又发来1个字节的数据（请注意，发送方发送的IP数据报是41字节长）。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。 TCP 的流量控制主要指的就是滑动窗口的控制和这两个问题。 ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:3:4","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3.5 拥塞控制 流量控制往往指点对点通信量的控制，要做的是抑制发送端发送数据的速率，以便接收端来得及接收。拥塞控制要做的则是防止过量的数据注入网络，它与流量控制的相似之处在于，某些拥塞控制算法是通过向发送端发送控制报文，令其放慢发送速率完成的，手段与流量控制相似。TCP 的拥塞控制主要是指通过某种手段判断网络是否出现拥塞，然后对发送速率进行调整。 当前进行拥塞控制主要是四种算法：慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）。 这四种算法都与一个拥塞窗口 cwnd（congestion window）的状态变量有关，拥塞窗口由发送方维持，其大小取决于网络的拥塞程度，并且在动态地变化，发送方会让自己的发送窗口等于拥塞窗口大小。只要发送方没有按时收到应当到达的确认报文，就猜测网络可能出现了拥塞，此时就将拥塞窗口减小，从而减少发送到网络中的数据，如果按时收到确认，就证明网络没有出现拥塞，拥塞窗口就再增大一些。四种拥塞控制算法实际上就是在控制拥塞窗口的变化。 慢开始 慢开始的思路是这样的，当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因此先将拥塞窗口设置为一个最大报文段的数值，每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值，这样从小到大逐步增加拥塞窗口大小，从而使数据注入到网络的速率更加合理。 举个例子，假设在一开始发送方先设置cwnd = 1，发送第一个报文段M1，接收方收到后确认M1。发送方收到对M1的确认后，把cwnd从1增大到2，于是发送方接着发送M2和M3两个报文段。接收方收到后发回对M2和M3的确认。发送方每收到一个对新报文段的确认（重传的不算在内）就使发送方的拥塞窗口加1，因此发送方在收到两个确认后，cwnd就从2增大到4，并可发送M4～M7共4个报文段（见图5-24）。因此使用慢开始算法后，每经过一个传输轮次(transmission round)，拥塞窗口cwnd就加倍。这里的传输轮次指的是一次往返时间。简单的图示如下 慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd = 1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要“慢得多”。这对防止网络出现拥塞是一个非常有力的措施。 拥塞避免 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh状态变量。慢开始门限ssthresh的用法如下： 当cwnd \u003c ssthresh时，使用上述的慢开始算法。 当cwnd \u003e ssthresh时，停止使用慢开始算法而改用拥塞避免算法。 当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。 拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样，拥塞窗口cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 快重传 如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。在下图所示的例子中，接收方收到了M1和M2后都分别发出了确认。现假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段（按照顺序的M3还没有收到）。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对 M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送M5和M6。接收方收到后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待为M3设置的重传计时器到期。由于发送方能尽早重传未被确认的报文段。 快恢复 与快重传配合使用的还有快恢复算法，其过程有以下两个要点： 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。 由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重的拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:3:5","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3.6 TCP连接 TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，而被动等待连接建立的应用进程叫做服务器(server)。 连接建立 TCP 连接建立的过程如下图所示，假定主机 A 运行的是 TCP 客户程序，而 B 运行 TCP 服务器程序。最初两端的TCP 进程都处于 CLOSED（关闭）状态。图中在主机下面的方框分别是 TCP 进程所处的状态。请注意，A 主动打开连接，而 B 被动打开连接。 B 被动打开连接的意思不是在连接建立前 B 不做任何事，相反，B 的 TCP 服务器进程需要先创建传输控制块 TCB，准备接受客户进程的连接请求。然后使服务器进程处于 LISTEN（收听）状态，等待客户的连接请求。 A 的 TCP 客户进程也是首先创建传输控制模块 TCB，然后在需要建立连接时向 B 发出连接请求报文段，这是建立连接的第一条报文，这时首部中的同步位 SYN = 1，同时选择一个初始序号 seq= x。TCP规定，SYN 报文段（即SYN = 1的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。 B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入 SYN-RCVD（同步收到）状态。 TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置1，确认号 ack = y + 1，而自己的序号seq = x + 1。TCP 的标准规定，这一个报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。 当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。 整个连接建立的过程涉及三个报文的发送接收，因此叫做三次握手(three-way handshake)。 面试时经常问的，也是比较关键的一个问题是第三次确认报文的作用，这里明确：A 发送第三次确认的原因是防止已失效的连接请求报文段突然又传送到了 B，从而产生错误。 所谓“已失效的连接请求报文段”是这样产生的。假设 A 发出一个连接请求，但因连接请求报文丢失而未收到确认。于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。如果 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用三次握手，那么只要 B 发出确认，新的连接就建立了。 此时由于 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。第三次的确认报文可以防止上述现象的发生。例如在刚才的情况下，A 不会向 B 的确认发出确认。B 由于收不到确认，就知道 A 并没有要求建立连接。 连接释放 数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置1，其序号 seq = u，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意，TCP规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。 B 收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加1。然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭(half-close)状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一些时间。 A 收到来自 B 的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待 B 发出的连接释放报文段。 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 w（在半关闭状态B可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK（最后确认）状态，等待 A 的确认。 A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack = w + 1，而自己的序号是 seq = u + 1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。然后进入到 TIME-WAIT（时间等待）状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做最长报文段寿命(Maximum Segment Lifetime)，RFC 793建议设为2分钟。但这完全是从工程上来考虑，对于现在的网络，MSL = 2分钟可能太长了一些。因此 TCP 允许不同的实现可根据具体情况使用更小的 MSL 值。因此，从 A 进入到 TIME-WAIT 状态后，要经过4分钟才能进入到 CLOSED 状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接 为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间呢？这有两个理由。 第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK状态的 B 收不到对已发送的 FIN+ ACK 报文段的确认。B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 CLOSED 状态。 第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。 B 只要收到了 A 发出的确认，就进入 CLOSED 状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的TCP 连接。我们注意到，B 结束 TCP 连接的时间要比 A 早一些。 上述的 TCP 连接释放过程叫做四次握手。 除时间等待计时器外，TCP还设有一个保活计时器(keepalive timer)。设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75分钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。 ","date":"2020-07-07","objectID":"/2020/transmission-control-protocol-and-user-datagram-protocol/:3:6","tags":["计算机基础"],"title":"计算机网络-TCP和UDP协议","uri":"/2020/transmission-control-protocol-and-user-datagram-protocol/"},{"categories":["平日里的白日梦"],"content":"信息过载可能严重影响我们的生活，网上看到了心理与行为信息部的一些建议。 ","date":"2020-06-11","objectID":"/2020/how-to-avoid-information-overload/:0:0","tags":["杂谈"],"title":"如何避免信息过载","uri":"/2020/how-to-avoid-information-overload/"},{"categories":["平日里的白日梦"],"content":"1. 主动浏览，拒绝被动推送 筛选有效的信息源 重点关注政府机关、专业组织等具有公信力的官方媒体发布的逝世类信息，尽量过滤自媒体发布的观点类信息。在微博、微信中可以设定分组，App中的信息推送功能也可以选择关闭。 控时控量的接收信息 每天可以固定一个时间段用来接收信息，时长最好不要超过1个小时。尽量不要在睡前浏览信息，一方面很容易超时，另一方面，浏览信息带来的负面情绪可能造成失眠。 ","date":"2020-06-11","objectID":"/2020/how-to-avoid-information-overload/:1:0","tags":["杂谈"],"title":"如何避免信息过载","uri":"/2020/how-to-avoid-information-overload/"},{"categories":["平日里的白日梦"],"content":"2. 细辨真假，防止盲目从众 如何判断一条消息是否真实呢？ ✅发布者为官方媒体、权威机构等； ✅作者具备扎实，雄厚的专业背景； ✅时间、地点、人物、起因、经过、结果明确； ❌语言煽动性或主观性过强； ❌开局一张图，剩下全靠编； ❌不明来源的聊天记录截图。 在人人都是自媒体的时代，真相与谣言齐飞。发布信息是大家的权力，但别忘了，同时你也承担着一份责任。在按下转发键的那一刻，你也许不会想到，这条消息将被多少人看到，给多少人带来心理重负，引起多少不必要的恐慌。 建议大家，如果您并不具备相关知识背景，那么请您相信这个领域专业的、值得信任的人，不要对外转发未经证实的消息。 ","date":"2020-06-11","objectID":"/2020/how-to-avoid-information-overload/:2:0","tags":["杂谈"],"title":"如何避免信息过载","uri":"/2020/how-to-avoid-information-overload/"},{"categories":["平日里的白日梦"],"content":"3. 回归真实，过好个人生活 设定日程规划 宅家期间，您可以制定一个日程规划表，让生活充实起来，多去做一些能够看到即时效果的事情，重拾对生活的控制感。比如：整理房间，学一道菜，读一本好书，每天至少30分钟锻炼… 关注身边亲人 多陪伴您的家人，关注家人的身心理变化，增强情感和信息交流。引导家中的老人和孩子接受正规渠道的消息，多关注充满正能量的、提供解决方案等“解困式”的信息，避免因恐慌、焦虑等消极情绪导致免疫力下降。总之，家人永远是您最重要的社会支持。 保持平和心态 危难关头，最考验人的心理素质。这一场心理战，您的表现如何？不妨采取写日记的方式，记录生活的精彩瞬间和深深的感动。请您记住，无论做什么，你才是生活的主人！ ","date":"2020-06-11","objectID":"/2020/how-to-avoid-information-overload/:3:0","tags":["杂谈"],"title":"如何避免信息过载","uri":"/2020/how-to-avoid-information-overload/"},{"categories":["Golang学习之路"],"content":"部署 Go 应用相对简单，因为所有应用代码都被打包成一个二进制文件了（视图模板、静态资源和配置文件等非 Go 代码除外），并且不需要依赖其他库，不需要额外的运行时环境（比如 Java 需要再安装 JVM），也不需要部署额外的 HTTP 服务器。 对于在线论坛项目，包含了静态资源文件（CSS、JavaScript、图片），所以我们将在 Go Web 应用之前前置一个 Nginx 服务器处理静态资源请求，然后通过反向代理处理动态资源请求（指向 Go 处理器方法的请求），对于那些不包含静态资源和视图模板的纯 API 项目，通常只需要打包一份二进制文件部署到服务器即可，更加便捷。 注：其实 Go 应用部署的最佳实践是基于 Docker，后续我们在部署专题中再介绍如何基于 Docker 将应用快速部署到远程云服务器。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"1. 构建应用 首先，我们可以在本地项目根目录下通过如下命令将应用代码打包成二进制可执行文件： GOOS=linux GOARCH=amd64 go build 注意这里指定了 GOOS 和 GOARCH 选项进行交叉编译，因为我们是在 Win10 系统（amd64）中打包，并且目标二进制文件需要在 Linux 服务器（linux）执行。该命令执行成功后会在当前目录下生成和项目名称相同的二进制文件： 然后我们可以将代码提交到 Github 或者其他代码仓库。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"2. 部署应用 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"2.1 部署代码 再登录服务器到部署目录下拉取代码： git clone https://github.com/nonfu/chitchat 初次拉取使用 git clone，后续在 chitchat 目录下运行 git pull 即可。 然后我们进入 chitchat 目录，配置 config.json 进行服务端数据库配置（正式项目不要将 config.json 提交到代码仓库，以免安全风险和后续拉取代码覆盖），确保 logs 目录对 Web 用户具有写权限（比如配置权限为 777，或者所属用户与 Web 用户组一致）。 注：当然我们这里部署代码的方式比较原始，对于多人协作的大型项目，可以借助持续集成工具（比如 Jenkins）进行自动化部署，并且由于项目比较简单，就不再演示单元测试、CI/CD 等其他 DevOps 工具的使用了。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"2.2 数据库初始化 在服务端 MySqL 数据库中创建 chitchat 数据库，并初始化对应数据表。如果不了解如何安装和创建数据库，可以参考这篇教程：将博客应用自动部署到线上服务器完整流程详解。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"2.3 访问应用 完成以上工作后，我们就可以在 chitchat 项目目录下运行 chitchat 二进制文件启动应用了： 然后我们在本地 hosts 文件中自定义一个测试域名与服务器 IP 的映射： your-server-ip-address chitchat.test 将上述 your-server-ip-address 替换成自己的远程服务器 IP 地址，然后我们就可以在浏览器中通过 http://chitchat.test:8080 访问应用了： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"3. 通过 Nginx 做反向代理 虽然上述方式可以正常运行，但是如果要高效处理静态资源文件并对其做缓存，可以借助 Nginx 作为反向代理服务器来完成，我们在 Nginx 虚拟主机配置目录 /etc/nginx/sites-available 中新增一个配置文件 chitchat.conf（以 Ubuntu 服务器为例）： server { listen 80; server_name chitchat.test www.chitchat.test; # 静态资源交由 Nginx 管理，并缓存一天 location /static { root /var/www/chitchat/public; expires 1d; add_header Cache-Control public; access_log off; try_files $uri @goweb; } location / { try_files /_not_exists_ @goweb; } # 动态请求默认通过 Go Web 服务器处理 location @goweb { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Scheme $scheme; proxy_redirect off; proxy_pass http://127.0.0.1:8080; } error_log /var/log/nginx/chitchat_error.log; access_log /var/log/nginx/chitchat_access.log; } 然后再启用该配置文件： ln -s /etc/nginx/sites-available/chitchat /etc/nginx/sites-enabled/chitchat 重启 Nginx 服务： service nginx restart 与此同时，我们可以把 chitchat/config.json 中的 App 配置项启动 IP 地址改为 127.0.0.1： \"App\": { \"Address\": \"127.0.0.1:8080\", \"Static\": \"public\", \"Log\": \"logs\", \"Locale\": \"locales\", \"Language\": \"zh\" }, 并再次重启这个 Go 应用，这样就只能通过 Nginx 访问应用，在浏览器中访问 http://chitchat.test： 而当你试图再通过 http://chitchat.test:8080 访问应用，则会报错： 我们可以测试下注册登录功能以及创建新群组功能： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"4. 通过 Supervisor 维护应用守护进程 看起来一切都 OK 了，但是目前这种模式下，用户退出后 Go Web 应用进程会关闭，这显然是不行的，而且如果 Go Web 应用进程因为其他异常挂掉，也无法自动重启，每次需要我们登录到服务器进行启动操作，这很不方便，也影响在线应用的稳定性，为此，我们需要借助第三方进程监控工具帮我们实现 Go Web 应用进程以后台守护进程的方式运行。常见的进程监控工具有 Supervisor、Upstart、systemd 等，由于我的服务器之前部署过 Supervisor，所以我就借助它来管理 Go Web 应用进程。 注：对 Supervisor 安装配置不了解的同学，可以参考这篇教程 —— 队列系统解决方案：Horizon。 首先创建对应的 Supervisor 配置文件 /etc/supervisor/conf.d/chitchat.conf，这里需要设置进程启动目录及命令、进程意外挂掉后是否自动重启、以及日志文件路径等： [program:chitchat] process_name=%(program_name)s directory=/var/www/chitchat command=/var/www/chitchat/chitchat autostart=true autorestart=true user=root redirect_stderr=true stdout_logfile=/var/www/chitchat/logs/chitchat.log 注意：我们需要进入 chitchat 所在目录执行启动命令，否则会找不到配置文件和其他资源路径，所以需要配置 directory 选项。 然后关闭之前通过手动运行 chitchat 启动的 Go Web 服务器，再运行如下指令通过 Supervisor 启动并维护 Go Web 应用进程： supervisorctl reread supervisorctl update supervisorctl start chitchat 你可以通过 ps -ef | grep chitchat 查看进程是否启动成功： 启动成功后，就可以在浏览器通过 http://chitchat.test 访问部署在远程服务器的在线论坛了： 并且无论是否退出远程服务器还是关闭 Go Web 应用进程，都不会影响在线论坛的访问，因为它是以守护进程的方式运行的，并且可以在关闭后自动重启。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"由于之前所有页面和消息文本都是英文的，而我们开发的应用基本都是面向中文用户的，所以需要对项目进行本地化，因此本篇介绍如何在 Go Web 应用中进行国际化和本地化编程，由于项目比较简单，只介绍消息提示、视图模板和日期格式的本地化。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1. 消息本地化 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.1 安装 go-i18n 扩展包 首先来看消息提示文本，消息提示文本通常包括表单验证消息、应用异常消息、接口响应消息等后端接口返回的消息字符串片段，关于这一块的本地化，可以借助 Go 官方自带的 golang.org/x/text 扩展包实现，这个扩展包扩展性好，但是上手起来有点复杂，因此我们使用的是一款更容易上手的第三方扩展包 —— go-i18n。 在使用这个扩展包之前，先在项目根目录下运行如下命令下载相关的扩展包： go get -u github.com/nicksnyder/go-i18n/v2/i18n go get -u github.com/nicksnyder/go-i18n/v2/goi18n 下载完成后，我们可以运行 goi18n -help 确保 goi18n 命令可执行 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.2 通过 go-i18n 自动生成翻译文件 接下来，我们来编写消息文本模板用于生成翻译文件。在这个项目中，只有一个消息提示文本，那就是访问的群组不存在时返回的 Cannot read thread，因此，我们在项目根目录下创建 messages.go，并基于 go-i18n 提供的类型编写消息模板如下： package main import \"github.com/nicksnyder/go-i18n/v2/i18n\" var messages = []i18n.Message{ { ID: \"thread_not_found\", Description: \"Thread not exists in db\", Other: \"Cannot read thread\", }, } 其中 ID 是消息文本的唯一标识，Other 则是对应的翻译字符串（默认是英文），然后基于 goi18n 命令自动生成翻译文件到 locales 目录（执行前先创建 locales 目录）： mkdir locales goi18n extract -outdir=locales -format=json messages.go 这样，就会在 locales 目录下生成可以被 go-i18n 包识别并解析的 JSON 格式翻译文件 active.en.json： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.3 编写中文版本翻译文件 然后，要进行本地化编程，可以在同级目录下创建并编辑 active.zh.json 用于存放消息文本的中文翻译： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.4 本地化配置初始化 回到在在线论坛项目，打开配置文件 config.json，新增本地化目录和语言配置： { \"App\": { ... \"Locale\": \"locales\", \"Language\": \"zh\" }, ... } 然后在 config/config.go 中新增与之映射的结构体字段，以及对应的初始化设置： package config import ( \"encoding/json\" \"github.com/nicksnyder/go-i18n/v2/i18n\" \"golang.org/x/text/language\" \"log\" \"os\" \"sync\" ) type App struct { ... Locale string Language string } ... type Configuration struct { App App Db Database LocaleBundle *i18n.Bundle } var config *Configuration var once sync.Once // 通过单例模式初始化全局配置 func LoadConfig() *Configuration { once.Do(func() { file, err := os.Open(\"config.json\") if err != nil { log.Fatalln(\"Cannot open config file\", err) } decoder := json.NewDecoder(file) config = \u0026Configuration{} err = decoder.Decode(config) if err != nil { log.Fatalln(\"Cannot get configuration from file\", err) } // 本地化初始设置 bundle := i18n.NewBundle(language.English) bundle.RegisterUnmarshalFunc(\"json\", json.Unmarshal) bundle.MustLoadMessageFile(config.App.Locale + \"/active.en.json\") bundle.MustLoadMessageFile(config.App.Locale + \"/active.\" + config.App.Language + \".json\") config.LocaleBundle = bundle }) return config } 注意我们在 App 结构体中新增了一个 *i18n.Bundle 类型的 LocaleBundle 字段，用于存放全局本地化 Bundle 实例，并且在 LoadConfig() 方法中以单例模式初始化该实例。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.5 在处理器方法中返回本地化消息 接下来，我们打开 handlers/helper.go，在 init 方法中初始化 Localizer 以便被所有处理器方法使用： package handlers import ( ... \"github.com/nicksnyder/go-i18n/v2/i18n\" . \"github.com/xueyuanjun/chitchat/config\" ) var logger *log.Logger var config *Configuration var localizer *i18n.Localizer func init() { // 获取全局配置实例 config = LoadConfig() // 获取本地化实例 localizer = i18n.NewLocalizer(config.LocaleBundle, config.App.Language) ... } ... 最后在 handlers/thread.go 和 handlers/post.go 中调用 errorMessage 辅助函数的地方调用 Localizer 提供的方法对消息文本进行翻译并返回给用户： if err != nil { msg := localizer.MustLocalize(\u0026i18n.LocalizeConfig{ MessageID: \"thread_not_found\", }) errorMessage(writer, request, msg) } else { ... } ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:5","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.6 测试消息本地化 重新启动应用，如果试图访问一个不存在的群组页面，就会返回如下中文提示信息： 说明我们的本地化翻译生效了，当然这里只是使用了 go-i18n 提供的最基本的功能，想要了解更多使用示例，可以参考如下链接： 官方文档 借助 go-i18n 更简单地实现全球化 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:6","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"2. 视图本地化 所谓视图本地化指的是静态 HTML 视图模板的本地化，这里就不再适合使用消息文本翻译的方式实现了，最简单的方式就是为每个语言创建独立的视图模板进行本地化，然后在应用代码中通过读取全局配置、用户手动选择、客户端参数（比如 HTML 请求头中的 Accept-Language 字段）、或者域名信息来判断加载那种本地化视图模板，为了简化演示流程，这里我们使用全局配置的方式，也就是我们上面配置文件中设置的 Language 字段。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"2.1 创建本地化视图模板 首先，我们在 views 目录下新增 en 和 zh 两个子目录，分别用于存放英文视图模板和中文视图模板，然后将原有视图文件移动到 en 目录下，并且在 zh 目录下创建每个视图模板的中文版本，以首页 index.html 为例，对应的中文版本如下： 其他中文视图模板也是类似，将其中的英文文本统一翻译成中文即可。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"2.2 通过配置加载本地化视图 打开 handlers/helper.go，在 generateHTML 方法中通过读取全局配置加载对应的本地化视图模板： func generateHTML(writer http.ResponseWriter, data interface{}, filenames ...string) { var files []string for _, file := range filenames { files = append(files, fmt.Sprintf(\"views/%s/%s.html\", config.App.Language, file)) } templates := template.Must(template.ParseFiles(files...)) templates.ExecuteTemplate(writer, \"layout\", data) } 非常简单，不再赘述。 注：同时移除 parseTemplateFiles 方法，并将调用该方法的地方调整为调用 generateHTML 以避免维护两个地方。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"2.3 测试视图本地化 重启应用，访问首页，即可看到页面视图已经都是中文显示了： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"3. 日期时间本地化 看起来都已经 OK 了，不过还有个小问题，那就是日期时间显示还是英文风格的，对应的实现代码在 models/thread.go 中： func (thread *Thread) CreatedAtDate() string { return thread.CreatedAt.Format(\"Jan 2, 2006 at 3:04pm\") } 我们当然可以直接修改这里来实现类似 2006-01-02 15:04:05 的日期时间格式（该时间节点是 Go 语言元年），不过，学院君这里换一种复杂一点的实现，以便顺手介绍下如何在 Go 视图模板中通过管道模式调用自定义函数。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"3.1 将自定义函数应用到视图模板 打开 handlers/helper.go，新增一个格式化日期时间的函数 formatDate，然后在 generateHTML 方法中将这个函数通过 template.FuncMap 组装后再通过 Funcs 方法应用到视图模板中，这样，就可以在所有视图模板中通过 fdate 别名来调用 formatDate 函数了： // 生成 HTML 模板 func generateHTML(writer http.ResponseWriter, data interface{}, filenames ...string) { var files []string for _, file := range filenames { files = append(files, fmt.Sprintf(\"views/%s/%s.html\", config.App.Language, file)) } funcMap := template.FuncMap{\"fdate\": formatDate} t := template.New(\"layout\").Funcs(funcMap) templates := template.Must(t.ParseFiles(files...)) templates.ExecuteTemplate(writer, \"layout\", data) } ... // 日期格式化辅助函数 func formatDate(t time.Time) string { datetime := \"2006-01-02 15:04:05\" return t.Format(datetime) } ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:3:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"3.2 调用自定义函数格式化本地日期时间 然后我们在所有视图文件中将群组创建日期渲染调整为如下方式，即通过管道连接符的方式将 .CreatedAt 变量作为参数传入 fdate 并输出返回值： {{ .CreatedAt | fdate }} 注意这里一定要使用 .CreatedAt，这个变量才是 time.Time 类型，而 .CreatedAtDate 是字符串类型。 再次重新启动应用，访问首页和群组详情页就可以看到格式化后的本地日期时间格式了： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:3:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"本文介绍如何将敏感信息或可变信息通过配置文件进行配置，然后在应用中读取这些配置文件来获取配置信息。 将敏感信息通过配置文件读取是为了避免随着代码提交到公开库造成敏感信息的泄露，给线上环境带来安全隐患，这些敏感信息包括数据库连接信息、第三方 SDK （比如微信、支付宝、Github）的密钥等。 将可变信息通过配置文件读取是为了避免硬编码，将经常变动的信息通过配置文件配置可以极大的提高代码的可维护性，这些可变信息通常包括应用服务器监听的地址和端口、目录路径设置、当前运行环境、超时时间等。 使用公开库时，如 github，配置文件需要写入 .gitignore 文件从而避免提交到线上。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"1. 定义全局配置文件 接下来，我们为在线论坛项目设置配置文件 config.json，将一些敏感信息和可变信息提交到 JSON 配置文件中 { \"App\": { \"Address\": \"0.0.0.0:8080\", \"Static\": \"public\", \"Log\": \"logs\" }, \"Db\": { \"Driver\": \"mysql\", \"Address\": \"localhost:3306\", \"Database\": \"chitchat\", \"User\": \"root\", \"Password\": \"root\" } } 应用相关的可变信息配置到 app 配置项，数据库相关的敏感信息配置到 Db 配置项 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"2. 通过单例模式初始化全局配置 在根目录下创建 config 目录，然后在该目录下新增 config.go 用来存放配置初始化代码 package config import ( \"encoding/json\" \"log\" \"os\" \"sync\" ) type App struct { Address string Static string Log string } type Database struct { Driver string Address string Database string User string Password string } type Configuration struct { App App Db Database } var config *Configuration var once sync.Once // 通过单例模式初始化全局配置 func LoadConfig() *Configuration { once.Do(func() { file, err := os.Open(\"config.json\") if err != nil { log.Fatalln(\"Cannot open config file\", err) } decoder := json.NewDecoder(file) config = \u0026Configuration{} err = decoder.Decode(config) if err != nil { log.Fatalln(\"Cannot get configuration from file\", err) } }) return config } 定义 Configuration 结构体以便和全局配置文件 config.json 字段进行映射，注意这里的首字母都需要大写 定义一个 LoadConfig 方法以单例模式返回全局配置实例的指针，这里使用单例的原因是因为应用代码中可能多处都要获取配置值，重复加载配置文件进行 JSON 解码存在性能损耗（当然，定义 init 方法本身就可以支持全局运行一次，这里主要演示下单例模式如何实现）。在 Go 语言中，我们可以借助并发编程中的 sync.Once 类型来实现单例模式，保证并发安全，在 once.Do 中定义的匿名函数全局只会执行一次 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"3. 项目代码重构 最后，我们将项目代码中相应位置的硬编码调整为通过上面方法返回的全局配置实例获取配置值 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"3.1 Web 服务器启动参数 首先需要在 main.go 的入口位置初始化全局配置 package main import ( . \"github.com/xueyuanjun/chitchat/config\" . \"github.com/xueyuanjun/chitchat/routes\" \"log\" \"net/http\" ) func main() { startWebServer() } // 通过指定端口启动 Web 服务器 func startWebServer() { // 在入口位置初始化全局配置 config := LoadConfig() r := NewRouter() // 通过 router.go 中定义的路由器来分发请求 // 处理静态资源文件 assets := http.FileServer(http.Dir(config.App.Static)) r.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", assets)) http.Handle(\"/\", r) log.Println(\"Starting HTTP service at \" + config.App.Address) err := http.ListenAndServe(config.App.Address, nil) if err != nil { log.Println(\"An error occured starting HTTP listener at \" + config.App.Address) log.Println(\"Error: \" + err.Error()) } } 我们在 startWebServer 方法的入口位置初始化全局配置，并且全局配置实例只在这里进行一次初始化，后续不会再执行加载配置文件和 JSON 解码操作，而是直接返回对应的 config 实例： config := LoadConfig() 然后将 Web 服务器的启动参数和静态资源目录都调整为通过配置值获取，这样我们后续只需要更改配置文件即可对其进行调整，而不需要修改任何代码，降低了代码维护成本。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:3:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"3.2 数据库连接配置 接下来，打开 models/db.go，将数据库连接信息调整为通过配置文件读取： package models import ( \"crypto/rand\" \"crypto/sha1\" \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" . \"github.com/xueyuanjun/chitchat/config\" \"log\" ) var Db *sql.DB func init() { var err error config := LoadConfig() // 加载全局配置实例 driver := config.Db.Driver source := fmt.Sprintf(\"%s:%s@(%s)/%s?charset=utf8\u0026parseTime=true\", config.Db.User, config.Db.Password, config.Db.Address, config.Db.Database) Db, err = sql.Open(driver, source) if err != nil { log.Fatal(err) } return } 虽然，在这里页调用了 LoadConfig()，但是由于是单例模式，所以会直接返回 config 实例，不会再进行初始化操作，然后我们获取配置值填充对应的 sql.Open 连接配置。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:3:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"4. 整体测试 至此，我们已经完成了通过配置文件读取应用配置的代码重构，我们可以为项目编写单元测试，也可以直接通过在浏览器访问这个在线论坛项目验证重构后应用是否可以正常运行，重新启动 Web 服务器，输出如下： $ go run main.go 2020/06/07 16:54:55 Starting HTTP server at 0.0.0.0:8080 表示启动服务器时读取配置信息正常，然后访问应用首页： 成功，对用户来说，没有任何感知后台的变动。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"到现在为止，我们已经完成了在线论坛项目基本功能的开发，对 Go 语言 Web 编程中如何实现 MVC 架构模式以及 CRUD（数据库增删改查）基本操作有了初步的认识。不过现在所有的日志和错误处理都是杂糅在业务代码中，本篇介绍如何对它们统一进行处理，使得业务代码和日志及错误处理逻辑分离。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"1. 日志处理 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"1.1 初始化日志处理器 首先来看日志处理，在 handlers/helper.go 中，新增如下日志处理器初始化代码： import ( \"log\" \"os\" ) var logger *log.Logger func init() { file, err := os.OpenFile(\"logs/chitchat.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { log.Fatalln(\"Failed to open log file\", err) } logger = log.New(file, \"INFO \", log.Ldate|log.Ltime|log.Lshortfile) } 这里我们借助 Go 官方提供的 log 包进行日志处理，首先声明一个 *log.Logger 类型的 logger 变量作为日志处理器，以便可以全局使用。默认的日志文件位于 logs/chitchat.log，我们通过 os.OpenFile 打开这个日志文件句柄，如果文件不存在，则自动创建。然后我们通过 log.New 初始化日志处理器并赋值给 logger，该方法需要传入日志文件、默认日志级别、以及日志格式，关于该方法的细节，我们后面在日志章节会详细介绍。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:1:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"1.2 定义日志函数 然后我们就可以通过 logger 这个日志处理器来记录日志了，在 helper.go 中新增如下几个日志函数： func info(args ...interface{}) { logger.SetPrefix(\"INFO \") logger.Println(args...) } // 为什么不命名为 error？避免和 error 类型重名 func danger(args ...interface{}) { logger.SetPrefix(\"ERROR \") logger.Println(args...) } func warning(args ...interface{}) { logger.SetPrefix(\"WARNING \") logger.Println(args...) } 非常简单，我们定义了三个日志函数来记录三个日志级别，分别是 INFO（普通）、ERROR（错误）、WARNING（警告），然后通过调用 logger.Println 传入参数记录日志信息到日志文件即可，这里的参数类型是 ...interface{}，表示可以传入参数支持任意类型、任意个数。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:1:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"1.3 重构业务代码 接下来，我们到业务处理器中，将原来的日志打印代码都重构为调用对应的日志函数，以 handlers/auth.go 为例，修改日志处理代码如下： // src/github.com/xueyuanjun/chitchat/handlers/auth.go // 注册新用户 func SignupAccount(writer http.ResponseWriter, request *http.Request) { err := request.ParseForm() if err != nil { danger(err, \"Cannot parse form\") } user := models.User{ Name: request.PostFormValue(\"name\"), Email: request.PostFormValue(\"email\"), Password: request.PostFormValue(\"password\"), } if err := user.Create(); err != nil { danger(err, \"Cannot create user\") } http.Redirect(writer, request, \"/login\", 302) } // 用户认证 func Authenticate(writer http.ResponseWriter, request *http.Request) { err := request.ParseForm() user, err := models.UserByEmail(request.PostFormValue(\"email\")) if err != nil { danger(err, \"Cannot find user\") } if user.Password == models.Encrypt(request.PostFormValue(\"password\")) { session, err := user.CreateSession() if err != nil { danger(err, \"Cannot create session\") } cookie := http.Cookie{ Name: \"_cookie\", Value: session.Uuid, HttpOnly: true, } http.SetCookie(writer, \u0026cookie) http.Redirect(writer, request, \"/\", 302) } else { http.Redirect(writer, request, \"/login\", 302) } } // 用户退出 func Logout(writer http.ResponseWriter, request *http.Request) { cookie, err := request.Cookie(\"_cookie\") if err != http.ErrNoCookie { warning(err, \"Failed to get cookie\") session := models.Session{Uuid: cookie.Value} session.DeleteByUUID() } http.Redirect(writer, request, \"/\", 302) } 其他处理器方法参照这个示例进行调整即可 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:1:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"2. 错误处理 Go 语言并没有像 PHP、Java 那样提供异常这种类型，只有 error 和 panic，对于 Go Web 应用中的错误处理，不影响程序继续往后执行的，可以通过日志方式记录下来，如果某些错误导致程序无法往后执行，比如浏览群组详情页，对应群组不存在，这个时候，我们就应该直接返回 404 响应或者将用户重定向到 404 页面，而不能继续往后执行，对于这种错误，只能通过单独的处理逻辑进行处理，这种错误类似于 Laravel 中的中断异常处理。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"2.1 重定向到错误页面 在这个项目中，我们通过重定向到错误页面的方式处理这种类型的错误，在 handlers/helper.go 中新增 error_message 函数： // 异常处理统一重定向到错误页面 func error_message(writer http.ResponseWriter, request *http.Request, msg string) { url := []string{\"/err?msg=\", msg} http.Redirect(writer, request, strings.Join(url, \"\"), 302) } 调用该方法会将用户重定向到错误处理页面（由 err 路由对应处理器方法渲染），响应状态码为 302，并且带上错误消息 msg，以便客户端感知错误原因。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"2.2 编写错误页面相关代码 为此，我们还要编写用于处理应用出错的路由、处理器和视图实现。 处理器方法 首先在 handlers/index.go 中编写全局的、渲染错误页面的处理器方法： func Err(writer http.ResponseWriter, request *http.Request) { vals := request.URL.Query() _, err := session(writer, request) if err != nil { generateHTML(writer, vals.Get(\"msg\"), \"layout\", \"navbar\", \"error\") } else { generateHTML(writer, vals.Get(\"msg\"), \"layout\", \"auth.navbar\", \"error\") } } 我们可以通过 vals.Get 方法从查询字符串获取 msg 参数，并将其渲染到错误视图 error.html 中。 错误视图 然后在 views 目录下新增 error.html 用来定义错误视图： {{ define \"content\" }} \u003cp class=\"lead\"\u003e{{ . }}\u003c/p\u003e {{ end }} 非常简单，只是通过 {{ . }} 获取 msg 变量的值并渲染出来。 注册路由 最后在 routes/routes.go 中注册错误路由： { \"error\", \"GET\", \"/err\", handlers.Err, }, ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"2.3 重构业务代码 在必要的地方调用错误处理函数 error_message 将用户重定向到错误页面，比如在 handlers/thread.go 中，在浏览群组详情页时，如果指定 ID 对应群组不存在，则将用户重定向到错误页面： // 通过 ID 渲染指定群组页面 func ReadThread(writer http.ResponseWriter, request *http.Request) { vals := request.URL.Query() uuid := vals.Get(\"id\") thread, err := models.ThreadByUUID(uuid) if err != nil { error_message(writer, request, \"Cannot read thread\") } else { ... } } 又比如 handlers/post.go 中，在创建新主题时，如果获取不到主题归属的群组，则将用户重定向到错误页面： // 在指定群组下创建新主题 func PostThread(writer http.ResponseWriter, request *http.Request) { sess, err := session(writer, request) if err != nil { http.Redirect(writer, request, \"/login\", 302) } else { ... thread, err := models.ThreadByUUID(uuid) if err != nil { error_message(writer, request, \"Cannot read thread\") } ... } } ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"3. 整体测试 至此，我们已经完成了日志和错误统一处理的代码重构，接下来，可以进行简单的测试，重启 HTTP 服务器，访问应用首页，此时会引入 helper.go，执行 init 方法，创建日志文件，我们试图使用错误的用户名密码登录： 测试就可以在 logs/chitchat.log 中看到错误日志了： ERROR 2020/04/07 14:55:39 helper.go:71: sql: no rows in result set Cannot find user 接下来，我们访问一个不存在的群组 http://localhost:8080/thread/read?id=100，页面就会重定向到错误页面： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"日志是一个系统必不可少的部分，本篇介绍Golang中的日志系统。 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:0:0","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"1. 内置log包 官方提供的 log 包实现了简单的日志服务。该包定义了一个 Logger 类型，提供了一些格式化输出方法，为了更容易地使用，对该类型提供了一个标准 Logger 实现，该 Logger 会打印每条日志信息的日期、时间、默认输出到标准错误，Fatal系列函数会在写入日志信息后调用 os.Exit(1)。Panic系列函数会在写入日志信息后panic。 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:1:0","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"1.1 内置实现 一个内置实现使用的简单例子如下 // This sample program demonstrates how to use the base log package. package main import ( \"log\" ) func init() { log.SetPrefix(\"TRACE: \") log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile) } func main() { // Println writes to the standard logger. log.Println(\"message\") // Fatalln is Println() followed by a call to os.Exit(1). log.Fatalln(\"fatal message\") // Panicln is Println() followed by a call to panic(). log.Panicln(\"panic message\") } ------------------------------- TRACE: 2019/04/09 14:24:32.868375 D:/go/TestFile/src/main/TestLog.go:15: message TRACE: 2019/04/09 14:24:32.962329 D:/go/TestFile/src/main/TestLog.go:18: fatal message Process finished with exit code 1 原型函数的说明如下 func Flags() int // Flags返回标准logger的输出选项 func SetFlags(flag int) // SetFlags设置标准logger的输出选项 func Prefix() string // Prefix返回标准logger的输出前缀 func SetPrefix(prefix string) // SetPrefix设置标准logger的输出前缀 func SetOutput(w io.Writer) // SetOutput设置标准logger的输出目的地，默认是标准错误输出 // Printf调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Printf相同的方法处理。 func Printf(format string, v ...interface{}) // Print调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Print相同的方法处理。 func Print(v ...interface{}) // Println调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Println相同的方法处理。 func Println(v ...interface{}) func Fatalf(format string, v ...interface{}) // Fatalf等价于{Printf(v...); os.Exit(1)} func Fatal(v ...interface{}) // Fatal等价于{Print(v...); os.Exit(1)} func Fatalln(v ...interface{}) // Fatalln等价于{Println(v...); os.Exit(1)} func Panicf(format string, v ...interface{}) // Panicf等价于{Printf(v...); panic(...)} func Panic(v ...interface{}) // Panic等价于{Print(v...); panic(...)} func Panicln(v ...interface{}) // Panicln等价于{Println(v...); panic(...)} SetPrefix 设置输出前缀，SetfFlags 设置输出选项，为了理解输出前缀与选项，我们先来看一个标准输出 TRACE: 2019/04/09 14:24:32.868375 D:/go/TestFile/src/main/TestLog.go:15: message 其中，TRACE 就是输出前缀，可以通过 SetPrefix 设置，通过 Prefix 输出，用来在普通的程序输出中分布出日志。后面冒号前的信息就是输出选项，通过 SetFlags 设置，通过 Flags 输出。输出选项的结构定义如下 const ( // 字位共同控制输出日志信息的细节。不能控制输出的顺序和格式。 // 在所有项目后会有一个冒号：2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 \u003c\u003c iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒分辨率：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d.go:23 Lshortfile // 文件无路径名+行号：d.go:23（会覆盖掉Llongfile） LstdFlags = Ldate | Ltime // 标准logger的初始值 ) log 包有一个很方便的地方就是，这些日志记录器是多 goroutine 安全的。这意味着在多个goroutine 可以同时调用来自同一个日志记录器的这些函数，而不会有彼此间的写冲突。标准日志记录器具有这一性质，用户定制的日志记录器也应该满足这一性质。 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:1:1","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"1.2 基于Logger自定义 官方的预置实现是基于Logger类型的，我们也可以基于Logger类型自己进行实现 Logger类型表示一个活动状态的记录日志的对象，它会生成一行行的输出写入一个io.Writer接口。每一条日志操作会调用一次io.Writer接口的Write方法。Logger类型的对象可以被多个线程安全的同时使用，它会保证对io.Writer接口的顺序访问。 type Logger struct { // contains filtered or unexported fields } Logger类型的方法就是官方实现的那些函数 func (l *Logger) Fatal(v ...interface{}) func (l *Logger) Fatalf(format string, v ...interface{}) func (l *Logger) Fatalln(v ...interface{}) func (l *Logger) Flags() int func (l *Logger) Output(calldepth int, s string) error func (l *Logger) Panic(v ...interface{}) func (l *Logger) Panicf(format string, v ...interface{}) func (l *Logger) Panicln(v ...interface{}) func (l *Logger) Prefix() string func (l *Logger) Print(v ...interface{}) func (l *Logger) Printf(format string, v ...interface{}) func (l *Logger) Println(v ...interface{}) func (l *Logger) SetFlags(flag int) func (l *Logger) SetPrefix(prefix string) 有区别的是，还有一个 New 函数用来创建一个 Logger，其中的参数 out 用于设置日志信息写入的目的地，prefix 设置前缀，flag 设置选项。 func New(out io.Writer, prefix string, flag int) *Logger 一个简单的使用示例如下 var buf bytes.Buffer logger := log.New(\u0026buf, \"logger: \", log.Lshortfile) logger.Print(\"Hello, log file!\") fmt.Print(\u0026buf) // Output logger: example_test.go:16: Hello, log file! 一般情况下，我们需要区分不同的日志级别：Info、Warning 和 Error，这里有一个参考实现 // 这个示例程序展示如何创建定制的日志记录器 package main import ( \"io\" \"io/ioutil\" \"log\" \"os\" ) var ( Trace *log.Logger // 记录所有日志 Info *log.Logger // 重要的信息 Warning *log.Logger // 需要注意的信息 Error *log.Logger // 非常严重的问题 ) func init() { file, err := os.OpenFile(\"errors.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { log.Fatalln(\"Failed to open error log file:\", err) } Trace = log.New(ioutil.Discard, \"TRACE: \", log.Ldate|log.Ltime|log.Lshortfile) Info = log.New(os.Stdout, \"INFO: \", log.Ldate|log.Ltime|log.Lshortfile) Warning = log.New(os.Stdout, \"WARNING: \", log.Ldate|log.Ltime|log.Lshortfile) Error = log.New(io.MultiWriter(file, os.Stderr), \"ERROR: \", log.Ldate|log.Ltime|log.Lshortfile) } func main() { Trace.Println(\"I have something standard to say\") Info.Println(\"Special Information\") Warning.Println(\"There is something you need to know about\") Error.Println(\"Something has failed\") } ------------------------------------ INFO: 2019/04/09 14:37:11 TestCustomLog.go:44: Special Information ERROR: 2019/04/09 14:37:11 TestCustomLog.go:46: Something has failed WARNING: 2019/04/09 14:37:11 TestCustomLog.go:45: There is something you need to know about 这里写入的目的地为 ioutil.Discard，这是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情并且始终成功返回。 OpenFile几个选项说明如下 O_CREATE // 如果不存在将创建一个新文件 O_WRONLY // 只写模式打开文件 O_APPEND // 写操作时将数据附加到文件尾部 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:1:2","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"2. 第三方log库 比较流行且近期还在更新的日志库有 logrus、zap、oklog、zerolog 可以考虑选择 JSON 格式的日志，参考 最佳日志实践（v2.0） 一文 关于性能可以参考 Go零消耗debug log技巧，使用官方模块在生产环境中存在性能瓶颈 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:2:0","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"3.参考 [1] 合肥懒皮，简书，Golang log日志，2019.04.09 [2] Go语言标准库文档 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:3:0","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"上篇文章基于 Cookie + Session 实现了简单的用户认证功能，用户认证之后，就可以创建群组和主题了，本篇介绍如何创建群组和主题，并将其渲染到前端页面。 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1. 群组的创建和浏览 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1.1 处理器方法 在 handlers 目录下新增 thread.go 编写群组创建与获取方法： package handlers import ( \"fmt\" \"github.com/xueyuanjun/chitchat/models\" \"net/http\" ) // GET /threads/new // 创建群组页面 func NewThread(writer http.ResponseWriter, request *http.Request) { _, err := session(writer, request) if err != nil { http.Redirect(writer, request, \"/login\", 302) } else { generateHTML(writer, nil, \"layout\", \"auth.navbar\", \"new.thread\") } } // POST /thread/create // 执行群组创建逻辑 func CreateThread(writer http.ResponseWriter, request *http.Request) { sess, err := session(writer, request) if err != nil { http.Redirect(writer, request, \"/login\", 302) } else { err = request.ParseForm() if err != nil { fmt.Println(\"Cannot parse form\") } user, err := sess.User() if err != nil { fmt.Println(\"Cannot get user from session\") } topic := request.PostFormValue(\"topic\") if _, err := user.CreateThread(topic); err != nil { fmt.Println(\"Cannot create thread\") } http.Redirect(writer, request, \"/\", 302) } } // GET /thread/read // 通过 ID 渲染指定群组页面 func ReadThread(writer http.ResponseWriter, request *http.Request) { vals := request.URL.Query() uuid := vals.Get(\"id\") thread, err := models.ThreadByUUID(uuid) if err != nil { fmt.Println(\"Cannot read thread\") } else { _, err := session(writer, request) if err != nil { generateHTML(writer, \u0026thread, \"layout\", \"navbar\", \"thread\") } else { generateHTML(writer, \u0026thread, \"layout\", \"auth.navbar\", \"auth.thread\") } } } 其中定义了三个方法，分别用于渲染群组创建表单页面、处理提交表单执行群组创建逻辑、以及根据指定 ID 渲染对应群组页面。前两个方法需要认证后才能访问，否则将用户重定向到登录页，群组详情页不需要认证即可访问，不过会根据是否认证返回不同的视图模板。 在这里，仍然通过辅助函数 session 判断用户是否认证，其他的业务逻辑也都非常简单，无非是获取表单输入、查询数据库、写入数据库、返回响应视图等操作，后面我们会在介绍处理 HTTP 请求时详细解释其中的细节，这里，我们先了解下全貌即可。 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1.2 视图模板 然后我们需要创建几个新的视图模板，在 views 目录下 new.thread.html 来编写创建群组表单： {{ define \"content\" }} \u003cform role=\"form\" action=\"/thread/create\" method=\"post\"\u003e \u003cdiv class=\"lead\"\u003eStart a new thread with the following topic\u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003ctextarea class=\"form-control\" name=\"topic\" id=\"topic\" placeholder=\"Thread topic here\" rows=\"4\"\u003e\u003c/textarea\u003e \u003cbr/\u003e \u003cbr/\u003e \u003cbutton class=\"btn btn-lg btn-primary pull-right\" type=\"submit\"\u003eStart this thread\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e {{ end }} 然后创建 thread.html 编写未认证情况下渲染的群组详情页视图（其中还包含了对群组主题的遍历和渲染）： {{ define \"content\" }} \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment-o\"\u003e\u003c/i\u003e {{ .Topic }}\u003c/span\u003e \u003cdiv class=\"pull-right\"\u003e Started by {{ .User.Name }} - {{ .CreatedAtDate }} \u003c/div\u003e \u003c/div\u003e {{ range .Posts }} \u003cdiv class=\"panel-body\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment\"\u003e\u003c/i\u003e {{ .Body }}\u003c/span\u003e \u003cdiv class=\"pull-right\"\u003e {{ .User.Name }} - {{ .CreatedAtDate }} \u003c/div\u003e \u003c/div\u003e {{ end }} \u003c/div\u003e {{ end }} 以及 auth.thread.html 编写认证后的群组详情页视图（在未认证视图模板的基础上新增了提交主题的表单区块）： {{ define \"content\" }} \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment-o\"\u003e\u003c/i\u003e {{ .Topic }}\u003c/span\u003e \u003cdiv class=\"pull-right\"\u003e Started by {{ .User.Name }} - {{ .CreatedAtDate }} \u003c/div\u003e \u003c/div\u003e {{ range .Posts }} \u003cdiv class=\"panel-body\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment\"\u003e\u003c/i\u003e {{ .Body }}\u003c/span\u003e \u003cdiv class=\"pull-right\"\u003e {{ .User.Name }} - {{ .CreatedAtDate }} \u003c/div\u003e \u003c/div\u003e {{ end }} \u003c/div\u003e \u003cdiv class=\"panel panel-info\"\u003e \u003cdiv class=\"panel-body\"\u003e \u003cform role=\"form\" action=\"/thread/post\" method=\"post\"\u003e \u003cdiv class=\"form-group\"\u003e \u003ctextarea class=\"form-control\" name=\"body\" id=\"body\" placeholder=\"Write your reply here\" rows=\"3\"\u003e\u003c/textarea\u003e \u003cinput type=\"hidden\" name=\"uuid\" value=\"{{ .Uuid }}\"\u003e \u003cbr/\u003e \u003cbutton class=\"btn btn-primary pull-right\" type=\"submit\"\u003eReply\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1.3 注册路由 最后在 routes/routes.go 中注册群组相关路由： var webRoutes = WebRoutes{ ... // 其他路由 { \"newThread\", \"GET\", \"/thread/new\", handlers.NewThread, }, { \"createThread\", \"POST\", \"/thread/create\", handlers.CreateThread, }, { \"readThread\", \"GET\", \"/thread/read\", handlers.ReadThread, }, } ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1.4 测试群组创建和浏览 这样，我们就完成了在线论坛项目群组创建和浏览的所有相关路由、处理器、视图编码，重新启动 HTTP 服务器，就可以在首页点击「Start a thread」链接创建新的群组了： 如果没有登录，会先跳转到登录页面，登录之后再次点击该链接就可以进入群组创建页面： 我们在输入框中输入群组主题「Golang」并点击右下角提交按钮，就可以成功创建一个新的群组并在首页看到了： ！然后，我们可以点击该群组的「Read more」链接进入群组详情页： 目前还没有任何主题，接下来，我们来编写创建主题的后端处理器方法和路由实现。 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"2. 创建新主题 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"2.1 处理器方法 我们在 handlers 目录下新增 post.go 来存放主题相关处理器方法： package handlers import ( \"fmt\" \"github.com/xueyuanjun/chitchat/models\" \"net/http\" ) // POST /thread/post // 在指定群组下创建新主题 func PostThread(writer http.ResponseWriter, request *http.Request) { sess, err := session(writer, request) if err != nil { http.Redirect(writer, request, \"/login\", 302) } else { err = request.ParseForm() if err != nil { fmt.Println(\"Cannot parse form\") } user, err := sess.User() if err != nil { fmt.Println(\"Cannot get user from session\") } body := request.PostFormValue(\"body\") uuid := request.PostFormValue(\"uuid\") thread, err := models.ThreadByUUID(uuid) if err != nil { fmt.Println(\"Cannot read thread\") } if _, err := user.CreatePost(thread, body); err != nil { fmt.Println(\"Cannot create post\") } url := fmt.Sprint(\"/thread/read?id=\", uuid) http.Redirect(writer, request, url, 302) } } 我们只定义了一个创建主题的处理器方法，在该处理器方法中，仍然会验证用户是否已认证，只有认证用户才能创建主题，我们最后会调用 user.CreatePost 方法根据群组 ID、用户 ID 和主题内容创建新的主题记录，保存成功后，会返回创建该主题的群组详情页，并将与该群组关联的所有主题渲染出来。关于数据库和视图模板引擎的语法细节，后面我们会在对应的独立教程中详细介绍。 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"2.2 注册路由 由于主题没有独立的视图模板，所以我们只需要在路由文件中注册创建主题对应的路由就可以了： { \"postThread\", \"POST\", \"/thread/post\", handlers.PostThread, }, ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"2.3 测试主题创建 再次重启 HTTP 服务器，就可以在之前的群组详情页创建新主题了： 点击「REPLY」按钮提交，页面会刷新并渲染主题内容： 回到论坛首页，你可以看到每个群组下的主题数目： ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"上篇演示了首页路由、处理器、视图模板的实现，接着就要实现群组、主题的增删查改，不过，需要在认证后才能执行这些操作，所以本篇介绍如何实现用户认证相关功能。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"1. 全局辅助函数 我们先在 handlers 目录下创建一个 helper.go 文件，用于定义一些全局辅助函数（主要用在处理器中）： package handlers import ( \"errors\" \"fmt\" \"github.com/xueyuanjun/chitchat/models\" \"html/template\" \"net/http\" ) // 通过 Cookie 判断用户是否已登录 func session(writer http.ResponseWriter, request *http.Request) (sess models.Session, err error) { cookie, err := request.Cookie(\"_cookie\") if err == nil { sess = models.Session{Uuid: cookie.Value} if ok, _ := sess.Check(); !ok { err = errors.New(\"Invalid session\") } } return } // 解析 HTML 模板（应对需要传入多个模板文件的情况，避免重复编写模板代码） func parseTemplateFiles(filenames ...string) (t *template.Template) { var files []string t = template.New(\"layout\") for _, file := range filenames { files = append(files, fmt.Sprintf(\"views/%s.html\", file)) } t = template.Must(t.ParseFiles(files...)) return } // 生成响应 HTML func generateHTML(writer http.ResponseWriter, data interface{}, filenames ...string) { var files []string for _, file := range filenames { files = append(files, fmt.Sprintf(\"views/%s.html\", file)) } templates := template.Must(template.ParseFiles(files...)) templates.ExecuteTemplate(writer, \"layout\", data) } // 返回版本号 func Version() string { return \"0.1\" } 目前提供了版本信息，判断用户是否登录，HTML 模板的解析与生成等逻辑，我们将 HTML 模板解析与生成逻辑提取出来，主要是为了避免重复编写类似的模板代码，比如现在，我们可以将 handlers/index.go 中的 Index 方法改写如下： func Index(w http.ResponseWriter, r *http.Request) { threads, err := models.Threads(); if err == nil { generateHTML(w, threads, \"layout\", \"navbar\", \"index\") } } 是不是看起来简单多了，更重要的是提高了代码的复用性。 在 session 函数中，通过从请求中获取指定 Cookie 字段里面存放的 Session ID，然后从 Session 存储器（这里存储驱动是数据库）查询对应 Session 是否存在来判断用户是否已认证，如果已认证则返回的 sess 不为空。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2. 用户认证相关处理器 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2.1 编写处理器代码 接下来，在 handlers 目录下创建一个 auth.go 来存放用户认证相关处理器： package handlers import ( \"fmt\" \"github.com/xueyuanjun/chitchat/models\" \"net/http\" ) // GET /login // 登录页面 func Login(writer http.ResponseWriter, request *http.Request) { t := parseTemplateFiles(\"auth.layout\", \"navbar\", \"login\") t.Execute(writer, nil) } // GET /signup // 注册页面 func Signup(writer http.ResponseWriter, request *http.Request) { generateHTML(writer, nil, \"auth.layout\", \"navbar\", \"signup\") } // POST /signup // 注册新用户 func SignupAccount(writer http.ResponseWriter, request *http.Request) { err := request.ParseForm() if err != nil { fmt.Println(\"Cannot parse form\") } user := models.User{ Name: request.PostFormValue(\"name\"), Email: request.PostFormValue(\"email\"), Password: request.PostFormValue(\"password\"), } if err := user.Create(); err != nil { fmt.Println(\"Cannot create user\") } http.Redirect(writer, request, \"/login\", 302) } // POST /authenticate // 通过邮箱和密码字段对用户进行认证 func Authenticate(writer http.ResponseWriter, request *http.Request) { err := request.ParseForm() user, err := models.UserByEmail(request.PostFormValue(\"email\")) if err != nil { fmt.Println(\"Cannot find user\") } if user.Password == models.Encrypt(request.PostFormValue(\"password\")) { session, err := user.CreateSession() if err != nil { fmt.Println(\"Cannot create session\") } cookie := http.Cookie{ Name: \"_cookie\", Value: session.Uuid, HttpOnly: true, } http.SetCookie(writer, \u0026cookie) http.Redirect(writer, request, \"/\", 302) } else { http.Redirect(writer, request, \"/login\", 302) } } // GET /logout // 用户退出 func Logout(writer http.ResponseWriter, request *http.Request) { cookie, err := request.Cookie(\"_cookie\") if err != http.ErrNoCookie { fmt.Println(\"Failed to get cookie\") session := models.Session{Uuid: cookie.Value} session.DeleteByUUID() } http.Redirect(writer, request, \"/\", 302) } 上述代码中定义了用户注册、登录、退出相关业务逻辑，非常简单，和 Laravel 认证脚手架生成的默认认证相关控制器非常相似。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2.2 用户注册 用户注册逻辑比较简单，无非是填写注册表单（Signup 处理器方法），提交注册按钮将用户信息保存到数据库（SignupAccount 处理器方法）。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2.3 用户登录 接下来，服务端会将用户重定向到登录页面（Login 处理器方法），用户填写登录表单后，就可以通过 Authenticate 处理器方法执行认证操作。 用户认证是基于 Cookie + Session 实现的，Session 的数据结构如下所示： type Session struct { Id int Uuid string Email string UserId int CreatedAt time.Time } 通过 Uuid 字段可以唯一标识这个 Session，因此可以看作是对外可见的全局 Session ID，在客户端 Cookie 存储的 Session ID 也是这个 Uuid。当用户认证成功之后，就会创建 Session，有了 Session 之后，就可以创建 Cookie 并写到响应中： cookie := http.Cookie{ Name: \"_cookie\", Value: session.Uuid, HttpOnly: true, } http.SetCookie(writer, \u0026cookie) 这样，下次用户访问在线论坛页面就会在请求头中带上包含 Session ID 的 Cookie，服务端通过解析这个 Uuid 并查询 Session 存储器（这里存储驱动是数据库）判断该用户 Session 是否存在，如果存在则用户认证通过，也就是前面辅助函数 session 所做的事情。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2.3 用户退出 上述 Cookie 未设置过期时间，所以生命周期和 Session 一致，当浏览器关闭时，Cookie 就自动删除，下次打开浏览器需要重新认证。 最后用户退出处理器方法 Logout 方法则是方便用户主动退出，当用户点击退出按钮，可以执行该处理器方法销毁当前用户 Session 和认证 Cookie，并将用户重定向到首页。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"3. 用户认证相关视图模板 定义好认证处理器后，我们来编写与认证相关的视图模板，主要是登录页面和注册页面，在 views 目录下新增 login.html 编写登录页面： {{ define \"content\" }} \u003cform class=\"form-signin center\" role=\"form\" action=\"/authenticate\" method=\"post\"\u003e \u003ch2 class=\"form-signin-heading\"\u003e \u003ci class=\"fa fa-comments-o\"\u003e ChitChat \u003c/i\u003e \u003c/h2\u003e \u003cinput type=\"email\" name=\"email\" class=\"form-control\" placeholder=\"Email address\" required autofocus\u003e \u003cinput type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" required\u003e \u003cbr/\u003e \u003cbutton class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"\u003eSign in\u003c/button\u003e \u003cbr/\u003e \u003ca class=\"lead pull-right\" href=\"/signup\"\u003eSign up\u003c/a\u003e \u003c/form\u003e {{ end }} 然后创建 signup.html 编写注册页面： {{ define \"content\" }} \u003cform class=\"form-signin\" role=\"form\" action=\"/signup_account\" method=\"post\"\u003e \u003ch2 class=\"form-signin-heading\"\u003e \u003ci class=\"fa fa-comments-o\"\u003e ChitChat \u003c/i\u003e \u003c/h2\u003e \u003cdiv class=\"lead\"\u003eSign up for an account below\u003c/div\u003e \u003cinput id=\"name\" type=\"text\" name=\"name\" class=\"form-control\" placeholder=\"Name\" required autofocus\u003e \u003cinput type=\"email\" name=\"email\" class=\"form-control\" placeholder=\"Email address\" required\u003e \u003cinput type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" required\u003e \u003cbutton class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"\u003eSign up\u003c/button\u003e \u003c/form\u003e {{ end }} 此外，我们还为登录和注册页面定义了单独的布局模板 auth.layout.html： {{ define \"layout\" }} \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003eChitChat\u003c/title\u003e \u003clink href=\"/static/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"/static/css/font-awesome.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"/static/css/login.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e {{ template \"content\" . }} \u003c/div\u003e \u003c!--/container --\u003e \u003cscript src=\"/static/js/jquery-2.1.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/static/js/bootstrap.min.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e {{ end }} 以上视图模板已经在认证处理器方法中引用。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"4. 注册用户认证路由 最后，我们需要在 routes/routes.go 中注册用户认证相关路由： // 定义所有 Web 路由 var webRoutes = WebRoutes{ ... // 其他路由 { \"signup\", \"GET\", \"/signup\", handlers.Signup, }, { \"signupAccount\", \"POST\", \"/signup_account\", handlers.SignupAccount, }, { \"login\", \"GET\", \"/login\", handlers.Login, }, { \"auth\", \"POST\", \"/authenticate\", handlers.Authenticate, }, { \"logout\", \"GET\", \"/logout\", handlers.Logout, }, } ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"5. 测试用户认证功能 这样一来，我们就可以重启应用并访问用户注册页面 http://localhost:8080/signup 进行注册了： 注册成功后，页面会跳转到登录页面 http://localhost:8080/login： 输入刚才填写的注册邮箱和密码，点击「SIGN IN」按钮登录成功后，页面跳转到首页。 我们还没有对首页做额外的认证判断和处理，所以此时显示的页面效果和之前一样，为了区别用户认证与未认证状态，我们可以基于认证状态渲染不同的导航模板，对于认证用户，渲染 auth.navbar 模板，对于未认证用户，还是保持和之前一样，为此，我们需要在 views 目录下新增 auth.navbar.html 视图： {{ define \"navbar\" }} \u003cdiv class=\"navbar navbar-default navbar-static-top\" role=\"navigation\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"navbar-header\"\u003e \u003cbutton type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"\u003e \u003cspan class=\"sr-only\"\u003eToggle navigation\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003c/button\u003e \u003ca class=\"navbar-brand\" href=\"/\"\u003e \u003ci class=\"fa fa-comments-o\"\u003e\u003c/i\u003e ChitChat \u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"navbar-collapse collapse\"\u003e \u003cul class=\"nav navbar-nav\"\u003e \u003cli\u003e\u003ca href=\"/\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"nav navbar-nav navbar-right\"\u003e \u003cli\u003e\u003ca href=\"/logout\"\u003eLogout\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} 同时还要修改 handlers.Index 处理器方法实现： func Index(writer http.ResponseWriter, request *http.Request) { threads, err := models.Threads(); if err == nil { _, err := session(writer, request) if err != nil { generateHTML(writer, threads, \"layout\", \"navbar\", \"index\") } else { generateHTML(writer, threads, \"layout\", \"auth.navbar\", \"index\") } } } 再次重启应用，刷新首页，导航条的展示效果就不一样了： 此时显示的是「Logout」链接，点击即可退出应用： ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:5:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"关于 Cookie 的使用是 Web 编程中的重要一部分，本篇介绍 Cookie 的基本知识和 Golang 中使用的方法。 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:0:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"1. 使用Cookie来管理状态 HTTP 是无状态协议，不记录之前发生过的请求和响应，也因此无法根据历史状态信息处理当前请求。但假设我们正在浏览淘宝，然后在首页进行了登录，点击并跳转到商品页面时，因为 HTTP 的无状态特性，就需要重新进行登录，这带来了诸多不便。 不可否认，无状态协议有它的优点，由于不必保存状态，减少了服务器的 CPU 及内存资源消耗，同时也因为协议足够简单，才可以用到各种场景中。那么如何解决逛淘宝这种需要记录历史信息的场景呢，这里就用到 Cookie 技术。 Cookie 技术通过在 HTTP 请求和响应报文中写入 Cookie 信息来控制客户端的状态。首先，服务端在发送的响应报文内添加一个叫做 Set-Cookie 的首部字段信息，客户端接收到后会保存 Cookie。当下次客户端向服务器发送请求时，就会自动在请求报文中加入保存的 Cookie 值。服务器发现客户端发送过来的 Cookie 后，会检查究竟是哪个客户端发来的连接请求，然后对比服务器上的数据，得到之前的状态信息。过程如下图所示（图源为《图解HTTP》） 所以 Cookie 的实质是 HTTP 请求与响应报文中的一个首部字段信息，下面给出一些报文示例： 请求报文（没有 Cookie 信息时的状态） GET /reader/ HTTP/1.1 Host: hackr.jp *首部字段内没有Cookie的相关信息 响应报文（服务器端生成 Cookie 信息） HTTP/1.1 200 OK Date: Thu, 12 Jul 2012 07:12:20 GMT Server: Apache ＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞ Content-Type: text/plain; charset=UTF-8 请求报文（自动发送保存的 Cookie 信息） GET /image/ HTTP/1.1 Host: hackr.jp Cookie: sid=1342077140226724 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:1:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"2. 关于Cookie的首部字段 关于 Cookie 的相关说明没有被编入标准化 HTTP/1.1 的RFC2516中，下面介绍的是使用最广泛的 Cookie 标准。 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的Cookie信息 响应首部字段 Cookie 服务器接收到的Cookie信息 请求首部字段 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:2:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"2.1 Set-Cookie Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; ⇒ path=/; domain=.hackr.jp; 当服务器准备开始管理客户端的状态时，会事先告知各种信息。下面的表格列举了Set-Cookie 的字段值。 属性 说明 NAME=VALUE 赋予Cookie的名称和其值（必须项） expires=DATE Cookie的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器域名） Secure 仅在HTTPS安全通信时才会发送Cookie HttpOnly 加以限制，使Cookie不能被JavaScript脚本访问 expires属性：有两种方法来设置过期时间：一种是直接设置 Expires 字段，一种是设置 MaxAge 字段。前者表示到期的具体时间点，后者表示 Cookie 的有效时长（单位是秒）。这并不是 Go 语言的设计，而是不同浏览器的混乱标准使然，比如虽然 HTTP/1.1 有意废弃 Expires，不过 IE 6、7、8 却不支持 MaxAge 字段。通常，考虑到默认时区问题，本地时间不可靠，推荐通过 MaxAge 字段设置 Cookie 过期时间，不过对于 Web 应用而言，通常不设置过期时间，让 Cookie 随着浏览器关闭而失效即可。 domain属性：domain 属性指定的域名可做到与结尾匹配一致，比如，当指定 example.com 后，除 example.com 本身外，www.example.com 或 www2.example.com 等都可以发送 Cookie，所以，除了针对具体指定的多个域名发送Cookie之外，不指定domain属性显得更安全 secure属性：指定 secure 属性的方法为 Set-Cookie: name=value; secure HttpOnly属性：指定 HttpOnly 属性的方法为 Set-Cookie: name=value; HttpOnly ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:2:1","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"2.2 Cookie Cookie: status=enable 在请求报文中添加该字段后，就相当于告诉服务器客户端想要获得 HTTP 状态管理支持。接收到多个Cookie时，同样可以以多个Cookie形式发送。 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:2:2","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"3. Session 管理 某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见，为达到这个目标，需要添加认证功能。HTTP/1.1 实用的认证包括 BASIC认证、DIGEST认证、SSL客户端认证、FormBase认证等，由于使用上的便利性和安全性问题，前两种几乎不适用，SSL客户端认证则由于导入及费用问题未得到普及，目前常用的是最后一种：基于表单的认证。 基于表单的认证方法并不是在HTTP协议中定义的，而是由客户端通过表单向服务器提交登录信息，然后由服务器安装自定义的实现方式进行验证，不同的应用使用的验证方式多有不同，但多数情况下，是基于用户输入的用户ID（通常是任意字符串或邮件地址）和密码等登录信息进行认证。 鉴于 HTTP 是无状态协议，之前已认证成功额用户状态无法保留，因此一般使用 Cookie 来管理 Session(会话)。 如上图所示，基本的步骤为 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID（如PHPSESSID=028a8c…）。你可以把Session ID想象成一种用以区分不同用户的等位号。然而，如果Session ID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性。 客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。 需要注意，上述介绍并不是唯一的实现方式，实际上，不仅基于表单认证的登录信息及认证过程没有标准化，服务端如何保持密码等登录信息也没有标准化。通常，一种安全的保存方法是，先利用给密码加盐（salt）的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险。 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:3:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"4. Go中Cookie的设置与读取 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:4:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"4.1 设置Cookie Go语言中通过 net/http 包中的 SetCookie 来设置 Cookie： http.SetCookie(w ResponseWriter, cookie *Cookie) w 表示需要写入的 response，cookie 是一个 struct，让我们来看看对象是怎样的： type Cookie str、uct { Name string Value string Path string Domain string Expires time.Time RawExpires string // MaxAge=0 意味着没有指定 Max-Age 的值 // MaxAge\u003c0 意味着现在就删除 Cookie，等价于 Max-Age=0 // MaxAge\u003e0 意味着 Max-Age 属性存在并以秒为单位存在 MaxAge int Secure bool HttpOnly bool Raw string Unparsed []string // 未解析的 attribute-value 属性位对 } 下面来看一个如何设置 Cookie 的例子： expiration := time.Now() expiration := expiration.AddDate(1, 0, 0) cookie := http.Cookie{ Name: \"username\", Value: \"zuolan\", Expires: expiration } http.SetCookie(writer, \u0026Cookie) ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:4:1","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"4.2 读取 Cookie 上面的例子演示了如何设置 Cookie 数据，这里演示如何读取 Cookie： cookie, _ := r.Cookie(\"username\") fmt.Fprint(w, cookie) 还有另外一种读取方式： for _, cookie := range r.Cookies() { fmt.Fprint(w, cookie.Name) } 可以看到通过 request 获取 Cookie 非常方便。 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:4:2","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"参考 上野宣[日]，图解HTTP，人民邮电出版社，2014 学院君，在 Go 语言中设置、读取和删除 HTTP Cookie，2020 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:5:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["研究生的区块链学习之路"],"content":"我们对之前的实验流程做了进一步的优化，并且对添加恶意行为检测后的系统进行了进一步的性能测试。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:0:0","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"1. 实验流程优化 上一次实验我们搭建 Quorum 私链网络是采用从零开始的方式，从 genesis.json 文件开始，手动编辑配置文件、创建节点、最后组建网络，不仅耗费时间，而且一旦错误就要重新开始，浪费了大量无意义的精力。另外，我们还需要一个区块链浏览器可视化网络、区块、交易和合约的状态，与智能合约的交互也需要优化，虽然 Truffle 集成了合约的部署和测试工作，但依然存在一些不足，国内也无法使用 truffle init 命令。 针对以上问题，结合 Quorum 社区的最新进展，我们本次调整了实验方案所使用的工具和手段： 使用 Quorum Wizard 命令行工具快速建立 Quorum 网络； 使用 Cakeshop 可视化区块链和智能合约状态； 使用 Remix + Quorum Plugin for Remix 的组合部署合约及与合约交互； 最后，我们对一些注意事项进行说明： Quourm Wizard 建立网络有 Bash 、 Docker-compse 和 kubernete 三种可选方式，我们使用第一种，但会尝试一下第二种； 之前在树莓派中建立区块链账户表示物联网网络和设备，但树莓派放在了实验室，由于疫情原因无法拿到手，因此本次建立一个 7 节点的私链网络，挑选一个节点代表物联网网关，然后建立一个新的账户表示设备，从而进行实验。 最后，确定本次方案时还有一些备选方案，比如 Epirus-free 也是一个可用的 Quorum 区块链浏览器，但结构比较简单，展示的参数也比较少，而且我们测试的时候迟迟无法加载出来数据，因此不选用。 quorum-maker 是一个一体化方案，可以快速建立基于 Docker 的 Quorum 网络，并提供一个区块链浏览器查看区块链和合约状态，各方面的功能都足够晚上，唯一的问题是对 IBFT 共识的支持还处在开发阶段，暂时不可用，因此我们只能选择上述多个工具组合的方法完成本次实验。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:1:0","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 环境准备 Win10 Home Edition 不支持 Docker，且实验中涉及的组件比较多，我们决定使用虚拟机来启动一个 Linux 环境。另外，方案中的几个工具对依赖的要求如下： Quorum Wizard： 基于 Bash 建立网络：如果需要隐私管理器，需要 Java 环境 基于 Docker Compse：需要 Docker 和 docker-compose 基于 Kubernetes：需要 Docker、kubectl 和 minikube Cakeshop：需要 Java 8+ 及 Node.js Geth 提供了接口供 Golang 使用来进行账户管理和合约监听，因为实验测试有可能用到，我们安装 Golang 根据说明，我们开始准备实验环境 安装 VMware Workstation 15 Pro，输入批量许可激活，建立 Ubuntu20.04 系统的虚拟机，分配内存 4G（有条件应为8G，这里是因为电脑配置比较低，一共只有8G，再多发生内存交换的概率比较大）、硬盘100GB。 进入 Ubuntu 20.04，更新系统，设置语言 安装git、golang、Java # 安装git $ sudo apt install -y git $ git version git version 2.25.1 # 安装golang $ sudo apt install -y golang $ go version go version go1.14.4 linux/amd64 # 安装 JRE $ sudo apt install default-jre $ java -version openjdk version \"11.0.7\" 2020-04-14 OpenJDK Runtime Environment (build 11.0.7+10-post-Ubuntu-3ubuntu1) OpenJDK 64-Bit Server VM (build 11.0.7+10-post-Ubuntu-3ubuntu1, mixed mode, sharing) # 安装JDK $ sudo apt install default-jdk $ javac -version javac 11.0.7 安装 Node 和 npm，由于直接安装后在使用 npm 全局安装包时会出现权限错误，因此使用 Node.js 版本管理工具 n $ sudo apt install curl $ curl -L https://git.io/n-install | bash # 重启终端 $ n lts installing : node-v12.18.0 mkdir : /home/shuzang/n/n/versions/node/12.18.0 fetch : https://nodejs.org/dist/v12.18.0/node-v12.18.0-linux-x64.tar.xz installed : v12.18.0 (with npm 6.14.4) # 更新 npm 到最新，顺便测试全局安装 $ npm install -g npm@latest /home/shuzang/n/bin/npm -\u003e /home/shuzang/n/lib/node_modules/npm/bin/npm-cli.js /home/shuzang/n/bin/npx -\u003e /home/shuzang/n/lib/node_modules/npm/bin/npx-cli.js + npm@6.14.5 updated 5 packages in 16.718s （可选）docker 和 docker-compose # 安装 docker CE $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun # 启动 docker CE $ sudo systemctl enable docker $ sudo systemctl start docker # 建立 docker 用户组并将当前用户加入 docker 组，这样就不需要 root 权限了 $ sudo groupadd docker $ sudo usermod -aG docker $USER # 测试安装 $ docker run hello-world # 安装 docker-compose $ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` \u003e /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:1:1","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 建立测试网络 全局安装 quorum-wizard $ npm install -g quorum-wizard 运行向导，建立测试网络，-v 参数用于输出日志记录。 $ quorum-wizard -v ... Welcome to Quorum Wizard! This tool allows you to easily create bash, docker, and kubernetes files to star t up a quorum network. You can control consensus, privacy, network details and more for a customized se tup. Additionally you can choose to deploy our chain explorer, Cakeshop, to easily vi ew and monitor your network. ? Welcome to Quorum Wizard! This tool allows you to easily create bash, docker, and kubernetes files to star t up a quorum network. You can control consensus, privacy, network details and more for a customized se tup. Additionally you can choose to deploy our chain explorer, Cakeshop, to easily vi ew and monitor your network. ? Welcome to Quorum Wizard! This tool allows you to easily create bash, docker, and kubernetes files to star t up a quorum network. You can control consensus, privacy, network details and more for a customized se tup. Additionally you can choose to deploy our chain explorer, Cakeshop, to easily vi ew and monitor your network. We have 3 options to help you start exploring Quorum: 1. Quickstart - our 1 click option to create a 3 node raft network with tesse ra and cakeshop 2. Simple Network - using pregenerated keys from quorum 7nodes example, this option allows you to choose the number of nodes (7 max), consensus me chanism, transaction manager, and the option to deploy cakeshop 3. Custom Network - In addition to the options available in #2, this selectio n allows for further customization of your network. Choose to generate keys, customize ports for both bash and docker, or chan ge the network id Quorum Wizard will generate your startup files and everything required to bring up your network. All you need to do is go to the specified location and run ./start.sh Simple Network ? Would you like to generate bash scripts, a docker-compose file, or a kubernete s config to bring up your network? bash ? Select your consensus mode - istanbul is a pbft inspired algorithm with transa ction finality while raft provides faster blocktimes, transaction finality and o n-demand block creation istanbul ? Input the number of nodes (2-7) you would like in your network - a minimum of 4 is recommended 4 ? Which version of Quorum would you like to use? Quorum 2.6.0 ? Choose a version of tessera if you would like to use private transactions in y our network, otherwise choose \"none\" Tessera 0.10.5 ? Do you want to run Cakeshop (our chain explorer) with your network? Yes ? What would you like to call this network? 4-nodes-istanbul-tessera-bash ... Building network directory... Generating network resources locally... Building qdata directory... Writing start script... Initializing quorum... Done -------------------------------------------------------------------------------- Tessera Node 1 public key: BULeR8JyUWhiuuCMU/HLA0Q5pzkYT+cHII3ZKBey3Bo= Tessera Node 2 public key: QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc= Tessera Node 3 public key: 1iTZde/ndBHvzhcl7V68x44Vx7pl8nwx9LqnM/AfJUg= Tessera Node 4 public key: oNspPPgszVUFw0qmGFfWwh1uxVUXgvBxleXORHj07g8= -------------------------------------------------------------------------------- Quorum network created Run the following commands to start your network: cd network/4-nodes-istanbul-bash ./start.sh A sample simpleStorage contract is provided to deploy to your network To use run ./runscript.sh public-contract.js from the network folder A private simpleStorage contract was created with privateFor set to use Node 2's public key: QfeDAys9MPDs2XHExtc84jKGHxZg/aj52DTh0vtA3Xc= To use run ./runscript private-contract.js from the network folder 在向导执行页面选择了运行 Cakeshop 的情况下，不需要自己再去安装 Cakeshop，可以直接启动。 $ cd network/4-nodes-istanbul-bash $ ./start.sh Starting Quorum network... Waiting until all Tessera nodes are running... ... All Tessera nodes started Starting Quorum nodes Starting Cakeshop Waiting until Cakeshop is running... ... Cakeshop started at http://localh","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:1:2","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"1.3 Remix 部署和交互说明 浏览器打开 Remix IDE （保证是 http 页面），点击左侧 Plugins（插件）标签页，搜索 Quorum Network，点击 Activate 激活插件。 在左侧标签栏寻找激活的插件，图标为 我们上面运行的网络各节点的 url 分别为 节点 url Node1 Quorum RPC：http://localhost:22000 Tessera：http://localhost:9081 Node2 Quorum RPC：http://localhost:22001 Tessera：http://localhost:9082 Node3 Quorum RPC：http://localhost:22002Tessera：http://localhost:9083 Node4 Quorum RPC：http://localhost:22003Tessera：http://localhost:9084 输入 Node1 的 Quroum RPC 和 Tessera 的 url，点击确认，得到如下的侧面板 从 Github 导入我们的合约 Quorum-Remix 插件使用 Remix 的 Solidity 编译器的结果，所以在 Remix 编译后的合约可以在Quorum插件的 Compiled Contracts 选项下找到，到时候输入参数点击部署即可，操作与 Remix 原本的 Deploy 选项卡完全一致。 最后，运行 .stop.sh 脚本可以停止所有的 quorum/geth 和 cakeshop 实例。 如果我们编写了交互用的 js 脚本，假设脚本名为 test.js，可以使用如下命令执行 $ ./runscript.sh test.js 有输入参数的情况下，可以使用 Bash 、Python 或 Go 有选择的批量执行脚本。 值得注意到是，我们上述没有使用隐私管理器，但这是 Quorum 的一个最重要的特性。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:1:3","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"1.4 错误排查记录 2020.06.08 Remix 无法显示所有插件，因此无法使用 Quorum Network 插件连接 Quorum 网络，经排查，为网络原因，连接手机开的热点后即可看到所有插件，深层原因未知。 2020.06.09 合约编译返回错误 Uncaught JavaScript exception: RangeError: Maximum call stack size exceeded. 调用栈溢出，猜测可能是虚拟机内存分配不足，在宿主机中使用 Remix 通过局域网 IP 地址连接 宿主机浏览器无法访问 http 连接，换用 Firefox 或者使用 Remix-IDE 桌面版本都无法访问 考虑到此时 Remix 与 后台 Quorum 网络拆分，尝试使用 WSL 子系统，并使用 npm 安装 remix-ide WSL 对 npm 支持不友好，普通用户和 root 用户权限全部被拒绝，所有包都无法安装 尝试在 win10 本地使用 npm 安装 remix，依赖过多，安装无法完成 重新尝试解决 win10 系统下无法访问 http 网页的错误，关闭防火墙不起作用，恢复 hosts 文件起作用，经确认，无法访问 http 网页是因为 hosts 文件被修改 重新尝试虚拟机的 Ubuntu 系统编译智能合约，Chrome 浏览器失败，Firefox 浏览器成功，确认不是因为内存分配不足。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:1:4","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"2. 性能测试 根据上篇最后一小节的分析，性能测试分为三部分：隐私合约及交易测试，访问控制系统测试和恶意行为检测部分的测试。 性能测试的指标如下所述： 访问控制系统 合约部署和重要操作的Gas 消耗：Gas 消耗可以通过 Remix 测试的时候获取，虽然对于 Quorum 而言，Gas 消耗并无太大意义，因为并不会真正消耗掉，而是会被返还，但对于大多数基于以太坊的方案来说，Gas 消耗意味着实际的金钱消耗。另一方面，Gas 消耗一定程度上能反映合约的体积。 一些重要的合约交互需要的时间：当然，首先我们应当确定，测量得到的时间中，是合约执行的时间占主要地位，还是区块链网络的同步时间占主要地位，只有前者得到的结果具有实际的意义。 属性及策略的增加对访问时间产生的影响。由于访问决策的逻辑，对策略的判断基本是遍历的方式，这意味着属性和策略的增加可能会使访问时间延长，我们应测量并讨论这一影响的后果及与其它方案的比较。 不同的方案对区块链造成的存储压力。由于方案设计的不同，区块链受到的存储压力不同。即，有些方案需要部署更多的合约，存储更多的数据，从而导致区块链的快速增长。我们需要测量完成同样多的访问不同方案的区块链增长速度，一个可度量的参数是单位时间增加的区块数。 不同方案的吞吐量。实际上，吞吐量更大程度上受区块链选择的影响，不过可以作为我们的一个测量方向。 恶意行为检测 需要验证奖励、惩罚、容忍、报警四大功能。 惩罚就是阻塞时间到期之前不允许方案，是一个功能测试；奖励和容忍是一体的，由于奖励的存在，某些不太重要的恶意行为可以被容忍而不会触发惩罚；报警是触发恶意行为时及时向管理员反馈，只要持续检测合约发送的事件即可。 我们可以得到的数据值包括：某个行为发生的时间、行为描述、信誉值（包括奖励和惩罚两部分都可以知道）、做出惩罚的时间、惩罚计算出的阻塞时间大小。我们可以得到以下结果 信誉值随时间的变化； 检测到恶意行为的概率（与容忍相关）； 阻塞时间的变化； 同样多的请求，恶意行为被阻止的百分比； 恶意行为检测需要大量的输入，包括访问控制系统中各种不同类型的行为，各行为产生的时间等，但是，还有一些注意事项： 实际环境中，不同的行为产生的概率可能不一致，例如更新操作多一点，而注册和删除操作少一点，访问操作最多等； 不同的行为间有先后关系，例如，更新、删除操作都必须在注册操作之后，访问操作也需要测量所依赖的属性已存在； 新增、更新或删除的属性或策略，可能会影响访问结果； 访问时间的随机性会决定「短时间频繁请求」这一恶意行为是否会产生； 我们将输入参数定义为一个文件，文件包括两列，第一列是行为产生的时间（应当随机产生），第二列是行为类型，根据行为类型的不同调用不同的脚本，从而完成这一行为。 对上述注意事项的解决办法是： 访问允许或拒绝依赖于已定义的属性和策略，这些属性和策略恒定不会被更新和删除，而所有新的新增、更新、删除操作是额外的； 如果某种行为产生时依赖的属性或策略不存在，比如更新时发现属性还未定义，那么跳过它执行下一个行为； 不同行为以等概率的方式随机生成； 我们以生成时间间隔的方式产生随机的时间； ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:2:0","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 隐私功能测试 隐私合约及交易是 Quorum 自带的功能，本身不是我们实现的，因此测试只是验证该功能是否启用。合约的部署与交互使用了 Quorum for Remix 插件，该插件在 Remix 的插件列表中可以找到。测试用的合约如下 pragma solidity ^0.5.4; contract SimpleStorage { uint storedData; event Change(string message, uint newVal); constructor(uint initVal) public { emit Change(\"initialized\", initVal); storedData = initVal; } function set(uint x) public { emit Change(\"set\", x); storedData = x; } function get() view public returns (uint retVal) { return storedData; } } 我们令Node2 代表农场，Node3 代表超市，假设农场部署了一个私有存储合约，状态只能被超市查看。农场部署合约传入一个初始值 50，理论上，Node2 和 Node3 可以通过调用 get() 函数获取到该数据，其它的节点无法查看该数据。 因此我们分别进入 Node3（超市） 和 Node4 的 Geth console 进行验证，如下图所示，左侧是 Node3，可以查看合约状态并获取数据，右边是 Node4，无法查看合约状态，也无法获得数据。 从 Cakeshop 区块链浏览器可以更清楚地看到两种情况 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:2:1","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 访问控制时间测试 主要测试参数为完成一次访问控制的时间，期间我们要确认信誉系统的加入是否对访问控制时间有影响，以及不同的访问控制方案是否对时间有影响。 2.2.1 测试准备 第一部分隐私功能测试时使用了 Quorum for Remix 插件，由于该插件在 Remix 中无法返回执行结果，在非隐私交易时不具备优势，因此访问控制系统时间测量的预准备工作，包括合约部署和交互，使用了 Remix 自己提供的 Deploy and Run 插件，主要利用 Web3 Provider 来连接 Quorum 网络进行操作。连接端口在 geth 启动时已默认打开，我们使用的三个节点对应的 Web3 端口如下 Node1：22000 Node2：22001 Node3：22002 另外，我们单独安装 Web3.js 并编写 JS 代码来进行访问控制 # 在用户根目录建立web3文件夹 $ mdkir web3 $ cd web3 # 在web3文件夹中本地安装 web3 1.2.8 版本，之前的版本有些依赖不再维护，安装会出错 $ npm install web3@1.2.8 为了获取足够样本进行分析，我们要进行大量的访问控制测试并获取每次的访问控制时间，先后使用的方案有三种，我们会阐述前两种方案不可行的原因 在 JS 脚本中设立循环，使用 setInterval() 函数延时固定的时间发起访问控制，得到的结果中，初次访问控制的时间为 10ms 左右，其后迅速减少，在 1ms 和 2ms 左右浮动。查询后发现，Javascript 中 setInterval 函数的实质是每隔一段时间向任务队列中添加回调函数，开始执行的时间是不确定的，最后导致了时间统计的不确定性。 使用 Shell 脚本编写循环，在循环中调用 JS 代码，然后使用 sleep 函数设置延时，访问时间的获取是通过 Javascript Date 对象的 getTime 方法，在发起访问控制前获取了一次时间，在获得结果后获取了第二次时间，然后求其差值。最后得到的结果发现，访问控制时间受发起访问的时机影响，呈周期性波动，也受 CPU 占用率的影响，占用率越高时间越短，显然这一结果是不合理的。关于这一次尝试的结果，可以查看第 2.5 节。 使用 Linux time 命令获取执行时间，我们猜测周期性的出现是系统中其它进程的影响，为了排除它们的影响，我们使用了 Linux 的 time 命令。当测试一个程序或比较不同算法时，执行时间是非常重要的，一个好的算法应该是用时最短的。所有类UNIX系统都包含time命令，使用这个命令可以统计时间消耗。例如： [root@localhost ~]# time ls anaconda-ks.cfg install.log install.log.syslog satools text real 0m0.009s user 0m0.002s sys 0m0.007s 输出的信息分别显示了该命令所花费的real时间、user时间和sys时间。 real时间是指挂钟时间，也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。 user时间是指进程花费在用户模式中的CPU时间，这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。 sys时间是指花费在内核模式中的CPU时间，代表在内核中执系统调用所花费的时间，这也是真正由进程使用的CPU时间。 shell内建也有一个time命令，当运行time时候是调用的系统内建命令，应为系统内建的功能有限，所以需要时间其他功能需要使用time命令可执行二进制文件/usr/bin/time。所以我们使用 /usr/bin/time 获取执行访问控制的时间，然后计算 user 和 sys 的和，得到的结果就是访问控制实际执行所花费的 CPU时间。 参考：Linux time命令 我们首先建立 xtime 文件(无后缀)，将如下内容写入 #!/bin/sh /usr/bin/time -f '%Uu %Ss %er %P' \"$@\" -f 参数用于指定输出格式，-f 后面的几个参数说明如下 参数 描述 %e real时间 %U user时间 %S sys时间 %P 进程所获取的CPU时间百分百，这个值等于user+system时间除以总共的运行时间。 然后建立 shell 脚本，命名为 runscript.sh，内容为 #!/bin/bash for ((i=1;i\u003c=500;i++)); do ./xtime node requester_legal.js sleep 5 done 其中，requester_legal.js 是完成访问控制的 JS 文件，接下来授予 xtime 和 runscript.sh 执行权限 $ chmod 777 xtime $ chmod 777 runscript.sh 执行 Shell 脚本之前，我们需要先解锁发起访问的账户，由于我们会一次性进行 500 次测试，每次间隔 5 s，因此一次性将账户解锁 2500s 以上，这里我们设置 4000s。解锁相应账户的命令如下，第二个参数为密码，第三个参数为时间。 \u003e personal.unlockAccount(eth.accounts[0],\"\",4000) \u003e personal.unlockAccount(eth.accounts[1],\"\",4000) 执行 runscript.sh 脚本即可开始测试 $ ./runscript 0.55 0.08 5.02 12% 0.54 0.07 4.96 12% 0.54 0.11 5.00 13% 0.55 0.09 5.02 12% ... 所有的时间会输出到终端，如上面的格式，第一列是用户态运行时间，第二列是内核态运行时间，第三列是实际运行时间，最后一列是进程所获取的CPU时间比例。 注1：设备发起访问控制时，应当首先获取目标设备绑定的访问控制合约地址，该地址可以根据设备账户在管理合约中查询得到，但这里我们为了测试方便，选择预定义，而不是每次去查询。 注2：所有的代码文件都放在 github 仓库中。 2.2.2 无信誉系统 完整的方案中包含 MC（管理合约）、ACC（访问控制合约）和RC（信誉合约），现在，我们将 RC 从系统中移除，并删除 MC 和 ACC 中所有相关的调用。 JS 文件基本逻辑如下，可以看到，前面都是变量定义的过程，执行主体是访问控制函数，当获取到 receipt 时退出（返回的事件位于 receipt 中，可以输出确认一下，正式测试时为了输出结果的格式可以只用 receipt.status判断即可）。 var Web3 = require('web3'); var web3 = new Web3(Web3.givenProvider || \"ws://localhost:23000\"); var accAbi = \"这里是合约ABI\" var accAddr = \"这里是合约地址\" var myACC = new web3.eth.Contract(accAbi, accAddr); myACC.methods.accessControl(\"这里是传入的参数列表\").send({ from: \"这里是发起访问的账户地址\", gas: 10000000, gasPrice: 0 }).then(function(receipt){ if (receipt.status) { console.log(receipt) process.exit(0); } }) 合约部署时得到的结果如下 合约 Gas 消耗 MC 1958457 ACC 4128313 合约部署完毕后定义属性和策略，最后根据具体情况修改 JS 和 Shell 脚本，500 次访问时间的平均值为 0.62682s，最大值为 0.99s，最小值为 0.57s。 2.2.3 恶意行为检测加入 加入信誉合约 RC 后进行测试，部署合约、注册设备、定义属性和策略。三种合约部署的 Gas 消耗分别为 合约 Gas 消耗 MC 2512367 ACC 4749983 RC 1170616 注意，我们在访问控制合约初始化时设定了两次访问控制请求间隔应不少于 100s，否则会触发 Too frequent request 错误。这个设定会极大的延长我们测试的总时间，所以我们把这个时间间隔重新设定为 4s，这样 shell 脚本中的 sleep 5 就不会触发错误。 测试前解锁相应的账户 \u003e personal.unlockAccount(eth.accounts[0],\"\",3600) \u003e personal.unlockAccount(eth.accounts[1],\"\",3600) 500 次测试结果的平均值为 0.66736s，最大值为 2.71s，最小值为 0.55s。 2.2.4 wang的方案 在下面的论文中，wang 等利用智能合约对传统 ABAC 架构进行了实现，我们认为对比该方案和我们的方案具有较大的意义。 P. Wang, Y. Yue, W. Sun, and J. Liu, “An Attribute-Based Distributed Access Control for Blockchain-enabled IoT,” in 2019 WiMob, Barcelona, Spain, Oct. 2019, pp. 1–6, doi: 10.110","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:2:2","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 不同方案的存储占用分析 由于不同访问控制方案的架构不同，随着物联网中用户、设备及访问请求数量的增加，区块链上存储的合约总大小增长速度不同，对区块链存储造成的压力不同。 下面是三种不同方案的合约字节码大小 方案 合约大小(bytecode 大小) BBRAC（我们的方案） ABDKMathQuad.sol: 885 bytes Management.sol: 77,960 bytes Reputation.sol: 102,088 bytes AccessControl.sol: 121,454 bytes zhang RC.sol: 7,735 bytes JC.sol: 17,174 bytes ACC.sol: 31,231 bytes wang Subject.sol: 23,760 bytes Object.sol: 12,431 bytes Policy.sol: 49,978 bytes AccessControl.sol: 40,086 bytes 合约的增长关系描述如下 BBRAC：1 个 ABDKMathQuad.sol, 1 个 Management.sol, 1 个 Reputation.sol, n 个 AccessControl.sol，n 为设备数量； zhang：1 个 RC.sol，1 个 JC.sol，n 个 ACC.sol，n 为 Subject-Object 数量； wang：1 个 Subject.sol，1 个 Object.sol，1 个 AccessControl.sol，n 个 Policy.sol，n 为用户数量，每个用户可能拥有多个设备。 我们假设设备数量为 n，每两个设备间均会发起访问请求，即有 $n^2$ 个 Subject-Object 对，每个设备归属于不同的用户，即用户数量也为 n（便于统一 x 轴），由此得到合约大小随设备数量增长的表达式（单位为 KB）： BBRAC：$y = 118.5n + 176.7$ zhang：$y = 30.5n^2 + 24.3$ wang：$y = 48.8n + 74.5$ 根据表达式绘制图表如下，可以看到，zhang 的方案中合约占用的存储空间随着设备增加在快速增长，5个设备以上存储占用就高于我们的方案，wang 的方案虽然比我们的存储占用增长速率低，但是在访问时间和和合法交易的通过率上有不足，这一点我们接下来介绍。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:2:3","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"3. 恶意行为检测测试 如上篇所述，信誉系统的测试需要发起持续不断的合约调用，具体来说，就是在随机的时间调用随机的合约函数，从而验证奖励、惩罚、容忍、报警四大功能。 随机的时间间隔使用泊松分布生成，具体方法在 另一篇文章 中介绍。在生成的随机时间点具体执行哪个合约调用，我们进行了如下考虑 首先，会影响信誉值的行为包括 事件 所属合约及函数 合法/恶意 事件编号 Attribute add MC:addAttribute 合法 1 Device manager update MC:updateManager 合法 2 Device customed attribute update MC:updateAttribute 合法 2 Device delete MC:deleteDevice 合法 3 Attribute delete MC:deleteAttribute 合法 3 Resource attribute add addResourceAttr 合法 1 Policy add ACC:addpolicy 合法 1 Device manager update ACC:updateManager 合法 2 Resource attribute update ACC:updateResourceAttr 合法 2 Resource attribute delete ACC:deleteResourceAttr 合法 3 Policy delete ACC:deletePolicy 合法 3 Policy item delete ACC:deletePolicyItem 合法 3 Access authorized ACC:accessControl 合法 4 Blocked end time not reached ACC:accessControl 恶意 0 Policy check failed ACC:accessControl 恶意 0 Too frequent access ACC:accessControl 恶意 1 Both above two ACC:accessControl 恶意 1 以上影响信誉值的行为间是有先后关系的，比如，update、delete 都必须在 add 之后完成，access control 发起的条件是相关的属性和策略已定义等。如果我们完全随机的产生事件，很可能某些行为无法执行。 解决办法：忽略行为间的先后关系，因为如果存在显式的先后关系，一定会被我们定义的 require 机制给阻止，不会导致系统出错。 当确定了具体的行为，调用时如何传入参数。因为属性和策略的增删改一定会影响访问控制的结果，这样的话，访问成功还是失败完全不受我们控制。 解决办法：去除会影响结果的行为，因为同一类行为对信誉值的影响是相同的，所以每种行为我们只需要保留一个就可以。比如，合法行为中，Attribute add、Resource attribute add、Policy add 三者等价，我们只保留 Attribute add 一个行为，产生的所有 add 类行为都转换为对 addAttribute 一个函数的调用。最后我们保留下来的行为包括 事件 所属合约及函数 合法/恶意 事件编号 Attribute add MC:addAttribute 合法 1 Device customed attribute update MC:updateAttribute 合法 2 Attribute delete MC:deleteAttribute 合法 3 Access authorized ACC:accessControl 合法 4 Policy check failed ACC:accessControl 恶意 0 Too frequent access ACC:accessControl 恶意 1 为了排除仅剩的这些行为间的相互影响，我们规定，access control 将依赖于已定义好的属性和策略，新添加/更改/删除属性不会对访问结果产生影响。 每一种行为出现的概率可能是不一致的。比如，update 出现的次数可能多一点，add 和 delete 会少一点，access control 发起的频率可能是最高的。但是，在这里，6种不同的行为我们都以同样的概率来考虑，我们用 0-5 一共 6 个整数表示 6 种不同的事件，然后随机生成这个范围内的一个整数，从而确定某一时刻要调用的函数。 使用一个文本文件存放输入参数，第一列是随机时间，第二列是随机事件，利用 Bash 读取每一行，然后在具体的时间调用指定的 JS 脚本完成这一过程。记录的结果包括从信誉合约检测到的各种值。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:3:0","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"附录 随机时间生成 我们要进行的仿真是在随机的时间执行随机的事件，这个时间就叫做事件到达时间。根据已有知识，随机的事件到达时间应该符合泊松分布，事件到达时间的间隔符合指数分布，实现时通常采用生成到达时间间隔的方式。这里的实现翻译了文章 How to Generate Random Timings for a Poisson Process，使用的语言是 Go。 事件的发生是随机的，但是从总体上看，事件以平均的速率发生，这就是泊松过程。举个例子，USGS 预计每年全世界大约发生 13000 场 4 级以上的地震，这些地震发生的时间是随机的，但一定在 13000 场左右。 统计学中有大量的函数和方程用于建模泊松过程，这篇文章介绍了一种其中一种函数，并给出了一个实现程序。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:4:0","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"1. 指数分布 如果每年 13000 场地震，那么平均 40 分钟一场地震，所以定义变量 $\\lambda = \\frac{1}{40}$，称为速率参数，这是一个频率的衡量：单位时间（地震的例子里是分钟）发生事件（地震）的平均速率。 因此，接下来的问题是，下一分钟发生地震的概率是多少？下一个十分钟呢？这里有一个众所周知的函数，称为 指数分布的累积分布函数（cumulative distribution function for the exponential distribution），该函数看起来如下： $$ F(x) = 1 - e^{-\\lambda x} $$ 其含义是，随之时间的流逝，在世界上某个地方发生地震的可能性不断增大，这里「指数」的含义是指数衰减，随着时间流逝，不发生地震的可能性逐渐趋近于0，相应的，发生至少一场地震的可能性也趋向于1。 插入一些值，我们发现： 下一分钟发生地震的可能性为 $F(1) \\approx 0.0247$，该值无限接近于 $\\frac{1}{40}$，这个我们预设的地震频率，但不相等； 下一个十分钟发生地震的可能性为 $F(10) \\approx 0.221$ 特别的，下一个 40 分钟发生地震的可能性为 $F(40) \\approx 0.632$，因此，40分钟的间隔内很可能发生地震，但不绝对。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:4:1","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"2. 编写仿真 现在，假设我们要模拟游戏引擎或其他某种程序中地震的发生。首先，我们需要弄清楚每次地震的开始时间。 一种方法是循环，每隔 X 分钟之后，在 0 到 1 之间采样一个随机浮点值。如果该数字小于 $F(X)$，则开始地震。X 可以是一个小数值，因此可以每分钟采样几次，甚至每秒采样几次。只要随机数生成器是统一的并且提供足够的数值精度，这一个方法就会很好用。但是，如果打算以 $λ=\\frac{1}{40}$ 每秒进行 60 次采样，随机数生成器需要至少18位精度，标准 C运行时库并不总是提供这一精度。 另一种方法是回避整个采样策略，只需编写一个函数即可确定下一次地震的确切时间。此函数应返回随机数，但不是大多数生成器生成的统一类型的随机数，而是以遵循指数分布的方式生成随机数。 Donald Knuth 在 「The Art of Computer Programming」一书的 3.4.1(D) 一节描述了一种生成这种值的方法，只需在 y 轴上选择介于 0 和 1 之间的均匀分布的随机点，然后在 x 轴上找到相应的时间值即可。例如，如果我们从下图 y 轴选择 0.2 点，那么到下一次地震的时间将是 64.38 分钟。 由于指数函数的反函数是 ln，写这个程序很简单，其中 U 是 0 到 1 之间的随机值： ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:4:2","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"3. 实现 package main import ( \"fmt\" \"math\" \"math/rand\" \"time\" ) func main() { rand.Seed(time.Now().UnixNano()) for i := 0; i \u003c 5; i++ { fmt.Println(nextTime(1 / 40.0)) } } func nextTime(rateParameter float64) float64 { return -math.Log(1.0-rand.Float64()) / rateParameter } // Output: 3.645968256349058 21.416099701223878 27.140451644356354 132.53700107810388 10.94869965544849 经测试，该函数返回的平均时间确实为40 package main import ( \"fmt\" \"testing\" ) func TestNextTime(t *testing.T) { var sum float64 for k := 0; k \u003c 10; k++ { for i := 0; i \u003c 1000000; i++ { sum += nextTime(1 / 40.0) } fmt.Println(sum / 1000000) sum = 0 } } // Output: === RUN TestNextTime 39.936436485414866 40.073299195147676 40.02405410596529 39.984823394877324 39.970452381128254 40.05045384327815 39.94419161580051 40.038542654941246 39.983753932119754 40.029867240804506 --- PASS: TestNextTime (0.42s) PASS ok github.com/shuzang/test 0.652s 实际上，Go 在 math/rand 库中本身就提供了一个生成符合指数分布的随机数的函数，叫做 rand.ExpFloat64()。实现的算法使用的是 Marsaglia 和 Tsang 在 2000 年发布的论文 The Ziggurat Method for Generating Random Variables ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:4:3","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["研究生的区块链学习之路"],"content":"4. 其它仿真器 The One 是一个 opportunistic Network Environment simulator，可以设置一个仿真的 IoT 网络，参数包括网络中设备数目、带宽、通信到达时间等，使用不同的模型生成随机的运动和通信，并将过程可视化。 ","date":"2020-06-01","objectID":"/2020/experimental-process-optimization-and-performance-test/:4:4","tags":["科研记录"],"title":"研究记录14-重新实验及实验流程优化","uri":"/2020/experimental-process-optimization-and-performance-test/"},{"categories":["Golang学习之路"],"content":"模板就是在写动态页面时不变的部分，服务端程序渲染可变部分生成动态网页，Go 语言提供了 html/template 包来支持模板渲染。 ","date":"2020-05-29","objectID":"/2020/golang-template/:0:0","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1. 基本语法 模板的基本语法来自于 text/template 包，与大多数语言一样，用 {{ 和 }} 来做标识，{{ }} 里可以是表达式，也可以是变量 ","date":"2020-05-29","objectID":"/2020/golang-template/:1:0","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1.1 变量 模板中的变量通过{{.}} 来访问。Golang渲染template的时候，可以在模板文件中读取变量内的值并渲染到模板里。有两个常用的传入类型。一是struct，在模板内可以读取该struct的内容。二是map[string]interface{}，在模板内可以使用key来进行渲染。 以结构体为例，假设初始化了一个结构体 User type User struct { UserId int Username string Age uint Sex string } user := User{1, \"Steven\", 35, \"男\"} 模板获取数据的方式如下 {{.}}{{.Username}}{{.UserId}}{{.Age}}{{.Sex}} 那么渲染后的模板内容如下 {1 Steven 35 男}Steven135男 也可以在模板中定义变量，初始化后就可以进行调用，如下所示 {{$MyUserName := \"StevenWang\"}} {{$MyUserName}} ","date":"2020-05-29","objectID":"/2020/golang-template/:1:1","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1.2 逻辑判断 Golang 模板支持 if 条件判断，当前支持最简单的 bool 类型和 string 类型，定义方式如下 {{if .confition}} {{end}} 当.condition是bool类型时，值为true表示执行。当.condition是string类型时，值非空表示执行。加入 else 时，形式如下 {{if .confition}} {{else}} {{end}} 此模板也支持if…else if嵌套，定义方式如下所示 {{if .confition}} {{else if .confition}} {{end}} Golang的模板提供了一些内置的模板函数来执行逻辑判断，下面列举目前常用的一些内置模板函数 函数语法 函数作用 {{if not .condition}} {{end}} not 非 {{if and .condition1 .condition2}} {{end}} and 与 {{if or .condition1 .condition2}} {{end}} or 或 {{if eq .var1 .var2}} {{end}} eq 等于 {{if ne .var1 .var2}} {{end}} ne 不等于 {{if lt .var1 .var2}} {{end}} lt 小于 {{if le .var1 .var2}}{{end}} le 小于等于 {{if gt .var1 .var2}}{{end}} gt 大于 {{if ge .var1 .var2}}{{end}} ge 大于等于 假设在 Go 程序中定义了一个map，如下 locals := make(map[string]interface{}) locals[\"username1\"] = \"Steven\" locals[\"username2\"] = \"Daniel\" 在模板文件中进行逻辑判断如下 {{if eq .username .user}} OK:账号名称一致 {{else if ne .username .user}} Err:账号名称不一致 {{end}} 逻辑判断也可以使用 with 作为关键词 {{with .condition}} {{end}} 或者 {{with .condition}} {{else}} {{end}} ","date":"2020-05-29","objectID":"/2020/golang-template/:1:2","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1.3 循环遍历 Golang 的模板支持 range 循环来遍历 map、slice中的内容，语法如下 {{range $index, $value := .slice}} {{end}} 在这个range循环内，遍历数据通过$index和 $value来实现。还有一种遍历方式，语法格式如下所示 {{range .slice}} {{end}} 这种方式无法访问到$index和$key的值，需要通过{{.}}来访问对应的$value。这种情况下，在循环体内，外部变量需要使用{{$.}}来访问。 模板文件的示例代码如下 {{range $index, $value := .filelist}} \u003cfigure\u003e \u003ca href=\"/html/upload/{{$value}}\"\u003e\u003cimg src=\"/html/upload/{{$value}}\"/\u003e\u003c/a\u003e \u003cfigcaption\u003e {{$value}} \u003cbr/\u003e \u003ca href=\"/delete?id={{$value}}\"\u003e[删除]\u003c/a\u003e {{$.username}}上传 \u003c/figcaption\u003e \u003c/figure\u003e {{end}} 循环也有 else 语句，如果作为循环条件的数组、切片、映射或通道长度为0，就执行 else 后的语句。 {{range .slice}} {{else}} {{end}} ","date":"2020-05-29","objectID":"/2020/golang-template/:1:3","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1.4 模板嵌套 在编写模板的时候，经常需要将公用的模板进行整合，比如每一个页面都有导航栏和页脚，通常的做法是将其编写为一个单独的模块，让所有的页面进行导入，这样就不用重复编写了。 任何网页都有一个主模板，然后可以在主模板内嵌入子模板来实现模块共享。当模板想要引入子模板时，通常使用如下语句 {{template \"navbar\"}} 这样就会载入名为 navbar 的子模版，同时，我们需要定义 navbar 子模版的实现 {{define \"navbar\"}} {{end}} 在定义中间的内容最终会替代源文件中的 {{template “navbar”}} 这一条语句 如果想要子模板获得父模板的变量，使用如下方法 {{template \"navbar\" .}} ","date":"2020-05-29","objectID":"/2020/golang-template/:1:4","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"2. 模板函数 上面的语法一般情况都是定义在前端文件中的，要对模板进行处理，html/template 还提供了一系列函数。 一个简单的例子如下 import \"text/template\" ... t, err := template.New(\"foo\").Parse(`{{define\"T\"}}Hello, {{.}}!{{end}}`) err = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\") 涉及到的几个函数分别是 New，Parse 和 ExecuteTemplate，解释如下 // 创建一个名为name的模板 func New(name string) *Template // Parse方法将字符串text解析为模板 func (t *Template) Parse(src string) (*Template, error) // 将解析好的模板应用到data上，使用名为name的t关联的模板产生输出。 func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error 所以 New 和 Parse 创建一个模板并将字符串解析到该模板，但实际使用时模板文件通常是单独的，这时一般使用 Must 和 ParseFiles 函数。 ParseFiles方法解析filenames指定的文件里的模板定义并将解析结果与t关联。如果发生错误，会停止解析并返回nil，否则返回(t, nil)。至少要提供一个文件。 func (t *Template) ParseFiles(filenames ...string) (*Template, error) 可以看到 ParseFiles 返回 (*Template, error)，Must 函数正好用来封装这种返回形式的函数 func Must(t *Template, err error) *Template 它会在 err 非 nil 时 panic，一般用于变量初始化 var t = template.Must(template.New(\"name\").Parse(\"html\")) 另外，ExecuteTemplate 将输出指定到名为 name 的模板上，但还有一种简单形式如下 func (t *Template) Execute(wr io.Writer, data interface{}) error Execute方法将解析好的模板应用到data上，并将输出写入wr，唯一的区别就是没有绑定模板。 ","date":"2020-05-29","objectID":"/2020/golang-template/:2:0","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"本文介绍 gorilla/mux 包的使用。 我们已知 Go 标准库 net/http 提供的默认路由是 DefaultServeMux，虽然简单易上手，但存在很多不足，比如 不支持参数设定，例如 /user/:uid 这种泛类型匹配； 对 REST 风格接口支持不友好，无法限制访问路由的方法； 对于拥有很多路由规则的应用，编写大量路由规则非常繁琐。 为此，我们可以使用第三方库 gorilla/mux 提供的更加强大的路由处理器（mux 代表 HTTP request multiplexer，即 HTTP 请求多路复用器），和 http.ServeMux 实现原理一样，gorilla/mux 提供的路由器实现类 mux.Router 也会匹配用户请求与系统注册的路由规则，然后将用户请求转发过去。 type Router struct { // Configurable Handler to be used when no route matches. NotFoundHandler http.Handler // Configurable Handler to be used when the request method does not match the route. MethodNotAllowedHandler http.Handler // Routes to be matched, in order. routes []*Route // Routes by name for URL building. namedRoutes map[string]*Route // If true, do not clear the request context after handling the request. // Deprecated: No effect, since the context is stored on the request itself. KeepContext bool // Slice of middlewares to be called after a match is found middlewares []middleware // configuration shared with `Route` routeConf } mux.Router 主要具备以下特性： 实现了 http.Handler 接口，所以和 http.ServeMux 完全兼容； 可以基于 URL 主机、路径、前缀、scheme、请求头、请求参数、请求方法进行路由匹配； URL 主机、路径、查询字符串支持可选的正则匹配； 支持构建或反转已注册的 URL 主机，以便维护对资源的引用； 支持路由嵌套，以便不同路由可以共享通用条件，比如主机、路径前缀等。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:0:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"1. 使用入门 运行如下命令进行安装 $ go get -u github.com/gorilla/mux 一个简单的示例如下 func main() { r := mux.NewRouter() r.HandleFunc(\"/\", HomeHandler) r.HandleFunc(\"/products\", ProductsHandler) r.HandleFunc(\"/articles\", ArticlesHandler) http.ListenAndServe(\":8080\", r) } main 函数中的第一行显式初始化了 mux.Router 作为路由器，然后在这个路由器中注册路由规则，最后将这个路由器传入 http.ListenAndServe 方法，整个调用过程和之前并无二致，因为mux.Router 也实现了 Handler 接口。 路径中可以包含变量。变量的定义形式为 {name} 或 {name:pattern}，只能是小写字母，不支持其它字符，同时，name 可以是正则表达式，如下面的例子所示 r := mux.NewRouter() r.HandleFunc(\"/products/{key}\", ProductHandler) r.HandleFunc(\"/articles/{category}/\", ArticlesCategoryHandler) r.HandleFunc(\"/articles/{category}/{id:[0-9]+}\", ArticleHandler) 相应地，在闭包处理函数中，我们使用 mux.Vars() 解析路由参数： func ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) w.WriteHeader(http.StatusOK) fmt.Fprintf(w, \"Category: %v\\n\", vars[\"category\"]) } ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:1:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"2. 路由代码拆分 比较简单的情况下，所有的路由、处理器都放在应用入口文件中，一般是 main.go，但如果项目比较大，甚至仅仅是博客这种级别的项目，就要处理文章、用户、图片等众多资源，所以我们需要针对这种情况进行一定的优化。 优化的办法就是将路由器与控制器分离，为了使代码结构更加清晰明了，我们把服务器、路由器、路由定义、处理器方法全都拆分开。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:2:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"2.1 路由器 我们在项目根目录下新建 routes 目录用来存放路由定义及实现。 首先在 routes 目录下创建 routes.go 存放路由定义，文件内容如下 package routes import \"net/http\" // 定义一个 WebRoute 结构体用于存放单个路由 type WebRoute struct { Name string Method string Pattern string HandlerFunc http.HandlerFunc } // 声明 WebRoutes 切片存放所有 Web 路由 type WebRoutes []WebRoute // 定义所有 Web 路由 var webRoutes = WebRoutes{ } 在这里，我们定义了一个 WebRoute 结构体来表示单个路由，其中包含了路由名称、请求方法、匹配字符串模式、以及对应的处理器方法，路由器可以根据这些配置请求请求分发。 然后定义了一个 WebRoutes 切片来存放所有 WebRoute 类型的路由，最后初始化这个切片为空，表示还没有定义任何路由。 接下来，在 routes 目录下创建 router.go 用来编写路由器实现 package routes import \"github.com/gorilla/mux\" // 返回一个 mux.Router 类型指针，从而可以当作处理器使用 func NewRouter() *mux.Router { // 创建 mux.Router 路由器示例 router := mux.NewRouter().StrictSlash(true) // 遍历 web.go 中定义的所有 webRoutes for _, route := range webRoutes { // 将每个 web 路由应用到路由器 router.Methods(route.Method). Path(route.Pattern). Name(route.Name). Handler(route.HandlerFunc) } return router } StrictSlash 定义斜杠尾随行为，意思是，传入 true 时，如果路由路径是 /path 这种形式，将重定向到 /path/ ，反之亦然。传入 false 时，不会重定向，这两种情况不会看作一种。 Methods，Path，Name，Handler分别用来限定请求方法、匹配字符串模式、路由名和处理器方法。通过这种方式，我们将 routes.go 中定义的所有 Web 路由都应用到了使用 mux.NewRouter 创建的路由器，以便可以处理用户请求的路由匹配和分发。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:2:1","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"2.2 服务器 在入口文件 main.go 中使用如下方法启动服务器 package main import ( . \"github.com/shuzang/projectname/routes\" \"log\" \"net/http\" ) func main() { startWebServer(\"8080\") } func startWebServer(port string) { r := NewRouter() http.Handle(\"/\", r) log.Println(\"Starting HTTP service at \" + port) err := http.ListenAndServe(\":\"+port, nil) // Goroutine will block here if err != nil { log.Println(\"An error occured starting HTTP listener at port \" + port) log.Println(\"Error: \" + err.Error()) } } 我们将 Web 服务器启动逻辑封装到 startWebServer 方法中实现，该方法需要传入端口参数。在具体实现时，我们调用了 routes/router.go 中定义的 NewRouter 方法，将其返回值作为处理器传入 http.Handle 方法，最后调用 http.ListenAndServe 启动 Web 服务器并监听传入的端口号。 最后在 main 方法中调用 startWebServer 方法即可。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:2:2","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"2.3 处理器 上层代码写完后，现在定义处理器方法。在项目根目录下新建 handlers 目录存放处理器方法，这里举 2 个示例，分别定义在 common.go 和 user.go 两个文件中，用来处理通用请求和用户资源。 首先在 common.go 中编写首页请求处理器方法 package handlers import ( \"io\" \"net/http\" ) func Home(w http.ResponseWriter, r *http.Request) { io.WriteString(w, \"Welcome to my site\") } 然后在 user.go 中定义获取指定用户对应处理器方法 package handlers import ( \"github.com/gorilla/mux\" \"io\" \"net/http\" ) func GetUser(w http.ResponseWriter, r *http.Request) { // Get user from DB by id... params := mux.Vars(r) id := params[\"id\"] io.WriteString(w, \"Return user info with id = \" + id) } 这时要记得，routes/routes.go 中的路由切片还是空的，用实现的处理器填充它 var webRoutes = WebRoutes{ WebRoute{ \"Home\", \"GET\", \"/\", handlers.Home, }, WebRoute{ \"User\", \"GET\", \"/user/{id}\", handlers.GetUser, }, } ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:2:3","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"3. 路由匹配规则 第一部分的路由匹配规则只是简单介绍，实际上，gorilla/mux 实现的匹配规则非常强大。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:3:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"3.1 常用匹配规则 限定请求方法 r.HandleFunc(\"/books/{title}\", CreateBook).Methods(\"POST\") r.HandleFunc(\"/books/{title}\", ReadBook).Methods(\"GET\") r.HandleFunc(\"/books/{title}\", UpdateBook).Methods(\"PUT\") r.HandleFunc(\"/books/{title}\", DeleteBook).Methods(\"DELETE\") 限定主机名或子域名 r.HandleFunc(\"/books/{title}\", BookHandler).Host(\"www.mybookstore.com\") 限定 Scheme r.HandleFunc(\"/secure\", SecureHandler).Schemes(\"https\") r.HandleFunc(\"/insecure\", InsecureHandler).Schemes(\"http\") 限定前缀和子路由 bookrouter := r.PathPrefix(\"/books\").Subrouter() bookrouter.HandleFunc(\"/\", AllBooks) bookrouter.HandleFunc(\"/{title}\", GetBook) 限定请求参数 r.HandleFunc(\"/request/header\", func(w http.ResponseWriter, r *http.Request) { header := \"X-Requested-With\" fmt.Fprintf(w, \"包含指定请求头[%s=%s]\", header, r.Header[header]) }).Headers(\"X-Requested-With\", \"XMLHttpRequest\") ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:3:1","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"3.2 自定义匹配规则 gorilla/mux 路由支持通过 MatcherFunc 方法自定义路由匹配规则，在该方法中，可以获取到请求实例 request，这样我们就可以拿到所有的用户请求信息，并对其进行判断，符合我们预期的请求才能匹配并访问该方法应用到的路由。 比如下面这个示例，我们限定只有来自 https://baidu.com 域名的请求才可以匹配到 /custom/matcher 路由 r.HandleFunc(\"/custom/matcher\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"请求来自指定域名: %s\", r.Referer()) }).MatcherFunc(func(request *http.Request, match *mux.RouteMatch) bool { return request.Referer() == \"https://baidu.com\" }) ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:3:2","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"3.3 路由命名 通过 Name 方法在路由规则中指定 postRouter := r.PathPrefix(\"/posts\").Subrouter() postRouter.HandleFunc(\"/\", listPosts).Methods(\"GET\").Name(\"posts.index\") postRouter.HandleFunc(\"/create\", createPost).Methods(\"POST\").Name(\"posts.create\") ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:3:3","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"4. 路由中间件 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:4:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"5. 处理静态资源响应 使用默认http包处理静态资源的方法如下 fs := http.FileServer(http.Dir(\"assets/\")) http.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs)) 使用 gorilla/mux 时，处理方法很相似 r := NewRouter() // 通过 router.go 中定义的路由器来分发请求 assets := http.FileServer(http.Dir(\"public\")) r.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", assets)) http.Handle(\"/\", r) // 应用路由器到 HTTP 服务器 ... 虽然 gorilla/mux 路由器提供了对静态资源的支持，但是通常我们还是会基于 Nginx 来处理静态资源，然后将动态请求转发给 Go HTTP 服务器，因为 Nginx 作为一款强大的反向代理服务器，并发处理静态资源的能力非常强悍，没必要自己去处理这块逻辑。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:5:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"本文介绍 Golang 如何实现 HTTP 服务端及客户端。 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:0:0","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1. HTTP协议客户端实现 Go语言标准库内置了net/http包，涵盖了HTTP客户端和服务端具体的实现方式。内置的net/http包提供了最简洁的HTTP客户端实现方式，无须借助第三方网络通信库，就可以直接使用HTTP中用得最多的GET和POST方式请求数据。 实现HTTP客户端就是客户端通过网络访问向服务端发送请求，服务端发送响应信息，并将相应信息输出到客户端的过程。实现客户端有多种方式，具体如下所示。 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:0","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.1 使用http.NewRequest()方法 首先创建一个client（客户端）对象，其次创建一个request（请求）对象，最后使用client发送request。 package main import ( \"fmt\" \"net/http\" ) func main() { testHttpNewRequest() } func testHttpNewRequest() { //1.创建一个客户端 client := http.Client{} //2.创建一个请求，请求方式可以是GET或POST request, err := http.NewRequest(\"GET\", \"http://www.baidu.com\", nil) checkErr(err) //3.客户端发送请求 cookName := \u0026http.Cookie{Name: \"username\", Value: \"Steven\"} //添加cookie request.AddCookie(cookName) response, err := client.Do(request) checkErr(err) //设置请求头 request.Header.Set(\"Accept-Lanauage\", \"zh-cn\") defer response.Body.Close() //查看请求头的数据 fmt.Printf(\"Header:%+v\\n\", request.Header) fmt.Printf(\"响应状态码: %v\\n\", response.StatusCode) //4.操作数据 if response.StatusCode == 200 { fmt.Println(\"网络请求成功\") checkErr(err) } else { fmt.Println(\"网络请求失败\", response.Status) } } //检查错误 func checkErr(err error) { defer func() { if ins, ok := recover().(error); ok { fmt.Println(\"程序出现异常: \", ins.Error()) } }() if err != nil { panic(err) } } 运行结果如下 $ go run main.go Header:map[Accept-Lanauage:[zh-cn] Cookie:[username=Steven]] 响应状态码: 200 网络请求成功 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:1","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.2 调用client.Get() 方法 这种方法总共两个步骤，先创建一个client（客户端）对象，然后使用client调用Get()方法。 package main import ( \"fmt\" \"net/http\" ) func main() { testClientGet() } func testClientGet() { //1.创建一个客户端 client := http.Client{} //2.通过client请求 response, err := client.Get(\"http://www.baidu.com\") checkErr(err) fmt.Printf(\"响应状态码: %v\\n\", response.StatusCode) if response.StatusCode == 200 { fmt.Println(\"网络请求成功\") defer response.Body.Close() } } //检查错误 func checkErr(err error) { defer func() { if ins, ok := recover().(error); ok { fmt.Println(\"程序出现异常: \", ins.Error()) } }() if err != nil { panic(err) } } 运行结果如下 $ go run main.go 响应状态码: 200 网络请求成功 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:2","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.3 使用client.Post()或client.PostForm()方法 这种方法也是两个步骤，先创建一个client（客户端）对象，然后使用client调用Post()或PostForm()方法。其实client的Post()或PostForm()方法，就是对http.NewRequest()的封装。 resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf) ... resp, err := http.PostForm(\"http://example.com/form\", url.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}}) ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:3","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.4 使用http.Get() 方法 这种方式只有一个步骤，http的Get()方法就是对DefaultClient.Get()的封装。 package main import ( \"fmt\" \"net/http\" ) func main() { testHttpGet() } func testHttpGet() { //获取服务器数据 response, err := http.Get(\"http://www.baidu.com\") checkErr(err) fmt.Printf(\"响应状态码: %v\\n\", response.StatusCode) if response.StatusCode == 200 { fmt.Println(\"网络请求成功\") defer response.Body.Close() checkErr(err) } else { fmt.Println(\"请求失败\", response.Status) } } //检查错误 func checkErr(err error) { defer func() { if ins, ok := recover().(error); ok { fmt.Println(\"程序出现异常: \", ins.Error()) } }() if err != nil { panic(err) } } 运行结果为 $ go run main.go 响应状态码: 200 网络请求成功 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:4","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.5 使用http.Post()或http.PostForm()方法 http的Post()函数或PostForm()，就是对DefaultClient.Post()或DefaultClient.PostForm()的封装。这种方法也只需要一个步骤 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:5","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2. HTTP协议服务端实现 使用Go语言标准库内置的net/http包，就可以实现一个基本的HTTP服务端。一个基本的HTTP服务器主要应完成如下功能 处理动态请求：处理浏览网站，登录帐户或发布图片等用户传入的请求。 提供静态文件：将JavaScript，CSS和图像等静态文件提供给浏览器，服务于用户。 接受连接请求：HTTP服务器必须监听指定端口从而接收来自网络的连接请求。 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:0","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2.1 处理动态请求 我们可以使用http.HandleFunc函数注册一个新的 Handler 来处理动态请求。它的第一个参数是请求路径的匹配模式，第二个参数是一个函数类型，表示针对这个请求要执行的功能。下例中针对请求返回一个欢迎访问的提示语。 http.HandleFunc(\"/\", func (w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Welcome to my website!\") }) http.ResponseWriter类型包含了服务器端给客户端的响应数据。服务器端往里面写入了什么内容，浏览器的网页源码就是什么内容。*http.Request包含了客户端发送给服务器端的请求信息（路径、浏览器类型等）。 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:1","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2.2 提供静态文件 使用http.FileServer() 方法提供 Javascript，CSS或图片等静态文件。它的参数是文件系统接口，可以使用http.Dir()来指定文件所在的路径。如果该路径中有index.html文件，则会优先显示html文件，否则会显示文件目录。 fs := http.FileServer(http.Dir(\"static/\")) http.FileServer()的返回值正好是 Handler 类型，也就是可以提供文件访问服务的HTTP处理器。现在，我们只需要将一个URL指向它，期间我们可以使用http.StripPrefix() 去除某些URL前缀，返回值同样是一个 Handler类型 http.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs)) ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:2","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2.3 接收连接请求 http.ListenAndServer()函数用来启动HTTP服务器，并且在指定的 IP 地址和端口上监听客户端请求 http.ListenAndServe(\":80\", nil) 函数实现如下，其中第一个参数为监听地址，第二个参数表示一个HTTP处理器 Handler。可以看到，底层调用的是 net/http 包的 ListenAndServe 方法，首先会初始化一个 Server 对象，然后调用该 Server 实例的 ListenAndServe 方法，进而调用 net.Listen(\"tcp\", addr)，也就是基于 TCP 协议创建 Listen Socket，并在传入的IP 地址和端口号上监听请求。 func ListenAndServe(addr string, handler Handler) error { server := \u0026Server{Addr: addr, Handler: handler} return server.ListenAndServe() } func (srv *Server) ListenAndServe() error { if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \"\" { addr = \":http\" } ln, err := net.Listen(\"tcp\", addr) if err != nil { return err } return srv.Serve(ln) } 最终我们看到调用了 Server 实例的 Serve(net.Listener) 方法，这个方法里面起了一个 for 循环，在循环体中首先通过 net.Listener（即上一步监听端口中创建的 Listen Socket）实例的 Accept 方法接收客户端请求，接收到请求后根据请求信息创建一个 conn 连接实例，最后单独开了一个 goroutine，把这个请求的数据当做参数扔给这个 conn 去服务： for { rw, err := l.Accept() if err != nil { ... } connCtx := ctx if cc := srv.ConnContext; cc != nil { connCtx = cc(connCtx, rw) if connCtx == nil { panic(\"ConnContext returned nil\") } } tempDelay = 0 c := srv.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return go c.serve(connCtx) } 用户的每一次请求都是在一个新的 goroutine 去服务，相互不影响。客户端请求的具体处理逻辑都是在 c.serve 中完成的。 conn 实例的 serve 方法首先会通过 c.readRequest() 解析请求，然后在 serverHandler{c.server}.ServeHTTP(w, w.req) 的 ServeHTTP 方法中获取相应的 handler：handler := c.server.Handler，也就是我们刚才在调用函数 ListenAndServe 时候的第二个参数。 func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \"*\" \u0026\u0026 req.Method == \"OPTIONS\" { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req) } 我们发现当 handler 为 nil，也就是 ListenAndServe() 的第二个参数为 nil 时，使用了默认的 http.DefaultServeMux，这是 ServeMux的默认实例 var DefaultServeMux = \u0026defaultServeMux var defaultServeMux ServeMux ServeMux的数据结构如下 type ServeMux struct { mu sync.RWMutex. // 由于请求涉及到并发处理，因此这里需要一个锁机制 m map[string]muxEntry // 路由规则字典，存放 URL 路径与处理器的映射关系 es []muxEntry // MuxEntry 切片（按照最长到最短排序） hosts bool // 路由规则中是否包含 host 信息 } 这里，我们需要重点关注的是 muxEntry 结构： type muxEntry struct { h Handler // 处理器具体实现 pattern string // 模式匹配字符串 } 最后我们来看一下 Handler 的定义，这是一个接口： type Handler interface { ServeHTTP(ResponseWriter, *Request) // 路由处理实现方法 } 当请求路径与 pattern 匹配时，就会调用 Handler 的 ServeHTTP 方法来处理请求。 http.HandleFunc(\"/\", sayHelloWorld) 当我们使用一个自定义的处理函数时，如上面的sayHelloWorld，并没有实现 Handler 接口，之所以可以成功添加到路由映射规则，是因为在底层通过 HandlerFunc() 函数将其强制转化为了 HandlerFunc 类型，而 HandlerFunc 类型实现了 ServeHTTP 方法，这样，sayHelloWorld 方法也就变相实现了 Handler 接口 func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(\"http: nil handler\") } mux.Handle(pattern, HandlerFunc(handler)) } ... type HandlerFunc func(ResponseWriter, *Request) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } 对于 sayHelloWorld 方法来说，它已然变成了 HandlerFunc 类型的函数类型，当我们在其实例上调用 ServeHTTP 方法时，调用的是 sayHelloWorld 方法本身。 前面我们提到，DefaultServeMux 是 ServeMux 的默认实例，当我们在 HandleFunc 中调用 mux.Handle 方法时，实际上是将其路由映射规则保存到 DefaultServeMux 路由处理器的数据结构中： func (mux *ServeMux) Handle(pattern string, handler Handler) { mux.mu.Lock() defer mux.mu.Unlock() if pattern == \"\" { panic(\"http: invalid pattern\") } if handler == nil { panic(\"http: nil handler\") } if _, exist := mux.m[pattern]; exist { panic(\"http: multiple registrations for \" + pattern) } if mux.m == nil { mux.m = make(map[string]muxEntry) } e := muxEntry{h: handler, pattern: pattern} mux.m[pattern] = e if pattern[len(pattern)-1] == '/' { mux.es = appendSorted(mux.es, e) } if pattern[0] != '/' { mux.hosts = true } } 还是以 sayHelloWorld 为例，这里的 pattern 字符串对应的是请求路径 /，handler 对应的是 sayHelloWorld 函数。 保存好路由映射规则之后，客户端请求的处理就默认调用ServeMux 实现的 ServeHTTP 方法： func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) { if r.RequestURI == \"*\" { w.Header().Set(\"Connection\", \"close\") w.WriteHeader(StatusBadRequest) return } h, _ := mux.Handler(r) h.ServeHTTP(w, r) } 如上所示，路由处理器接收到请求之后，如果 URL 路径是 *，则关闭连接，否则","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:3","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2.4 获取客户端提交的数据 前面已经提到，客户端提交的数据全部位于 *http.Request 中，下面的例子虽然做了声明，但没有使用，本节介绍一下如何从 *http.request 中提取想要的数据 http.HandleFunc(\"/\", func (w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Welcome to my website!\") }) Request的部分结构如下 type Request struct { ... // Method指定HTTP方法（GET、POST、PUT等）。对客户端，\"\"代表GET。 Method string // Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。 Form url.Values // PostForm是解析好的POST或PUT的表单数据。 PostForm url.Values ... } 使用ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。 func (r *Request) ParseForm() error 然后使用 FormValue 返回以 key 为健查询 r.Form 得到的第一个值 func (r *Request) FormValue(key string) string PostFormValue则返回key为键查询r.PostForm字段得到的第一个值，用于POST和PUT func (r *Request) PostFormValue(key string) string 当提交的请求数据中有文件时，使用FormFile，可以返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。 func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error) 一个简单的实现如下 func loginActionHandler(w http.ResponseWriter, r *http.Request) { r.ParseForm() if r.Method == \"GET\" \u0026\u0026 r.ParseForm() == nil { username := r.FormValue(\"username\") pwd := r.FormValue(\"password\") if len(username) \u003c 4 || len(username) \u003e 10 { w.Write([]byte(\"用户名不符合规范\")) } if len(pwd) \u003c 6 || len(pwd) \u003e 16 { w.Write([]byte(\"密码不符合规范\")) } http.Redirect(w, r, \"/list\", http.StatusFound) return } else { w.Write([]byte(\"请求方式不对\")) return } w.Write([]byte(\"登录失败\")) } ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:4","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"前两篇分别介绍了整体设计及数据表的创建、模型类的编写，本篇了解如何在服务端处理用户请求，并启动论坛首页。文章转自学院君的教程，略有改动。 用户请求的处理流程如下： 客户端发送请求； 服务端路由器（multiplexer）将请求分发给指定处理器（handler）； 处理器处理请求，完成对应的业务逻辑； 处理器调用模板引擎生成 HTML 并将响应返回给客户端。 接下来我们按照这个流程来编写服务端代码。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"1. 路由器定义 这里我们基于 gorilla/mux 来实现路由器，所以需要安装对应依赖： $ go get -u github.com/gorilla/mux 将路由器定义在 routes 目录下的 router.go 中 package routes import \"github.com/gorilla/mux\" // 返回一个 mux.Router 类型指针，从而可以当作处理器使用 func NewRouter() *mux.Router { // 创建 mux.Router 路由器示例 router := mux.NewRouter().StrictSlash(true) // 遍历 web.go 中定义的所有 webRoutes for _, route := range webRoutes { // 将每个 web 路由应用到路由器 router.Methods(route.Method). Path(route.Pattern). Name(route.Name). Handler(route.HandlerFunc) } return router } 将所有路由定义在同一目录的 routes.go 中： package routes import \"net/http\" // 定义一个 WebRoute 结构体用于存放单个路由 type WebRoute struct { Name string Method string Pattern string HandlerFunc http.HandlerFunc } // 声明 WebRoutes 切片存放所有 Web 路由 type WebRoutes []WebRoute // 定义所有 Web 路由 var webRoutes = WebRoutes{ } ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"2. 启动HTTP服务器 最后在项目根目录下的 main.go 中引入上述路由器来启动 HTTP 服务器： package main import ( . \"github.com/xueyuanjun/chitchat/routes\" \"log\" \"net/http\" ) func main() { startWebServer(\"8080\") } // 通过指定端口启动 Web 服务器 func startWebServer(port string) { r := NewRouter() http.Handle(\"/\", r) // 通过 router.go 中定义的路由器来分发请求 log.Println(\"Starting HTTP service at \" + port) err := http.ListenAndServe(\":\" + port, nil) // 启动协程监听请求 if err != nil { log.Println(\"An error occured starting HTTP listener at port \" + port) log.Println(\"Error: \" + err.Error()) } } 这里我们指定 HTTP 服务器监听 8080 端口，使用的路由器正是上述 router.go 中 NewRouter 方法返回的 mux.Router 指针类型实例，这里可以看到引用的时候并没有带上包名前缀，之所以可以这么做是因为通过特殊符号 . 引入了 routes包，通过这种方式引入的包可以直接调用包中对外可见的变量、方法和结构体，而不需要加上包名前缀。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"3. 处理静态资源 在线论坛涉及到前端静态资源文件的处理，我们可以在 startWebServer 方法中新增如下这两行代码： r := NewRouter() // 通过 router.go 中定义的路由器来分发请求 // 处理静态资源文件 assets := http.FileServer(http.Dir(\"public\")) r.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", assets)) http.Handle(\"/\", r) // 应用路由器到 HTTP 服务器 ... 其中 http.FileServer 用于初始化文件服务器和目录为当前目录下的 public 目录。 然后在第二段代码中指定静态资源路由及处理逻辑：将 /static/ 前缀的 URL 请求去除 static 前缀，然后在文件服务器查找指定文件路径是否存在（public 目录下的相对地址）。 比如 URL 请求路径为 http://localhost:8080/static/css/bootstrap.min.css，对应的查找路径是： \u003capplication root\u003e/public/css/bootstrap.min.css 对于静态资源文件直接返回文件内容，不会进行额外处理。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4. 编写处理器实现 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4.1 首页处理器方法 做好上述准备工作后，接下来，我们来创建论坛首页的路由处理器，在 handlers 目录下新增一个 index.go 来定义首页的处理器方法： package handlers import ( \"github.com/xueyuanjun/chitchat/models\" \"html/template\" \"net/http\" ) // 论坛首页路由处理器方法 func Index(w http.ResponseWriter, r *http.Request) { files := []string{\"views/layout.html\", \"views/navbar.html\", \"views/index.html\",} templates := template.Must(template.ParseFiles(files...)) threads, err := models.Threads(); if err == nil { templates.ExecuteTemplate(w, \"layout\", threads) } } ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4.2 创建视图模板 这里我们使用 Go 自带的 html/template 作为模板引擎，需要传入位于 views 目录下的视图模板文件，这里传入了多个模板文件，包括主布局文件 layout.html： {{ define \"layout\" }} \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003eChitChat\u003c/title\u003e \u003clink href=\"/static/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"/static/css/font-awesome.min.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e {{ template \"navbar\" . }} \u003cdiv class=\"container\"\u003e {{ template \"content\" . }} \u003c/div\u003e \u003c!--/container --\u003e \u003cscript src=\"/static/js/jquery-2.1.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/static/js/bootstrap.min.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e {{ end }} 顶部导航模板 navbar.html： {{ define \"navbar\" }} \u003cdiv class=\"navbar navbar-default navbar-static-top\" role=\"navigation\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"navbar-header\"\u003e \u003cbutton type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"\u003e \u003cspan class=\"sr-only\"\u003eToggle navigation\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003c/button\u003e \u003ca class=\"navbar-brand\" href=\"/\"\u003e \u003ci class=\"fa fa-comments-o\"\u003e\u003c/i\u003e ChitChat \u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"navbar-collapse collapse\"\u003e \u003cul class=\"nav navbar-nav\"\u003e \u003cli\u003e\u003ca href=\"/\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"nav navbar-nav navbar-right\"\u003e \u003cli\u003e\u003ca href=\"/login\"\u003eLogin\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} 以及首页视图模板 index.html： {{ define \"content\" }} \u003cp class=\"lead\"\u003e \u003ca href=\"/thread/new\"\u003eStart a thread\u003c/a\u003e or join one below! \u003c/p\u003e {{ range . }} \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment-o\"\u003e\u003c/i\u003e {{ .Topic }}\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"panel-body\"\u003e Started by {{ .User.Name }} - {{ .CreatedAtDate }} - {{ .NumReplies }} posts. \u003cdiv class=\"pull-right\"\u003e \u003ca href=\"/thread/read?id={{.Uuid }}\"\u003eRead more\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} {{ end }} 引入多个视图模板是为了提高模板代码的复用性，因为对于同一个应用的不同页面来说，可能基本布局、页面顶部导航和页面底部组件都是一样的，关于视图模板的细节，我们在后面视图模板部分会详细介绍，这里简单了解下即可。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4.3 渲染视图模板 我们可以从数据库查询群组数据并将该数据传递到模板文件，最后将模板视图渲染出来，对应代码如下： threads, err := models.Threads(); if err == nil { templates.ExecuteTemplate(w, \"layout\", threads) } 编译多个视图模板时，默认以第一个模板名作为最终视图模板名，所以这里第二个参数传入的是 layout，第三个参数传入要渲染的数据 threads，对应的渲染逻辑位于 views/index.html 中： {{ range . }} \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment-o\"\u003e\u003c/i\u003e {{ .Topic }}\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"panel-body\"\u003e Started by {{ .User.Name }} - {{ .CreatedAtDate }} - {{ .NumReplies }} posts. \u003cdiv class=\"pull-right\"\u003e \u003ca href=\"/thread/read?id={{.Uuid }}\"\u003eRead more\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} 其中 {{ range . }} 表示将处理器方法传入的变量，这里是 threads 进行循环。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4.4 注册首页路由 最好，我们在 routes/routes.go 中注册首页路由及对应的处理器方法 Index： import \"github.com/xueyuanjun/chitchat/handlers\" // 定义所有 Web 路由 var webRoutes = WebRoutes{ { \"home\", \"GET\", \"/\", handlers.Index, }, } ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"5. 访问论坛首页 访问论坛首页之前，我们将相应的前端资源文件拷贝到 public 目录下，此时项目整体目录结构如下： 然后我们在项目根目录下运行如下代码启动 HTTP 服务器 $ go run main.go 然后我们在浏览器访问论坛首页 http://localhost:8080： ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:5:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"在 Go 中，加密是很重要的一部分，本文对此进行介绍。 ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:0:0","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"1. Hash 利用 Hash 算法可以将任意长度的二进制值（明文）映射为较短的固定长度的二进制值（Hash 值），是密码学的基础之一。 ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:1:0","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"1.1 流行的Hash算法 目前常见的Hash算法包括Message Digest（MD）系列和Secure HashAlgorithm（SHA）系列算法。 MD算法主要包括MD4和MD5两个算法。MD4（RFC 1320）是MIT的Ronald L. Rivest在1990年设计的，其输出为128位。MD4已被证明不够安全。MD5（RFC 1321）是Rivest于1991年发布的MD4改进版本。它对输入仍以512位进行分组，其输出是128位。MD5比MD4更加安全，但过程更加复杂，计算速度要慢一点。MD5已于2004年被成功碰撞，其安全性已不足以应用于商业场景。 SHA算法由美国国家标准与技术研究院（National Institute ofStandards and Technology，NIST）征集制定。SHA-0算法于1993年问世，1998年即遭破解。随后的修订版本SHA-1算法在1995年面世，它的输出为长度160位的Hash值，安全性更好。SHA-1设计采用了MD4算法类似原理。SHA-1已于2005年被成功碰撞，意味着无法满足商用需求。为了提高安全性，NIST后来制定出更安全的SHA-224、SHA-256、SHA-384和SHA-512算法（统称为SHA-2算法）。新一代的SHA-3算法也正在研究中。 目前MD5和SHA-1已经不够安全，推荐至少使用SHA-256算法。比特币系统就是使用SHA-256算法。 SHA-3算法又名Keccak算法。Keccak的输出长度有：512位、384位、256位、224位。 SHA-3并不是要取代SHA-2，因为SHA-2目前并没有暴露明显的弱点。由于对MD5出现成功的破解，以及对SHA-1出现理论上破解的方法，NIST认为需要一个与之前算法不同的、可替换的加密杂凑算法，也就是现在的SHA-3。区块链中的以太坊系统就是使用Keccak256算法 ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:1:1","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"1.2 SHA-256 SHA-256算法输入报文的最大长度是264 bit，产生的输出是一个256bit的报文摘要。SHA-256算法步骤如下。 附加填充比特：对报文进行填充，使报文长度与448模512同余（长度=448 mod512），填充的比特数范围是1到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个1，再加很多个0，直到长度满足mod512=448。为什么是448？因为448+64=512。第二步会加上一个64bit的原始报文的长度信息。 附加长度值：将用64bit表示的初始报文（填充前）的位长度附加在步骤1的结果后（低位字节优先）。 初始化缓存：使用一个256bit的缓存来存放该Hash函数的中间及最终结果。该缓存表示为A=0x6A09E667，B=0xBB67AE85，C=0x3C6EF372，D=0xA54FF53A，E=0x510E527F，F=0x9B05688C，G=0x1F83D9AB，H=0x5BE0CD19。 处理512bit（16个字）报文分组序列：该算法使用了6种基本逻辑函数，由64步迭代运算组成。每步都以256bit缓存值ABCDEFGH为输入，然后更新缓存内容。 每步使用一个32bit Kt（常数值）和一个32bit Wt（分组后的报文）。 ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:1:2","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"1.3 示例代码 计算字符串的 SHA-256 使用如下函数原型 func Sum256(data []byte) [Size]byte ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:1:3","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"2. 对称加密算法","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:2:0","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"在本篇教程中，我们将在 MySQL 中创建一个 chitchat 数据库作为论坛项目的数据库。我选择了在本地安装 MySQL Server，但也可以基于 Docker 容器运行。转自学院君的教程，略有改动。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"1. 项目初始化 首先创建项目目录，命名为 chitchat，然后初始化目录结构如下 各个子目录/文件的作用介绍如下： main.go：应用入口文件 config.json：全局配置文件 handlers：用于存放处理器代码（可类比为 MVC 模式中的控制器目录） logs：用于存放日志文件 models：用于存放与数据库交互的模型类 public：用于存放前端资源文件，比如图片、CSS、JavaScript 等 routes：用于存放路由文件和路由器实现代码 views：用于存放视图模板文件 在 Github 网页端创建同名仓库，然后在本地执行如下命令初始化仓库（我们使用 Github 存储代码） echo \"# chitchat\" \u003e\u003e README.md git init git add README.md git commit -m \"Initialize project directory\" git remote add origin https://github.com/shuzang/chitchat.git git push -u origin master 然后在 chitchat 目录下初始化 Go 项目， 后续通过 Go Module 来管理依赖 $ go mod init github.com/shuzang/chitchat ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"2. 创建数据表 在 MySQL Server 中创建 chitchat 数据库，然后创建数据表，数据表对应的 SQL 语句如下 create table users ( id serial primary key, uuid varchar(64) not null unique, name varchar(255), email varchar(255) not null unique, password varchar(255) not null, created_at timestamp not null ); create table sessions ( id serial primary key, uuid varchar(64) not null unique, email varchar(255), user_id integer references users(id), created_at timestamp not null ); create table threads ( id serial primary key, uuid varchar(64) not null unique, topic text, user_id integer references users(id), created_at timestamp not null ); create table posts ( id serial primary key, uuid varchar(64) not null unique, body text, user_id integer references users(id), thread_id integer references threads(id), created_at timestamp not null ); 使用 Navicat for MySQL 进行连接测试 大量的语句逐条执行很容易出错，可以通过脚本形式批量执行1。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3. 与数据库交互 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3.1 数据库驱动 数据表创建完成后，接下来，需要在 Go 应用代码中与数据库交互，Go 语言开发组并没有为此提供官方的数据库驱动实现，只是提供了数据库交互接口，我们可以通过实现这些接口的第三方扩展包完成与 MySQL 数据库的交互，本项目选择的扩展包是 go-mysql-driver 。 我们可以在 Go 应用中编写模型类基于这个扩展包提供的方法与 MySQL 交互完成增删改查操作，开始之前，可以运行如下命令安装这个依赖： $ go get -u github.com/go-sql-driver/mysql ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3.2 数据库连接 然后在 chitchat/models 目录下创建 db.go，并编写数据库连接初始化方法以及生成 UUID、哈希加密方法： package models import ( \"crypto/rand\" \"crypto/sha256\" \"database/sql\" \"fmt\" \"log\" _ \"github.com/go-sql-driver/mysql\" ) var Db *sql.DB func init() { var err error Db, err = sql.Open(\"mysql\", \"root:root@/chitchat?charset=utf8\u0026parseTime=true\") if err != nil { log.Fatal(err) } } // create a random UUID with from RFC 4122 // adapted from http://github.com/nu7hatch/gouuid func createUUID() (uuid string) { u := new([16]byte) _, err := rand.Read(u[:]) if err != nil { log.Fatalln(\"Cannot generate UUID\", err) } // 0x40 is reserved variant from RFC 4122 u[8] = (u[8] | 0x40) \u0026 0x7F // Set the four most significant bits (bits 12 through 15) of the // time_hi_and_version field to the 4-bit version number. u[6] = (u[6] \u0026 0xF) | (0x4 \u003c\u003c 4) uuid = fmt.Sprintf(\"%x-%x-%x-%x-%x\", u[0:4], u[4:6], u[6:8], u[8:10], u[10:]) return } // hash plaintext with sha-256 func Encrypt(plaintext string) (cryptext string) { cryptext = fmt.Sprintf(\"%x\", sha256.Sum256([]byte(plaintext))) return } 其中，Db 变量代表数据库连接池，通过 init 方法在 Web 应用启动时自动初始化数据库连接，这样，我们就可以在应用中通过 Db 变量对数据库进行增删改查操作了，这也是该变量首字母大写的原因，方便在 models 包之外被引用，具体的操作实现我们放到独立的模型文件中处理。 注：这里通过 sql.Open 初始化数据库连接，我们写死了数据库连接配置，在实际生产环境，这块配置值应该从配置文件或系统环境变量获取。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3.3 用户模型相关类 有了代表数据库连接池的 Db 变量之后，就可以为每个数据表编写对应的模型类实现增删改查操作了，首先在 models 目录下创建 user.go 用于定义用户模型类 User 与 users 表进行交互，以及与 sessions 表进行关联： package models import \"time\" type User struct { Id int Uuid string Name string Email string Password string CreatedAt time.Time } // Create a new session for an existing user func (user *User) CreateSession() (session Session, err error) { statement := \"insert into sessions (uuid, email, user_id, created_at) values (?, ?, ?, ?)\" stmtin, err := Db.Prepare(statement) if err != nil { return } defer stmtin.Close() uuid := createUUID() stmtin.Exec(uuid, user.Email, user.Id, time.Now()) stmtout, err := Db.Prepare(\"select id, uuid, email, user_id, created_at from sessions where uuid = ?\") if err != nil { return } defer stmtout.Close() // use QueryRow to return a row and scan the returned id into the Session struct err = stmtout.QueryRow(uuid).Scan(\u0026session.Id, \u0026session.Uuid, \u0026session.Email, \u0026session.UserId, \u0026session.CreatedAt) return } // Get the session for an existing user func (user *User) Session() (session Session, err error) { session = Session{} err = Db.QueryRow(\"SELECT id, uuid, email, user_id, created_at FROM sessions WHERE user_id = ?\", user.Id). Scan(\u0026session.Id, \u0026session.Uuid, \u0026session.Email, \u0026session.UserId, \u0026session.CreatedAt) return } // Create a new user, save user info into the database func (user *User) Create() (err error) { // Postgres does not automatically return the last insert id, because it would be wrong to assume // you're always using a sequence.You need to use the RETURNING keyword in your insert to get this // information from postgres. statement := \"insert into users (uuid, name, email, password, created_at) values (?, ?, ?, ?, ?)\" stmtin, err := Db.Prepare(statement) if err != nil { return } defer stmtin.Close() uuid := createUUID() stmtin.Exec(uuid, user.Name, user.Email, Encrypt(user.Password), time.Now()) stmtout, err := Db.Prepare(\"select id, uuid, created_at from users where uuid = ?\") if err != nil { return } defer stmtout.Close() // use QueryRow to return a row and scan the returned id into the User struct err = stmtout.QueryRow(uuid).Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.CreatedAt) return } // Delete user from database func (user *User) Delete() (err error) { statement := \"delete from users where id = ?\" stmt, err := Db.Prepare(statement) if err != nil { return } defer stmt.Close() _, err = stmt.Exec(user.Id) return } // Update user information in the database func (user *User) Update() (err error) { statement := \"update users set name = ?, email = ? where id = ?\" stmt, err := Db.Prepare(statement) if err != nil { return } defer stmt.Close() _, err = stmt.Exec(user.Name, user.Email, user.Id) return } // Delete all users from database func UserDeleteAll() (err error) { statement := \"delete from users\" _, err = Db.Exec(statement) return } // Get all users in the database and returns it func Users() (users []User, err error) { rows, err := Db.Query(\"SELECT id, uuid, name, email, password, created_at FROM users\") if err != nil { return } for rows.Next() { user := User{} if err = rows.Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.Password, \u0026user.CreatedAt); err != nil { return } users = append(users, user) } rows.Close() return } // Get a single user given the email func UserByEmail(email string) (user User, err error) { user = User{} err = Db.QueryRow(\"SELECT id, uuid, name, email, password, created_at FROM users WHERE email = ?\", email). Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.Password, \u0026user.CreatedAt) return } // Get a single user given the UUID func UserByUUID(uuid string) (user User, err error) { user = User{} err = Db.QueryRow(\"SELECT id, uuid, name, email, password, created_at FROM users WHERE uuid = ?\", uuid). Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.Password, \u0026user.CreatedAt) return } 创建 session.go 用于定义会话模型类 Session： package models import \"time\" type Session struct { Id int Uuid string Email string UserId int Created","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3.4 主题模型相关类 编写好用户相关模型类后，接下来在同级目录下创建 thread.go，定义群组模型类 Thread 与 threads 表进行交互： package models import \"time\" type Thread struct { Id int Uuid string Topic string UserId int CreatedAt time.Time } // format the CreatedAt date to display nicely on the screen func (thread *Thread) CreatedAtDate() string { return thread.CreatedAt.Format(\"Jan 2, 2006 at 3:04pm\") } // get the number of posts in a thread func (thread *Thread) NumReplies() (count int) { rows, err := Db.Query(\"SELECT count(*) FROM posts where thread_id = ?\", thread.Id) if err != nil { return } for rows.Next() { if err = rows.Scan(\u0026count); err != nil { return } } rows.Close() return } // get posts to a thread func (thread *Thread) Posts() (posts []Post, err error) { rows, err := Db.Query(\"SELECT id, uuid, body, user_id, thread_id, created_at FROM posts where thread_id = ?\", thread.Id) if err != nil { return } for rows.Next() { post := Post{} if err = rows.Scan(\u0026post.Id, \u0026post.Uuid, \u0026post.Body, \u0026post.UserId, \u0026post.ThreadId, \u0026post.CreatedAt); err != nil { return } posts = append(posts, post) } rows.Close() return } // Get all threads in the database and returns it func Threads() (threads []Thread, err error) { rows, err := Db.Query(\"SELECT id, uuid, topic, user_id, created_at FROM threads ORDER BY created_at DESC\") if err != nil { return } for rows.Next() { conv := Thread{} if err = rows.Scan(\u0026conv.Id, \u0026conv.Uuid, \u0026conv.Topic, \u0026conv.UserId, \u0026conv.CreatedAt); err != nil { return } threads = append(threads, conv) } rows.Close() return } // Get a thread by the UUID func ThreadByUUID(uuid string) (conv Thread, err error) { conv = Thread{} err = Db.QueryRow(\"SELECT id, uuid, topic, user_id, created_at FROM threads WHERE uuid = ?\", uuid). Scan(\u0026conv.Id, \u0026conv.Uuid, \u0026conv.Topic, \u0026conv.UserId, \u0026conv.CreatedAt) return } // Get the user who started this thread func (thread *Thread) User() (user User) { user = User{} Db.QueryRow(\"SELECT id, uuid, name, email, created_at FROM users WHERE id = ?\", thread.UserId). Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.CreatedAt) return } 以及 post.go 编写主题模型类与 posts 表进行交互： package models import \"time\" type Post struct { Id int Uuid string Body string UserId int ThreadId int CreatedAt time.Time } func (post *Post) CreatedAtDate() string { return post.CreatedAt.Format(\"Jan 2, 2006 at 3:04pm\") } // Get the user who wrote the post func (post *Post) User() (user User) { user = User{} Db.QueryRow(\"SELECT id, uuid, name, email, created_at FROM users WHERE id = ?\", post.UserId). Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.CreatedAt) return } 此外，我们到 user.go 中为 User 模型新增如下两个方法与 Thread、Post 模型进行关联，用于创建新的群组和主题： // Create a new thread func (user *User) CreateThread(topic string) (conv Thread, err error) { statement := \"insert into threads (uuid, topic, user_id, created_at) values (?, ?, ?, ?)\" stmtin, err := Db.Prepare(statement) if err != nil { return } defer stmtin.Close() uuid := createUUID() stmtin.Exec(uuid, topic, user.Id, time.Now()) stmtout, err := Db.Prepare(\"select id, uuid, topic, user_id, created_at from threads where uuid = ?\") if err != nil { return } defer stmtout.Close() // use QueryRow to return a row and scan the returned id into the Session struct err = stmtout.QueryRow(uuid).Scan(\u0026conv.Id, \u0026conv.Uuid, \u0026conv.Topic, \u0026conv.UserId, \u0026conv.CreatedAt) return } // Create a new post to a thread func (user *User) CreatePost(conv Thread, body string) (post Post, err error) { statement := \"insert into posts (uuid, body, user_id, thread_id, created_at) values (?, ?, ?, ?, ?)\" stmtin, err := Db.Prepare(statement) if err != nil { return } defer stmtin.Close() uuid := createUUID() stmtin.Exec(uuid, body, user.Id, conv.Id, time.Now()) stmtout, err := Db.Prepare(\"select id, uuid, body, user_id, thread_id, created_at from posts where uuid = ?\") if err != nil { return } defer stmtout.Close() // use QueryRow to return a row and scan the returned id into the Session struct err = stmtout.QueryRow(uuid).Scan(\u0026post.Id, \u0026post.Uuid, \u0026post.Body,","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"4. 小结 在上述编写的模型类中，模型类与数据表的映射由 go-mysql-driver 底层实现，每次从数据库查询到结果之后，可以通过 Scan 方法将数据表字段值映射到对应的结构体模型类，而将模型类保存到数据库时，又可以基于字段映射关系将结构体属性值转化为对应的数据表字段值。 底层数据库交互逻辑定义好了之后，接下来，我们就可以编写上层实现代码了，下一篇介绍在线论坛项目上层路由和处理器方法的实现。 mysql下如何执行sql脚本 ↩︎ ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"转自学院君的教程1 ，这里进行复现并深入理解，文章内容可能略有调整。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛1-整体设计与数据模型","uri":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/"},{"categories":["Golang学习之路"],"content":"1. 项目介绍 要完成的是一个简单的在线论坛项目，主要仿照 Google 网上论坛 进行开发，但功能和界面要简化很多，包括 用户认证功能（注册、登录、退出等） 认证后的用户可以创建新的群组（帖子）、以及在群组中发表主题（跟帖） 访客用户访问论坛首页可以查看群组列表，进入指定群组页面可以查看对应的主题信息 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛1-整体设计与数据模型","uri":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/"},{"categories":["Golang学习之路"],"content":"2. 技术方案 采用典型的 MVC 架构2，以群组详情页为例，假设对应的 URL 是 http://chitchat.test/thread/read?id=123，其中 chitchat.test 是请求域名，thread/read 是请求路由（查看群组），?id=123 是请求参数（群组ID），通过域名确定应用所在的服务器 IP，通过端口号（此处没有显式展示，一般默认是 80 端口）确定应用进程，应用接收到请求后，通过路由将请求分发到指定处理器方法（路由器，或者叫做多路复用器做的就是这个工作，是整个应用请求分发的入口），通过请求参数对数据库进行查询，再将视图响应发送给请求用户，如果数据库查询没有结果，则返回 404 响应。这里，数据库承担的是 M 的角色（Model），视图响应承担的是 V 的角色（View），处理器方法承担的是 C 的角色（Controller）： 上图中 Client 代表发起请求的用户，虚框内是部署在服务器已启动的在线论坛应用，Multiplexer 代表路由器（比如 gorilla/mux ），Handler 代表处理器/处理器方法，数据库操作位于处理器方法中，Templates 代表最终展示给用户的经过模板引擎编译过的视图模板。 我们需要在本地按照这个 MVC 架构基于业务流程编写代码，最后将测试过的应用代码编译打包，部署到远程服务器（这样才能被普通用户访问），并启动该应用，等待客户端请求，这样就完成了整个应用开发流程。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛1-整体设计与数据模型","uri":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/"},{"categories":["Golang学习之路"],"content":"3. 数据模型 根据我们之前拟定的需求，至少需要三个模型： 用户（User） 群组（Thread） 主题（Post） 另外，我们在本项目开发时，会把用户会话（Session）也存储到数据库（用于认证），所以需要一个额外的会话模型，此外，为了简化应用，我们不会真的像 Google 网上论坛那样对用户做权限管理，整个应用只包含一种用户类型，并且具备所有操作权限： 学院君，基于 Go 语言开发在线论坛 ↩︎ 知乎，MVC架构模式详细说明以及与三层架构的区别 ↩︎ ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛1-整体设计与数据模型","uri":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/"},{"categories":["Golang学习之路"],"content":"Go 官方提供了database 包，database 包下有 sql/driver。该包用来定义操作数据库的接口，这保证了无论使用哪种数据库，操作方式都是相同的。但 Go 官方并没有提供连接数据库的 driver，如果要操作数据库，还需要第三方的 driver 包。这里介绍 go-mysql-driver 的使用。 ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:0:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"1. 安装 在执行了 go mod 的项目目录下执行如下安装命令 $ go get -u github.com/go-sql-driver/mysql Win10 下，go-sql-driver 包将被安装到 %GOPATH%\\pkg\\mod\\github.com\\go-sql-driver\\mysql@v1.5.0 目录下，其它项目使用时不必重复下载，执行上述命令即可直接引入。 ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:1:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"2. 导入 示例代码如下 import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) Golang 提供了database/sql 包，用于对 SQL 数据库的访问。它提供了一系列接口方法，用于访问关系数据库但并不会提供数据库特有的方法，那些特有的方法交给数据库驱动去实现。 对于数据库操作来说，开发者不应该直接使用导入的驱动包所提供的方法，而应该使用 sql.DB 对象所提供的统一的方法。因此在导入 MySQL 驱动时，使用了匿名导入包的方式，即将 go-sql-driver 包重命名为特殊符号 _。采用这种方式只会执行其中的 init 函数和初始化其全局变量，无法调用函数。 ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:2:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3. 连接数据库 连接数据库使用 sql 包中的 Open() 函数，原型如下 func Open(driverName, dataSourceName string) (*DB, error) driverName：使用的驱动名。这个名字其实就是数据库驱动注册到 database/sql 时所使用的名字 dataSourceName：数据库连接信息。它包含了数据库的用户名、密码、数据库主机以及需要连接的数据库名等信息。 使用示例如下 db, err := sql.Open(\"mysql\", \"用户名:密码@tcp(IP:端口)/数据库?charset=utf8\") sql.Open() 返回的 sql.DB 对象是 Goroutine 并发安全的。sql.DB 通过数据库驱动为开发者提供管理底层数据库连接的打开和关闭操作。sql.DB 帮助开发者管理数据库连接池。正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果开发者没有把连接释放回连接池，会导致过多连接使系统资源耗尽。 sql.DB 的设计目标就是作为长连接（一次连接多次数据交互）使用，不宜频繁开关。比较好的做法是，为每个不同的 datastore 建一个DB 对象，保持这些对象打开。如果需要短连接（一次连接一次数据交互），就把 DB 作为参数传入函数，而不要在函数中开关。 ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:3:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"4. 增删改数据 直接调用DB对象的 Exec() 方法如下所示 func (db *DB) Exec(query string, args ...interface{}) (Result, error) 通过db.Exec()插入数据，通过返回的 err 可知插入失败的原因，通过返回的结果可以进一步查询本次插入数据影响的行数（RowsAffected）和最后插入的ID（如果数据库支持查询最后插入ID）。事实上，Result 是对已执行的 SQL 命令的总结，类型定义如下 type Result interface { // LastInsertId返回一个数据库生成的回应命令的整数。 // 当插入新行时，一般来自一个\"自增\"列。 // 不是所有的数据库都支持该功能，该状态的语法也各有不同。 LastInsertId() (int64, error) // RowsAffected返回被update、insert或delete命令影响的行数。 // 不是所有的数据库都支持该功能。 RowsAffected() (int64, error) } Exec() 方法的使用方式如下所示 result,err := db.Exec(\"INSERT INTO user_info (username, departname, created) VALUES (?,?,?)\", \"Steven\", \"区块链教学部\"， \"2017-10-1\") 预编译语句（PreparedStatement）提供了诸多好处。PreparedStatement 可以实现自定义参数的查询，通常来说比手动拼接字符串SQL语句高效；PreparedStatement 还可以防止SQL注入攻击。因此，开发中应尽量使用它。 通常使用 PreparedStatement 和 Exec() 完成 INSERT、UPDATE、DELETE 操作。使用DB对象的Prepare() 方法获得预编译对象 stmt，然后调用 Exec() 方法，语法如下所示。 func (db *DB) Prepare(query string) (*Stmt, error) 具体用法如下 stmt, err := db.Prepare(\"INSERT INTO user_info SET username=?, departnamt=?, created=?\") result, err := stmt.Exec(\"Jackson\", \"研发部\", \"2017-10-1\") 获取影响数据库的行数，可以根据该数值判断是否操作（插入、删除或修改）成功。语法如下所示。 count, err := result.RowsAffected() 预编译对象 stmt 属于 Stmt 类型，是一个准备好的状态，可以安全地被多个 Goroutine 同时使用，类型定义与方法集如下，定义在 DB 对象上的 Exec 和 Stmt 对象上的 Exec 传入参数有区别，后者不需要 SQL 语句，但作用应该是相同的。 type Stmt struct { // 内含隐藏或非导出字段 } func (s *Stmt) Exec(args ...interface{}) (Result, error) func (s *Stmt) Query(args ...interface{}) (*Rows, error) func (s *Stmt) QueryRow(args ...interface{}) *Row func (s *Stmt) Close() error ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:4:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"5. 查询数据 数据查询的一般步骤如下 调用 db.Query() 方法执行 SQL 语句，此方法返回一个 Rows 作为查询结果，语法如下所示 func (db *DB) Query(query string, args ...interface{}) (*Rows, error) 注意，Rows 作为查询结果，其游标指向结果集的第零行 将 rows.Next() 方法的返回值作为 for 循环的条件，迭代查询数据，语法如下所示。 func (rs *Rows) Next() bool Next 的返回值不是简单的一个对下一个结果是否存在的判断，而是准备下一行结果用于 Scan 方法进行扫描，如果准备好，返回 true，如果没有下一行或准备时出现错误，返回 false 在循环中，通过 rows.Scan()方法读取每一行数据，语法如下所示。 func (rs *Rows) Scan(dest ...interface{}) error rows.Scan() 方法的参数顺序很重要，必须和查询结果的列相对应（数量和顺序都需要一致）。假设 SELECT * From user_info where age ＞=20 AND age ＜ 30 查询的列顺序是 id, name, age，和插入操作顺序相同，rows.Scan() 的参数传入也需要按照此顺序 rows.Scan(＆id, ＆name, ＆age)，不然会造成数据读取的错位。 调用db.Close()关闭查询，Close 关闭 DB对象，释放任何打开的资源，但实际上因为 DB 句柄通常被多个 Go 协程共享，不会被关闭。 查询多行数据的一个完整示例如下所示 stmt, err := db.Prepare(\"SELECT * FROM user_info WHERE uid\u003c?\") rows, err := stmt.Query(10) // 注意这里的 Query 也是 stmt 的方法 user := new(UserTable) for rows.Next() { err := rows.Scan(\u0026user.Uid, \u0026user.Username, \u0026user.Department, \u0026user.Created) if err != nil { panic(err) continue } fmt.Println(*user) } 因为 Golang 是强类型语言，所以查询数据时先定义数据类型。数据库中的数据有3种可能状态：存在值、存在零值、未赋值，因此可以将待查询的数据类型定义为 sql.NullString、sql.NullInt64 类型等。可以通过 Valid 值来判断查询到的值是赋值状态还是未赋值状态。 每次 db.Query() 操作后，都建议调用 rows.Close()。因为 db.Query() 会从数据库连接池中获取一个连接，这个底层连接在结果集（rows）未关闭前会被标记为处于繁忙状态。当遍历读到最后一条记录时，会发生一个内部 EOF 错误，自动调用 rows.Close()。但如果出现异常，提前退出循环，rows 不会关闭，连接不会回到连接池中，连接也不会关闭，则此连接会一直被占用。因此通常使用 defer rows.Close() 来确保数据库连接可以正确放回到连接池中。rows.Close() 操作是幂等操作，而一个幂等操作的特点是：其任意多次执行所产生的影响与一次执行的影响相同。所以即便对已关闭的 rows 再执行 close() 也没关系。 谈到这里，我们可以注意到 Close 方法一共有三种，分别定义在 DB、Stmt、Rows 三个方法上，用于关闭数据库连接、预准备状态和查询结果，不过本质上都是释放某个连接池中的连接。 单条数据通过 QueryRow() 方法查询，语法如下所示。 func (db *DB) QueryRow(query string, args ...interface{}) *Row 使用示例如下 var username, departname, created string err := db.QueryRow(\"SELECT username, departname, created FROM user_info WHERE uid=?\", 3).Scan(\u0026username, \u0026departname, \u0026created) ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:5:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"6. 示例代码 定义一个表结构如下 mysql\u003e CREATE TABLE user_info ( -\u003e uid INT(10) NOT NULL AUTO_INCREMENT, -\u003e username VARCHAR(64) DEFAULT NULL, -\u003e departname VARCHAR(64) DEFAULT NULL, -\u003e created DATE DEFAULT NULL, -\u003e PRIMARY KEY(uid) -\u003e ); Query OK, 0 rows affected, 1 warning (0.03 sec) mysql\u003e DESC user_info; +------------+-------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------+-------------+------+-----+---------+----------------+ | uid | int | NO | PRI | NULL | auto_increment | | username | varchar(64) | YES | | NULL | | | departname | varchar(64) | YES | | NULL | | | created | date | YES | | NULL | | +------------+-------------+------+-----+---------+----------------+ 4 rows in set (0.00 sec) 编写一个完整的测试代码，使用上述提到的所有数据库操作 package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) // 定义数据库连接信息 type DbConn struct { Dsn string // 数据库驱动字符串 Db *sql.DB } // 数据库中的用户表的映射对象 type UserTable struct { Uid int Username string Department string Created string } func main() { var err error dbConn := DbConn{ Dsn: \"root:@tcp(127.0.0.1:3306)/testdb?charset=utf8\", } dbConn.Db, err = sql.Open(\"mysql\", dbConn.Dsn) if err != nil { fmt.Println(err) } defer dbConn.Db.Close() //1. 测试直接使用 DB 的 Exec() 方法增删改 execData(\u0026dbConn) //2. 测试使用预编译语句和 Exec() 方法增删改 preExecData(\u0026dbConn) //3. 查询单行数据(以最后一条数据为例) result := dbConn.QueryRowData(\"select * from user_info where uid = (select max(uid) from user_info)\") fmt.Println(result) //4. 查询多行数据 result1 := dbConn.QueryData(\"select * from user_info where uid\u003c10\") fmt.Println(len(result1)) //5. 查询多行数据（使用预编译语句） result2 := dbConn.PreQueryData(\"select * from user_info where uid\u003c? order by uid desc\", 10) fmt.Println(len(result2)) //遍历查询的结果集 for k, v := range result2 { fmt.Println(\"uid: \", k, v) } } func execData(dbConn *DbConn) { count, id, err := dbConn.ExecData(\"insert user_info (username,departname,created) values ('Josh', 'business group','2020-06-14')\") if err != nil { fmt.Println(err.Error()) } else { fmt.Println(\"受影响的行数：\", count) fmt.Println(\"新添加数据的id：\", id) } } func (dbConn *DbConn) ExecData(sqlString string) (count, id int64, err error) { result, err := dbConn.Db.Exec(sqlString) if err != nil { fmt.Println(err) return } if id, err = result.LastInsertId(); err != nil { fmt.Println(err) return } if count, err = result.RowsAffected(); err != nil { fmt.Println(err) return } return count, id, nil } func preExecData(dbConn *DbConn) { count, id, err := dbConn.PreExecData(\"insert user_info (username,departname,created) values ('Jackson', 'Education Department','2020-06-14')\") if err != nil { fmt.Println(err.Error()) } else { fmt.Println(\"受影响的行数：\", count) fmt.Println(\"新添加数据的id：\", id) } } func (dbConn *DbConn) PreExecData(sqlString string, args ...interface{}) (count, id int64, err error) { stmt, err := dbConn.Db.Prepare(sqlString) defer stmt.Close() if err != nil { fmt.Println(err) return } result, err := stmt.Exec(args...) if err != nil { fmt.Println(err) return } if id, err = result.LastInsertId(); err != nil { fmt.Println(err) return } if count, err = result.RowsAffected(); err != nil { fmt.Println(err) return } return count, id, nil } func (dbConn *DbConn) QueryRowData(sqlString string) (data UserTable) { user := new(UserTable) err := dbConn.Db.QueryRow(sqlString).Scan(\u0026user.Uid, \u0026user.Username, \u0026user.Department, \u0026user.Created) if err != nil { fmt.Println(err) return } return *user } func (dbConn *DbConn) QueryData(sqlString string) (resultSet map[int]UserTable) { rows, err := dbConn.Db.Query(sqlString) defer rows.Close() if err != nil { fmt.Println(err) return } resultSet = make(map[int]UserTable) user := new(UserTable) for rows.Next() { err := rows.Scan(\u0026user.Uid, \u0026user.Username, \u0026user.Department, \u0026user.Created) if err != nil { fmt.Println(err) continue } resultSet[user.Uid] = *user } return resultSet } func (dbConn *DbConn) PreQueryData(sqlString string, args ...interface{}) (resultSet map[int]UserTable) { stmt, err := dbConn.Db.Prepare(sqlString) defer st","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:6:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["爱编程爱技术的孩子"],"content":"本文详细介绍 对表中数据 的增删查改操作。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:0:0","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 查询数据 查询表中数据所涉及的命令是最多的，一个基本的语法格式如下 SELECT {* | \u003c字段列名\u003e} FROM \u003c表 1\u003e, \u003c表 2\u003e… \u003cjoin_type\u003e join \u003cjoin_table\u003e on \u003cjoin_condition\u003e WHERE \u003c表达式\u003e GROUP BY \u003cgroup by definition\u003e HAVING \u003cexpression\u003e [{\u003coperator\u003e \u003cexpression\u003e}…] ORDER BY \u003corder by definition\u003e LIMIT [\u003coffset\u003e,] \u003crow count\u003e 这里简单解释各条子句的含义， SELECT {*|\u003c字段列名\u003e} 表示所要查询字段的名称。 FROM \u003c表 1\u003e，\u003c表 2\u003e…，表示查询数据的来源，可以是单个或多个表。 WHERE \u003c表达式\u003e 限定查询数据必须满足的查询条件。 GROUP BY\u003c 字段 \u003e 告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。 ORDER BY\u003c 字段 \u003e 告诉 MySQL 按什么样的顺序显示查询出来的数据。 LIMIT[，]，该子句告诉 MySQL 每次显示多少条查询出来的数据。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:0","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 基本查询 使用 * 通配符可以查询整个表的数据 SELECT * FROM 表名; 下面的表将是后面所有语句执行的基表 mysql\u003e SELECT * FROM tb_students_info; +----+--------+---------+------+------+--------+------------+ | id | name | dept_id | age | sex | height | login_date | +----+--------+---------+------+------+--------+------------+ | 1 | Dany | 1 | 25 | F | 160 | 2015-09-10 | | 2 | Green | 3 | 23 | F | 158 | 2016-10-22 | | 3 | Henry | 2 | 23 | M | 185 | 2015-05-31 | | 4 | Jane | 1 | 22 | F | 162 | 2016-12-20 | | 5 | Jim | 1 | 24 | M | 175 | 2016-01-15 | | 6 | John | 2 | 21 | M | 172 | 2015-11-11 | | 7 | Lily | 6 | 22 | F | 165 | 2016-02-26 | | 8 | Susan | 4 | 23 | F | 170 | 2015-10-01 | | 9 | Thomas | 3 | 22 | M | 178 | 2016-06-07 | | 10 | Tom | 4 | 23 | M | 165 | 2016-08-05 | +----+--------+---------+------+------+--------+------------+ 10 rows in set (0.26 sec) 如果在 SELECT 命令后指定字段名，则结果只显示这些字段，相当于投影操作 SELECT \u003c字段名1\u003e,\u003c字段名2\u003e,…,\u003c字段名n\u003e FROM \u003c 表名 \u003e; 查询多个字段的示例如下 mysql\u003e SELECT id,name,height -\u003e FROM tb_students_info; +----+--------+--------+ | id | name | height | +----+--------+--------+ | 1 | Dany | 160 | | 2 | Green | 158 | | 3 | Henry | 185 | | 4 | Jane | 162 | | 5 | Jim | 175 | | 6 | John | 172 | | 7 | Lily | 165 | | 8 | Susan | 170 | | 9 | Thomas | 178 | | 10 | Tom | 165 | +----+--------+--------+ 10 rows in set (0.00 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:1","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 条件查询 使用 WHERE 关键字来指定查询条件，相当于选择操作。查询条件可以是： 带比较运算符和逻辑运算符的查询条件 带 IS NULL 或 IS NOT NULL 关键字的查询条件 带 BETWEEN AND 关键字的查询条件 带 IN 或 NOT IN 关键字的查询条件 带 LIKE 关键字的查询条件 查询条件可以是一条，也可以是多条，如下例 # 单一条件 mysql\u003e SELECT name,height FROM tb_students_info -\u003e WHERE height=170; +-------+--------+ | name | height | +-------+--------+ | Susan | 170 | +-------+--------+ 1 row in set (0.17 sec) # 多条件 mysql\u003e SELECT name,age,height FROM tb_students_info -\u003e WHERE age\u003e21 AND height\u003e=175; +--------+------+--------+ | name | age | height | +--------+------+--------+ | Henry | 23 | 185 | | Jim | 24 | 175 | | Thomas | 22 | 178 | +--------+------+--------+ 3 rows in set (0.00 sec) 比较运算符和逻辑运算符的时候大家都很熟悉，下面介绍其它几种运算 空值查询 IS NULL 和 IS NOT NULL 关键字用来进行判空查询，判断某个元组的分量是不是等于 NULL。 这里要注意的是 MySQL 中空值不等于 0，也不等于空字符串。一个使用示例如下 mysql\u003e SELECT `name`,`login_date` FROM tb_students_info -\u003e WHERE login_date IS NULL; +--------+------------+ | NAME | login_date | +--------+------------+ | Dany | NULL | | Green | NULL | | Henry | NULL | | Jane | NULL | | Thomas | NULL | | Tom | NULL | +--------+------------+ 6 rows in set (0.01 sec) 范围查询 BETWEEN AND 关键字用来进行范围查询，判断某个属性是否在指定的范围内，语法格式如下 [NOT] BETWEEN 取值1 AND 取值2 使用示例如下 mysql\u003e SELECT name,age FROM tb_students_info -\u003e WHERE age BETWEEN 20 AND 23; +--------+------+ | name | age | +--------+------+ | Green | 23 | | Henry | 23 | | Jane | 22 | | John | 21 | | Lily | 22 | | Susan | 23 | | Thomas | 22 | | Tom | 23 | +--------+------+ 8 rows in set (0.00 sec) IN/NOT IN MySQL 中的 IN 用来判断表达式的值是否位于给出的列表中；如果是，返回值为 1，否则返回值为 0。语法格式如下 expr IN ( value1, value2, value3 ... valueN ) expr NOT IN ( value1, value2, value3 ... valueN ) 示例如下 SELECT 2 IN (1,3,5,'this'), 'this' NOT IN (1,3,5,'this'); +---------------------+------------------------------+ | 2 IN (1,3,5,'this') | 'this' NOT IN (1,3,5,'this') | +---------------------+------------------------------+ | 0 | 0 | +---------------------+------------------------------+ 1 row in set, 2 warnings (0.00 sec) 当 IN 运算符的两侧有一个为空值 NULL 时，如果找不到匹配项，则返回值为 NULL；如果找到了匹配项，则返回值为 1。 NOT IN 的作用和 IN 恰好相反。 模糊查询 使用 LIKE 关键字可以搜索匹配字段中的指定内容，语法格式如下 [NOT] LIKE '字符串' NOT ：可选参数，字段中的内容与指定的字符串不匹配时满足条件。 字符串：指定用来匹配的字符串。“字符串”可以是一个很完整的字符串，也可以包含通配符。 LIKE 关键字支持百分号 % 和下划线 _ 通配符。 # %通配符,代表任何长度的字符串，字符串的长度可以为 0 mysql\u003e SELECT name FROM tb_students_info -\u003e WHERE name LIKE 'T%'; +--------+ | name | +--------+ | Thomas | | Tom | +--------+ 2 rows in set (0.12 sec) # _通配符,只能代表单个字符，字符的长度不能为 0 mysql\u003e SELECT name FROM tb_students_info -\u003e WHERE name LIKE '____y'; # 4个下划线 +-------+ | name | +-------+ | Henry | +-------+ 1 row in set (0.00 sec) 默认情况下，LIKE 关键字匹配字符的时候是不区分大小写的。如果需要区分大小写，可以加入 BINARY 关键字。 mysql\u003e SELECT name FROM tb_students_info WHERE name LIKE BINARY 't%'; Empty set (0.01 sec) 如果查询内容中包含通配符，可以使用“\\”转义符 mysql\u003e SELECT NAME FROM test.`tb_students_info` WHERE NAME LIKE '%\\%'; +-------+ | NAME | +-------+ | Dany% | +-------+ 1 row in set (0.00 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:2","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 分组查询 通过 WHERE 子句筛选后，可能会使用 GROUP BY 关键字根据一个或多个字段对查询结果进行分组。语法格式如下 GROUP BY \u003c字段名\u003e 其中，\u003c字段名\u003e 表示需要分组的字段名称，多个字段时用逗号隔开。 单个字段分组 单独使用时，查询结果只显示每个分组的第一条记录，但要记得，每个分组一般不会只有这一条记录 mysql\u003e SELECT `name`,`sex` FROM tb_students_info -\u003e GROUP BY sex; +-------+------+ | name | sex | +-------+------+ | Henry | 女 | | Dany | 男 | +-------+------+ 2 rows in set (0.01 sec) 使用 GROUP_CONCAT() 函数可以在一条记录中把该分组所有的结果显示出来 mysql\u003e SELECT `sex`, GROUP_CONCAT(name) FROM tb_students_info -\u003e GROUP BY sex; +------+----------------------------+ | sex | GROUP_CONCAT(name) | +------+----------------------------+ | 女 | Henry,Jim,John,Thomas,Tom | | 男 | Dany,Green,Jane,Lily,Susan | +------+----------------------------+ 2 rows in set (0.00 sec) 多个字段分组 多个字段分组查询时，会先按照第一个字段进行分组。如果第一个字段中有相同的值，MySQL 才会按照第二个字段进行分组。如果第一个字段中的数据都是唯一的，那么 MySQL 将不再对第二个字段进行分组。 mysql\u003e SELECT age,sex,GROUP_CONCAT(name) FROM tb_students_info -\u003e GROUP BY age,sex; +------+------+--------------------+ | age | sex | GROUP_CONCAT(name) | +------+------+--------------------+ | 21 | 女 | John | | 22 | 女 | Thomas | | 22 | 男 | Jane,Lily | | 23 | 女 | Henry,Tom | | 23 | 男 | Green,Susan | | 24 | 女 | Jim | | 25 | 男 | Dany | +------+------+--------------------+ 7 rows in set (0.00 sec) 聚合函数 聚合函数包括 COUNT()，SUM()，AVG()，MAX() 和 MIN()。其中，COUNT() 用来统计记录的条数；SUM() 用来计算字段值的总和；AVG() 用来计算字段值的平均值；MAX() 用来查询字段的最大值；MIN() 用来查询字段的最小值。这些都是分组查询时常用的函数。 mysql\u003e SELECT sex,COUNT(sex) FROM tb_students_info -\u003e GROUP BY sex; +------+------------+ | sex | COUNT(sex) | +------+------------+ | 女 | 5 | | 男 | 5 | +------+------------+ 2 rows in set (0.00 sec) WITH ROLLUP WITH POLLUP 关键字用来在所有记录的最后加上一条记录，这条记录是上面所有记录的总和，即统计记录数量。 mysql\u003e SELECT sex,GROUP_CONCAT(name) FROM tb_students_info -\u003eGROUP BY sex WITH ROLLUP; +------+------------------------------------------------------+ | sex | GROUP_CONCAT(name) | +------+------------------------------------------------------+ | 女 | Henry,Jim,John,Thomas,Tom | | 男 | Dany,Green,Jane,Lily,Susan | | NULL | Henry,Jim,John,Thomas,Tom,Dany,Green,Jane,Lily,Susan | +------+------------------------------------------------------+ 3 rows in set (0.00 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:3","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 过滤分组 在 MySQL 中，可以使用 HAVING 子句对分组后的数据进行过滤。语法格式如下 HAVING \u003c查询条件\u003e HAVING 关键字和 WHERE 关键字都可以用来过滤数据，且 HAVING 支持 WHERE 关键字中所有的操作符和语法。但是 WHERE 和 HAVING 关键字也存在以下几点差异： 一般情况下，WHERE 用于过滤数据行，而 HAVING 用于过滤分组。 WHERE 查询条件中不可以使用聚合函数，而 HAVING 查询条件中可以使用聚合函数。 WHERE 在数据分组前进行过滤，而 HAVING 在数据分组后进行过滤 。 WHERE 查询条件中不可以使用字段别名，而 HAVING 查询条件中可以使用字段别名。 # 使用 WHERE mysql\u003e SELECT name,sex FROM tb_students_info -\u003e WHERE height\u003e150; +--------+------+ | name | sex | +--------+------+ | Dany | 男 | | Green | 男 | | Henry | 女 | | Jane | 男 | | Jim | 女 | | John | 女 | | Lily | 男 | | Susan | 男 | | Thomas | 女 | | Tom | 女 | +--------+------+ 10 rows in set (0.00 sec) # 使用 HAVING mysql\u003e SELECT GROUP_CONCAT(name),sex,height FROM tb_students_info -\u003e GROUP BY height -\u003e HAVING AVG(height)\u003e170; +--------------------+------+--------+ | GROUP_CONCAT(name) | sex | height | +--------------------+------+--------+ | John | 女 | 172 | | Jim | 女 | 175 | | Thomas | 女 | 178 | | Henry | 女 | 185 | +--------------------+------+--------+ 4 rows in set (0.00 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:4","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.5 排序 ORDER BY 关键字用来将查询结果中的数据按照一定的顺序进行排序。其语法格式如下： ORDER BY \u003c字段名\u003e [ASC|DESC] 语法说明如下。 字段名：表示需要排序的字段名称，多个字段时用逗号隔开。 ASC|DESC：ASC表示字段按升序排序；DESC表示字段按降序排序。其中ASC为默认值。 使用 ORDER BY 关键字应该注意以下几个方面： ORDER BY 关键字后可以跟子查询。 当排序的字段中存在空值时，ORDER BY 会将该空值作为最小值来对待。 在对多个字段进行排序时，排序的第一个字段必须有相同的值，才会对第二个字段进行排序。如果第一个字段数据中所有的值都是唯一的，MySQL 将不再对第二个字段进行排序。 # 单字段排序 mysql\u003e SELECT * FROM tb_students_info ORDER BY height; +----+--------+---------+------+------+--------+------------+ | id | name | dept_id | age | sex | height | login_date | +----+--------+---------+------+------+--------+------------+ | 2 | Green | 3 | 23 | F | 158 | 2016-10-22 | | 1 | Dany | 1 | 25 | F | 160 | 2015-09-10 | | 4 | Jane | 1 | 22 | F | 162 | 2016-12-20 | | 7 | Lily | 6 | 22 | F | 165 | 2016-02-26 | | 10 | Tom | 4 | 23 | M | 165 | 2016-08-05 | | 8 | Susan | 4 | 23 | F | 170 | 2015-10-01 | | 6 | John | 2 | 21 | M | 172 | 2015-11-11 | | 5 | Jim | 1 | 24 | M | 175 | 2016-01-15 | | 9 | Thomas | 3 | 22 | M | 178 | 2016-06-07 | | 3 | Henry | 2 | 23 | M | 185 | 2015-05-31 | +----+--------+---------+------+------+--------+------------+ 10 rows in set (0.08 sec) # 多字段排序 mysql\u003e SELECT name,height FROM tb_students_info ORDER BY height,name; +--------+--------+ | name | height | +--------+--------+ | Green | 158 | | Dany | 160 | | Jane | 162 | | Lily | 165 | | Tom | 165 | | Susan | 170 | | John | 172 | | Jim | 175 | | Thomas | 178 | | Henry | 185 | +--------+--------+ 10 rows in set (0.09 sec) 默认情况下，查询数据按字母升序进行排序（A～Z），但数据的排序并不仅限于此，还可以使用 ORDER BY 中的 DESC 对查询结果进行降序排序（Z～A）。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:5","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.6 去重 SELECT 选择属性列后，新表可能出现重复的元组，可以使用 DISTINCT 关键字去重 SELECT DISTINCT \u003c字段名\u003e FROM \u003c表名\u003e; 其中，“字段名”为需要消除重复记录的字段名称，多个字段时用逗号隔开。 使用 DISTINCT 关键字时需要注意以下几点： DISTINCT 关键字只能在 SELECT 语句中使用。 在对一个或多个字段去重时，DISTINCT 关键字必须在所有字段的最前面。 如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重。 示例如下 # 原表 mysql\u003e SELECT * FROM test.student; +----+----------+------+-------+ | id | name | age | stuno | +----+----------+------+-------+ | 1 | zhangsan | 18 | 23 | | 2 | lisi | 19 | 24 | | 3 | wangwu | 18 | 25 | | 4 | zhaoliu | 18 | 26 | | 5 | zhangsan | 18 | 27 | | 6 | wangwu | 20 | 28 | +----+----------+------+-------+ 6 rows in set (0.00 sec) # 对 name 和 age 字段搜索结果去重 mysql\u003e SELECT DISTINCT name,age FROM student; +----------+------+ | name | age | +----------+------+ | zhangsan | 18 | | lisi | 19 | | wangwu | 18 | | zhaoliu | 18 | | wangwu | 20 | +----------+------+ 5 rows in set (0.00 sec) 因为 DISTINCT 只能返回它的目标字段，而无法返回其它字段，所以在实际情况中，我们经常使用 DISTINCT 关键字来返回不重复字段的条数。 mysql\u003e SELECT COUNT(DISTINCT name,age) FROM student; +--------------------------+ | COUNT(DISTINCT name,age) | +--------------------------+ | 5 | +--------------------------+ 1 row in set (0.01 sec) 值得一提的是，聚合函数中也有 DISTINCT 的选项，如下 AVG([distinct] expr) COUNT({*|[distinct] } expr) MAX([distinct] expr) MIN([distinct] expr) SUM([distinct] expr) 这意味着 HAVING 子句也可以出现该关键字，比如 SELECT class FROM courses GROUP BY class HAVING COUNT(DISTINCT student) \u003e= 5 ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:6","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.7 设置别名 当表名或字段名很长或者执行一些特殊查询的时候，为了查询方便，可以使用 AS 关键字来为表和字段指定别名。 注意：表的别名不能与该数据库的其它表同名。字段的别名不能与该表的其它字段同名。在条件表达式中不能使用字段的别名，否则会出现 ERROR 1054 (42S22): Unknown column 这样的错误提示信息。 语法格式如下，其中 AS 关键字可省略，省略后原名和别名用空格隔开 \u003c表名\u003e [AS] \u003c别名\u003e # 为表指定别名 \u003c字段名\u003e [AS] \u003c别名\u003e # 为字段指定别名 示例如下 # 为表指定别名 mysql\u003e SELECT stu.name,stu.height FROM tb_students_info AS stu; +--------+--------+ | name | height | +--------+--------+ | Dany | 160 | | Green | 158 | | Henry | 185 | | Jane | 162 | | Jim | 175 | | John | 172 | | Lily | 165 | | Susan | 170 | | Thomas | 178 | | Tom | 165 | +--------+--------+ 10 rows in set (0.04 sec) # 为字段指定别名 mysql\u003e SELECT name AS student_name, age AS student_age FROM tb_students_info; +--------------+-------------+ | student_name | student_age | +--------------+-------------+ | Dany | 25 | | Green | 23 | | Henry | 23 | | Jane | 22 | | Jim | 24 | | John | 21 | | Lily | 22 | | Susan | 23 | | Thomas | 22 | | Tom | 23 | +--------------+-------------+ 10 rows in set (0.00 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:7","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.8 限制查询结果的条数 使用 LIMIT 关键字限制查询结果返回的条数。LIMIT 关键字有 3 种使用方式，即指定初始位置、不指定初始位置以及与 OFFSET 组合使用。 基本语法格式如下，第一条记录的位置是 0，两个参数必须都是正整数。 LIMIT 初始位置，记录数 示例 mysql\u003e SELECT * FROM tb_students_info LIMIT 3,5; +----+-------+---------+------+------+--------+------------+ | id | name | dept_id | age | sex | height | login_date | +----+-------+---------+------+------+--------+------------+ | 4 | Jane | 1 | 22 | F | 162 | 2016-12-20 | | 5 | Jim | 1 | 24 | M | 175 | 2016-01-15 | | 6 | John | 2 | 21 | M | 172 | 2015-11-11 | | 7 | Lily | 6 | 22 | F | 165 | 2016-02-26 | | 8 | Susan | 4 | 23 | F | 170 | 2015-10-01 | +----+-------+---------+------+------+--------+------------+ 5 rows in set (0.00 sec) 省略初始位置时默认从第一条记录开始，如果表中剩余记录数不够，则返回所有剩余记录 mysql\u003e SELECT * FROM tb_students_info LIMIT 4; +----+-------+---------+------+------+--------+------------+ | id | name | dept_id | age | sex | height | login_date | +----+-------+---------+------+------+--------+------------+ | 1 | Dany | 1 | 25 | F | 160 | 2015-09-10 | | 2 | Green | 3 | 23 | F | 158 | 2016-10-22 | | 3 | Henry | 2 | 23 | M | 185 | 2015-05-31 | | 4 | Jane | 1 | 22 | F | 162 | 2016-12-20 | +----+-------+---------+------+------+--------+------------+ 4 rows in set (0.00 sec) LIMIT 可以和 OFFSET 组合使用，不过仅仅是换了一种写法，没有其它语义 LIMIT 记录数 OFFSET 初始位置 ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:8","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.9 多表查询 前面所讲的查询语句都是针对一个表的，但是在关系型数据库中，表与表之间是有联系的，所以在实际应用中，经常使用多表查询。多表查询就是同时查询两个或两个以上的表，主要有交叉连接、内连接和外连接。 交叉连接 交叉连接（CROSS JOIN）一般用来返回连接表的笛卡尔积。语法格式如下 SELECT \u003c字段名\u003e FROM \u003c表1\u003e CROSS JOIN \u003c表2\u003e [WHERE子句] SELECT \u003c字段名\u003e FROM \u003c表1\u003e, \u003c表2\u003e [WHERE子句] 以上两种语法的返回结果是相同的，但是第一种语法是官方建议的标准写法。 当存在 WHERE 语句时，执行完交叉连接会执行筛选，当没有 WHERE 语句，返回的就是完整的笛卡尔积，但是，不管哪种情况，都会先生成完整的笛卡尔积结果，这个结果中包含的元组数目非常大，所以一般不建议使用交叉连接。 为了减少结果结果中数据行的数目，应尽量使用内连接，内连接使用 ON 关键字设置连接条件。我们从 WHERE 语句 和 ON 语句的执行顺序可以理解这一点，WHERE 在 连接之后执行，而 ON 语句在连接之前进行。 内连接 内连接（INNER JOIN）就是利用条件表达式来消除交叉连接的某些数据行。 内连接使用 INNER JOIN 关键字连接两张表，并使用 ON 子句来设置连接条件。如果没有连接条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的，两者可以互换，因此 ON 子句的作用比较重要。内连接的语法格式如下 SELECT \u003c字段名\u003e FROM \u003c表1\u003e INNER JOIN \u003c表2\u003e [ON子句] 示例 mysql\u003e SELECT s.name,c.course_name FROM tb_students_info s INNER JOIN tb_course c -\u003e ON s.course_id = c.id; +--------+-------------+ | name | course_name | +--------+-------------+ | Dany | Java | | Green | MySQL | | Henry | Java | | Jane | Python | | Jim | MySQL | | John | Go | | Lily | Go | | Susan | C++ | | Thomas | C++ | | Tom | C++ | +--------+-------------+ 10 rows in set (0.00 sec) 注意：当对多个表进行查询时，要在 SELECT 语句后面指定字段是来源于哪一张表。因此，在多表查询时，SELECT 语句后面的写法是表名.列名。另外，如果表名非常长的话，也可以给表设置别名，这样就可以直接在 SELECT 语句后面写上表的别名.列名。 外连接 内连接的查询结果都是符合连接条件的记录，而外连接会先将连接的表分为基表和参考表，再以基表为依据返回满足和不满足条件的记录。外连接可以分为左外连接和右外连接。 左外连接使用 LEFT OUTER JOIN 关键字，语法格式如下 SELECT \u003c字段名\u003e FROM \u003c表1\u003e LEFT OUTER JOIN \u003c表2\u003e \u003cON子句\u003e 上述语法中，“表1”为基表，“表2”为参考表。左外连接查询时，可以查询出“表1”中的所有记录和“表2”中匹配连接条件的记录。如果“表1”的某行在“表2”中没有匹配行，那么在返回结果中，“表2”的字段值均为空值（NULL）。示例如下 # 两张原始表 mysql\u003e SELECT * FROM tb_course; +----+-------------+ | id | course_name | +----+-------------+ | 1 | Java | | 2 | MySQL | | 3 | Python | | 4 | Go | | 5 | C++ | | 6 | HTML | +----+-------------+ 6 rows in set (0.00 sec) mysql\u003e SELECT * FROM tb_students_info; +----+--------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+--------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | | 2 | Green | 23 | 男 | 158 | 2 | | 3 | Henry | 23 | 女 | 185 | 1 | | 4 | Jane | 22 | 男 | 162 | 3 | | 5 | Jim | 24 | 女 | 175 | 2 | | 6 | John | 21 | 女 | 172 | 4 | | 7 | Lily | 22 | 男 | 165 | 4 | | 8 | Susan | 23 | 男 | 170 | 5 | | 9 | Thomas | 22 | 女 | 178 | 5 | | 10 | Tom | 23 | 女 | 165 | 5 | | 11 | LiMing | 22 | 男 | 180 | 7 | +----+--------+------+------+--------+-----------+ 11 rows in set (0.00 sec) # 左外连接查询结果 mysql\u003e SELECT s.name,c.course_name FROM tb_students_info s LEFT OUTER JOIN tb_course c -\u003e ON s.`course_id`=c.`id`; +--------+-------------+ | name | course_name | +--------+-------------+ | Dany | Java | | Henry | Java | | NULL | Java | | Green | MySQL | | Jim | MySQL | | Jane | Python | | John | Go | | Lily | Go | | Susan | C++ | | Thomas | C++ | | Tom | C++ | | LiMing | NULL | +--------+-------------+ 12 rows in set (0.00 sec) 右外连接 是左外连接的反向连接，使用 RIGHT OUTER JOIN 关键字，大致内容相同，不再赘述。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:9","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.10 子查询 子查询指将一个查询语句嵌套在另一个查询语句中，通过这种方式可以实现多表查询。子查询可以在 SELECT、INSERT、UPDATE 和 DELETE 语句中使用，而且可以进行多层嵌套。 子查询可以在使用表达式的任何地方使用，不过在实际开发时出现在 WHERE 子句和 FROM 子句中比较多。语法格式如下 WHERE \u003c表达式\u003e \u003c操作符\u003e (子查询) 其中，操作符可以是比较运算符和 IN、NOT IN、EXISTS、NOT EXISTS 等关键字。 IN | NOT IN：当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回值正好相反。 mysql\u003e SELECT name FROM tb_students_info -\u003e WHERE course_id IN (SELECT id FROM tb_course WHERE course_name = 'Java'); +-------+ | name | +-------+ | Dany | | Henry | +-------+ 2 rows in set (0.01 sec) EXISTS | NOT EXISTS：用于判断子查询的结果集是否为空，若子查询的结果集不为空，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。 mysql\u003e SELECT * FROM tb_students_info -\u003e WHERE EXISTS(SELECT course_name FROM tb_course WHERE id=1); +----+--------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+--------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | | 2 | Green | 23 | 男 | 158 | 2 | | 3 | Henry | 23 | 女 | 185 | 1 | | 4 | Jane | 22 | 男 | 162 | 3 | | 5 | Jim | 24 | 女 | 175 | 2 | | 6 | John | 21 | 女 | 172 | 4 | | 7 | Lily | 22 | 男 | 165 | 4 | | 8 | Susan | 23 | 男 | 170 | 5 | | 9 | Thomas | 22 | 女 | 178 | 5 | | 10 | Tom | 23 | 女 | 165 | 5 | | 11 | LiMing | 22 | 男 | 180 | 7 | +----+--------+------+------+--------+-----------+ 11 rows in set (0.01 sec) 习惯上，外层的 SELECT 查询称为父查询，圆括号中嵌入的查询称为子查询（子查询必须放在圆括号内）。MySQL 在处理上例的 SELECT 语句时，执行流程为：先执行子查询，再执行父查询。 子查询的功能也可以通过表连接完成，但是子查询会使 SQL 语句更容易阅读和编写。一般来说，表连接（内连接和外连接等）都可以用子查询替换，但反过来却不一定，有的子查询不能用表连接来替换。子查询比较灵活、方便、形式多样，适合作为查询的筛选条件，而表连接更适合于查看连接表的数据。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:10","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1.11 正则表达式查询 MySQL 中，使用 REGEXP 关键字指定正则表达式的字符匹配模式，其基本语法格式如下： 属性名 REGEXP '匹配方式' 其中，“属性名”表示需要查询的字段名称；“匹配方式”表示以哪种方式来匹配查询，符合正则表达式的写法。一个示例如下 mysql\u003e SELECT * FROM tb_students_info -\u003e WHERE name REGEXP '^J'; +----+------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+------+------+------+--------+-----------+ | 4 | Jane | 22 | 男 | 162 | 3 | | 5 | Jim | 24 | 女 | 175 | 2 | | 6 | John | 21 | 女 | 172 | 4 | +----+------+------+------+--------+-----------+ 3 rows in set (0.01 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:1:11","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 插入数据 INSERT 语句有两种语法形式，分别是 INSERT…VALUES 语句和 INSERT…SET 语句。 INSERT…VALUES INSERT INTO \u003c表名\u003e [ \u003c列名1\u003e [ , … \u003c列名n\u003e] ] VALUES (值1) [… , (值n) ]; 语法说明如下。 \u003c表名\u003e：指定被操作的表名。 \u003c列名\u003e：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERT\u003c表名\u003eVALUES(…) 即可。 VALUES 或 VALUE 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。 INSERT…SET INSERT INTO \u003c表名\u003e SET \u003c列名1\u003e = \u003c值1\u003e, \u003c列名2\u003e = \u003c值2\u003e, … 此语句用于直接给表中的某些列指定对应的列值，即要插入的数据的列名在 SET 子句中指定，col_name 为指定的列名，等号后面为指定的数据，而对于未指定的列，列值会指定为该列的默认值。 由 INSERT 语句的两种形式可以看出： 使用 INSERT…VALUES 语句可以向表中插入一行数据，也可以插入多行数据； 使用 INSERT…SET 语句可以指定插入行中每列的值，也可以指定部分列的值； INSERT…SELECT 语句向表中插入其他表的数据。 采用 INSERT…SET 语句可以向表中插入部分列的值，这种方式更为灵活； INSERT…VALUES 语句可以一次插入多条数据。 在 MySQL 中，用单条 INSERT 语句处理多个插入要比使用多条 INSERT 语句更快。 当使用单条 INSERT 语句插入多行数据的时候，只需要将每行数据用圆括号括起来即可。 mysql\u003e INSERT INTO tb_courses -\u003e (course_name,course_grade,course_info) -\u003e VALUES('System',3,'Operation System'); Query OK, 1 rows affected (0.08 sec) mysql\u003e SELECT * FROM tb_courses; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | | 2 | Database | 3 | MySQL | | 3 | Java | 4 | Java EE | | 4 | System | 3 | Operating System | +-----------+-------------+--------------+------------------+ 4 rows in set (0.00 sec) 可以使用 INSERT INTO…SELECT…FROM 语句从一个或多个表中取出数据，并将这些数据作为行数据插入另一个表中。 mysql\u003e INSERT INTO tb_courses_new -\u003e (course_id,course_name,course_grade,course_info) -\u003e SELECT course_id,course_name,course_grade,course_info -\u003e FROM tb_courses; Query OK, 4 rows affected (0.17 sec) Records: 4 Duplicates: 0 Warnings: 0 mysql\u003e SELECT * FROM tb_courses_new; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | | 2 | Database | 3 | MySQL | | 3 | Java | 4 | Java EE | | 4 | System | 3 | Operating System | +-----------+-------------+--------------+------------------+ 4 rows in set (0.00 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:2:0","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 修改数据 使用 UPDATE 语句修改单个表，语法格式为： UPDATE \u003c表名\u003e SET 字段 1=值 1 [,字段 2=值 2… ] [WHERE 子句 ] [ORDER BY 子句] [LIMIT 子句] 语法说明如下： \u003c表名\u003e：用于指定要更新的表名称。 SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。 WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。 ORDER BY 子句：可选项。用于限定表中的行被修改的次序。 LIMIT 子句：可选项。用于限定被修改的行数。 注意：修改一行数据的多个列值时，SET 子句的每个值用逗号分开即可。 # 更新所有行的 course_grade 字段值为 4 mysql\u003e UPDATE tb_courses_new -\u003e SET course_grade=4; Query OK, 3 rows affected (0.11 sec) Rows matched: 4 Changed: 3 Warnings: 0 mysql\u003e SELECT * FROM tb_courses_new; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 4 | Computer Network | | 2 | Database | 4 | MySQL | | 3 | Java | 4 | Java EE | | 4 | System | 4 | Operating System | +-----------+-------------+--------------+------------------+ 4 rows in set (0.00 sec) # 更新 course_id 值为 2 的记录，将 course_grade 字段值改为 3.5，将 course_name 字段值改为“DB” mysql\u003e UPDATE tb_courses_new -\u003e SET course_name='DB',course_grade=3.5 -\u003e WHERE course_id=2; Query OK, 1 row affected (0.13 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u003e SELECT * FROM tb_courses_new; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 4 | Computer Network | | 2 | DB | 3.5 | MySQL | | 3 | Java | 4 | Java EE | | 4 | System | 4 | Operating System | +-----------+-------------+--------------+------------------+ 4 rows in set (0.00 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:3:0","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 删除数据 使用 DELETE 语句从单个表中删除数据，语法格式为： DELETE FROM \u003c表名\u003e [WHERE 子句] [ORDER BY 子句] [LIMIT 子句] 语法说明如下： \u003c表名\u003e：指定要删除数据的表名。 ORDER BY 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。 WHERE 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。 LIMIT 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。 注意：在不使用 WHERE 条件的时候，将删除所有数据。 # 删除表中全部数据 mysql\u003e DELETE FROM tb_courses_new; Query OK, 3 rows affected (0.12 sec) mysql\u003e SELECT * FROM tb_courses_new; Empty set (0.00 sec) # 删除 course_id 为 4 的记录 mysql\u003e DELETE FROM tb_courses -\u003e WHERE course_id=4; Query OK, 1 row affected (0.00 sec) mysql\u003e SELECT * FROM tb_courses; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | | 2 | Database | 3 | MySQL | | 3 | Java | 4 | Java EE | +-----------+-------------+--------------+------------------+ 3 rows in set (0.00 sec) TRUNCATE 关键字可以用于完全清空一个表 TRUNCATE [TABLE] 表名 其中，TABLE 关键字可省略。 mysql\u003e TRUNCATE TABLE tb_student_course; Query OK, 0 rows affected (0.04 sec) mysql\u003e SELECT * FROM tb_student_course; Empty set (0.00 sec) TRUNCATE 和 DELETE 的区别 从逻辑上说，TRUNCATE 语句与 DELETE 语句作用相同，但是在某些情况下，两者在使用上有所区别。 DELETE 是 DML 类型的语句；TRUNCATE 是 DDL 类型的语句。它们都用来清空表中的数据。 DELETE 是逐行一条一条删除记录的；TRUNCATE 则是直接删除原来的表，再重新创建一个一模一样的新表，而不是逐行删除表中的数据，执行数据比 DELETE 快。因此需要删除表中全部的数据行时，尽量使用 TRUNCATE 语句， 可以缩短执行时间。 DELETE 删除数据后，配合事件回滚可以找回数据；TRUNCATE 不支持事务的回滚，数据删除后无法找回。 DELETE 删除数据后，系统不会重新设置自增字段的计数器；TRUNCATE 清空表记录后，系统会重新设置自增字段的计数器。 DELETE 的使用范围更广，因为它可以通过 WHERE 子句指定条件来删除部分数据；而 TRUNCATE 不支持 WHERE 子句，只能删除整体。 DELETE 会返回删除数据的行数，但是 TRUNCATE 只会返回 0，没有任何意义。 总结 当不需要该表时，用 DROP；当仍要保留该表，但要删除所有记录时，用 TRUNCATE；当要删除部分记录时，用 DELETE ","date":"2020-05-24","objectID":"/2020/mysql-learning-6-data-query-language/:4:0","tags":["计算机基础"],"title":"Mysql学习6-操作表中数据","uri":"/2020/mysql-learning-6-data-query-language/"},{"categories":["爱编程爱技术的孩子"],"content":"约束是一种限制，它通过限制表中的数据，来确保数据的完整性和唯一性。本文介绍 MySQL 的约束和运算符。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:0:0","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 约束 MySQL 主要支持 6 种约束 主键约束：唯一标识该表中的每条信息。例如，学生信息表中的学号是唯一的。 外键约束：经常和主键约束一起使用，用来确保数据的一致性。 唯一约束：保证列的唯一性，但与主键约束不同的是，可以为表中多个字段设置唯一约束，并且设置唯一约束的列是允许有空值的，虽然只能有一个空值。 检查约束：检查数据表中字段值是否有效 非空约束：约束表中的字段不能为空 默认值约束：用来约束当数据表中某个字段不输入值时，自动为其添加一个已经设置好的值。通常用在已经设置了非空约束的列，这样能够防止数据表在录入数据时出现错误。 以上 6 种约束中，一个数据表中只能有一个主键约束，其它约束可以有多个。使用 SHOW CREATE TABLE 语句可查看表中的约束。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:1:0","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 主键 主键分为单字段主键和多字段联合主键，联合主键指一张表的主键由多个字段组成，比如学生选课数据表，学生编号和课程编号都不能单独作为主键，因为要限定一个学生只能选择同一课程一次，要将两者一起作为主键。不论哪种情况，每个表只能定义一个主键 创建表时设置 使用 PRIMARY KEY 关键字在定义字段时指定主键，适用于单字段主键设置，语法格式如下 \u003c字段名\u003e \u003c数据类型\u003e PRIMARY KEY [默认值] 示例 mysql\u003e CREATE TABLE tb_emp3 -\u003e ( -\u003e id INT(11) PRIMARY KEY, -\u003e name VARCHAR(25), -\u003e deptId INT(11), -\u003e salary FLOAT -\u003e ); Query OK, 0 rows affected (0.37 sec) 或者在定义完所有字段后指定，多字段主键设置只能用这种方法。语法格式如下 [CONSTRAINT \u003c约束名\u003e] PRIMARY KEY [字段名] 示例 # 单字段主键设置 mysql\u003e CREATE TABLE tb_emp4 -\u003e ( -\u003e id INT(11), -\u003e name VARCHAR(25), -\u003e deptId INT(11), -\u003e salary FLOAT, -\u003e PRIMARY KEY(id) -\u003e ); Query OK, 0 rows affected (0.37 sec) # 多字段主键设置 mysql\u003e CREATE TABLE tb_emp5 -\u003e ( -\u003e name VARCHAR(25), -\u003e deptId INT(11), -\u003e salary FLOAT, -\u003e PRIMARY KEY(id,deptId) -\u003e ); Query OK, 0 rows affected (0.37 sec) 修改表时设置 主键约束可在修改表时添加，应保证原表没有主键，要设置成主键的字段没有空值且没有重复，语法格式如下 ALTER TABLE \u003c数据表名\u003e ADD PRIMARY KEY(\u003c字段名\u003e); 示例 mysql\u003e ALTER TABLE tb_emp2 -\u003e ADD PRIMARY KEY(id); Query OK, 0 rows affected (0.94 sec) Records: 0 Duplicates: 0 Warnings: 0 删除主键 语法格式如下 ALTER TABLE \u003c数据表名\u003e DROP PRIMARY KEY; 主键自增长 给字段添加 AUTO_INCREMENT 属性可以实现主键自增长，语法格式如下 字段名 数据类型 AUTO_INCREMENT 默认情况下，AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1。 一个表中只能有一个字段使用 AUTO_INCREMENT 约束，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）。 AUTO_INCREMENT 约束的字段必须具备 NOT NULL 属性。 AUTO_INCREMENT 约束的字段只能是整数类型（TINYINT、SMALLINT、INT、BIGINT 等）。 AUTO_INCREMENT 约束字段的最大值受该字段的数据类型约束，如果达到上限，AUTO_INCREMENT 就会失效。 示例 mysql\u003e CREATE TABLE tb_student( -\u003e id INT(4) PRIMARY KEY AUTO_INCREMENT, -\u003e name VARCHAR(25) NOT NULL -\u003e ); Query OK, 0 rows affected (0.07 sec) 如果第一条记录设置了该字段的初始值，那么新增加的记录就从这个初始值开始自增。 mysql\u003e CREATE TABLE tb_student2 ( -\u003e id INT NOT NULL AUTO_INCREMENT, -\u003e name VARCHAR(20) NOT NULL, -\u003e PRIMARY KEY(ID) -\u003e )AUTO_INCREMENT=100; Query OK, 0 rows affected (0.03 sec) # 插入的数据从100开始增加，而不是1 ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:1:1","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 外键 对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。主表删除某条记录时，从表中与之对应的记录也必须有相应的改变。一些规则如下 主表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。 必须为主表定义主键。 一个表可以有一个或多个外键。 主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。 从表的外键关联的必须是主表的主键，且主键和外键的数据类型必须一致。 可在创建表时使用 FOREIGN KEY 指定外键，语法格式如下 [CONSTRAINT \u003c外键名\u003e] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES \u003c主表名\u003e 主键列1 [，主键列2，…] 示例 # 创建主表 mysql\u003e CREATE TABLE tb_dept1 -\u003e ( -\u003e id INT(11) PRIMARY KEY, -\u003e name VARCHAR(22) NOT NULL, -\u003e location VARCHAR(50) -\u003e ); Query OK, 0 rows affected (0.37 sec) # 创建从表并设定外键 mysql\u003e CREATE TABLE tb_emp6 -\u003e ( -\u003e id INT(11) PRIMARY KEY, -\u003e name VARCHAR(25), -\u003e deptId INT(11), -\u003e salary FLOAT, -\u003e CONSTRAINT fk_emp_dept1 -\u003e FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -\u003e ); Query OK, 0 rows affected (0.37 sec) 也可在修改表时添加外键约束，前提是从表中外键列中的数据必须与主表中主键列中的数据一致或者是没有数据。语法格式如下 ALTER TABLE \u003c数据表名\u003e ADD CONSTRAINT \u003c外键名\u003e FOREIGN KEY(\u003c列名\u003e) REFERENCES \u003c主表名\u003e (\u003c列名\u003e); 示例 mysql\u003e ALTER TABLE tb_emp2 -\u003e ADD CONSTRAINT fk_tb_dept1 -\u003e FOREIGN KEY(deptId) -\u003e REFERENCES tb_dept1(id); Query OK, 0 rows affected (1.38 sec) Records: 0 Duplicates: 0 Warnings: 0 删除外键约束语法如下 ALTER TABLE \u003c表名\u003e DROP FOREIGN KEY \u003c外键约束名\u003e; ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:1:2","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 唯一约束 使字段值不能重复出现，一张表主键约束只有一个，唯一约束可有多个，虽然允许有空值，但只能有一个。 可在创建表时使用 UNIQUE 关键字指定，如下示例 mysql\u003e CREATE TABLE tb_dept2 -\u003e ( -\u003e id INT(11) PRIMARY KEY, -\u003e name VARCHAR(22) UNIQUE, -\u003e location VARCHAR(50) -\u003e ); Query OK, 0 rows affected (0.37 sec) 也可在修改表时使用如下语法 ALTER TABLE \u003c数据表名\u003e ADD CONSTRAINT \u003c唯一约束名\u003e UNIQUE(\u003c列名\u003e); 示例 mysql\u003e ALTER TABLE tb_dept1 -\u003e ADD CONSTRAINT unique_name UNIQUE(name); Query OK, 0 rows affected (0.63 sec) Records: 0 Duplicates: 0 Warnings: 0 删除唯一约束的语法如下 ALTER TABLE \u003c表名\u003e DROP INDEX \u003c唯一约束名\u003e; ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:1:3","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 检查约束 检查字段有效性，使用 SQL 表达式指定需要检查的条件，放在某个列的定义后称为基于列的 CHECK 约束，放在所有列的定义以及主键约束和外键定义之后，称为基于表的 CHECK 约束 创建表时使用 CHECK 关键字指定 mysql\u003e CREATE TABLE tb_emp7 -\u003e ( -\u003e id INT(11) PRIMARY KEY, -\u003e name VARCHAR(25), -\u003e deptId INT(11), -\u003e salary FLOAT, -\u003e CHECK(salary\u003e0 AND salary\u003c100), -\u003e FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -\u003e ); Query OK, 0 rows affected (0.37 sec) 修改表时使用如下语法 ALTER TABLE tb_emp7 ADD CONSTRAINT \u003c检查约束名\u003e CHECK(\u003c检查约束\u003e) 示例 mysql\u003e ALTER TABLE tb_emp7 -\u003e ADD CONSTRAINT check_id -\u003e CHECK(id\u003e0); Query OK, 0 rows affected (0.19 sec) Records: 0 Duplicates: 0 Warnings: 0 删除检查约束的语法如下 ALTER TABLE \u003c数据表名\u003e DROP CONSTRAINT \u003c检查约束名\u003e; ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:1:4","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"1.5 默认值 创建表时使用 DEFAULT 关键字设定默认值 mysql\u003e CREATE TABLE tb_dept3 -\u003e ( -\u003e id INT(11) PRIMARY KEY, -\u003e name VARCHAR(22), -\u003e location VARCHAR(50) DEFAULT 'Beijing' -\u003e ); Query OK, 0 rows affected (0.37 sec) 修改表时使用如下语法 ALTER TABLE \u003c数据表名\u003e CHANGE COLUMN \u003c字段名\u003e \u003c数据类型\u003e DEFAULT \u003c默认值\u003e; 示例 mysql\u003e ALTER TABLE tb_dept3 -\u003e CHANGE COLUMN location -\u003e location VARCHAR(50) DEFAULT 'Shanghai'; Query OK, 0 rows affected (0.15 sec) Records: 0 Duplicates: 0 Warnings: 0 删除默认值的语法如下 ALTER TABLE \u003c数据表名\u003e CHANGE COLUMN \u003c字段名\u003e \u003c字段名\u003e \u003c数据类型\u003e DEFAULT NULL; 示例 mysql\u003e ALTER TABLE tb_dept3 -\u003e CHANGE COLUMN location -\u003e location VARCHAR(50) DEFAULT NULL; Query OK, 0 rows affected (0.15 sec) Records: 0 Duplicates: 0 Warnings: 0 ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:1:5","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"1.6 非空约束 创建表时使用 NOT NULL 关键字设置非空约束 mysql\u003e CREATE TABLE tb_dept4 -\u003e ( -\u003e id INT(11) PRIMARY KEY, -\u003e name VARCHAR(22) NOT NULL, -\u003e location VARCHAR(50) -\u003e ); Query OK, 0 rows affected (0.37 sec) 修改表时使用如下语法 ALTER TABLE \u003c数据表名\u003e CHANGE COLUMN \u003c字段名\u003e \u003c字段名\u003e \u003c数据类型\u003e NOT NULL; 删除非空约束语法如下 ALTER TABLE \u003c数据表名\u003e CHANGE COLUMN \u003c字段名\u003e \u003c字段名\u003e \u003c数据类型\u003e NULL; ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:1:6","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 运算符 在 MySQL 中，可以通过运算符来获取表结构以外的另一种数据。例如，学生表中存在一个 birth 字段，这个字段表示学生的出生年份。如果想得到这个学生的实际年龄，可以使用 MySQL 中的算术运算符用当前的年份减学生出生的年份，求出的结果就是这个学生的实际年龄了。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:2:0","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 常用运算符 MySQL 支持的 4 种运算符分别是 算术运算符：加减乘除、取余 比较运算符：等于、安全的等于（\u003c=\u003e）、不等于、大于等于、大于、小于等于、小于、 IS NULL、IS NOT NULL、BETWEEN AND 逻辑运算符：与、或、非、异或 位运算符：按位与、按位或、按位取反、按位异或、按位左移、按位右移 算术运算示例如下 # 创建和插入数据 CREATE TABLE temp(num INT); INSERT INTO temp VALUE (64); # 利用运算符查看 mysql\u003e SELECT num, num+10, num-2.4, num*2, num/2, num%3, MOD (num,3), num/0, num%0 FROM temp; +------+--------+---------+-------+---------+-------+-------------+-------+-------+ | num | num+10 | num-2.4 | num*2 | num/2 | num%3 | MOD (num,3) | num/0 | num%0 | +------+--------+---------+-------+---------+-------+-------------+-------+-------+ | 64 | 74 | 61.6 | 128 | 32.0000 | 1 | 1 | NULL | NULL | +------+--------+---------+-------+---------+-------+-------------+-------+-------+ 1 row in set (0.01 sec) 可以注意到以下几点 无法整除时保留小数点后4位 取余有两种写法 除数为 0 没有意义返回 NULL 逻辑运算符示例如下 SELECT NOT 1, NOT NULL, !0, 1 AND 0, 1 OR 0, 1 XOR 0; +-------+----------+----+---------+--------+---------+ | NOT 1 | NOT NULL | !0 | 1 AND 0 | 1 OR 0 | 1 XOR 0 | +-------+----------+----+---------+--------+---------+ | 0 | NULL | 1 | 0 | 1 | 1 | +-------+----------+----+---------+--------+---------+ 1 row in set, 1 warning (0.00 sec) 注意到以下几点 逻辑非有 NOT 和 ! 两种写法，逻辑与有 AND 和 \u0026\u0026 两种写法，逻辑或有 OR 和 || 两种写法，逻辑异或只有 XOR 一种写法 操作数为 NULL，返回值与 NULL 相关，操作数为 0 ，返回值与 0 相关，这是两种不同情况 比较运算符示例如下 mysql\u003e SELECT 1=0, NULL\u003c=\u003eNULL, 1 != 2, 1 \u003c= 2, 1 \u003e= 2, 1 IS NULL, 1 IS NOT NULL, 1 BETWEEN 1 AND 3; +-----+-------------+--------+--------+--------+-----------+---------------+-------------------+ | 1=0 | NULL\u003c=\u003eNULL | 1 != 2 | 1 \u003c= 2 | 1 \u003e= 2 | 1 IS NULL | 1 IS NOT NULL | 1 BETWEEN 1 AND 3 | +-----+-------------+--------+--------+--------+-----------+---------------+-------------------+ | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | +-----+-------------+--------+--------+--------+-----------+---------------+-------------------+ 1 row in set (0.00 sec) 注意到 \u003c=\u003e 指安全的等于，用来判断 NULL 值，使结果返回 1 或 0 而不是 NULL； BETWEEN AND 判断的数可以位于区间边界； 位运算符示例如下 mysql\u003e SELECT 10|15, 10\u002615, 10^15, 1\u003c\u003c2, 1\u003e\u003e1, ~1; +-------+-------+-------+------+------+----------------------+ | 10|15 | 10\u002615 | 10^15 | 1\u003c\u003c2 | 1\u003e\u003e1 | ~1 | +-------+-------+-------+------+------+----------------------+ | 15 | 10 | 5 | 4 | 0 | 18446744073709551614 | +-------+-------+-------+------+------+----------------------+ 1 row in set (0.00 sec) 位运算一般用于操作整数，对整数进行位运算才有实际的意义。整数在内存中是以补码形式存储的，正数的补码形式和原码形式相同，而负数的补码形式和它的原码形式是不一样的，这意味着对负数进行位运算时，操作的是它的补码，而不是它的原码。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:2:1","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 运算符优先级表 优先级由低到高排列 运算符 1 =(赋值运算）、:= 2 II、OR 3 XOR 4 \u0026\u0026、AND 5 NOT 6 BETWEEN、CASE、WHEN、THEN、ELSE 7 =(比较运算）、\u003c=\u003e、\u003e=、\u003e、\u003c=、\u003c、\u003c\u003e、!=、 IS、LIKE、REGEXP、IN 8 | 9 \u0026 10 «、» 11 -(减号）、+ 12 *、/、% 13 ^ 14 -(负号）、〜（位反转） 15 ! ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:2:2","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 IN 和 NOT IN MySQL 中的 IN 运算符用来判断表达式的值是否位于给出的列表中；如果是，返回值为 1，否则返回值为 0。NOT IN 的作用和 IN 恰好相反。语法格式如下 expr IN ( value1, value2, value3 ... valueN ) expr NOT IN ( value1, value2, value3 ... valueN ) 示例如下 SELECT 2 IN (1,3,5,'this'), 'this' NOT IN (1,3,5,'this'); +---------------------+------------------------------+ | 2 IN (1,3,5,'this') | 'this' NOT IN (1,3,5,'this') | +---------------------+------------------------------+ | 0 | 0 | +---------------------+------------------------------+ 1 row in set, 2 warnings (0.00 sec) 当 IN 运算符的两侧有一个为空值 NULL 时，如果找不到匹配项，则返回值为 NULL；如果找到了匹配项，则返回值为 1。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:2:3","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"3. MySQL 函数 MySQL 提供了一些内部函数帮助用户更方便地处理表中数据，包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数和加密函数等。SELECT、INSERT、UPDATE 和 DELETE 语句及其子句（例如 WHERE、ORDER BY、HAVING 等）中都可以使用 MySQL 函数。实际应用时可以查阅： MySQL 常用函数汇总 MySQL 官方参考文档 ","date":"2020-05-24","objectID":"/2020/mysql-learning-5-constraints-and-operators/:3:0","tags":["计算机基础"],"title":"Mysql学习5-约束与运算符","uri":"/2020/mysql-learning-5-constraints-and-operators/"},{"categories":["爱编程爱技术的孩子"],"content":"介绍数据表的基本操作，主要包括创建数据表、查看数据表结构、修改数据表和删除数据表等。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-4-data-manipulation-language/:0:0","tags":["计算机基础"],"title":"Mysql学习4-数据表操作","uri":"/2020/mysql-learning-4-data-manipulation-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 创建 创建数据表的语法格式为 CREATE TABLE \u003c表名\u003e ([表定义选项])[表选项][分区选项]; 其中，[表定义选项]的格式为： \u003c列名1\u003e \u003c类型1\u003e [,…] \u003c列名n\u003e \u003c类型n\u003e 语句的主要语法及使用说明如下： CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。 \u003c表名\u003e：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，‘mydb’.‘mytbl’ 是合法的，但 ‘mydb.mytbl’ 不合法。 \u003c表定义选项\u003e：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。 默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。 示例如下 mysql\u003e USE test_db; Database changed mysql\u003e CREATE TABLE tb_emp1 -\u003e ( -\u003e id INT(11), -\u003e name VARCHAR(25), -\u003e deptId INT(11), -\u003e salary FLOAT -\u003e ); Query OK, 0 rows affected (0.37 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-4-data-manipulation-language/:1:0","tags":["计算机基础"],"title":"Mysql学习4-数据表操作","uri":"/2020/mysql-learning-4-data-manipulation-language/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 查看 使用 SHOW TABLES 查看数据表 mysql\u003e SHOW TABLES; +--------------------+ | Tables_in_test_db | +--------------------+ | tb_emp1 | +--------------------+ 1 rows in set (0.00 sec) 使用 DESCRIBE/DESC \u003c表名\u003e 查看表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等 mysql\u003e DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(25) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.14 sec) 其中，各个字段的含义如下： Null：表示该列是否可以存储 NULL 值。 Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，值是多少。 Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。 使用 SHOW CREATE TABLE \u003c表名\u003e 显示创建表时的CREATE TABLE语句、存储引擎和字符编码，末尾使用 \\G 可以使显示结果更规整 mysql\u003e SHOW CREATE TABLE tb_emp1\\G *************************** 1. row *************************** Table: tb_emp1 Create Table: CREATE TABLE `tb_emp1` ( `id` int(11) DEFAULT NULL, `name` varchar(25) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 1 row in set (0.03 sec) ","date":"2020-05-24","objectID":"/2020/mysql-learning-4-data-manipulation-language/:2:0","tags":["计算机基础"],"title":"Mysql学习4-数据表操作","uri":"/2020/mysql-learning-4-data-manipulation-language/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 修改 修改表指的是修改数据库中已经存在的数据表的结构，例如增加或删减列、更改原有列类型、重新命名列或表等，前提是数据库中已经存在该表。语法格式如下 ALTER TABLE \u003c表名\u003e [修改选项] 修改选项的语法格式如下 { ADD COLUMN \u003c列名\u003e \u003c类型\u003e | CHANGE COLUMN \u003c旧列名\u003e \u003c新列名\u003e \u003c新列类型\u003e | ALTER COLUMN \u003c列名\u003e { SET DEFAULT \u003c默认值\u003e | DROP DEFAULT } | MODIFY COLUMN \u003c列名\u003e \u003c类型\u003e | DROP COLUMN \u003c列名\u003e | RENAME TO \u003c新表名\u003e | CHARACTER SET \u003c字符集名\u003e | COLLATE \u003c校对规则名\u003e } 一些示例如下 ALTER TABLE \u003c旧表名\u003e RENAME [TO] \u003c新表名\u003e; # 修改表名 ALTER TABLE 表名 [DEFAULT] CHARACTER SET \u003c字符集名\u003e [DEFAULT] COLLATE \u003c校对规则名\u003e; # 修改表字符集 一个具体的修改字段名的例子如下 mysql\u003e ALTER TABLE tb_emp1 -\u003e CHANGE col1 col3 CHAR(30); Query OK, 0 rows affected (0.76 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u003e DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | col3 | char(30) | YES | | NULL | | | id | int(11) | YES | | NULL | | | name | varchar(30) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 5 rows in set (0.01 sec) 有意思的是，添加字段时可以选择位置 mysql\u003e ALTER TABLE student ADD age INT(4); # 默认在末尾添加 mysql\u003e ALTER TABLE student ADD stuId INT(4) FIRST; # 在开头添加 mysql\u003e ALTER TABLE student ADD stuno INT(11) AFTER name; # 在中间位置添加 ","date":"2020-05-24","objectID":"/2020/mysql-learning-4-data-manipulation-language/:3:0","tags":["计算机基础"],"title":"Mysql学习4-数据表操作","uri":"/2020/mysql-learning-4-data-manipulation-language/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 删除 删除数据表的语法格式如下 DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...] 在删除表的同时，表的结构和表中所有的数据都会被删除，因此在删除数据表之前最好先备份，以免造成无法挽回的损失。不过应注意 用户必须拥有执行 DROP TABLE 命令的权限，否则数据表不会被删除。 表被删除时，用户在该表上的权限不会自动删除。 数据表之间还经常存在外键关联的情况，这时如果直接删除父表，会破坏数据表的完整性，也会删除失败。此时有以下两种方法： 先删除与它关联的子表，再删除父表；但是这样会同时删除两个表中的数据。 将关联表的外键约束取消，再删除父表；适用于需要保留子表的数据，只删除父表的情况。 假设tb_emp5 表为子表，具有名称为 fk_emp4_emp5 的外键约束；tb_emp4 为父表，其主键 id 被子表 tb_ emp5 所关联。删除被数据表 tb_emp5 关联的数据表 tb_emp4，SQL 语句如下： # 解除外键约束 mysql\u003e ALTER TABLE tb_emp5 DROP FOREIGN KEY fk_emp4_emp5; Query OK, 0 rows affected (0.03 sec) Records: 0 Duplicates: 0 Warnings: 0 # 删除父表 mysql\u003e DROP TABLE tb_emp4; ","date":"2020-05-24","objectID":"/2020/mysql-learning-4-data-manipulation-language/:4:0","tags":["计算机基础"],"title":"Mysql学习4-数据表操作","uri":"/2020/mysql-learning-4-data-manipulation-language/"},{"categories":["爱编程爱技术的孩子"],"content":"存储引擎决定数据表的类型，数据表的字段则有自己的数据类型。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:0:0","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 数据类型 MySQL 的数据类型有大概可以分为 4 种 数值类型：包括整数类型 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型 FLOAT 和 DOUBLE，定点数类型 DECIMAL 日期/时间类型：包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:1:0","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 数值类型 整数类型大小如下表 类型名称 说明 存储需求 TINYINT 很小的整数 1个字节 SMALLINT 小的整数 2个宇节 MEDIUMINT 中等大小的整数 3个字节 INT (INTEGHR) 普通大小的整数 4个字节 BIGINT 大整数 8个字节 浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 默认为 （10，0）。类型大小如下表 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:1:1","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 日期/时间类型 整体情况如下表所示 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。 TIMESTAMP 与 DATETIME 最大区别是： DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关； 而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:1:2","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 字符串类型 下表中列出了 MySQL 中的字符串数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1\u003c=M\u003c=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L\u003c = M和 1\u003c=M\u003c=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L\u003c2^8 TEXT 小的非二进制字符串 L+2字节，在此，L\u003c2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L\u003c2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L\u003c2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） ENUM ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下： \u003c字段名\u003e ENUM( '值1', '值1', …, '值n' ) 取值时在指定的枚举列表中使用索引获取，一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。 列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。 ENUM 值依照列索引顺序排列，空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。 如果将 ENUM 列声明为 NULL，默认值为 NULL。如果被声明为 NOT NULL，默认值为允许的值列表的第 1 个元素。 SET SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下： SET( '值1', '值2', …, '值n' ) 与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。 但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。 如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:1:3","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 二进制类型 MySQL 支持两类字符型数据：文本字符串和二进制字符串。文本字符串就是上一小节介绍的内容，二进制字符串就是本节介绍的「二进制类型」。下表中列出了 MySQL 中的二进制数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L\u003c2^8 BLOB (M) 小 BLOB L+2 字节，在此，L\u003c2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L\u003c2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L\u003c2^32 ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:1:4","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 存储引擎 存储引擎可理解为表的类型，决定了数据表在计算机中的存储方式。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。 MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:2:0","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 常见类型 使用 SHOW ENGINES; 语句查看系统所支持的引擎类型 mysql\u003e show engines; +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | MyISAM | YES | MyISAM storage engine | NO | NO | NO | | InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO | | ARCHIVE | YES | Archive storage engine | NO | NO | NO | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ 9 rows in set (0.01 sec) 简单介绍如下 存储引擎 描述 ARCHIVE 用于数据存档的引擎，数据被插入后就不能在修改了，且不支持索引。 CSV 在存储数据时，会以逗号作为数据项之间的分隔符。 BLACKHOLE 会丢弃写操作，该操作会返回空内容。 FEDERATED 将数据存储在远程数据库中，用来访问远程表的存储引擎。 InnoDB 具备外键支持功能的事务处理引擎 MEMORY 置于内存的表 MRG_MYISAM 用来管理由多个 MyISAM 表构成的表集合 MyISAM 主要的非事务处理存储引擎 NDB MySQL 集群专用存储引擎 ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:2:1","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 操作 对默认存储引擎操作语句格式如下 SHOW VARIABLES LIKE 'default_storage_engine%'; # 查看默认存储引擎 SET default_storage_engine=\u003c 存储引擎名 \u003e # 设置默认存储引擎 引擎选择的原则如下 MyISAM 存储引擎不支持事务和外键，所以访问速度比较快。如果应用主要以读取和写入为主，只有少量的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择 MyISAM 存储引擎是非常适合的。MyISAM 是在 Web 数据仓储和其他应用环境下最常使用的存储引擎之一。 InnoDB 存储引擎在事务上具有优势，即支持具有提交、回滚和崩溃恢复能力的事务安装，所以比 MyISAM 存储引擎占用更多的磁盘空间。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎是比较合适的。InnoDB 存储引擎除了可以有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。 MEMORY 存储引擎将所有数据保存在 RAM 中，所以该存储引擎的数据访问速度快，但是安全上没有保障。MEMORY 对表的大小有限制，太大的表无法缓存在内存中。由于使用 MEMORY 存储引擎没有安全保障，所以要确保数据库异常终止后表中的数据可以恢复。如果应用中涉及数据比较少，且需要进行快速访问，则适合使用 MEMORY 存储引擎。 修改数据表的存储引擎的语法格式如下 ALTER TABLE \u003c表名\u003e ENGINE=\u003c存储引擎名\u003e; ","date":"2020-05-24","objectID":"/2020/mysql-learning-3-data-type-and-storage-engine/:2:2","tags":["计算机基础"],"title":"Mysql学习3-数据类型和存储引擎","uri":"/2020/mysql-learning-3-data-type-and-storage-engine/"},{"categories":["爱编程爱技术的孩子"],"content":"本文介绍对数据库的操作，包括创建、删除、修改等。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-2-data-definition-language/:0:0","tags":["计算机基础"],"title":"Mysql学习2-数据库操作","uri":"/2020/mysql-learning-2-data-definition-language/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 查看 查看数据库的语法格式为： SHOW DATABASES [LIKE '数据库名']; 语法说明如下： LIKE 从句是可选项，用于匹配指定的数据库名称。LIKE 从句可以部分匹配（使用 %），也可以完全匹配。 数据库名由单引号' '包围。 mysql\u003e SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sakila | | sys | | world | +--------------------+ 6 row in set (0.22 sec) 如上所示，安装 MySQL 时系统自动创建 6 个数据库，各自功能如下 information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。 mysql：MySQL 的核心数据库，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。 performance_schema：主要用于收集数据库服务器性能参数。 sakila：MySQL 提供的样例数据库，该数据库共有 16 张表，这些数据表都是比较常见的，在设计数据库时，可以参照这些样例数据表来快速完成所需的数据表。 sys：主要提供一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。 world：MySQL 自动创建的数据库，只包括 3 张数据表，分别保存城市，国家和国家使用的语言等内容。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-2-data-definition-language/:1:0","tags":["计算机基础"],"title":"Mysql学习2-数据库操作","uri":"/2020/mysql-learning-2-data-definition-language/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 创建 创建数据库的语法格式为： CREATE DATABASE [IF NOT EXISTS] \u003c数据库名\u003e [[DEFAULT] CHARACTER SET \u003c字符集名\u003e] [[DEFAULT] COLLATE \u003c校对规则名\u003e]; [] 中的内容可选，语法说明如下 数据库名不能以数字开头，尽量有实际意义，不区分大小写； [IF NOT EXISTS] 用来避免数据库已存在而重复创建的错误 [DEFAULT] CHARACTER SET 指定字符集，避免数据乱码，不指定则使用默认字符集 [DEFAULT] COLLATE 指定字符集默认校对规则 注：字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式。 示例 mysql\u003e CREATE DATABASE test_db; # 创建数据库 mysql\u003e CREATE DATABASE IF NOT EXISTS test_db_char # 创建数据库的同时指定字符集和校对规则 -\u003e DEFAULT CHARACTER SET utf8 -\u003e DEFAULT COLLATE utf8_chinese_ci; ","date":"2020-05-24","objectID":"/2020/mysql-learning-2-data-definition-language/:2:0","tags":["计算机基础"],"title":"Mysql学习2-数据库操作","uri":"/2020/mysql-learning-2-data-definition-language/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 修改 只能对数据库使用的字符集和校对规则进行修改，语法格式为： ALTER DATABASE [数据库名] { [ DEFAULT ] CHARACTER SET \u003c字符集名\u003e | [ DEFAULT ] COLLATE \u003c校对规则名\u003e} 语法说明如下： ALTER DATABASE 用于更改数据库的全局特性。 使用 ALTER DATABASE 需要获得数据库 ALTER 权限。 数据库名称可以忽略，此时语句对应于默认数据库。 CHARACTER SET 子句用于更改默认的数据库字符集。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-2-data-definition-language/:3:0","tags":["计算机基础"],"title":"Mysql学习2-数据库操作","uri":"/2020/mysql-learning-2-data-definition-language/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 删除 删除数据库的语法格式为： DROP DATABASE [ IF EXISTS ] \u003c数据库名\u003e 执行该命令会将数据库中存储的所有数据表和数据一同删除，且不能恢复。因此最好在删除数据库之前先将数据库进行备份。 IF EXISTS 用于防止当数据库不存在时发生错误。 系统自动创建的 information_schema 和 mysql 两个数据库存放一些和数据库相关的信息，删除后MySQL 将不能正常工作。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-2-data-definition-language/:4:0","tags":["计算机基础"],"title":"Mysql学习2-数据库操作","uri":"/2020/mysql-learning-2-data-definition-language/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 选择 创建数据库之后，该数据库不会自动成为当前数据库，需要用 USE 来指定当前数据库。其语法格式为： USE \u003c数据库名\u003e 该语句可以通知 MySQL 把 \u003c数据库名\u003e 所指示的数据库作为当前数据库。该数据库保持为默认数据库，直到语段的结尾，或者直到遇见一个不同的 USE 语句。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-2-data-definition-language/:5:0","tags":["计算机基础"],"title":"Mysql学习2-数据库操作","uri":"/2020/mysql-learning-2-data-definition-language/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 其它 单行注释使用 #，多行注释使用 /*……*/ 不同操作系统大小写是否区分的规则如下表 Windows Linux 数据库名 否（忽略大小写） 是 表名 否 是 表别名 否 是 列名 否 否 列别名 否 否 变量名 否 是 ","date":"2020-05-24","objectID":"/2020/mysql-learning-2-data-definition-language/:6:0","tags":["计算机基础"],"title":"Mysql学习2-数据库操作","uri":"/2020/mysql-learning-2-data-definition-language/"},{"categories":["爱编程爱技术的孩子"],"content":"本文介绍数据库和 MySQL的基础知识。得庆幸当初数据库课学的还可以，大部分内容看一眼都能想起来，不需要去理解，就是单纯的忘了一些语句写法。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-1-introduction/:0:0","tags":["计算机基础"],"title":"Mysql学习1-入门","uri":"/2020/mysql-learning-1-introduction/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 关系型数据库 关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。简单说，关系型数据库是由多张能互相连接的表组成的数据库。 优点 都是使用表结构，格式一致，易于维护。 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。 数据存储在磁盘中，安全。 缺点 读写性能比较差，不能满足海量数据的高效率读写。 不节省空间。因为建立在关系模型上，就要遵循某些规则，比如数据中某字段值即使为空仍要分配空间。 固定的表结构，灵活度较低。 常见的关系型数据库有 Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access 和 MySQL 等。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-1-introduction/:1:0","tags":["计算机基础"],"title":"Mysql学习1-入门","uri":"/2020/mysql-learning-1-introduction/"},{"categories":["爱编程爱技术的孩子"],"content":"2. NoSQL 非关系型数据库被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 优点 非关系型数据库存储数据的格式可以是 key-value 形式、文档形式、图片形式等。使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。 速度快，效率高。 NoSQL 可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘。 海量数据的维护和处理非常轻松。 非关系型数据库具有扩展简单、高并发、高稳定性、成本低廉的优势。 可以实现数据的分布式处理。 缺点 非关系型数据库暂时不提供 SQL 支持，学习和使用成本较高。 非关系数据库没有事务处理，没有保证数据的完整性和安全性。适合处理海量数据，但是不一定安全。 功能没有关系型数据库完善。 常见的非关系型数据库有 Neo4j、MongoDB、Redis、Memcached、MemcacheDB 和 HBase 等。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-1-introduction/:2:0","tags":["计算机基础"],"title":"Mysql学习1-入门","uri":"/2020/mysql-learning-1-introduction/"},{"categories":["爱编程爱技术的孩子"],"content":"3. MySQL MySQL 是最流行的数据库之一，是一个免费开源的关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 适合中小型软件，被个人用户以及中小企业青睐。 针对不同的用户，MySQL 分为两个版本： MySQL Community Server（社区版）：该版本是自由下载且完全免费的，但是官方不提供技术支持。 MySQL Enterprise Server（企业版）：该版本是收费的，而且不能下载，但是该版本拥有完善的技术支持 MySQL 的命名机制由 3 个数字和 1 个后缀组成，例如 mysql-5.7.20： 第 1 个数字“5”是主版本号，用于描述文件的格式，所有版本 5 的发行版都有相同的文件夹格式。 第 2 个数字“7”是发行级别，主版本号和发行级别组合在一起便构成了发行序列号。 第 3 个数字“20”是在此发行系列的版本号，随每次新发行的版本递增。通常选择已经发行的最新版本。 MySQL 的主要特点就是免费，并且在任何平台上都能使用，占用空间相对较小。 MySQL 是 C/S 架构，有 Client 和 Server 两部分，可以都安装在一台电脑上，也可以独立安装。 学习 MySQL 必须掌握的知识点如下： MySQL 的下载安装。熟悉 MySQL 的配置文件，目录结构。 MySQL 服务器的启动，登录与退出。 MySQL 常用命令及语法规范。 MySQL 数据类型与数据表的操作。例如，数据表的增删改查、单表查询、多表查询等。 MySQL 运算符和函数，例如，日期函数，时间函数，信息函数，聚合函数，加密函数，自定义函数等。 MySQL 存储过程，存储过程的调用。 MySQL 各个存储引擎的特点，如何选择合适的存储引擎等。 MySQL 事务的概念和使用等。 MySQL 权限管理和用户管理等。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-1-introduction/:3:0","tags":["计算机基础"],"title":"Mysql学习1-入门","uri":"/2020/mysql-learning-1-introduction/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 安装与配置 官方下载页面：https://dev.mysql.com/downloads/ Windows 中 配置环境变量为 C：\\Program Files\\MySQL\\MySQL Server 5.7\\bin(默认安装路径)，配置后才能在普通命令行中使用。 启动和停机命令为 net start DB 和 net stop DB，其中 DB 为自己的 MySQL 服务器名，在安装时指定。 使用 mysql -h 127.0.0.1 -u root -p 登录 -h 后面的参数是服务器的主机地址，从服务器登录省略该参数 -u 后面跟登录数据库的用户名称 -p 后面是用户登录密码，中间没有空格，也可以置空随后跟随提示输入 PS C:\\Users\\lylw1\u003e mysql -u root -p Enter password: **** Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 13 Server version: 8.0.19 MySQL Community Server - GPL Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql\u003e 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的 Your MySQL connection id is 13：id 表示 MySQL 数据库的连接次数。 Server version: 8.0.19 MySQL Community Server - GPL：Server version 后面说明数据库的版本，Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 Linux 以 Ubuntu 为例，官网下载 deb 包，使用 dpkg 命令安装 $ sudo dpkg -i mysql-apt-config* mysql-apt-config* 为包名，使用如下命令验证安装 $ sudo systemctl status mysql.service 如果服务没有启动，使用如下命令 $ sudo systemctl start mysql.service ","date":"2020-05-24","objectID":"/2020/mysql-learning-1-introduction/:4:0","tags":["计算机基础"],"title":"Mysql学习1-入门","uri":"/2020/mysql-learning-1-introduction/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 图形化管理工具 常用的图形化管理工具有 MySQL Workbench 和 Navicat，前者是官方提供的工具，但后者比较好用。 ","date":"2020-05-24","objectID":"/2020/mysql-learning-1-introduction/:5:0","tags":["计算机基础"],"title":"Mysql学习1-入门","uri":"/2020/mysql-learning-1-introduction/"},{"categories":["爱编程爱技术的孩子"],"content":"6. SQL 对数据库进行查询和修改操作的语言叫做 SQL（Structured Query Language，结构化查询语言）。SQL 语言是目前广泛使用的关系数据库标准语言，是各种数据库交互方式的基础。SQL包括四部分 数据定义语言（Data Definition Language，DDL）：用来创建或删除数据库以及表等对象，主要包含以下几种命令： DROP：删除数据库和表等对象 CREATE：创建数据库和表等对象 ALTER：修改数据库和表等对象的结构 数据操作语言（Data Manipulation Language，DML）：用来变更表中的记录，主要包含以下几种命令：- SELECT：查询表中的数据 INSERT：向表中插入新数据 UPDATE：更新表中的数据 DELETE：删除表中的数据 数据查询语言（Data Query Language，DQL）：用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。 数据控制语言（Data Control Language，DCL）：用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令： GRANT：赋予用户操作权限 REVOKE：取消用户的操作权限 COMMIT：确认对数据库中的数据进行的变更 ROLLBACK：取消对数据库中的数据进行的变更 SQL 的几个易错书写规则如下 以分号 ; 结尾 SQL 语句不区分大小写 单词需要半角空格或换行来分隔 ","date":"2020-05-24","objectID":"/2020/mysql-learning-1-introduction/:6:0","tags":["计算机基础"],"title":"Mysql学习1-入门","uri":"/2020/mysql-learning-1-introduction/"},{"categories":["爱编程爱技术的孩子"],"content":"各种语言的基础语法部分都很相似，因此这里简单总结一下 ","date":"2020-05-22","objectID":"/2020/javascript-learning-2-basic-syntax/:0:0","tags":null,"title":"JavaScript学习2-基础语法","uri":"/2020/javascript-learning-2-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 变量与常量 尽管以前使用 var 关键字，但现在更多使用 let 关键字声明变量 let myName; // 声明 myName = 'shuzang'; // 初始化 let nyName = 'shuzang'; // 声明 + 初始化，这是最常使用的方式 myName = 'newName'; // 声明后更新变量值 let a=10,b=20,c=30; // 同时声明多个变量 注：关键字更换的原因参考 var 与 let 的区别，更换只有好处没有坏处 常量则使用 const 关键字 const button = document.querySelector('button'); 变量与常量的命名规则与其它语言相同，由字母、数字、下划线、美元符组成，不能以数字开头。 ","date":"2020-05-22","objectID":"/2020/javascript-learning-2-basic-syntax/:1:0","tags":null,"title":"JavaScript学习2-基础语法","uri":"/2020/javascript-learning-2-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 数据类型 JS 的数据类型有 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 引用数据类型：对象(Object)、数组(Array)、函数(Function)。 注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。 let hello = 'hello js!'; // 字符串，单引号和双引号都可以，但应保持使用一种方式 let myAge = 17; // 数字,整数和浮点数都是数字类型 let iAmAlive = true; // 布尔 let myNumberArray = [10,15,40]; // 数组 let dog = { name : 'Spot', breed : 'Dalmatian' }; //对象 JavaScript是一种「动态类型语言」，这意味着不需要指定变量将包含什么数据类型（例如number或string） ","date":"2020-05-22","objectID":"/2020/javascript-learning-2-basic-syntax/:2:0","tags":null,"title":"JavaScript学习2-基础语法","uri":"/2020/javascript-learning-2-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 字符串 格式转换 let myString = '123'; let myNum = Number(myString); // 字符串转换为数字 myString = myNum.toString(); // 数字转换回字符串 一些方法如下 let browserType = 'mozilla'; browserType.length; // 获取字符串长度 browserType[0]; // 看作字符数组，获取第一个字符 browserType[browserType.length-1]; // 获取最后一个字符 browserType.indexOf('zilla'); // 搜索子串，返回索引2 browserType.indexOf('vanilla'); // 返回-1 browserType.slice(0,3); // 提取索引 0-2 的子串，slice方法类似Go的切片 browserType.slice(2); // 提取索引2开始直到字符串结束的子串 browserType = browserType.replace('moz','van'); // 子串替换 大小写转换 let radData = 'My NaMe Is MuD'; radData.toLowerCase(); radData.toUpperCase(); ","date":"2020-05-22","objectID":"/2020/javascript-learning-2-basic-syntax/:2:1","tags":null,"title":"JavaScript学习2-基础语法","uri":"/2020/javascript-learning-2-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 数组 JS 中数组元素可以是同一种类型，也可以混合 let sequence = [1, 1, 2, 3, 5, 8, 13]; let random = ['tree', 795, [0, 1, 2]]; 可以获取长度 let sequence = [1, 1, 2, 3, 5, 8, 13]; sequence.length; // 返回 7 sequence.push(11); // 在末尾添加元素 11 var newLenght = sequence.push(21,22) // 一次可添加多个元素，返回值是新数组的长度, 可以不声明返回值 var removedItem = sequence.pop(); // 删除最后一个元素, 返回值是删除的元素 sequence.unshift(34); // 在开头添加元素 34 sequence.shift(); // 删除开头的元素 尽管字符串可以看作字符数组，但也可以指定分隔符 let myData = 'Manchester,London,Liverpool'; let myArray = myData.split(','); // myArray = ['Manchester','London','Liverpool'] myArray.lenght; // 返回 3 myArray[0]; // 返回 'Manchester' let myNewString = myArray.join(','); // 相反的操作，数组转换成字符串 myArray.toString(); // 另外一种数组转换为字符串的方法，更简单，但无法指定分隔符 ","date":"2020-05-22","objectID":"/2020/javascript-learning-2-basic-syntax/:2:2","tags":null,"title":"JavaScript学习2-基础语法","uri":"/2020/javascript-learning-2-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 运算符 算术运算符：+，-，*，/，%，**（幂） 递增递减运算符：++，– 赋值运算符：=，+=，-=，*=，/= 比较运算符：===，!==，\u003c，\u003e，\u003c=，\u003e= == 和 != 同样有效，但它们只测试值是否相等，数据类型可能不同，=== 和 !== 严格测试值和数据类型是否相同，严格的版本出现的错误更少，因此推荐使用这种方式。 ","date":"2020-05-22","objectID":"/2020/javascript-learning-2-basic-syntax/:3:0","tags":null,"title":"JavaScript学习2-基础语法","uri":"/2020/javascript-learning-2-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 控制结构 条件结构与其它语言相同 if...else 或者 if...else if...else switch...case...default，需要主动执行 break 跳出 支持三元运算符：( condition ) ? run this code : run this code instead 循环结构包含了我们接触过的所有写法 for do...while while for...in，返回索引 for...of，返回值 最后，可以使用 label 来随意跳转，但没有想到任何这样做的好处 ","date":"2020-05-22","objectID":"/2020/javascript-learning-2-basic-syntax/:4:0","tags":null,"title":"JavaScript学习2-基础语法","uri":"/2020/javascript-learning-2-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 函数 使用 function 关键字定义，格式如下 func 函数名(形参列表){ ... } 这里注意到的是 JS 中无需声明返回值列表，直接在函数体中使用 return 返回相应的值即可，参数也无需声明类型 JS 支持匿名函数（也称为函数表达式） function() { alert('hello'); } 但匿名函数主要用来相应事件触发 myButton.onclick = function() { alert('hello'); // I can put as much code // inside here as I want } 具名函数和匿名函数都可以赋值给变量 var square = function(number) { return number * number; }; var x = square(4); // x gets the value 16 var factorial = function fac(n) {return n\u003c2 ? 1 : n*fac(n-1)}; console.log(factorial(3)); ","date":"2020-05-22","objectID":"/2020/javascript-learning-2-basic-syntax/:5:0","tags":null,"title":"JavaScript学习2-基础语法","uri":"/2020/javascript-learning-2-basic-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"JavaScript 是标准 Web 技术的第三层，负责实现动态的行为，比如实现交互式的地图、2D/3D动画、滚动播放的视频等。 JS 的标准是 ECMAScript，2015年发布了该标准的第六版，通常被称为 ECMAScript 6 或 ES6。此后，ECMAScript 每年发表一次新标准，至今最新的为 ECMASCript2020 ","date":"2020-05-22","objectID":"/2020/javascript-learning-1-overview/:0:0","tags":null,"title":"JavaScript学习1-概览","uri":"/2020/javascript-learning-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"1. API 浏览器 API 内建于浏览器中，JS 可以通过调用浏览器 API 筛选当前计算机环境的相关数据，从而实现复杂的工作，例如 文档对象模型 （DOM） API 能动态地操作 HTML 和 CSS。比如当某个页面出现了一个弹窗，或者显示了一些新内容，这就是 DOM 在运行。 地理位置 API（Geolocation API） 获取地理信息。 画布（Canvas） 和 WebGL API 可以创建生动的 2D/3D 动画。比如 webglsamples。 HTMLMediaElement 和 WebRTC 等影音类 API 可以让我们利用多媒体，比如在网页中直接播放音乐和影片，或用自己的网络摄像头获取录像，然后在其他人的电脑上展示。 第三方 API 则没有默认嵌入浏览器，需要从网上获得它们地代码和信息，比如： Twitter API、新浪微博 API 可以在网站上展示最新推文之类 谷歌地图 API、高德地图 API 可以在网站嵌入定制的地图等等。 以合理的方式调用这些 API 是我们在使用 JS 过程中做的最多的事情。 ","date":"2020-05-22","objectID":"/2020/javascript-learning-1-overview/:1:0","tags":null,"title":"JavaScript学习1-概览","uri":"/2020/javascript-learning-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"2. JS 对页面做了什么 首先明确，HTML 和 CSS 都就位后，JS 才开始运行，因为 JS 主要作用是通过调用 DOM API 动态修改 HTML 和 CSS，如果同时执行，可能引发错误。 每个浏览器标签页是一个运行代码的独立容器，不同标签页中的代码一般不能相互影响。 JS 是解释型语言，代码自上而下运行，实时地返回运行结果，因此要注意代码书写的顺序。 const para = document.querySelector('p'); para.addEventListener('click', updateName); function updateName() { let name = prompt('输入一个新的名字：'); para.textContent = '玩家1：' + name; } 上例中，首先选定一个文本段落，然后给它附上一个事件监听器，使得在它被点击时，updateName() 代码块（code block）便会运行。updateName() 向用户请求一个新名字，然后把这个名字插入到段落中以更新显示。如果互换前两行代码，浏览器开发者控制台将返回一个错误： TypeError: para is undefined。这意味着 para 对象还不存在，所以我们不能为它增添一个事件监听器。 ","date":"2020-05-22","objectID":"/2020/javascript-learning-1-overview/:2:0","tags":null,"title":"JavaScript学习1-概览","uri":"/2020/javascript-learning-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 向页面添加 JS CSS 使用 \u003cstyle\u003e 元素向 HTML 嵌入内部样式表，或者使用 \u003clink\u003e 元素链接外部样式表。JS 则只有一个元素可用：\u003cscript\u003e，内部 JavaScript 是直接将代码放在标签中，例如 \u003cscript\u003e document.addEventListener(\"DOMContentLoaded\", function() { function createParagraph() { let para = document.createElement('p'); para.textContent = '你点击了这个按钮！'; document.body.appendChild(para); } const buttons = document.querySelectorAll('button'); for(let i = 0; i \u003c buttons.length ; i++) { buttons[i].addEventListener('click', createParagraph); } }); \u003c/script\u003e 外部 JavaScript 是将 JS 代码保存为文件，然后在 \u003cscript\u003e 标签中引用。 function createParagraph() { let para = document.createElement('p'); para.textContent = '你点击了这个按钮！'; document.body.appendChild(para); } const buttons = document.querySelectorAll('button'); for(let i = 0; i \u003c buttons.length ; i++) { buttons[i].addEventListener('click', createParagraph); } 将上面的 JS 代码保存到 script.js 文件中，放在与 HTML 文件同目录下，然后在 HTML 文件中添加如下代码即可，效果是相同的。 \u003cscript src=\"script.js\" async\u003e\u003c/script\u003e 后者是推荐做法，应保存样式与动作分离。 ","date":"2020-05-22","objectID":"/2020/javascript-learning-1-overview/:3:0","tags":null,"title":"JavaScript学习1-概览","uri":"/2020/javascript-learning-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 脚本调用时机 HTML 代码同样按次序调用，用 JS 管理页面元素时，若 JS 在欲操作的元素前加载，代码将出错。 第三部分中，内部 JS 代码调用时使用了事件监听器监听浏览器的 DOMContentLoaded 事件，当 HTML 文档体加载、解释完毕后，事件触发时才会调用代码，从而避免了错误发生。而外部 JS 代码则是声明了 async 异步属性来解决该问题，它告知浏览器在遇到 \u003cscript\u003e 元素时不要中断后续 HTML 内容的加载。 原始的方法是将所有脚本元素放在 HTML 文档体末尾加载，但对 JS 代码比较多的网站性能损耗明显。 延缓加载 JS 有两种关键词：async 和 defer。前者是在加载 JS 代码的同时接着渲染后面的内容，相当于两件事并行完成，无法保证脚本调用的顺序，适用于页面种的脚本间相互独立的情况。如下，script2.js 可能在 jquery 之前执行。 \u003cscript async src=\"js/vendor/jquery.js\"\u003e\u003c/script\u003e \u003cscript async src=\"js/script2.js\"\u003e\u003c/script\u003e \u003cscript async src=\"js/script3.js\"\u003e\u003c/script\u003e 后者使脚本按照页面中出现的顺序加载，如下，执行顺序为严格的 jquery.js，script2.js，script3.js \u003cscript defer src=\"js/vendor/jquery.js\"\u003e\u003c/script\u003e \u003cscript defer src=\"js/script2.js\"\u003e\u003c/script\u003e \u003cscript defer src=\"js/script3.js\"\u003e\u003c/script\u003e ","date":"2020-05-22","objectID":"/2020/javascript-learning-1-overview/:4:0","tags":null,"title":"JavaScript学习1-概览","uri":"/2020/javascript-learning-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 注释 与大部分语言相同，JS 的单行注释也是 //，多行注释也是 /* …… */ ","date":"2020-05-22","objectID":"/2020/javascript-learning-1-overview/:5:0","tags":null,"title":"JavaScript学习1-概览","uri":"/2020/javascript-learning-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。 ","date":"2020-05-18","objectID":"/2020/network/:0:0","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 外部访问容器 容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。 使用 docker container ls 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。 $ docker run -d -P training/webapp python app.py $ docker container ls -lCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbc533791f3f5 training/webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-\u003e5000/tcp nostalgic_morse 同样的，可以通过 docker logs 命令来查看应用的信息。 $ docker logs -f nostalgic_morse * Running on http://0.0.0.0:5000/ 10.0.2.2 - - [23/May/2014 20:16:31] \"GET / HTTP/1.1\" 200 - 10.0.2.2 - - [23/May/2014 20:16:31] \"GET /favicon.ico HTTP/1.1\" 404 - -p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。 使用 hostPort:containerPort 格式将本地的 5000 端口映射到容器的 5000 端口，可以执行 $ docker run -d -p 5000:5000 training/webapp python app.py 此时默认会绑定本地所有接口上的所有地址。 使用 ip:hostPort:containerPort 格式可以指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1 $ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。 $ docker run -d -p 127.0.0.1::5000 training/webapp python app.py 还可以使用 udp 标记来指定 udp 端口 $ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py 使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址 $ docker port nostalgic_morse 5000 127.0.0.1:49155. 注意： 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。） -p 标记可以多次使用来绑定多个端口，如 $ docker run -d \\ -p 5000:5000 \\ -p 3000:80 \\ training/webapp \\ python app.py ","date":"2020-05-18","objectID":"/2020/network/:1:0","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 容器互联 通过将容器加入自定义的 Docker 网络可以连接多个容器 ","date":"2020-05-18","objectID":"/2020/network/:2:0","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 新建网络 下面先创建一个新的 Docker 网络。 $ docker network create -d bridge my-net -d 参数指定 Docker 网络类型，有 bridge和 overlay。其中 overlay 网络类型用于 Swarm mode，暂时不需要理解。 ","date":"2020-05-18","objectID":"/2020/network/:2:1","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 连接容器 运行一个容器并连接到新建的 my-net 网络 $ docker run -it --rm --name busybox1 --network my-net busybox sh 打开新的终端，再运行一个容器并加入到 my-net 网络 $ docker run -it --rm --name busybox2 --network my-net busybox sh 再打开一个新的终端查看容器信息 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b47060aca56b busybox \"sh\" 11 minutes ago Up 11 minutes busybox2 8720575823ec busybox \"sh\" 16 minutes ago Up 16 minutes busybox1 下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。 在 busybox1 容器输入以下命令 / # ping busybox2 PING busybox2 (172.19.0.3): 56 data bytes 64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms 64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms 用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。 同理在 busybox2 容器执行 ping busybox1，也会成功连接到。 / # ping busybox1 PING busybox1 (172.19.0.2): 56 data bytes 64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms 64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms 这样，busybox1 容器和 busybox2 容器建立了互联关系。 ","date":"2020-05-18","objectID":"/2020/network/:2:2","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"3. Docker Compose Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。当我们有多个容器之间需要互相连接，需要使用该工具。 ","date":"2020-05-18","objectID":"/2020/network/:3:0","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 简单介绍 Compose允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。 Compose 项目由 Python 编写，因此可以通过 pip 进行安装，也可以从 官方 GitHub Release 处直接下载编译好的二进制文件。根据安装方式的不同，执行 pip uninstall 命令或删除二进制包来卸载 compose。不过值得庆幸的是，Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。 ","date":"2020-05-18","objectID":"/2020/network/:3:1","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 使用 用 Python 来建立一个能够记录页面访问次数的 web 网站，以此为例进行介绍。首先新建文件夹，在该目录中编写 app.py 文件。 from flask import Flask from redis import Redis app = Flask(__name__) redis = Redis(host='redis', port=6379) @app.route('/') def hello(): count = redis.incr('hits') return 'Hello World! 该页面已被访问 {} 次。\\n'.format(count) if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", debug=True) 编写 Dockerfile 文件，内容为 FROMpython:3.6-alpineADD . /codeWORKDIR/codeRUN pip install redis flaskCMD [\"python\", \"app.py\"] 编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。 version:'3'services:web:build:.ports:- \"5000:5000\"redis:image:\"redis:alpine\" 运行 compose 项目 $ docker-compose up 此时访问本地 5000 端口，每次刷新页面，计数就会加 1。 ","date":"2020-05-18","objectID":"/2020/network/:3:2","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 模板文件 docker-compose 的命令可以执行 docker-compose --help 查看理解。这里要详细说明的是 Compose 模板文件。 模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大部分指令跟 docker run 相关参数的含义都是类似的。默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。 version:\"3\"services:webapp:image:examples/webports:- \"80:80\"volumes:- \"/data\" 每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中重复设置。 常用命令介绍如下 build 指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 version:'3'services:webapp: build:./dir 你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。 使用 dockerfile 指令指定 Dockerfile 文件名。 使用 arg 指令指定构建镜像时的变量。 version:'3'services:webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno:1 使用 cache_from 指定构建镜像的缓存 build:context:.cache_from:- alpine:latest- corp/web_app:3.14 command 覆盖容器启动后默认执行的命令 command:echo\"hello world\" container_name 指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。 container_name:docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。 devices 指定设备映射关系。 devices:- \"/dev/ttyUSB1:/dev/ttyUSB0\" depends_on 解决容器的依赖、启动先后的问题。以下例子中会先启动 redis 和 db 再启动 web version:'3'services:web:build:.depends_on:- db- redisredis:image:redisdb:image:postgres 注意：web 服务不会等待 redis db 「完全启动」之后才启动。 dns 自定义 DNS 服务器。可以是一个值，也可以是一个列表。 dns:8.8.8.8dns:- 8.8.8.8- 114.114.114.114 dns_search 配置 DNS 搜索域。可以是一个值，也可以是一个列表。 dns_search:example.comdns_search:- domain1.example.com- domain2.example.com env_file 从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。 env_file:.envenv_file:- ./common.env- ./apps/web.env- /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。 # common.env: Set development environmentPROG_ENV=development environment 设置环境变量。你可以使用数组或字典两种格式。 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。 environment:RACK_ENV:developmentSESSION_SECRET:environment:- RACK_ENV=development- SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括 y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF expose 暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数 expose:- \"3000\"- \"8000\" extra_hosts 类似 Docker 中的 --add-host 参数，指定额外的 host 名称映射信息。 extra_hosts:- \"googledns:8.8.8.8\"- \"dockerhub:52.1.157.61\" 会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。 8.8.8.8googledns52.1.157.61dockerhub healthcheck 通过命令检查容器是否健康运行。 healthcheck:test:[\"CMD\",\"curl\",\"-f\",\"http://localhost\"]interval:1m30stimeout:10sretries:3 image 指定镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 image:ubuntuimage:orchardup/postgresqlimage:a4bc65fd labels 为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。 labels:com.startupteam.description:\"webapp for a startup team\"com.startupteam.department:\"devops department\"com.startupteam.release:\"rc3 for v1.0\" logging 配置日志选项 logging:driver:syslogoptions:syslog-address:\"tcp://192.168.0.42:123\" 目前支持三种日志驱动类型。 driver:\"json-file\"driver:\"syslog\"driver:\"none\" options 配置日志驱动的相关参数。 options:max-size:\"200k\"max-file:\"10\" network_mode 设置网络模式。使用和 docker run 的 --network 参数一样的值。 network_mode:\"bridge\"network_mode:\"host\"network_mode:\"none\"network_mode:\"service:[service name]\"network_mode:\"container:[container name/id]\" networks 配置容器连接的网络。 version:\"3\"services:some-service:networks:- some-network- other-networknetworks:some-network:other-network: pid 跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。 pid:\"host\" ports 暴露端口信息。 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 ports:- \"3000\"- \"8000:8000\"- \"49100:22\"- \"127.0.0.1:8001:8001\" 注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。 secrets 存储敏感数据，例如 mysql 服务密码。 version:\"3.1\"services:mysql:image:mysqlenvironment:MYSQL_ROOT_PASSWORD_FILE:/run/secrets/db_root_passwordsecrets:- db_root_password- my_other_secretsecrets:my_secret:file:./my_secret.txtmy_other_secret:external:true volumes 数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CON","date":"2020-05-18","objectID":"/2020/network/:3:3","tags":["linux"],"title":"Docker-网络","uri":"/2020/network/"},{"categories":["爱编程爱技术的孩子"],"content":"Docker 的三个基本概念是镜像（Image）、容器（Container）和仓库（Repository），理解了这三个概念基本就理解了 Docker。 ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:0:0","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 镜像 尽管都使用了镜像这个词，但 Docker 的镜像和虚拟机上安装的系统镜像并不完全相同。虚拟机安装的镜像是完整的操作系统，包括内核、根文件系统等部分，体积一般较大，比如 ubuntu20.04 LTS 就有2.5GB。而 Docker 的镜像不包括内核，可以看作一个定制的最小化的根文件系统，体积往往很小，本文写作时 docker ubuntu latest 仅有73.9MB。实际上，Docker 本身是基于宿主机的内核运行的。 ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:1:0","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 Union FS Docker 镜像保持的如此之小，仅依靠去除内核和删减根文件系统是不够的，更重要的原因是，Docker 使用了 Union FS 的技术，整体设计是一个分层存储的架构。联合文件系统（UnionFS）是一种轻量级的高性能分层文件系统，它支持将文件系统中的修改信息作为一次提交，并层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，应用看到的是挂载的最终结果。简单来说，镜像不是一整个文件，而是由一组文件系统组成，更具体一点，由多层文件系统组成。镜像构建时，会一层层构建，前一层是后一层的基础，每一层构建完就不会再发生改变，后一层的任何改变只会发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。以 ubuntu 为例，下载镜像时我们可以很清楚的看到分了四层 $ docker pull ubuntu Using default tag: latest latest: Pulling from library/ubuntu d51af753c3d3: Pull complete fc878cd0a91c: Pull complete 6154df8ff988: Pull complete fee5db0ff82f: Pull complete Digest: sha256:747d2dbbaaee995098c9792d99bd333c6783ce56150d1b11e333bbceed5c54d7 Status: Downloaded newer image for ubuntu:latest docker.io/library/ubuntu:latest 使用 docker history 命令还可以查看镜像构建历史记录 $ docker history ubuntu IMAGE CREATED CREATED BY SIZE COMMENT 1d622ef86b13 3 weeks ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0B \u003cmissing\u003e 3 weeks ago /bin/sh -c mkdir -p /run/systemd \u0026\u0026 echo 'do… 7B \u003cmissing\u003e 3 weeks ago /bin/sh -c set -xe \u0026\u0026 echo '#!/bin/sh' \u003e /… 811B \u003cmissing\u003e 3 weeks ago /bin/sh -c [ -z \"$(apt-get indextargets)\" ] 1.01MB \u003cmissing\u003e 3 weeks ago /bin/sh -c #(nop) ADD file:a58c8b447951f9e30… 72.8MB 分层存储的特征使得镜像的复用、定制变得更加容易，甚至可以用之前构建好的镜像作为基础层，然后一步步添加新层，以定制自己需要的内容，构建新的镜像。 ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:1:1","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 镜像使用 Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。 获取镜像 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 选项部分包括三个参数，但很少用到，可以通过 docker pull --help 查看，这里介绍镜像名称的格式 Docker 镜像仓库地址：地址的格式一般是 \u003c域名/IP\u003e[:端口号]。默认地址是 Docker Hub（官方仓库地址）。 仓库名：仓库名是两段式名称，即 \u003c用户名\u003e/\u003c软件名\u003e。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 仍以 ubuntu 为例 $ docker pull ubuntu Using default tag: latest latest: Pulling from library/ubuntu d51af753c3d3: Pull complete fc878cd0a91c: Pull complete 6154df8ff988: Pull complete fee5db0ff82f: Pull complete Digest: sha256:747d2dbbaaee995098c9792d99bd333c6783ce56150d1b11e333bbceed5c54d7 Status: Downloaded newer image for ubuntu:latest docker.io/library/ubuntu:latest 命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。镜像名称为 ubuntu，因此将会获取官方镜像 library/ubuntu 仓库中标签为 latest 的镜像。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。 如果从 Docker Hub 下载镜像非常缓慢，可以参照 镜像加速器 配置加速器。 列出镜像 要想列出已经下载下来的镜像，可以使用 docker image ls 命令。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 1d622ef86b13 3 weeks ago 73.9MB mysql 8.0 0c27e8e5fcfa 3 weeks ago 546MB mysql latest 0c27e8e5fcfa 3 weeks ago 546MB hello-world latest bf756fb1ae65 4 months ago 13.3kB 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。j镜像ID 是镜像的唯一标识，一个镜像可能对应多个标签，比如上面例子中的 mysql:8.0 和 mysql:latest。 不加任何参数的情况下，docker image ls 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。 $ docker image ls ubuntu #根据仓库名列出镜像 $ docker image ls ubuntu:18.04 #列出指定仓库名和标签的镜像 $ docker image ls -f since=mongo:3.2 #使用过滤器列出指定条件的镜像 删除本地镜像 如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为： $ docker image rm [选项] \u003c镜像1\u003e [\u003c镜像2\u003e ...] 其中，\u003c镜像\u003e 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 $ docker image rm mysql:8.0 Untagged: mysql:8.0 $ docker image rm ubuntu Untagged: ubuntu:latest Untagged: ubuntu@sha256:747d2dbbaaee995098c9792d99bd333c6783ce56150d1b11e333bbceed5c54d7 Deleted: sha256:1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01 Deleted: sha256:279e836b58d9996b5715e82a97b024563f2b175e86a53176846684f0717661c3 Deleted: sha256:39865913f677c50ea236b68d81560d8fefe491661ce6e668fd331b4b680b1d47 Deleted: sha256:cac81188485e011e56459f1d9fc9936625a1b62cacdb4fcd3526e5f32e280387 Deleted: sha256:7789f1a3d4e9258fbe5469a8d657deb6aba168d86967063e9b80ac3e1154333f 可以注意到删除行为分两类，一类是 Untagged，另一类是 Deleted。前面介绍过，镜像的唯一标识是 ID 和摘要，而一个镜像可以有多个标签，因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。 镜像的删除也是分层进行的，如果某一层正被其他镜像使用，则不会被删除。另外，如果有基于当前镜像的容器正在进行，该镜像也不会被删除。 虚悬镜像 有时候镜像列表中会出现没有仓库名，也没有标签的特殊镜像 \u003cnone\u003e \u003cnone\u003e 00285df0df87 5 days ago 342 MB 这个镜像原本应当是有镜像名和标签的，但随着官方镜像维护，发布了新版本后，重新执行 docker pull 时，镜像名和标签被转移到了新下载的镜像上，旧的镜像上的名称则被取消，从而成为 \u003cnone\u003e。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 `` 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) 。一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。 $ docker image prune ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:1:2","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 容器 镜像与容器的关系，大致可以比对面向对象中的类与实例。具体来说，容器是独立运行的一个或一组应用，以及它们的运行态环境。 ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:2:0","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 启动 启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。 因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。 新建并启动 所需要的命令主要为 docker run。 例如，下面的命令输出一个 “Hello World”，之后终止容器。 $ docker run ubuntu /bin/echo 'hello world' # windows下使用git命令行需要输入 //bin/echo hello world 这跟在本地直接执行 /bin/echo 'hello world' 几乎感觉不出任何区别。 下面的命令则启动一个 bash 终端，允许用户进行交互。 $ docker run -t -i ubuntu:18.04 /bin/bash root@af8bae53bdd3:/# 其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。这两个是最常使用的选项 在交互模式下，用户可以通过所创建的终端来输入命令，例如 root@af8bae53bdd3:/# pwd / root@af8bae53bdd3:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 启动已终止容器 已启动的容器在执行完毕后不会被自动删除，利用 docker container start 命令，可以将一个已经终止的容器重新启动运行。 容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。 root@ba267838cc1b:/# ps PID TTY TIME CMD 1 ? 00:00:00 bash 11 ? 00:00:00 ps 可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。 ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:2:1","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 守护态运行 更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。比如使用 -d 参数执行上面的命令 $ docker run -d ubuntu /bin/echo 'hello' 08e90e1961f8b12434931d5f0a64fa5f4615c9613d4b942310c991de17b9bc40 此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面，输出结果可以用 docker logs 查看 $ docker container logs 08e hello 注：容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关，容器只有在执行完命令后才会关闭，一种极端情况是，执行的命令是一个无限循环，这时容器永远不会关闭。 ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:2:2","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 终止 我们已经知道，当 Docker 容器中指定的应用终结时，容器也自动终止。不过，也可以使用 docker container stop 来终止一个运行中的容器。 对于前面提到的启动了内置终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。 $ docker run -t -i ubuntu:18.04 /bin/bash root@af8bae53bdd3:/# # 输入 exit 或 使用 Ctrl+d 快捷键退出 使用 docker container ls 仅能看到运行状态的容器，要查看终止状态的容器需要使用 docker container ls -a $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 08e90e1961f8 ubuntu \"//bin/echo hello\" 9 minutes ago Exited (0) 9 minutes ago lucid_napier 20cd094abd6c ubuntu \"//bin/bash\" 16 minutes ago Exited (0) 10 minutes ago awesome_fermat b57c3358e522 ubuntu \"//bin/echo 'Hello w…\" 18 minutes ago Exited (0) 18 minutes ago gifted_murdock e47304d78c1a ubuntu:latest \"C:/Program Files/Gi…\" 23 minutes ago Created serene_shamir 81284613ca04 hello-world \"/hello\" About an hour ago Exited (0) About an hour ago nostalgic_meitner cd6182d13e68 mysql \"docker-entrypoint.s…\" 3 weeks ago Exited (255) 3 weeks ago 0.0.0.0:3306-\u003e3306/tcp, 33060/tcp chitchat 处于终止状态的容器，可以通过 docker container start 命令来重新启动。 此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。 ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:2:3","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 进入容器 在使用 -d 参数时，容器启动后会进入后台。某些时候可能需要进入容器内进行操作，可以使用 docker attach 命令或 docker exec 命令，推荐使用 后者。 attach 命令 $ docker run -it -d ubuntu e132b98549ad94ba0809a73e86bd63a3fd5f86067735beb83b6b74a14e51772f $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e132b98549ad ubuntu \"/bin/bash\" 5 seconds ago Up 4 seconds intelligent_galois $ docker attach e13 root@e132b98549ad:/# 如果从这个 stdin 中 exit，会导致容器的停止 exec 命令 docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。 只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。 $ docker run -it -d ubuntu 8486e83970e0c8d2594dff9277df369a867dc662feb1ac3b28c84dd305c8f078 $ docker exec -i 848 bash ls bin boot dev ... $ docker exec -it 848 bash root@69d137adef7a:/# 如果从这个 stdin 中 exit，不会导致容器的停止，这就是为什么推荐使用 docker exec ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:2:4","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"2.5 导出与导入 如果要导出本地某个容器，可以使用 docker export 命令。 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8486e83970e0 ubuntu \"/bin/bash\" 5 minutes ago Up 5 minutes hardcore_haslett e132b98549ad ubuntu \"/bin/bash\" 7 minutes ago Exited (0) 5 minutes ago intelligent_galois $ docker export 848 \u003e ubuntu.tar 这样将导出容器快照到本地文件，导出的目录为执行该命令的当前目录。 可以使用 docker import 从容器快照文件中再导入为镜像，例如 $ cat ubuntu.tar | docker import - test/ubuntu:v1.0 sha256:8b3f836f35916cf3aa2199b06e84e917a6421438a58ed4fc1924cd6d07b85d45 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE test/ubuntu v1.0 8b3f836f3591 6 seconds ago 73.9MB ubuntu latest 1d622ef86b13 3 weeks ago 73.9MB ubuntu 18.04 c3c304cb4f22 3 weeks ago 64.2MB mysql latest 0c27e8e5fcfa 3 weeks ago 546MB hello-world latest bf756fb1ae65 4 months ago 13.3kB 此外，也可以通过指定 URL 或者某个目录来导入，例如 $ docker import http://example.com/exampleimage.tgz example/imagerepo 注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。 ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:2:5","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"2.6 删除 可以使用 docker container rm 来删除一个处于终止状态的容器。 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8486e83970e0 ubuntu \"/bin/bash\" 11 minutes ago Up 11 minutes hardcore_haslett e132b98549ad ubuntu \"/bin/bash\" 13 minutes ago Exited (0) 11 minutes ago intelligent_galois $ docker container rm e13 e13 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8486e83970e0 ubuntu \"/bin/bash\" 11 minutes ago Up 11 minutes hardcore_haslett 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。 $ docker container rm -f 848 848 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 如果终止状态的容器太多，一个个删除很麻烦，可以使用下面的命令清理所有处于终止状态的容器 $ docker container prune ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:2:6","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 仓库 仓库（Repository）是集中存放镜像的地方。 一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 docker.io/ubuntu 来说，docker.io 是注册服务器地址，ubuntu 是仓库名。 目前 Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 3,480,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 通过 docker search 命令来查找官方仓库中的镜像，通过 docker pull 命令来将它下载到本地。 也可以构建自己的私有仓库，但这里不做介绍。 参考：前言 - Docker —— 从入门到实践 (gitbook.io) ","date":"2020-05-18","objectID":"/2020/image-container-and-repository/:3:0","tags":["linux"],"title":"Docker-镜像、容器与仓库","uri":"/2020/image-container-and-repository/"},{"categories":["研究生的区块链学习之路"],"content":"项目进行过程中知识点的总结 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:0:0","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"1. 字符串比较 翻译自：Fravoll-String Equality Comparison 比较两个给定字符串是否相等，是 Solidity 编程中最常见的一种情况，但语言本身并没有提供内置函数用于字符串比较，本文介绍两种可用方法并分析 Gas 消耗情况。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:1:0","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 StringUtils 库 第一种方法是使用 Ethereum 基金会提供的 StringUtils 库，它对每个字符进行成对比较，如果有一个字符对不匹配，则返回false。这种办法可以返回正确的结果，对于短字符串和字符不同发生在字符串前面的情况仅消耗少量 Gas。但是对于相等的字符串和长字符串，这种方法的 Gas 消耗较高，因为必须做很多比较才能得到正确结果。因此，字符串比较的两个可衡量的因素是字符串平均长度和正确率。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:1:1","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 哈希函数 作者提出使用哈希函数进行比较，同时检查所提供的字符串的长度，从一开始就剔除长度不匹配的字符串。其步骤如下 检查两个字符串是否有相同长度，通过转换为 bytes 类型完成，因为 bytes 类型有内置长度函数。如果相同进入第2步，如果不相同返回结果； 使用 keccak256() 函数对两个字符串求哈希，然后比较计算得到的哈希值，从而确定是否相等。 一个示例代码如下 # 这段代码未经安全审计，使用有风险 function hashCompareWithLengthCheck(string a, string b) internal returns (bool) { if(bytes(a).length != bytes(b).length) { return false; } else { return keccak256(abi.encodePacket(a)) == keccak256(abi.encodePacket(b)); } } abi.encodePacket(...) returns (bytes) 用于对给定参数执行紧打包编码，官方文档中不推荐使用 keccak256(...) 直接计算哈希，而是使用 keccak256(abi.encodePacked(...)) ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:1:2","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"1.3 Gas 消耗分析 在 Remix 编写代码测试了三种不同情况的字符串比较的 Gas 消耗 比较哈希 比较每个字符，同时比较字符串长度 比较哈希，同时比较字符串长度 结果如下表所示，输入列为输入的待比较字符串，输出列的单位为 Wei Input A Input B Hash Character + Length Hash + Length abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz 1225 7062 1261 abcdefghijklmnopqrstuvwxyX abcdefghijklmnopqrstuvwxyz 1225 7012 1261 Xbcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz 1225 912 1261 aXcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz 1225 1156 1261 abXdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz 1225 1400 1261 abcdefghijkl abcdefghijklmnopqrstuvwxyz 1225 690 707 a a 1225 962 1261 ab ab 1225 1156 1261 abc abc 1225 1450 1261 可以看出，哈希+字符串长度 的比较方式 Gas 消耗更加稳定，这种方式比较高效。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:1:3","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"2. 可见性与Getter函数 转自：Solidity 0.6.4 中文文档 Solidity 有两种函数调用：内部调用（Internal Function Calls）和外部调用（External Function Calls）。前者指直接或递归地调用合约内部函数，不会产生实际的 EVM 调用，因此也被称为「消息嗲用」，后者指从合约外部调用合约中的函数，会产生一个 EVM 调用。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:2:0","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 可见性 因此，函数和状态变量有四种可见性。函数可以指定为 external，public，internal 或 private，对于状态变量， 默认是 internal 且不能设置为 external。 external：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f()可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存. public：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。 internal：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。 private：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。 合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。 可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间，如下例 pragma solidity \u003e=0.4.16 \u003c0.7.0; contract C { function f(uint a) private pure returns (uint b) { return a + 1; } function setData(uint a) internal { data = a; } uint public data; } 在下面的例子中，D 可以调用 c.getData（） 来获取状态存储中 data 的值，但不能调用 f 。 合约 E 继承自 C ，因此可以调用 compute。 pragma solidity \u003e=0.4.0 \u003c0.7.0; contract C { uint private data; function f(uint a) private returns(uint b) { return a + 1; } function setData(uint a) public { data = a; } function getData() public returns(uint) { return data; } function compute(uint a, uint b) internal returns (uint) { return a+b; } } // 下面代码编译错误 contract D { function readData() public { C c = new C(); uint local = c.f(7); // 错误：成员 `f` 不可见 c.setData(3); local = c.getData(); local = c.compute(3, 5); // 错误：成员 `compute` 不可见 } } contract E is C { function g() public { C c = new C(); uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员） } } ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:2:1","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 Getter 函数 编译器自动为所有 public 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 data 的函数， 该函数没有参数，返回值是一个 uint 类型，即状态变量 data 的值。 状态变量的初始化可以在声明时完成。 pragma solidity \u003e=0.4.0 \u003c0.7.0; contract C { uint public data = 42; } contract Caller { C c = new C(); function f() public { uint local = c.data(); } } getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果使用外部访问（即用 this. ），它被认作为一个函数。 pragma solidity ^0.4.0 \u003c0.7.0; contract C { uint public data; function x() public { data = 3; // 内部访问 uint val = this.data(); // 外部访问 } } 如果你有一个数组类型的 public 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 data(0) 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如： pragma solidity \u003e=0.4.0 \u003c0.7.0; contract arrayExample { // public state variable uint[] public myArray; // 指定生成的Getter 函数 /* function myArray(uint i) public view returns (uint) { return myArray[i]; } */ // 返回整个数组 function getArray() public view returns (uint[] memory) { return myArray; } } 现在可以使用 getArray() 获得整个数组，而 myArray(i) 是返回单个元素。 下一个例子稍微复杂一些： pragma solidity ^0.4.0 \u003c0.7.0; contract Complex { struct Data { uint a; bytes3 b; mapping (uint =\u003e uint) map; } mapping (uint =\u003e mapping(bool =\u003e Data[])) public data; } 这将会生成以下形式的函数 function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) { a = data[arg1][arg2][arg3].a; b = data[arg1][arg2][arg3].b; } 请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:2:2","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"3. 合约间调用 之前的实验合约间的调用没有成功，这次就仔细地研究一下合约间地调用机制。分为两种情况 调用者和被调用者在一个sol文件中 调用者和被调用者在不同的sol文件中 本文提到的合约调用方法的实质是抽象合约的使用。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:3:0","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 同sol文件的智能合约调用 下面的智能合约中，Main和Add两个合约定义在一个Main.sol文件中，可以同时编译，然后逐个部署。 pragma solidity ^0.5.0; contract Main { Add add; constructor(address _m) public { add = Add(_m); } function Addnumber() public view returns (uint) { return add.add5(10); } } contract Add { function add5(uint s) public pure returns (uint){ return 5+s; } } 以使用Remix为例，点击编译按钮编译Main.sol文件，将会同时编译Main和Add两个合约。 然后首先部署Add合约，因为Main合约的部署需要Add的合约地址作为参数。切换到部署和运行选项卡，选择Add合约，点击Deploy，成功部署后，复制合约地址。 然后重新选择Main合约，填入Add合约地址作为参数，点击部署按钮。 测试合约间调用，由合约内容可知，Main合约中的Addnumber函数调用了Add合约的add5函数，传入参数为10，得到的结果应为15。展开左侧的Deployed Contracts，点击Addnumber进行调用，结果如下。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:3:1","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 不同sol文件的智能合约调用 这一次我们测试不同sol文件的智能合约调用，来一个复杂一点的，两个合约分别是Add.sol和Main.sol。 Add.sol使用了一个结构体来定义数值，并通过映射定义查找表来寻找这个值。文件中定义了两个函数，numRegister用来向表中添加数值，addValue用来将从表中查到的指定值+5返回。之所以用这个结构是因为我们的项目里用到了，这里来测试一下可不可行。 pragma solidity ^0.5.0; contract Add { struct Num{ uint value; } mapping(uint =\u003e Num) public lookupTable; function numRegister(uint key, uint _value) public { lookupTable[key].value = _value; } function addValue(uint key) public view returns (uint) { return lookupTable[key].value + 5; } } Main.sol没有多大变化 pragma solidity ^0.5.0; contract Main { Add add; constructor(address _m) public { add = Add(_m); } function Addnumber() public view returns (uint) { return add.addValue(5); } } contract Add { function addValue(uint key) public view returns (uint); } 仍然是先编译部署Add合约，部署后调用numRegister函数写入数值5，并调用addValue函数测试返回。 接着编译部署Main合约，复制Add合约地址作为初始化参数，部署后调用Addnumber函数测试 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:3:2","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 总结 合约内的调用方法是相同的，都要先实例化，然后传入被调合约地址，接着才能调用。而写在不同sol文件中时，需要额外声明被调合约的抽象合约，有些文章中说使用call，callcode或delegatecall，但并不建议，因为这三个函数都是非常底层的函数，破坏了类型的安全，只能作为最后的手段使用。 详细的解释参考了StackExchange-Calling function from deployed contract ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:3:3","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"4. 函数修饰词pure和view 转自深入理解Solidity-函数 这两个函数修饰词的作用是告诉编译器函数是否会读取/修改状态，view 表示保证不修改状态，pure 表示保证不读取也不修改状态。Solidity v0.4.17 之前没有这两个修饰词，而是使用 constant 关键字，和 view 的含义相同，不过在 v0.5.0 之后被移除，现在只能使用这两个 view 和 pure。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:4:0","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 view 视图函数 Getter 方法会被自动标记为 view，除此之外，一个 view 修饰的例子如下 pragma solidity \u003e=0.5.0 \u003c0.7.0; contract C { function f(uint a, uint b) public view returns (uint) { return a * (b + 42) + now; } } view 保证函数不修改状态，以下操作会被认为是修改状态 修改状态变量。 产生事件。 创建其它合约。 使用 selfdestruct。 通过调用发送以太币。 调用任何没有标记为 view 或者 pure 的函数。 使用低级调用。 使用包含特定操作码的内联汇编。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:4:1","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 pure 纯函数 pure 保证不读取也不修改状态，不修改的定义上面已经提到，下面的操作被认为是读取状态 读取状态变量。 访问 address(this).balance 或者 .balance。 访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。 调用任何未标记为 pure 的函数。 使用包含某些操作码的内联汇编。 一个 pure 修饰的例子如下 pragma solidity \u003e=0.5.0 \u003c0.7.0; contract C { function f(uint a, uint b) public pure returns (uint) { return a * (b + 42); } } ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:4:2","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"5. 浮点数处理 首先声明，Solidity 中支持浮点数定义，但无法赋值和进行计算。文档中对其描述是「目前还不完全支持」，虽然这意味着以后可能会完全支持，但等不及了，下面记录几个可参考的资料。 来自 ethereum stackexchange 中的回答，介绍了一些可用的库； ABDK Math Quad，包含两个合约库，一个支持定点数，一个支持浮点数； Mikhail Vladimirov 的 Math in Solidity 系列文章，介绍如何在 Solidity 中处理各种数学运算，写的非常棒。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:5:0","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"6. 地址类型 在智能合约中显式传入地址类型时，可能会出现如下错误 Address checksum This looks like an address but has an invalid checksum. If this is not used as an address, please prepend ‘00’. 关于该问题的一个讨论见 https://github.com/ethereum/EIPs/issues/55 这是因为合约中现在使用地址类型必须做一个转换，不是简单的全部大写字母或小写字母，而是遵循一定的规则，这个规则见 ethereum/EIPs#55 但是网上提供的解决方案一般是使用JS库中的转换函数，在智能合约中无法直接解决，好在，web3提供了一个在线API接口，可以调用其checkAddressChecksum函数对地址进行转换，然后将转换后的结果直接用于合约代码。 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:6:0","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"7. Gas limit问题 在搭建的以太坊私链上进行智能合约部署时，出现了以下问题 INFO [03-21|13:50:11.690] Served eth_sendTransaction reqid=24 t=684.186µs err=\"exceeds block gas limit\" Error: exceeds block gas limit undefined 出现该错误的原因如错误描述，是当前合约所需的gas超过了区块的最大gas。这可能与参数gasLimit有关。在创世区块的配置文件中，我们使用了默认的配置值，为0x2fefd8，转换为10进制即3141592。 注：在线转换工具 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:7:0","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"原因查找 因为部署智能合约之前已经进行过挖矿，区块链中已有数个区块，我们查询目前的gasLimit值。 \u003eeth.getBlock(eth.blockNumber) { difficulty: 131072, extraData: \"0xd683010900846765746886676f312e3132856c696e7578\", gasLimit: 3147727, gasUsed: 0, hash: \"0x7e03472bcad02f6e85a3cdb21cfba856da58a4955dd2b6d21e3b8561446ae390\", logsBloom: \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", miner: \"0x79b43b2196723fff1485999aba45fda3e8b4df58\", mixHash: \"0x10a5130f4ea573f1f1599c11b8ade9ac3feb256c0414db1a277b7b63e8343d48\", nonce: \"0x6bba1166a347ba0f\", number: 2, parentHash: \"0xed8c7febfc1ab5e4e388bd886be1182635e77b0047f530c93af4eb31f898bd7c\", receiptsRoot: \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", sha3Uncles: \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", size: 534, stateRoot: \"0x741c086895803cc3f85c8e7fb738acfb42aa03a12a03edf246b1c14055123b78\", timestamp: 1552396507, totalDifficulty: 263168, transactions: [], transactionsRoot: \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", uncles: [] } 发现此时区块的gasLimit值为3147727。 查找我们部署的合约web3代码 var testContract = web3.eth.contract([{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"multiply\",\"outputs\":[{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]); var test = testContract.new( { from: web3.eth.accounts[0], data: '0x6080604052348015600f57600080fd5b5060a58061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063c6888fa114602d575b600080fd5b605660048036036020811015604157600080fd5b8101908080359060200190929190505050606c565b6040518082815260200191505060405180910390f35b600060078202905091905056fea165627a7a72305820028fd57d2fec4df9170b559fe84245ed4f81bc40f3cad3c185c8035501bdb3220029', gas: '4700000' }, function (e, contract){ console.log(e, contract); if (typeof contract.address !== 'undefined') { console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash); } }) 发现合约所需gas为4700000，比gasLimit值高，所以部署失败，出现了Error: exceeds block gas limit undefined的错误 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:7:1","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["研究生的区块链学习之路"],"content":"解决办法 第一种解决办法是修改genesis.json中的gasLimit参数，设置一个更大的值。但这样做需要重新构建网络，极为繁琐。 另一种解决办法是通过geth命令的--targetgaslimit参数来调整gasLimit值 \u003e --targetgaslimit 4712388 这里没有调整成功，提示原因是端口在运行，可能和docker有关，不知道怎么解决。 该问题最后是通过调整web3中的gaslimit值解决的，因为这个简单的智能合约怎么看都不像能消耗4700000gas的样子，果然查询之后发现只消耗100000左右，于是将web3代码中的gaslimit调整到120000，重新部署，果然成功。 一个关于gaslimit的解释见：以太坊Block Gaslimit动态调整机制分析 ","date":"2020-05-04","objectID":"/2020/summary-of-smart-contract-knowledge-points/:7:2","tags":["区块链"],"title":"智能合约知识点总结","uri":"/2020/summary-of-smart-contract-knowledge-points/"},{"categories":["爱编程爱技术的孩子"],"content":"在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Branch\u0026Bound）就是两种减小搜索空间大小的技术。 ","date":"2020-05-04","objectID":"/2020/algorithm-backtracking/:0:0","tags":["数据结构与算法"],"title":"算法-回溯","uri":"/2020/algorithm-backtracking/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 回溯的基本思想 ","date":"2020-05-04","objectID":"/2020/algorithm-backtracking/:1:0","tags":["数据结构与算法"],"title":"算法-回溯","uri":"/2020/algorithm-backtracking/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 解空间树 假设可以用一个 n 元组 $X=(x_1,x_2,……,x_n)$ 来表示所求问题的解，其中 $x_i$ 的取值范围为某个有穷集合 S。我们把 $X=(x_1,x_2,……,x_n)$ 所有可能取值的组合称作问题的解空间。 举个例子，假设 0-1 背包问题中物品有 3 个，用 $X=(x_1,x_2,x_3)$ 表示，其中 $x_i \\in \\{0,1\\}, 1 \\leq i \\leq 3$，则问题的解空间为 $\\{(0,0,0),(0,1,0),(0,0,1),(1,0,0),(0,1,1),(1,0,1),(1,1,0),(1,1,1)\\}$ 我们用一颗 n+1 层的树来表示解空间，其中，第 i 层和第 i+1 层之间边的标号表示变量 $x_{i+1}$ 的可能取值，从根结点到叶节点路径上的标号就构成问题的一个可能的解。 我们还可以这样理解解空间，将解空间划分为两个维度：一个可行解中元素的个数和每个元素的取值范围。这两者正好对应解空间树的深度（实际是深度-1）和宽度。比如在上面的 0-1 背包问题中，问题的一个解由一个 3 元组 $X=(x_1,x_2,x_3)$ 表示，这里每个解中有 3 个元素，因此解空间树的深度是 4，每个元素有 0 和 1 两个取值，因此每个节点有两棵子树。 注：这里树的深和宽不是标准化的说法，仅为了便于说明。理解上面这段话非常有利于实际解决问题时解空间树的构造。 ","date":"2020-05-04","objectID":"/2020/algorithm-backtracking/:1:1","tags":["数据结构与算法"],"title":"算法-回溯","uri":"/2020/algorithm-backtracking/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 基本思想 回溯的基本思想是：在问题的解空间树中，按照深度优先的策略，从根结点出发搜索。搜索至任一结点时，先判断该结点和其儿子结点的边所标记的值是否满足解的要求，是就加入到解中，继续向下深度优先搜索以其儿子结点为根的子树，否则就结束对以该儿子结点为根的子树的搜索，选择对另一个儿子结点作为根的子树进行搜索。全部搜索完毕或都不满足就向父节点回溯。 仍以 0-1背包问题为例，设物品重量为 $w=[16,15,15]$，物品价值为 $v=[45,25,25]$，背包容量 $c=30$。定义 $r$ 为当前背包的剩余容量，$v$ 为当前背包的价值。因为物品有 3 个，所以树深为 3+1=4，又因为每个解元素有两种取值，1为放入背包，0为不放入，所以每个结点有两棵子树，最终解空间树绘制如下 遇到某个结点判断与儿子结点的边是否满足条件时，用到剪枝函数，分两种 约束函数：就是不可行的解，比如上图第二层第一个结点，r=14，小于当前物品重量 15，因此子树不可行； 限界函数：就是非最优解，比如上图虚线框起来的结点，因为之前得到的最大价值为 v=50，这里出现的 v 都小于该值，所以不是最优解。 我们理解了基本思想后，就可以很容易的发现回溯的最坏时间复杂度是 $O(N×2^N)$ ","date":"2020-05-04","objectID":"/2020/algorithm-backtracking/:1:2","tags":["数据结构与算法"],"title":"算法-回溯","uri":"/2020/algorithm-backtracking/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 一般步骤 回溯法的一般步骤为 针对所给问题，定义问题解空间 确定易于搜索的解空间树 以深度优先的方式搜索解空间树，并在搜索过程中用剪枝函数避免无效搜索 用约束函数考察左子树是否可行 用限界函数考察右子树是否（有可能）最优 经常用回溯法解决的问题有两类：子集树和排列树。子集树是从 n 个元素的集合中找出满足某种性质的子集，排列树是确定 n 个元素满足某种性质的排列，下面分别介绍两类问题的思路。 ","date":"2020-05-04","objectID":"/2020/algorithm-backtracking/:1:3","tags":["数据结构与算法"],"title":"算法-回溯","uri":"/2020/algorithm-backtracking/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 子集树 给定一个不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。leetcode 78题-子集 注：解集不能包含重复的子集 示例输入: nums = [1,2,3] 示例输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 回溯法可以保证生成的结果完整无冗余，实际上，就是输出整棵子集树（解空间树）。本题中，解向量的维度是 3 ，每个解元素有选择和不选择两种可能，因此解空间树是一颗4层的二叉树。 func subsets(nums []int) [][]int { res := make([][]int,0) cur := make([]int,0) // 使用闭包可以节省 nums,res,cur 三个参数的传递，同时避免 res 的全局定义 // 必须事先声明，否则无法在函数中调用自身 var backTrace func(level int) // 回溯的思路是每个元素都有选择与不选择两种可能，解空间树是一棵 n+1 层二叉树 backTrace = func(level int) { // len(nums)+1 层说明位于叶子节点，将当前可行解加入结果数组 if level \u003e len(nums) { // 建立一个新切片，将结果复制到新切片，然后再添加到结果集，因为 cur 是指向结果的指针，指向的结果后面还会变动 tmp := make([]int,len(cur)) copy(tmp,cur) res = append(res,tmp) return } // 遍历二叉树的两个分叉 for i := 0; i \u003c= 1; i++ { // i 为 0 表示当前元素不加入当前解 if i == 0 { backTrace(level+1) }else{ cur = append(cur,nums[level-1]) backTrace(level+1) // 删除当前元素然后进行回溯 cur = cur[:len(cur)-1] } } } backTrace(1) return res } 一种常用的减小时空复杂度的方法是位运算，用于每个元素的可能取值为 0 和 1 的情况。取值只有 0 和 1 的情况下，我们可以将一条完整的路径看作一个二进制数字，比如一个 n+1 层的二叉树的每一个可行解都可以看作一个 n+1 位的二进制数字，二进制数字的每一位代表该层的元素选择或不选择，这样，只要生成所有可能的二进制数就构成了一个完整的解空间，程序如下 func subsets(nums []int) [][]int { ln := len(nums) // 这样移位保证左边0的存在，比如一共3位，保证001而不是0，可以从 1000 到 10000 进行遍历，取每个值的右边三位 s, e := 1\u003c\u003cln, 1\u003c\u003c(ln+1) var res [][]int for i := s; i \u003c e; i++ { var tmp []int for j := 0; j \u003c ln; j++ { // 通过与运算判断当前位是否为1，为1则加入结果，i为当前元素 if i\u0026(1\u003c\u003cj) != 0 { tmp = append(tmp, nums[j]) } } res = append(res, tmp) } return res } 上面的子集树问题还有另一种回溯思路，那就是单独计算每一种可能长度的解的集合，然后统一添加到最终的集合。比如对于 nums=[1,2,3]，一个元素的解集为{[1],[2],[3]}，两个元素的解集为{[1,2],[2,3],[1,3]}，三个元素的解集为{[1,2,3]}，再加上空集，就是总的结果。程序如下 func subsets(nums []int) [][]int { res := make([][]int,0) // 使用闭包可以节省 nums 和 res 两个参数的传递，同时避免 res 的全局定义 var backTrace func(cur []int, index,length int) // 必须事先声明，否则无法在函数中调用自身 backTrace = func(cur []int, index,length int) { // 结束条件为元素个数达到了当前限定的长度 if len(cur) == length { // 将结果复制到新切片后再添加到结果集，因为 cur 是指向结果的指针，指向的结果后面还会变动 tmp := make([]int,length) copy(tmp,cur) res = append(res,tmp) return } // 可以看作遍历子树，儿子节点所有可能的取值是未使用过的值，也就是索引 index 之后的值 for i := index; i \u003c len(nums); i++ { // 当前节点加入结果，然后递归遍历子树 cur = append(cur,nums[i]) backTrace(cur,i+1,length) // 进行回溯，去除当前结果，回到上一层 cur = cur[:len(cur)-1] } } // 对于每个长度的序列，将所有可能加入最终的结果集 for i := 0; i \u003c= len(nums); i++ { cur := make([]int,0) backTrace(cur,0,i) } return res } 用回溯法搜索子集树的一般算法为 Backtrack(k) //t：递归深度，即当前活动结点在解空间树中的深度，根节点t=1 //n：解空间树的高度，即问题的规模 //算法已搜索到一个叶结点，对可行解x进行记录或输出 if t \u003e n output(x) else //搜索当前活动结点的子树 for i = 0 to 1 do //以二叉树为例 x[t] = i //当前活动结点x[t]的第i个取值 //满足约束条件且目标函数未越界时，搜索子树 if (Constraint(t) and Bound(t)) Backtrack(t+1) 如果说上面求子集的例子其实是求所有的可能，没有进行剪枝，下面可以给出另一个例子 题目：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例： 输入：n = 3 输出：[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 程序如下 func generateParenthesis(n int) []string { res := make([]string,0) cur := make([]byte,0) a,b := 0,0 var backTrace func(level int) backTrace = func(level int) { if level \u003e 2*n { if a == b { res = append(res, string(cur)) } return } if a \u003c n { cur = append(cur,'(') a++ backTrace(level+1) cur = cur[:len(cur)-1] a-- } if b \u003c a { cur = append(cur,')') b++ backTrace(level+1) cur = cur[:len(cur)-1] b-- } } backTrace(1) return res } 其中 a \u003c n 和 b \u003c a 就是用来剪枝的，回溯的一个关键步骤就是在调用回溯函数之前添加到结果集，之后从结果集删除，这就是回溯的本质含义。 ","date":"2020-05-04","objectID":"/2020/algorithm-backtracking/:2:0","tags":["数据结构与算法"],"title":"算法-回溯","uri":"/2020/algorithm-backtracking/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 排列树 以全排列的例子开头，leetcode 64题-全排列 题目：给定一个没有重复数字的序列，返回其所有可能的全排列。 示例输入: [1,2,3] 示例输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 排列与子集问题的区别在于每一层子树的个数都减1，因为已选择的元素不必再次出现，因此，全排列问题是一棵4层，然后每层子树个数依次减一的树，这样时间复杂度也很容易理解，就是 $N!$。 解上面问题的程序如下 func permute(nums []int) [][]int { res := make([][]int,0) cur := make([]int,0) var backTrace func(level int) backTrace = func(level int) { if level \u003e len(nums) { tmp := make([]int,len(cur)) copy(tmp,cur) res = append(res,tmp) return } for i := level-1; i \u003c len(nums); i++ { cur = append(cur, nums[i]) // nums 数组中，level-1 索引前的是已用过的，不能选，只能选 level-1 之后的，在未选元素 //集合中选了任何一个元素后，与未选元素集合的第一个交换，相当于把刚刚选择的元素加入了已选元 //素集合，到下一层索引向前移动一格，就保证了下一层的未选元素集合正确 nums[i],nums[level-1] = nums[level-1],nums[i] backTrace(level+1) cur = cur[:len(cur)-1] nums[i],nums[level-1] = nums[level-1],nums[i] } } backTrace(1) return res } 思路和子集树基本相同，多的一个步骤交换是用来处理每层子树个数减一这个问题的，实质是不断的调整未选择元素的集合。交换是一种高效的做法，除此之外，还可以用一个 Map 来标记已选和未选元素。 用回溯法搜索排列树的一般算法为 Backtrack(k) //t：递归深度，即当前活动结点在解空间树中的深度，根节点t=1 //n：解空间树的高度，即问题的规模 //算法已搜索到一个叶结点，对可行解x进行记录或输出 if t \u003e n output(x) else //搜索当前活动结点的子树 //处理[t:n]的排列 for i = t to n do swap(x[t],x[i]) //满足约束条件且目标函数未越界时，搜索子树 if (Constraint(t) and Bound(t)) Backtrack(t+1) swap(x[t],x[i]) // 回溯到交换之前 ","date":"2020-05-04","objectID":"/2020/algorithm-backtracking/:3:0","tags":["数据结构与算法"],"title":"算法-回溯","uri":"/2020/algorithm-backtracking/"},{"categories":["爱编程爱技术的孩子"],"content":"贪心是一种策略，是一种总是寻求当前最优的策略。因为贪心只关心局部的最优，因此不是总能得到全局的最优解，所以我们选择贪心解决问题时必须保证状态的独立性，即当前最优值只与当前状态有关，不会影响以后的状态。 动态规划与贪心的区别在于动态规划状态之间是有联系的，这也是状态转移方程的制定依据，但它们也有相同之处，那就是原问题的最优解必须包含子问题的最优解，这条性质叫做最优子结构性质，这是一个问题可用动态规划或贪心来解决的基础。 下面我们通过一系列的问题来说明贪心问题，尤其要关注的是贪心策略的选取。 ","date":"2020-05-03","objectID":"/2020/algorithm-greedu/:0:0","tags":["数据结构与算法"],"title":"算法-贪心","uri":"/2020/algorithm-greedu/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 背包问题 问题描述：给定 n 种物品和一个背包。物品 i 的重量是 $w_i$，其价值为 $v_i$，背包的容量为 c。问应如何选择装入背包 的物品，使得装入背包中物品的总价值最大? 背包问题是可用贪心来解决的，直觉上，可以有以下几种贪心选择策略 价值贪心：优先选择价值最大的物品，但这种方法如果选择的物品重量很大，背包载重的消耗速度会很快； 重量贪心：优先选择重量最小的物品，这种方法又不能保证价值快速增加； 价值重量比：将物品重量按单位重量的价值降序排列，依次装入，这样能保证最优。 // n 为物品数量，M为背包容量，v,w 分别为单个物品的价值和重量，x为解向量 func Knapsack_greedy(n,M int, v,w,x []int) { sort(n,v,w) // 按照单位重量价值进行排序 for i := 1; i \u003c n; i++ { // 初始化解向量 x[i] = 0 } c = M // c 是背包当前载重 for i := 1; i \u003c n; i++ { if w[i] \u003e c { x[i] = 1 c -= w[i] } } if i \u003c= n { x[i] = c/w[i] // 装入第 i 个物品的部分 } } 如果想要证明该问题使用贪心算法是可行的，可以按如下思路：首先证明原问题的一个最优解是以贪心选择开始。然后假设i次贪心选择能 够得到一个最优解，那么证明i+1次贪心选择也能得到一个最优解。一个图解如下 ","date":"2020-05-03","objectID":"/2020/algorithm-greedu/:1:0","tags":["数据结构与算法"],"title":"算法-贪心","uri":"/2020/algorithm-greedu/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 活动安排问题 要求高效地安排一系列争用某一公共资源（如会议室）的活动，使尽可能多的活动能兼容使用公共资源，这就是活动安排问题。 设有 n 个活动的集合 $E={e_1 ,e_2…e_n}$，其中每个活动都要求使用同一资源，而在同一时间内只有一个活动能使用 这一资源。每个活动 i 都有一个要求使用该资源的起始 时间 $s_i$ 和一个结束时间 $f_i$，且 $s_i \u003c f_i$。如果选择了活动 i，则它在半开时间区间 $[s_i ,f_i)$内占用资源。若区间$[s_i ,f_i)$与区间$[s_j ,f_j)$不相交，则称 $e_i$和$e_j$ 是相容的。 也就是说，当 $s_i≥f_j$ 或 $s_j≥f_i$ 时，活动 i 和活动 j 相容。 我们可以想到的贪心策略有 选择具有最早开始时间的活动 选择具有最早结束时间的活动 选择具有最少占用时间的活动 选择覆盖未选择活动最少的活动 但直观上，每次选择具有最早结束时间的相容活动，使剩余 的可安排时间段极大化，以便安排尽可能多的相容活动。事实也是如此，我们用图来说明一个实例 实现如下 // n 为活动数量，s,f分别为每个活动的起始和结束时间，A为结果集合 func GreedySelector(n int, s,f []int, A []bool) { A[1] = true j := 1 for i := 2; i \u003c n; i++ { if s[i] \u003e= f[j] { A[i] = true j = i }else{ A[i] = false } } } ","date":"2020-05-03","objectID":"/2020/algorithm-greedu/:2:0","tags":["数据结构与算法"],"title":"算法-贪心","uri":"/2020/algorithm-greedu/"},{"categories":["爱编程爱技术的孩子"],"content":"动态规划策略通常用于求解最优化问题。在这类问题中，可能会有许多可行解，每个解对应一个值，我们希望找到具有最优值的那个解，也就是最优解。当题目中涉及「最大」「最小」等词时，很有可能就是这类问题，要考虑是否可用动态规划求解。 ","date":"2020-05-01","objectID":"/2020/algorithm-dynamic-programming/:0:0","tags":["数据结构与算法"],"title":"算法-动态规划","uri":"/2020/algorithm-dynamic-programming/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 基本介绍 动态规划（Dynamic Programming, DP）的思想与分治法很类似，也是把待求解问题分解成若干子问题，不同的是，分治法的子问题是相互独立的，而动态规划的子问题可能重复。我们通过保存已解决的子问题的答案，在需要时就可以直接访问这些已求得的答案，这样可以避免大量重复计算，从而得到多项式时间内的算法。 ","date":"2020-05-01","objectID":"/2020/algorithm-dynamic-programming/:1:0","tags":["数据结构与算法"],"title":"算法-动态规划","uri":"/2020/algorithm-dynamic-programming/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 找零钱问题 这里拿一个找零钱的问题举例：假设有4分、3分、1分三种硬币面值，要找给顾客6分钱，应该怎么做？我们按以下步骤来思考： 假设要找给顾客的是1分钱，那么只需要一个1分面值的硬币 假设找2分钱，需要两个1分面值的硬币（1分 + 1分） 假设找3分钱，需要一个3分面值的硬币 假设找4分钱，需要一个4分面值的硬币 假设找5分钱，可能是 1 + 4：1个1分面值 + 1个4分面值（硬币数最少） 2 + 3：2个1分面值 + 1个3分面值 假设找6分钱，可能是 1 + 5：1个1分面值 + （1个1分面值 + 1个4分面值） 2 + 4：1个1分面值 + 1个4分面值 3 + 3：1个3分面值 + 1个3分面值 找2分钱的时候重复利用了找1分钱的结果，不过这个不是很明显，最明显的是，找6分钱的时候重复利用了找5分钱的结果（5分钱中 1+4 是最优解法） ","date":"2020-05-01","objectID":"/2020/algorithm-dynamic-programming/:1:1","tags":["数据结构与算法"],"title":"算法-动态规划","uri":"/2020/algorithm-dynamic-programming/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 常用概念 动态规划中涉及的一些术语解释如下 术语 解释 阶段（stage） 将所给问题的过程，按时间或空间特征分解成若干相互联系的阶段，以便按次序去求每阶段的解 状态（state） 各阶段开始时的客观条件叫做状态 决策（decision） 当各阶段的状态确定后，就可以做出不同的决定，从而确定下一阶段的状态，这种决定称为决策 状态转移（transition） 根据上一阶段的状态和决策来导出本阶段的状态 对动态规划思想中[重叠子问题]^(overlapping subproblem)的理解是：前一个阶段的状态可以带当前阶段，当前阶段的状态可以带到下一个阶段，利用表格记录之前所有阶段的状态。放在找零钱问题中，找5分钱得到的状态是 「1个1分 + 1个4分」，这一状态被存起来（通常是一个数组），到下一状态，也就是找6分钱的时候，就可以直接应用这个结果。 从分析中可以看到，我们在每个阶段用的都是上一个阶段的最优解，这就要求我们遇到的问题也必须符合这个性质才能应用动态规划算法。只有原问题的最优解包含子问题的最优解，我们才能自底向上地从子问题的最优解逐步构造出原问题的最优解。 ","date":"2020-05-01","objectID":"/2020/algorithm-dynamic-programming/:1:2","tags":["数据结构与算法"],"title":"算法-动态规划","uri":"/2020/algorithm-dynamic-programming/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 算法的基本步骤 分析最优解的结构。这一阶段需要我们证明原问题的最优解包含子问题的最优解，运用反证法。首先假设由原问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题的最优解更好的解，从而导致矛盾。 递归定义最优值。建立当前阶段最优值和前一阶段最优值的递推关系式，当前阶段的决策为：选中可能解中的最优解。 计算最优值。以自底向上的方式在表格中存储各个阶段的最优值。 构造最优值。从原问题的最优值开始，根据计算各个阶段最优值时得到的信息回溯。 一个容易看懂的步骤为 表示解 表示最优解 根据原问题的最优解和子问题的最优解的关系确定状态转移方程 确定边界条件 利用 dp 数组记录状态，编写程序解决 以最长公共子序列问题为例，使用上述步骤解决，问题描述如下 给定2个序列 $X=\\{x_1,x_2,……,x_m\\}$ 和 $Y=\\{y_1,y_2,……,y_n\\}$，找出 X 和 Y 的最长公共子序列。 公共子序列只需要保持下标递增的相对顺序即可，元素可以不相邻。例如，序列 $Z=\\{B,C,D,B\\}$ 是序列 $X=\\{A,B,C,B,D,A,B\\}$ 的一个子序列，相应的递增下标序列为 $\\{2,3,5,7\\}$ 给定2个序列 X 和 Y ，当另一个序列 Z 既是 X 子序列又是 Y 的子序列时，称 Z 是序列 X 和 Y 的公共子序列 分析最优解结构 设序列 $X=\\{x_1,x_2,……,x_m\\}$ 和 $Y=\\{y_1,y_2,……,y_n\\}$ 的最长公共子序列为 $Z=\\{z_1,z_2,……,z_k\\}$。 $X_{m-1}=\\{x_1,x_2,……,x_{m-1}\\}$;$Y_{n-1}=\\{y_1,y_2,……,y_{n-1}\\}$;$Z_{k-1}=\\{z_1,z_2,……,z_{k-1}\\}$ 若 $x_m = y_n$，则 $z_k = x_m = y_n$，且 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的最长公共子序列 若 $x_m \\neq y_n$，且 $z_k \\neq x_m$，则 $Z$ 是 $X_{m-1}$ 和 $Y$ 的最长公共子序列 若 $x_m \\neq y_n$，且 $z_k \\neq y_n$，则 $Z$ 是 $X$ 和 $Y_{n-1}$ 的最长公共子序列 这里假设了最优解，然后分析了三种情况的子问题最优解都包含在原问题的最优解中。 递归定义最优值 定义 $C[i][j]$ 是 $X_i$ 和 $Y_j$ 的最长公共子序列的长度，其中， $X_i=\\{x_1,x_2,……,x_i\\}$ ， $Y_j=\\{y_1,y_2,……,y_j\\}$ 。 递归关系为： 存储结构的示意图为 计算最优值 LCSLength(x,y,c,b) { m = x.length - 1 n = y.length - 1 for i = 1 to m do c[i][0] = 0 for j = 1 to n do c[0][j] = 0 for i = 1 to m do for j = 1 to n do if x[i] = y[j] c[i][j] = c[i-1][j-1] + 1 b[i][j] = 1 // 表示对角线值 else if c[i-1][j] \u003e= c[i][j-1] c[i][j] = c[i-1][j] b[i][j] = 2 // 表示上值 else c[i][j] = c[i][j-1] b[i][j] = 3 // 表示左值 } 构造最优解 LCS(i,j,x,b) { if i = 0 or j = 0 return if b[i][j] = 1 Lcs(i-1,j-1,x,b) print(x[i]) else if b[i][j] = 2 Lcs(i-1,j,x,b) else Lcs(i,j-1,x,b) } 结果 设给定的两个序列为 $X={x,y,x,z,y,x,y,z,z,y}$，$Y={x,z,y,z,x,y,z,x,y,z,x,y}$，跟踪算法 LCSLength 和 LCS 的运行结果。为简单计，用 $c[i][j] / b[i][j]$ 表示每个阶段的状态，过程如下 根据 OI Wiki，将 DP 问题主要分为九种，下面进行介绍。 ","date":"2020-05-01","objectID":"/2020/algorithm-dynamic-programming/:1:3","tags":["数据结构与算法"],"title":"算法-动态规划","uri":"/2020/algorithm-dynamic-programming/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 背包 DP 背包问题是最经典的问题之一，普遍出现在动态规划部分和运筹学的书中，下面描述问题 有 n 个物品和一个容量为 W 的背包，每个物品有重量 $w_i$ 和价值 $v_i$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。 ","date":"2020-05-01","objectID":"/2020/algorithm-dynamic-programming/:2:0","tags":["数据结构与算法"],"title":"算法-动态规划","uri":"/2020/algorithm-dynamic-programming/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 0-1 背包 如果选择装入背包的物品时，每种物品 $i$ 只有两种选择：装入或不装入。不能将物品 $i$ 装入背包多次，也不能只装入部分物品。这就是 0-1 背包问题。 形式化问题为：找出一个 n 元 0-1 向量$（x_1,x_2,……,x_n）$ ，使得 $max \\sum_{i=1}^n v_i x_i$，需满足以下两个约束条件 $$ \\sum_{i=1}^n w_i x_i \\leq c \\\\ x_i \\in \\{0,1\\}, 1 \\leq i \\leq n $$ 下面证明该问题具有最优子结构性质，即原问题的最优解包含子问题的最优解。 原问题：假设当前有 n 种物品，背包载重为 c 原问题的最优解：$(y_1,y_2,……,y_n)$ 子问题：除第一个物品外的 n-1 种物品，背包载重为 $c-w_1y_1$ 子问题的最优解：$(y_2,……,y_n)$ 可以看出，如果原问题和原问题的最优解成立，那么子问题的最优解就成立且包含在原问题的最优解中。 然后来递归定义最优值，通常这个式子也叫做状态转移方程。注意证明过程中给出的最优解的序列先后顺序不一定等于物品的序列顺序。我们定义子问题 $P(i,W)$ 为：在前 i 个物品中挑选总重量不超过 W 的物品，只能挑选一个并使总价值最大，这时的总价值（最优值）记作 $m(i,W)$，其中 $i \\leq i \\leq n; 1 \\leq W \\leq C$，得到的状态转移方程如下 如果我们确认了状态转移方程的正确，就不要再想其它的了，不然只会陷入思维陷阱。接下来根据方程编写程序计算最优值与构造最优解即可 Input: n,C, w[],v[] for W=0 to C do m[0][W] = 0 for i=0 to n do m[i][0] = 0 for i=1 to n for W=1 to C if w[i] \u003e W m[i][W] = m[i-1][W] else m[i][W] = max{m[i-1][W], v[i]+m[i-1][W-w[i]]} return m[n][C] ","date":"2020-05-01","objectID":"/2020/algorithm-dynamic-programming/:2:1","tags":["数据结构与算法"],"title":"算法-动态规划","uri":"/2020/algorithm-dynamic-programming/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 完全背包 完全背包问题中一个物品可以选取无数次，而不是一次。子问题的定义与0-1背包相同，但状态转移方程有区别 $$ m(i,W) = max\\{m(i-1,W),v_i + m(i,W-w_i)\\} $$ ","date":"2020-05-01","objectID":"/2020/algorithm-dynamic-programming/:2:2","tags":["数据结构与算法"],"title":"算法-动态规划","uri":"/2020/algorithm-dynamic-programming/"},{"categories":["研究生的区块链学习之路"],"content":"吸收了一些新论文的想法，对原访问控制系统功能做了补充，添加了恶意行为检测（或者称为动态访问控制），目的是减少恶意行为，增加合法行为在区块链中得到确认的几率。所有调整总结查看 附录I。 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:0:0","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"1. 背景与相关工作 基于智能合约实现的系统中，恶意的行为（如短时间频繁的调用）可能产生过量的交易，从而降低合法交易被区块链收集的概率，或者使得确认时间延长，而区块链本身无法对这类行为做出规避。初步的思路是吸收动态访问控制的思想，基于操作的严重性、资源的敏感性、用户的访问历史记录等信息，对决策做出动态的调整 ，从而完成对恶意行为的惩罚和合法行为的奖励。 目前，只有少数 Blockchain-IoT 访问控制的论文结合了动态访问控制的思想1 2，可以作为该方向的参考。 我们计划采用信誉机制来解决恶意行为处理问题，该思路来自于Huang等3的论文，他们在论文中设计了一个基于信誉的 PoW 共识机制来取得效率与安全的平衡。首先为节点 $i$ 设置一个信誉值属性 $Cr_i$，该值会随着节点的行为实时的变化。合法的行为，如遵守系统规则发送交易，会随着时间的推移使信誉值逐步增加，与之相反，节点产生异常行为会导致信誉值下降。PoW中的难度值会根据每个节点的信誉值自调整，信誉值越低，运行 PoW 算法花费的时间越长。因此，诚实的节点消耗的资源更少，恶意节点攻击所需的花费更多。 在该论文中，作者定义的攻击模型有两个（即两种恶意行为）： Lazy Tips：懒惰的节点指那些总是验证固定的以前的交易，而不去验证最新的交易的节点。例如，恶意实体可以通过发出许多验证固定交易对的交易来人为地扩大[提示]^(tips)的数量。这会使其它节点有更高的概率选中这些提示，而丢弃属于诚实节点的提示 Double-spending：通过在前一次花费被验证之前提交多个交易，恶意节点希望将一枚代币花费两次或多次，这就是双花问题。尽管这样的行为会被共识机制检测到并撤销，但它降低了系统效率，因为其它相关的交易也会被撤销重新执行。 更具体的信誉值增减算法的设计，可以参考 附录II。不过这里作者设计的算法与 PoW 结合程度较深，对恶意行为的惩罚依赖于难度值的调整，无法在 BFT 类共识算法中继续得到使用，同时，对于智能合约中由于函数调用产生的一些恶意行为，也难以阻止。 Mohammed等2 在 RBAC 中结合了信誉机制来消除恶意行为的影响，但该方案依赖于一个中心化的证书权威，恶意行为主要指的是证书的不一致和证书过期。 其它参考文献待补充… ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:1:0","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"2. 方案 第一步是调整整个合约系统的架构，这里会详细介绍调整后的架构是怎么样的，以及每种合约所调整的功能，最后介绍所设计的信誉算法。 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:2:0","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 合约架构 将原系统中的注册合约（Register Contract, RC）更名为管理合约（Management Contract, MC），将原系统中的判决合约（Judge Contract, JC）更名为信誉合约（Reputation Contract）。因此，当前系统中的三种合约分别为：管理合约 MC，访问控制合约 ACC 和信誉合约 RC，这几种合约间的调用关系如下图 管理合约 MC 负责管理其它合约和管理设备属性。ACC 在进行访问控制决策时，会首先从 MC 获取访问者的相关属性，然后和定义的策略进行匹配。在 MC 中注册的所有设备都新增了一个endBBN 固定属性，用于设置终止阻塞的区块号，该字段只能被信誉合约更新，用户和管理者都无法改动。 访问控制合约 ACC 负责管理 object 属性、访问控制策略和执行访问控制决策。对 ACC 相关函数的调用，其行为日志会提交给 RC 供分析。在执行访问控制决策时，会首先从 MC 读取访问者的 endBBN 字段，查看是否大于当前区块号，如果大于则直接阻止该请求，不会进入区块链网络。 信誉合约 RC 负责根据 ACC 提交的行为记录计算信誉函数的值，并根据该值计算阻塞区块数，最后调用 MC 的相关函数更新对应设备的endBBN 字段，做出惩罚。 之前有一个版本是使用时间作为惩罚的，但是 Solidity 提供的时间戳实际上是区块被挖掘时的时间戳，和区块号无异，反而区块号更能表示这种线性关系，所以最后选择使用区块数量作为惩罚标准。 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:2:1","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 新添加的功能 我们为访问控制系统（Access Control system, ACS）增加了两个新的功能，主要为了完善原系统没有考虑到的问题。 首先是策略冲突的解决机制，指的是当定义的众多策略条目产生冲突时，如何决定最终的结果。我们在 ACC 中为设备增加了一个算法（algorithm）字段，该字段可选的值有两个：denyoverrides 和 allowoverrides。前者表示只要有一条策略结果为 deny，最终的结果就是 deny，后者表示只要有一条策略结果为 allow，最终的结果就是 allow。在核心的访问控制决策函数中针对算法字段做出了相应的处理。该思路来自4，我们先前的方案相当于默认使用 allowoverrides 冲突解决机制。 其次是无策略定义时的处理方式。依靠管理员定义策略的一个问题是，总有可能出现遗漏，比如说，针对设备的某个资源没有定义策略，那么访问控制决策时就没有凭借。在之前的决策逻辑中，这种情况会被直接算作访问通过，然后给予授权，显然，这种处理方式是不合理的。我们在决策逻辑中，处理 deny 和 allow 两种结果，额外增加了一种名为 NotDefine 的结果，用作标识这种没有定义策略的情况。 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:2:2","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 恶意行为检测与处理 根据背景部分所述，为了处理区块链本身无法抵御的一些恶意行为，在吞吐量有限的情况下尽可能为合法行为提供更高的打包机会，我们添加了恶意行为检测和处理机制。采用信誉算法的原因是，不同的恶意行为严重程度不一致，我们不仅需要完成惩罚和奖励的基本功能，也需要提供一定的容忍。 3.3.1 信誉算法 设备 $i$ 的信誉值由两部分组成，合法行为的正面影响和恶意行为的负面影响。公式如下，其中，$Cr_i^P$ 为正面影响部分，$Cr_i^N$ 为负面影响部分，$\\lambda_1$ 和 $\\lambda_2$ 分别是它们的权重。 $$ Cr_i = \\lambda_1Cr_i^P - \\lambda_2Cr_i^N $$ 信誉值的负面影响部分 $Cr_i^N$ 也可以称为惩罚函数，其值与历史恶意行为的数量和类型（历史行为记录和操作严重性）有关，每个恶意行为的影响随着时间的推移逐渐减小，但不可以变为 0，具体的函数如下 $$ Cr_i^N = \\sum_{k=0}^{m_i-1} \\frac{\\alpha_k }{m_i-k} $$ 其中 $m_i$ 表示设备 $i$ 当前的恶意行为总数，$k$ 表示历史恶意行为的索引顺序，$\\alpha_k$ 表示第 $k$ 个恶意行为的惩罚系数，该系数在 0-1 内取值。$k$ 的最大取值为 $m_i-1$，因此分母最小值为 1，不会导致值过大；$k$ 从 0 开始取值是为了保证所有的历史恶意行为都会对当前结果产生影响。恶意行为种类包括如下三种，这里两种恶意行为不可能同时发生，因为策略检测失败必然导致设备受处罚，从而无法触发短时间高密度的请求，但以后添加其它恶意行为需要重新考虑。 短时间高密集的请求，行为 ID 为 1； 策略检查失败（非法访问），行为 ID 为 2； 重要策略检查失败。我们可以标识某条策略条目为重要，当违反该策略时，会作为恶意行为进行记录，比如，某个设备的访问目标一直都是固定的，突然发生了改变，说明可能是恶意的，又或者访问者的位置突然发生了改变等。这一类恶意行为优先级高于普通的策略检查失败（非法访问），计算时权重更高，行为 ID 为 3。 信誉值的正面影响部分 $Cr_i^P$ 可以称为奖励函数，其值与合法行为数量正相关，定义如下 $$ Cr_i^P = min({Cr_i^P}\\text{max}, (l_i-k_1)\\omega) $$ 其中，${Cr_i^P}_{max}$ 是 $Cr_i^P$ 的上界，防止奖励无限制积累，$l_i$ 为设备 $i$ 的合法行为总数，$k_1$ 是上一次做出惩罚时计算的最后一个合法行为索引，因此，$l_i-k_1$ 其实相当于当前计算奖励值的一个滑动窗口大小。合法的行为只有一种：访问通过，$\\omega$ 是合法行为的权重。 每一次行为提交都会更新行为列表，合法行为添加到合法行为列表，恶意行为添加到恶意行为列表，然后分别计算惩罚函数和奖励函数的值并得到最终的信誉值。当信誉值小于 0 时，会计算阻塞区块数并更新 MC 中设备对应的终止阻塞区块号属性， 同时更新计算使用的最后一个合法行为索引，当下次统计合法行为时，该索引之前的合法行为将不会被再次计算。与之相对的，恶意行为记录永远不会清空，虽然它们产生的影响随着时间的推移变小，但不可能消失，因此每次惩罚函数计算都会读取所有恶意行为。 惩罚手段是阻塞设备的访问请求，意思是计算一个阻塞区块数，从当前区块开始的这一段区块内，来自该设备的所有访问请求都被拒绝。阻塞时间根据如下指数函数来计算，可以看出，惩罚函数的值越大，阻塞时间越长。 $$ T_{Blocked} = 2^{-Cr_i}, Cr_i \\le 0 $$ 3.3.2 一些考虑 将设计方案时的一些考虑和存在的问题总结如下 设备信誉值不应当与设备活跃程度有关，某种设备可能短时间一次请求都不发起，但这种情况不应当对设备信誉值产生影响； 如果设备一直遵守规则，信誉值会保持不断增长，最终可能导致超限。因此需要为信誉值设置上限，不需要设置下限是因为当数字大到一定程度，相当于该设备被永远阻塞。 设备前期累积的信誉值不应当与设备产生的特定恶意行为抵消，也就是说，设备产生了某种特别恶劣的行为，即时它前期积累了很高的信誉，也必须惩罚； 以太坊智能合约语言 Solidity 不支持浮点数定义和运算，因此公式中涉及的除法运算和浮点数定义需要调整，我们设计了一个整数信誉算法供使用，可以参考附录 III； Solidity 中时间的计算单位是 s，以时间作为衡量的话，可能由于两次行为间隔太久导致结果过大，因此将行为数量作为窗口而不是时间间隔； 有一版方案合法行为包括普通的增删改，但是设备、属性、策略的增删改都是由设备的管理者完成的，不能作为设备本身的行为判断。 参数设置出于直觉，我们暂时设置为 惩罚函数中，$\\alpha_0 = 0.2, \\alpha_1 = 0.2, \\alpha_2 = 0.3$，因为第三种恶意行为是前两种的综合； 奖励函数中，$\\omega = 0.3$，奖励函数中，${Cr_i^P}_{max} = 30$ 我们最后没有使用整数信誉算法，而是直接使用了这个涉及浮点数定义和运算的算法，方法是使用了一个提供四精度浮点数运算的库，同时，为了输入需要的参数，我们采用10进制移位的方法，比如，想输入 0.1，采用 1/10 的方式，输入 1.34，采用 134/100 的方式，通过两个整数计算得到最终的值。 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:2:3","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"4. 合约测试 首先在 Remix 中测试代码的可用性，编译配置开启 Enable optimization（可以大幅减少 gas 消耗5），部署和调用的 gas 消耗统计如下 操作 transaction cost execution cost MC deploy 2787467 gas 2053591 gas RC deploy 1922683 gas 1433235 gas ACC deploy 3899979 gas 2889159 gas ABDKMathQuad deploy 76861 gas 17297 gas 下面是测试时执行的步骤，顺序不能改变 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:3:0","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 准备工作 系统管理者部署MC MC部署账户(系统管理者)：0x4542ED8d83107Db8e9Cab06d9A8D7a02b896f7d9 返回： MC合约地址：0x1f1e534ff105d9e697a1c9afabcd02560de55bbe 监管机构部署RC RC部署账户(监管机构)：0x5521Ba0bC012bE5dC12855f4972c48505Dc88c4A 传入： MC合约地址：0x1f1e534ff105d9e697a1c9afabcd02560de55bbe 返回： RC合约地址：0x644e0e3b47ad746be213e1553928f96f70a2655c 系统管理者调用 MC中的 setRC() 进行设置 调用账户(系统管理者)：0x4542ED8d83107Db8e9Cab06d9A8D7a02b896f7d9 传入： RC合约地址：0x644e0e3b47ad746be213e1553928f96f70a2655c 监管机构账户：0x5521Ba0bC012bE5dC12855f4972c48505Dc88c4A 设备管理者部署 ACC ACC部署账户(设备管理者)：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入： MC合约地址：0x1f1e534ff105d9e697a1c9afabcd02560de55bbe RC合约地址：0x644e0e3b47ad746be213e1553928f96f70a2655c 设备管理者地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 返回： ACC合约地址：0x19455cac7bd27705661d467e20ee82b1cc48737b 设备管理者调用 MC 中的 deviceRegister() 函数，注册自身 调用账户(设备管理者)：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入参数为： 设备地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 管理者地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 合约地址：0x19455cac7bd27705661d467e20ee82b1cc48737b 设备ID：gateway33 设备类型：gateway 设备角色：manager 设备部署 ACC ACC部署账户(设备)：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1 传入： MC合约地址：0x1f1e534ff105d9e697a1c9afabcd02560de55bbe RC合约地址：0x644e0e3b47ad746be213e1553928f96f70a2655c 设备管理者地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 返回： ACC合约地址：0x54d463eca95c313077815ce0a893b4036199e28e 设备管理者调用 MC 中的 deviceRegister() 函数，注册设备固定属性 调用账户(设备管理者)：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入参数为： 设备地址：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1 管理者地址：0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 合约地址：0x54d463eca95c313077815ce0a893b4036199e28e 设备ID：pallat23 设备类型：pallat 设备角色：device 设备管理者调用 MC 中的 addAttribute() 函数，添加额外属性 调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入参数： 设备地址：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1 属性名：currentFruit 属性值：apple 调用 MC 中的 get 类函数，查看设备属性，包括 getFixedAttribute(), getDeviceRelatedAddress(), getCustomedAttribute() 三个函数 设备管理者调用 MC 中的 updateAttribute() 函数，更改属性 调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入参数： 设备地址：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1 属性名：currentFruit 属性值：peer 调用 MC 中的 getCustomedAttribute() 函数，查看更改后的属性，确认无误 设备管理者调用 MC 中的 deleteAttribute() 函数，删除 currentFruit 属性 调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入参数： 设备地址：0xB52fd79681f876af9dac92d1ED9a23Aac3fdBfa1 属性名：currentFruit 调用 MC 中的 getCustomedAttribute() 函数，会返回 Attribute not exist! 错误 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:3:1","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 访问测试 设备管理者调用 ACC 的 addResourceAttr() 函数添加资源属性 调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入参数： 资源名：GPS 属性名：currentLocation 属性值：116.309551, 39.896559 然后调用 getResourceAttr() 函数查看 设备管理者调用 ACC 的 updateResourceAttr() 函数更新资源属性，继续查看；最后调用 deleteResourceAttr() 函数删除资源属性，查看返回 Resource attribute not exist! 错误 设备管理者调用 ACC 的 addPolicy() 函数添加策略 调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入参数： 资源名：truck 操作：read 属性所有者：subject 属性名：deviceType 操作符：= 属性值：gateway 重要级别：0 成功后调用 getPolicy() 查看策略 设备管理者调用 ACC 的 accessControl() 函数，测试访问控制 调用账户(设备管理者): 0x8f3dA5cD93Eb378Cdd27631C1757075B25D65B18 传入参数： 资源名：truck 操作：read 以上为访问成功的测试，之后将所有可能的情况都测试一遍，包括：策略未定义、频繁访问、策略检查未通过、重要策略检查未通过。 除此之外，还要测试算法为 denyoverrides 和 allowoverrides 两种情况下对于冲突策略的处理结果，每一种测试都要注意返回的 event 中 behaviorID 和 finalResult 是否对应。 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:3:2","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"4.3 RC测试 暂时去除 reputationCompute() 函数前的 require 验证，测试该函数 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:3:3","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"4.4 其它 应当使用某种工具对合约进行审计，验证其安全性，本来打算使用曾用过的 Mythx，但 Mythx 已转为收费，其它工具类似，因此放弃了审计工作，仅使用 Remix 自带的安全性验证。 所有功能测试完成后，统计所有类型合约 deploy 所需要的 Gas 梳理，统计编译后元数据的大小，用于之后的结果对比与分析。 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:3:4","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"附录I 所做调整 下面是所作的调整总结 功能-策略冲突解决机制 功能-无匹配策略时的处理 功能-恶意行为检测 架构-策略定义拆分单独的合约（提供重用性） 架构-部分函数迁移到单独的库文件 Utils.sol（for gas save） 语法-匹配最新版本编译器 语法-统一代码风格 实验过程-去除合约审计（MythX 转为收费） 实验过程-移除树莓派节点（在家的时候没有树莓派） 实验过程-恶意行为的测试方案 实验过程-测试新的性能指标（必要的） 实验过程-利用 JavaScript 和 Bash 交互迁移到利用 Go 思路-明晰背景（为什么做这件事） 思路-信誉算法设计 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:4:0","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"附录II 参考的信誉算法 根据节点 $i$ 的行为，将其信誉值 $Cr_i$ 划分为两部分，公式如下 $$ Cr_i = \\lambda_1 Cr_i^P + \\lambda_2 Cr_i^N $$ 其中 $Cr_i^P$ 代表正面影响部分，$Cr_i^P$ 代表负面影响部分。$\\lambda_1$ 和 $\\lambda_2$ 分别代表各部分的权重系数，调节这两个值就可以调整两部分所占权重，比如，如果我们想要严格的惩罚策略，应该令 $\\lambda_2$ 更大一点。 $Cr_i^P$ 与节点 $i$ 单位时间内正常的交易数量成正相关，即通过节点活跃程度定义，表示如下 $$ Cr_i^P = \\frac{\\sum_{k=1}^{n_i} \\omega_k} {\\Delta T} $$ 其中 $n_i$ 代表节点 $i$ 在最近的单位时间内有效交易的数量，$\\Delta T$ 代表单位时间，$\\omega_k$ 代表第 $k$ 个交易的权重，交易的权重指的是该交易被验证的次数。也就是说，如果节点 $i$ 在一段时间内保持活跃，$Cr_i^P$ 将根据活跃程度不断调整，保证活跃节点可以使用更少的算力更快地发布交易。如果节点 $i$ 在一段时间内没有发布交易，就认为它是不活跃的，甚至是不可信节点，所以系统不会为它降低 PoW 的难度，即 $Cr_i^P = 0$。 $Cr_i^N$ 与节点 $i$ 的恶意行为数量成负相关，可以表示为 $$ Cr_i^N = -\\sum_{k=1}^{m_i} \\alpha(\\beta) · \\frac{\\Delta T}{t-t_k} $$ 其中 $m_i$ 表示节点 $i$ 的恶意行为总数，$t$ 表示当前时间，$t_k$ 表示节点 $i$ 造成的第 $k$ 个恶意行为的时间点，$\\alpha(\\beta)$ 表示恶意行为 $\\beta$ 的惩罚系数，该系数定义如下，其中 $\\alpha_l$ 和 $\\alpha_d$ 可以根据对恶意行为敏感度的要求进行调整。 $$ \\alpha(\\beta) = \\begin{cases} \\alpha_l\u0026\\text{if β is lazy tips behavior;} \\\\ \\alpha_d \u0026 \\text{if β is double-spending behavior} \\end{cases} $$ 从$Cr_i^N$ 的公式中我们可以发现，随着时间的推移，恶意行为对节点的影响在逐渐减小，但不同于 $Cr_i^P$，它无法减小到0，也就是完全消除。当一个恶意行为发生的时候，$Cr_i^N$ 的绝对值会很大，由于 PoW 难度巨大，攻击将无法持续，通过这种方式我们可以及时阻止恶意行为。 该机制正常运行的需求是我们可以获取每个节点相关的所有交易，这样就可以计算出交易权重 $\\omega$ 和 恶意行为记录 $\\alpha(\\beta)$，从而可以独立地计算出 $Cr_i^P$ 和 $Cr_i^N$，最终得到信誉值。作者在论文中将信誉值与 PoW 难度关联，具体来说，这两种成反比，定义公式为 $Cr_i = \\delta \\frac 1{D_i}$，其中 $D_i$ 为节点 $i$ 的 PoW 难度，$\\delta$ 为比例系数。这样，信誉值高的难度低，信誉值低的难度高，难度的调整通过控制前缀0的最小长度完成，整个系统得以实现。 具体的实验中以上公式中的相关参数如何设置，作者给出了一些描述。交易权重 $\\omega$ 可以直接计算，两个权重系数设置为 $\\lambda_1 = 1,\\lambda_2 = 0.5$，因为 $Cr_i^N$ 的值可能相对比较大，如果想要更严厉的惩罚措施，$\\lambda_2$ 可以设置的更大。考虑到 IIoT 系统的请求频率，单位时间设置为 $\\Delta T = 30s$，一个不是太长的间隔。对于 lazy tips，设置 $\\alpha(\\beta) = 0.5$，对于 double-spending，设置 $\\alpha(\\beta) = 1$，因为双花对系统造成的损害更严重。 ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:5:0","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["研究生的区块链学习之路"],"content":"附录III 整数信誉算法 改进后的方案中，惩罚公式如下 $$ Cr_i^N = -\\sum_{k=1}^{m} max \\{\\alpha(\\beta)-(m - k), 1 \\} $$ 其中，$m$ 为设备 $i$ 当前的恶意行为总数，$k$ 是第 k 个恶意行为发生时的恶意行为总数，$\\alpha(\\beta)$ 表示恶意行为 $\\beta$ 的惩罚系数，在1-10内取值,该系数定义如下，可以根据对恶意行为敏感度的要求进行调整。 $$ \\alpha(\\beta) = \\begin{cases} \\alpha_1 \u0026 \\text{如果 β 非法的访问控制请求; } \\\\ \\alpha_2 \u0026 \\text{如果 β 代表短时间发起大量请求} \\end{cases} $$ $max \\{\\alpha(\\beta)-(m - k), 1 \\}$ 的含义是，每发生一个新的恶意行为，旧的恶意行为惩罚系数就减一，底线是惩罚系数的最小值1，这能保证随着时间的推移，旧的恶意行为的影响不断减小，但不会减小到0。 奖励函数 $Cr_i^P$ 定义不变， $\\omega_k$ 代表第 $k$ 种操作的权重，$n_k$ 代表第 $k$ 种操作的数量，但权重的取值范围限定在 1-10 $$ Cr_i^P = max \\{ Cr_{imax}^P , \\sum_{k=1}^4 \\omega_k n_k \\} $$ 最终的信誉值计算公式如下 $$ Cr_i = Cr_i^P + Cr_i^N $$ 阻塞时间的计算依然是以 2 为底的指数函数，但这里会进行判断，当恶意行为是短时间发起大量请求时，立刻进行处罚，否则只有在信誉值低于某个值$\\gamma$ 时才进行处罚。阻塞时间函数如下 $$ T_{blocked} = 2^{Cr_i}, if \\ \\text{频繁请求恶意行为} \\ or \\ \\text{(信誉值} \u003c \\gamma) $$ ZHANG Y, KASAHARA S, SHEN Y, 等. Smart Contract-Based Access Control for the Internet of Things[J]. IEEE Internet of Things Journal, 2019, 6(2): 1594–1605. DOI:10.1109/JIOT.2018.2847705. ↩︎ AMOON M, ALTAMEEM T, ALTAMEEM A. RRAC: Role Based Reputed Access Control Method for Mitigating Malicious Impact in Intelligent IoT Platforms[J]. Computer Communications, 2020, 151: 238–246. DOI:10.1016/j.comcom.2020.01.011. ↩︎ J. Huang, L. Kong, G. Chen, M.-Y. Wu, X. Liu, and P. Zeng, “Towards Secure Industrial IoT: Blockchain System With Credit-Based Consensus Mechanism,” IEEE Trans. Ind. Inf., vol. 15, no. 6, pp. 3680–3689, Jun. 2019, doi: 10.1109/TII.2019.2903342. ↩︎ WANG P, YUE Y, SUN W, 等. An Attribute-Based Distributed Access Control for Blockchain-enabled IoT[C/OL]//2019 International Conference on Wireless and Mobile Computing, Networking and Communications (WiMob). Barcelona, Spain: IEEE, 2019: 1–6[2020–04–02]. https://ieeexplore.ieee.org/document/8923232/. DOI:10.1109/WiMOB.2019.8923232. ↩︎ difference between transaction cost and execution cost ↩︎ ","date":"2020-04-28","objectID":"/2020/credit-based-mechanism/:6:0","tags":["科研记录"],"title":"研究记录13-添加恶意行为检测机制","uri":"/2020/credit-based-mechanism/"},{"categories":["爱编程爱技术的孩子"],"content":"Docker Desktop 是 Windows 安装 Docker 的推荐安装方式，然而系统需求是 Pro, Enterprise 或 Education 版本，Home 版不支持，因为没有 Hyper-V。 这篇文章记录网上找到的 Win10 Home 版安装 Docker Desktop 的方式，主要思路是自行安装 Hyper-V 及 相关服务，并修改注册表欺骗 Docker 的安装检测。 ","date":"2020-04-23","objectID":"/2020/install-docker-desktop-on-windows-10-home/:0:0","tags":["linux"],"title":"Docker-Win10 Home安装Docker","uri":"/2020/install-docker-desktop-on-windows-10-home/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 安装 Hyper-V 新建 txt 文档，复制以下内容到文档中。 pushd \"%~dp0\" dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum \u003ehyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^\u003enul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 将文档格式后缀由 .txt 更改为 .cmd，然后以管理员方式执行。该脚本会自动安装 Hyper-V 服务，安装完成后按提示键入 Y，电脑自动重启。注意，这里键入 Y 后直接就重启了，所以有其它未保存任务及时保存。 重启完成后进入搜索「启用或关闭 Windows 功能」并打开，查看 「Hyper-V」选项是否被选中，如果没有，勾选并重启电脑。 再次新建 txt 文档并填充如下内容 pushd \"%~dp0\" dir /b %SystemRoot%\\servicing\\Packages\\*containers*.mum \u003econtainers.txt for /f %%i in ('findstr /i . containers.txt 2^\u003enul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\" del containers.txt Dism /online /enable-feature /featurename:Containers -All /LimitAccess /ALL pause 更改后缀为 .cmd 并以管理员方式执行，安装完毕后键入 Y 重启电脑。至此第一步完成 ","date":"2020-04-23","objectID":"/2020/install-docker-desktop-on-windows-10-home/:1:0","tags":["linux"],"title":"Docker-Win10 Home安装Docker","uri":"/2020/install-docker-desktop-on-windows-10-home/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 伪装成专业版绕过安装检测 Docker Desktop 安装时会检测系统版本，因此我们修改注册表 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion EditionID = Professional 然后遵照官方文档下载安装 Docker即可。 注：重启后修改的注册表项会自动还原，但不影响 Docker 运行。 ","date":"2020-04-23","objectID":"/2020/install-docker-desktop-on-windows-10-home/:2:0","tags":["linux"],"title":"Docker-Win10 Home安装Docker","uri":"/2020/install-docker-desktop-on-windows-10-home/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 测试 查看 Docker 版本 $ docker --version Docker version 19.03.8, build afacb8b 运行 hello-world 镜像测试安装是否成功 $ docker run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 出现 Hello from Docker! 说明安装成功。 参考：Orientation and setup | Docker Documentation ","date":"2020-04-23","objectID":"/2020/install-docker-desktop-on-windows-10-home/:3:0","tags":["linux"],"title":"Docker-Win10 Home安装Docker","uri":"/2020/install-docker-desktop-on-windows-10-home/"},{"categories":["爱编程爱技术的孩子"],"content":"Docker Hub 中的 mysql 镜像 地址为 https://hub.docker.com/_/mysql，安装运行过程如下。 ","date":"2020-04-23","objectID":"/2020/using-docker-installation-to-run-mysql/:0:0","tags":["linux"],"title":"Docker-使用 Docker 安装运行 mysql","uri":"/2020/using-docker-installation-to-run-mysql/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 拉取镜像 $ docker pull mysql # 查看 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE mysql latest 0c27e8e5fcfa 6 hours ago 546MB hello-world latest bf756fb1ae65 3 months ago 13.3kB ","date":"2020-04-23","objectID":"/2020/using-docker-installation-to-run-mysql/:1:0","tags":["linux"],"title":"Docker-使用 Docker 安装运行 mysql","uri":"/2020/using-docker-installation-to-run-mysql/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 运行 mysql 容器 $ docker run -p 3306:3306 --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 上面各命令的含义为 run 运行一个docker容器 --name 后面这个是生成的容器的名字some-mysql -p 3306:3306 表示这个容器中使用3306（第二个）映射到本机的端口号也为3306（第一个） -e MYSQL_ROOT_PASSWORD=123456 初始化root用户的密码 -d 表示使用守护进程运行，即服务挂在后台 tag 是 MySQL 版本，比如可以填写 5.7，如果没有设置版本，Dcoker 会自动在本地检测有没有最新的，如果没有会自动去 Docker Hub 下载。该字段的选项如下 8.0.19，8.0，8，latest 5.7.29，5.7，5 5.6.47，5.6 # 查看当前容器运行状态 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 94e4725784bb mysql:8.0 \"docker-entrypoint.s…\" 5 seconds ago Up 4 seconds 3306/tcp, 33060/tcp chitchat 如果暂时关闭了容器界面，隔了一天后回来，使用docker ps命令可能看不到任何东西，这时候添加-a参数 ","date":"2020-04-23","objectID":"/2020/using-docker-installation-to-run-mysql/:2:0","tags":["linux"],"title":"Docker-使用 Docker 安装运行 mysql","uri":"/2020/using-docker-installation-to-run-mysql/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 进入 mysql 容器 执行 docker exec 命令进入 mysql 容器，该命令会在容器中启动一个命令行 $ docker exec -it chitchat bash 日志文件可通过如下命令查看 $ docker logs chitchat 之后操作为正常的 mysql 命令操作，如 root@94e4725784bb:/# mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 8.0.19 MySQL Community Server - GPL Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql\u003e ","date":"2020-04-23","objectID":"/2020/using-docker-installation-to-run-mysql/:3:0","tags":["linux"],"title":"Docker-使用 Docker 安装运行 mysql","uri":"/2020/using-docker-installation-to-run-mysql/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 测试连接 第一种是使用 Navicat for MySQL 测试，Navicat 安装在宿主机的 win10系统中 点击「测试连接」查看连接是否成功，成功后点确定可以进入以图形化方式查看数据库 因为我们使用 Golang，这里写一段代码测试Golang连接是否成功 package tes import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) func query() { //\"用户名:密码@[连接方式](主机名:端口号)/数据库名\" db, _ := sql.Open(\"mysql\", \"root:****@(127.0.0.1:3306)/chitchat\") // 设置连接数据库的参数 defer db.Close() //关闭数据库 err := db.Ping() //连接数据库 if err == nil { fmt.Println(\"数据库连接成功\") return } } 如果连接成功，会输出「数据库连接成功」字样，此时同时也说明了我们在 Docker 中部署 MySQL，然后从宿主机连接的方式是可行的，宿主机中不需要再安装 MySQL client 等。 ","date":"2020-04-23","objectID":"/2020/using-docker-installation-to-run-mysql/:4:0","tags":["linux"],"title":"Docker-使用 Docker 安装运行 mysql","uri":"/2020/using-docker-installation-to-run-mysql/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 退出与重连 输入exit退出 docker 内的命令行，再次输入 exit 退出 docker，此时退出容器但没有关闭 $ docker exec -it chitchat bash root@cd6182d13e68:/# exit exit $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cd6182d13e68 mysql \"docker-entrypoint.s…\" 11 hours ago Up 8 minutes 0.0.0.0:3306-\u003e3306/tcp, 33060/tcp chitchat 进入已启动的容器可以使用 $ docker attach chitchat 不过重启电脑后运行 docker ps发现没了，此时执行 docker start命令可以再次启动 $ docker start chitchat 本文参考：使用Docker安装、运行mysql - 简书 (jianshu.com) 不使用docker直接在win10中安装mysql参考win10安装Mysql教程 ","date":"2020-04-23","objectID":"/2020/using-docker-installation-to-run-mysql/:5:0","tags":["linux"],"title":"Docker-使用 Docker 安装运行 mysql","uri":"/2020/using-docker-installation-to-run-mysql/"},{"categories":["研究生的区块链学习之路"],"content":"P. Wang, Y. Yue, W. Sun, and J. Liu, “An Attribute-Based Distributed Access Control for Blockchain-enabled IoT,” in 2019 International Conference on Wireless and Mobile Computing, Networking and Communications (WiMob), Barcelona, Spain, Oct. 2019, pp. 1–6, doi: 10.1109/WiMOB.2019.8923232. 第一作者是西电的，国家自然科学基金项目成果，研究方向完全一致，都是利用智能合约实现 ABAC 模型完成物联网访问控制。可以看的出来，这篇论文也深受 Zhang1 的影响，参考的文献全都看过，由于方向一致，这是必然的事情。因此，这里记的笔记不包括引言、相关工作、实验等部分，仅仅理解和阐述作者的架构描述，并分析其优缺点，将优点吸纳到我们当前的方案。 ","date":"2020-04-22","objectID":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/:0:0","tags":["论文笔记"],"title":"An Attribute-Based Distributed Access Control for Blockchain-enabled IoT","uri":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1. 系统架构 用来说明方案的 IoT 场景是 smart home，如下图所示。作者将设备分为三类 有足够计算和存储能力的节点，比如 server 和 desktop，这部分作为区块链全节点； 只有有限的计算和存储能力，比如 mobile phone 和 smart TV，这部分作为轻节点； 计算和存储能力高度有限，比如传感器，这些设备称为超轻量级节点，由所连接的网关作为代理。 Server 负责存储 IoT 设备产生的数据，包括传感器收集的环境信息、运行过程产生的日志文件，同时向设备提供服务，因此也会发送一些命令到设备从而控制设备的执行。全节点或轻节点通过有线或 Wi-Fi 连到网络，维持区块链的运行，保存所有或部分访问控制信息，执行访问控制。超轻量级节点通过 Bluetooth、Wi-Fi、ZigBee 等技术连到网关，从而连到网络，不存储访问控制信息，只通过网关发起访问控制请求或获取访问控制结果。 ","date":"2020-04-22","objectID":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/:1:0","tags":["论文笔记"],"title":"An Attribute-Based Distributed Access Control for Blockchain-enabled IoT","uri":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2. 访问控制架构 核心是 ABAC 模型，如下图所示，收到访问控制请求后根据主体属性（Subject Attribute, SA）、客体属性（Object Attribute, OA）和环境属性（Environment Attribute, EA）执行预定义的策略，从而得到结果。 作者使用了一个 Subject Contract（SC）、一个 Object Contract（OC）、一个 Access Control Contract（ACC）和多个 Policy Contracts（PC）来实现该模型，各部分介绍如下。 ","date":"2020-04-22","objectID":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/:2:0","tags":["论文笔记"],"title":"An Attribute-Based Distributed Access Control for Blockchain-enabled IoT","uri":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 Subject Contract 由于设备可以作为 subject 发起访问，也可以作为 object 提供资源，subject 访问不同的 object 时属性还有可能不同，作者将主体属性划分为两部分： Manufacturer Attribute（MA）：由制造商在出厂时设置的属性，无法二次修改，主要包括一些设备的基本信息，比如 MAC 地址和序列号。 Setting by Object Attribute（SOA）：如果设备 o 作为 object 设置了针对 subject s 的 SOA，意味着该属性只在 s 访问 o 时生效，其它 subject 访问 o 不生效。 SC 负责管理合法制造商的账户、IoT 设备账户和设备的主体属性信息，属性以键值对的形式定义，如下所示 $$ [name_1:value_1] [name_2:value_2] …… [name_n:value_n] $$ 一个 MA 的示例为 $[type:remotecontrol][mac:00efefefefef]$， 一个 SOA 的示例为 $[group:owner][role:children]$ SC 提供了如下功能 addmanufacturer()：只能由 SC 所有者调用，传入制造商账户地址，将该地址代表的制造商加如合法制造商列表 addsubject()：只能由合法制造商列表中的成员调用，负责注册新的 IoT 设备 addobattr()：由 object 调用，设置针对某个 subject 的 SOA，接收设备地址和一个描述属性的字符串 delemanufacturer()，deleteobattr()：如函数名 ","date":"2020-04-22","objectID":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/:2:1","tags":["论文笔记"],"title":"An Attribute-Based Distributed Access Control for Blockchain-enabled IoT","uri":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 Object Contract OC 负责管理每个设备的 object attributes（OA），和主题属性的结构定义相同，一个 OA 示例为$[type:TV][location:living]$。OC 提供的函数功能有： addobattr()：接收设备地址和一个描述属性的字符串，设置客体属性 deleteobattr()：接收设备地址，删除对应的属性 getattr()：接收设备地址，获取对应的属性 ","date":"2020-04-22","objectID":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/:2:2","tags":["论文笔记"],"title":"An Attribute-Based Distributed Access Control for Blockchain-enabled IoT","uri":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 Policy Contract 每个用户创建自己的 PC，并在 ACC 中和用户的设备进行绑定，因此，一个 PC 可能对应多个 IoT 设备，但只有一个所有者且只有所有者可以添加或删除策略。 [策略]^(policy) 和 [规则]^(rule) 在 PC 中是不同的，策略由如下五个字段定义 $$ resource, action,duty,rule,algorithm $$ 其中，$duty$ 是实施完访问控制需要做的事；一个策略可能包含多个规则，一个 $rule$ 由 $SA,OA,EA,resource,action,result$ 六部分组成；$algorithm$ 用来在规则产生矛盾时进行判定；返回的结果有两种：$allow$ 和 $deny$。一个示例为 policy: [resource:switch] [action:on] [duty:record] [algorithm:denyoverrides] rule1: ​ subject attribute: [group:owner] [role:parent] [type:remotecontrol] ​ object attribute: [type:TV] [location:livingroom] ​ environment attribute: [time: 21:00 - 23:00] ​ result: allow PC 提供如下函数功能： addpolicy()：添加新策略到用户策略集，接收四个参数：resource, action, duty 和 algorithm addrule()：添加新规则到策略，接收六个参数：SA, OA, EA, resource, action 和 result，通过资源和操作，可以找到相应的策略并将规则添加到规则列表 delepolicy()，delerule()：如函数名 ","date":"2020-04-22","objectID":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/:2:3","tags":["论文笔记"],"title":"An Attribute-Based Distributed Access Control for Blockchain-enabled IoT","uri":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2.4 Access Control Contract ACC 用来确定请求是否符合用户自定义的策略，最终会返回相应的结果并执行预定的 $duty$，如记录访问历史到区块链等，历史记录结构示例如下 PC 提供的函数功能如下 Initialization()：为了和 SC，OC 交互，记录它们的合约地址 setobjectpolicyaddress()：负责将 PC 地址绑定到 IoT 设备地址，接收这两个地址作为参数 accesscontrol()：执行访问控制，接收 subject address、object address 、resource 、action 四个参数，与其它几个合约交互获取相应的属性信息和策略信息，然后根据策略中每个规则进行判决并记录，如果满足规则，获取 $allow$ 或 $deny$ 两个结果之一，如果不满足，返回 $NotAplicable$，最后利用 $algorithm$ 处理冲突得到最终结果。如果设置了 $duty$ 字段，那么执行该字段描述的任务。该函数的算法伪代码如下 ","date":"2020-04-22","objectID":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/:2:4","tags":["论文笔记"],"title":"An Attribute-Based Distributed Access Control for Blockchain-enabled IoT","uri":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3. 总结与收获 这篇论文基本可以看作传统的 XACML 的架构使用智能合约的实现，比如 SC 和 OC 用来维护属性信息，相当于策略信息点（PIP）；PC 维护策略信息，相当于策略管理点（PAP），ACC接收并执行访问控制策略，相当于策略实施点（PEP）和策略决策点（PDP）的结合。这种结构将各部分功能进行了良好的划分，确保了低内聚高耦合，所以现在应该去深入理解一下传统 ABAC 模型，了解其缺点后，再讨论是像这篇论文这一原样实现还是做一些改变。 在 Ouaddah 的论文中评价了 ABAC 模型的优劣2。他认为 ABAC 模型的优点是较好的互操作性和细粒度的访问控制，缺点是较为复杂和非用户驱动，这里介绍一下两个缺点： Complexity：属性语义的诠释，属性的可信度，表达基于属性的授权请求和响应的语法定义，这些都是导致 ABAC 复杂的原因。另外，XACML 的复杂性常导致用户避免使用它转而使用更传统的方法。这种复杂性还阻碍了它在日常场景中的应用，例如，可穿戴娱乐物联网应用领域。只有在需要高度互操作性和细粒度表达的应用中才适合使用这种模型。 Not User-driven：尽管 XACML 和 ABAC 是完善而精确的策略描述方法，XACML 策略的结构是复杂的。用户必须深入理解 XACML 才能熟练地写下详细地策略，这使得 XACML 难以掌握和使用。这种方式地隐私管理不支持以[本机方式]^(native way)与用户交互，为了让用户参与策略制定过程，需要一个用户驱动的隐私管理器。 可以思考如何在区块链中改善这两者。 Y. Zhang, S. Kasahara, Y. Shen, X. Jiang, and J. Wan, “Smart contractbased access control for the internet of things,” IEEE Internet of Things Journal, vol. 6, no. 2, pp. 1594–1605, 2019. ↩︎ A. Ouaddah, H. Mousannif, A. A. Elkalam, and A. A. Ouahman, “Access control in The Internet of Things: Big challenges and new opportunities,” Computer Networks, vol. 112, pp. 237–262, 2016. ↩︎ ","date":"2020-04-22","objectID":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/:3:0","tags":["论文笔记"],"title":"An Attribute-Based Distributed Access Control for Blockchain-enabled IoT","uri":"/2020/an-attribute-based-distributed-access-control-for-blockchain-enabled-iot/"},{"categories":["研究生的区块链学习之路"],"content":"V. C. Hu, D. R. Kuhn, and D. F. Ferraiolo, “Attribute-Based Access Control,” Computer, vol. 48, no. 2, pp. 85–88, Feb. 2015, doi: 10.1109/MC.2015.33. ","date":"2020-04-22","objectID":"/2020/attribute-based-access-control/:0:0","tags":["论文笔记"],"title":"Attribute-Based Access Control","uri":"/2020/attribute-based-access-control/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引言 传统的访问控制基于用户身份（分配给该用户的角色或组），这种方式在管理上非常繁琐，策略的表达能力也不足。一种解决办法是基于用户和对象属性以及环境条件来授予或拒绝用户请求，这种方法称为基于属性的访问控制（Attribute-based access control，ABAC）。 ","date":"2020-04-22","objectID":"/2020/attribute-based-access-control/:1:0","tags":["论文笔记"],"title":"Attribute-Based Access Control","uri":"/2020/attribute-based-access-control/"},{"categories":["研究生的区块链学习之路"],"content":"2. ABAC 模型介绍 ABAC 是一个逻辑访问控制模型，它通过对实体（[主体]^(subject)和 [对象]^(object)）、操作、与请求相关的环境这三类属性定义评估规则来控制对对象的访问。由于它在决策逻辑中加入了更多的输入变量，提供了更大的可能性，使得策略规则的表示更加明确和详细。 使用 ABAC 使得我们无需针对每个主体和对象创建访问规则集。例如，南希·史密斯是心脏科的一名护士，我们将她作为主体，并且在她受雇时为她分配一组主体属性，将心脏病患者的病历文件夹作为对象，在文件夹被创建时分配一组对象属性，对象属性由创建者直接赋予或从自动扫描工具接收。管理者或者对象所有者可以利用主体和对象的这些属性创建一组访问控制规则，比如心脏科的护士被允许查看心脏病患者的病例文件夹，从而控制访问请求。 在 ABAC 模型中，只需要更改属性值即可影响最后的访问结果，而无需维护定义在主体和对象之上的规则集，这种方法提供了更加动态的访问控制管理能力。此外，ABAC 还允许管理员或对象所有者在事先不知道访问主体的情况下定义访问控制策略，也能够应对无限数量主体的访问请求。当新的主体加入组织时，也无需修改访问规则和对象属性，只需要为新加入的主体分配合适的主体属性即可，比如新入职的心脏科护士被分配部门为心脏科的属性。这种针对未知主体的适应性是 ABAC 的主要好处之一。 由于 ABAC 高度的灵活性，已经引起了整个行业甚至政府的兴趣，并且是当今发展最快的访问控制模型。但是除了为主体、对象和环境设置属性这一基本思路外，ABAC 模型的实现并没有统一的标准。 ","date":"2020-04-22","objectID":"/2020/attribute-based-access-control/:2:0","tags":["论文笔记"],"title":"Attribute-Based Access Control","uri":"/2020/attribute-based-access-control/"},{"categories":["研究生的区块链学习之路"],"content":"3. 企业环境下的实现 由于缺乏对 ABAC 特性的共识，用户无法准确评估与该模型相关的好处和挑战。为了解决这个问题，国家标准与技术研究所（NIST）发布了《Guide to Attribute Based Access Control (ABAC) Definition and Considerations》1。这个文档有两个作用，首先，它提供了 ABAC 的定义和功能组件的描述。其次，它描述了在企业中使用 ABAC 控制信息的计划、设计、实现和操作考虑。这本指南的重点是 ABAC 的实现，而不是成本和效率的权衡。 当跨企业部署 ABAC 用以增加不同组织之间的信息共享时，其实现可能会变得更加复杂，需要一个属性管理的基础设施、机器可执行的策略以及一系列支持访问决策和策略执行的功能。如下图所示，除了基本的策略、属性和访问控制机制要求外，企业还必须支持企业策略开发和分发、企业身份和主体属性、主体属性共享、企业对象属性、身份验证等管理功能，以及访问控制机制的部署和分发。启用这些功能需要仔细考虑影响企业 ABAC 解决方案设计、安全性和互操作性的许多因素，上面提到的指南可以帮助 ABAC 系统规划者、架构师、管理者和实现者来分阶段完成这些功能。 ","date":"2020-04-22","objectID":"/2020/attribute-based-access-control/:3:0","tags":["论文笔记"],"title":"Attribute-Based Access Control","uri":"/2020/attribute-based-access-control/"},{"categories":["研究生的区块链学习之路"],"content":"4. Attribute Assurance ABAC 属性的元数据定义对属性标准化非常重要，通常，属性元数据可分为三类： 准确性为在语义和句法上正确使用这些属性和环境条件奠定了基础，并且确保了属性是可信的 完整性考虑用于在系统之间安全共享属性的不同标准和协议，以避免损害属性的完整性和机密性，或暴露属性提供者（AP）或依赖方（RP）系统或实体中的漏洞 可用性确保属性的更新和检索支持 RP。此外，必须考虑属性存储库的故障转移和备份功能。请注意，某些属性可能会定期或随时间变化 AP 是提供主体、对象（或资源）或环境条件属性的任何人或系统，可以是原始的权威源，也可以从权威源接收信息，然后重新打包、存储和转发到 ABAC 系统。属性值可以是人工生成的（例如，员工数据库）或从公式（例如，信用评分）派生的。无论属性来源如何，系统都应确保从 AP 接收到的属性值与适用的主体、对象或环境条件准确关联。下表说明了基于准确性、完整性和可用性三个维度的属性保证的级别（Levels of attribute assurance, LOAA）的示例 ","date":"2020-04-22","objectID":"/2020/attribute-based-access-control/:4:0","tags":["论文笔记"],"title":"Attribute-Based Access Control","uri":"/2020/attribute-based-access-control/"},{"categories":["研究生的区块链学习之路"],"content":"5. 总结与收获 基于属性的访问控制是一种灵活的访问控制方法，它只受计算语言和可用属性丰富性的限制。这种灵活性使最大范围的主体能够访问最大范围的对象，而无需指定每个主体和每个对象之间的关系，使ABAC成为许多分布式或快速变化的环境的理想选择。更多关于保证属性准确性和可靠性的工作可以查看 http://csrc.nist.gov/projects/abac/index.html 了解了 ABAC 的主要优点，了解了 ABAC 在企业环境实现需要考虑很多的问题，实现比较复杂。不过最大的收获是知道了实现 ABAC 可以查看文章提到的指南。最后一部分 Attribute Assurance 没有看懂，似乎是属性定义需要满足的几个特性。 V.C. Hu et al., Guide to Attribute Based Access Control (ABAC) Definition and Considerations, Nat’l Institute of Standards and Technology, Jan. 2014, [online] Available: http://nvlpubs.nist.gov/nistpubs/specialpublications/NIST.sp.800-162.pdf. ↩︎ ","date":"2020-04-22","objectID":"/2020/attribute-based-access-control/:5:0","tags":["论文笔记"],"title":"Attribute-Based Access Control","uri":"/2020/attribute-based-access-control/"},{"categories":["研究生的区块链学习之路"],"content":"L. Evers and P. Havinga, “Supply Chain Management Automation using Wireless Sensor Networks,” in 2007 IEEE Internatonal Conference on Mobile Adhoc and Sensor Systems, Pisa, Italy, Oct. 2007, pp. 1–3, doi: 10.1109/MOBHOC.2007.4428689. 注：插图来自原论文和网络。 ","date":"2020-04-20","objectID":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/:0:0","tags":["论文笔记"],"title":"Supply Chain Management Automation using Wireless Sensor Networks","uri":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引言 这篇论文谈到的问题是无线传感器网络（WSN）如何用于供应链管理领域。 以RFID1形式出现的无源射频技术已经被引入到供应链管理中用以简化流程，[主动无线电通信技术]^(active radio communication)也可以提高处理效率和降低成本。比如，通过对安装到板条箱（crate）、笼车（roll container）、托盘（pallet）和航运集装箱（shipping containers）上的 WSN 节点进行编程，可以监控整个货物运输过程，包括验证新鲜食品当前温度等环境情况和检测由于突然冲击、打开集装箱和其他形式的违约而造成的损失。这种全流程的监控可以大幅减少交货延误和货物丢失或被盗的可能性，避免造成重大损失。 ","date":"2020-04-20","objectID":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/:1:0","tags":["论文笔记"],"title":"Supply Chain Management Automation using Wireless Sensor Networks","uri":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/"},{"categories":["研究生的区块链学习之路"],"content":"2. 场景描述 如下图，示例场景是一批香蕉从巴西里约热内卢附近的农场运往鹿特丹的超市配送中心。香蕉被打包放到托盘上，每个托盘都装有一个传感器节点。一大早，这些托盘就被卡车从农场运到港口的一个货运码头，在那里，托盘被装进集装箱，然后集装箱一路运到连锁超市的配送中心。在整个旅程中，香蕉的温度需要保持在10到15摄氏度之间，同时应该远离新鲜的咖啡豆等物品，因为这些东西产生的乙烯加速香蕉的成熟过程。 从农场到配送中心的运输过程中（称之为[旅程]^(journey)），监控如下事件： 托盘上的温度传感器测量环境温度，并将测量的温度存储在设备的日志文件中。如果温度超过限制，设备就会发出警报。 每个托盘的设备与周围其他的设备通信，检查周围是否正在运输咖啡豆等货物。当托盘被装进集装箱时，设备还要求集装箱检查一定距离（比如10米）内是否有运送咖啡店等物品的其它集装箱。如果在附近发现了咖啡店等物品，设备会将其写入日志文件并发出警报。 在整个旅程中，每个托盘上的设备都检查是否符合运输计划。如图2所示，在旅程的每个阶段，设备都会验证自己是否装到正确的卡车上，是否卸到了正确的仓库，所有的行程都会被记录下来，当设备没有在限定的时间位于正确的地点，就会发出警报。 在农场中，装上卡车之前，托盘上的设备验证当前位置是否正确。接下来，设备随着托盘被装到卡车上，然后和周围同一卡车上的托盘设备通信，比较记录的目的地和内容，从而进行验证。而在卡车中，托盘节点必须检测从卡车中取出的操作，主要通过检测卡车和港口装卸码头无线基础设施（访问点，access point）的存在来推断。如果没有检测到正确的码头，则需要发出警报。托盘在码头卸货后，装在集装箱内，一直运到配送中心。设备在码头验证它们是否被放到正确的集装箱，最后通过检测配送中心的访问点，验证是否到达配送中心。 当在旅途中检测到错误时，设备会发出警报。根据运输阶段的不同，使用不同类型的警报方法。例如，当托盘在卡车外面等待装运时，发出警报声和闪烁 LED 引起工人的注意，从而纠正问题。但当进入卡车内部时，应将警报信息发送给卡车驾驶员。 ","date":"2020-04-20","objectID":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/:2:0","tags":["论文笔记"],"title":"Supply Chain Management Automation using Wireless Sensor Networks","uri":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/"},{"categories":["研究生的区块链学习之路"],"content":"3. 实验 作者使用 SensorScheme2 进行简单的实现，这是一个基于 Scheme 语言的解释器，能够动态加载 WSN 代码到设备。该平台提供了一个安全的执行环境，在该环境中，程序故障不会使节点崩溃。此外，由于传输的代码比较小，节点能够被快速而高效的编程，在实验中，节点在传输开始前重新编程，只花费了几秒钟。本文使用该平台实现了第二部分提到的场景，对货物运输的全过程进行监控，完成了供应链管理的自动化。SensorScheme实现 实验在两个位置的桌子间进行，距离10米以上，使彼此的无线电无法直接到达，两边都需要连接到笔记本电脑和其他演示设备。使用一组 Tmote Sky3motes作为托盘上安装的设备，两个位置的桌子充当农场、港口、配送中心等不同地点，笔记本电脑连接的 mote 充当这些地点的访问点。 实验开始时，在农场位置（一个桌子上）对托盘上的 mote 进行编程，然后将它们放到安装了 mote 的一个盒子中，充当场景中的卡车。然后，参与者将这个盒子移动到另一个代表港口船坞位置的桌子，到达该位置后，可以看到图3所示的屏幕上的信息， mote 上的 LED 状态指示灯也会给出指示。在这里，安装了 motes 的托盘被重新放到另一个代表集装箱的盒子里，并移回到第一个位置的桌子，现在这个位置代表配送中心。只有整个运输过程无差错，才不会出现任何警报，否则，笔记本电脑的屏幕会出现警告信息，根据情况， mote 的 LED 也会闪烁提示。运输过程的最后，货物到达配送中心，将读取每个设备的日志文件，其中包括整个旅程中传感器记录的温度信息和所有不当操作触发的警报记录。 图3是完成整个运输过程后仓库访问点的屏幕输出，五个托盘节点首先被运送到码头，并在那里与码头的接入点联系，向仓库转发一条信息说明其中一个节点（pallet05）正在移动到错误的位置。触发的警报信息也显示在其中，除了这里的警报信息外，在码头节点还会闪烁红色 LED 来发出警报，其它节点则短暂闪烁绿色 LED 说明其放到了正确的位置。 ","date":"2020-04-20","objectID":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/:3:0","tags":["论文笔记"],"title":"Supply Chain Management Automation using Wireless Sensor Networks","uri":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/"},{"categories":["研究生的区块链学习之路"],"content":"4. 收获 我们将该论文描述的场景作为我们实验的场景，由于我们关注的是访问控制，环境温度的测量与超限警报不进行实现，几个涉及访问控制的关键步骤如下 托盘上的节点对卡车上的节点发起访问，验证是否被装到了正确的卡车 托盘上的节点对其它托盘节点发起访问，比较目的地 托盘上的节点对周围其它托盘节点或集装箱节点发起访问，查看是否存在咖啡豆等货物 托盘上的节点对农场、码头、配送中心的访问点发起访问，验证是否在正确的时间到达了正确的地点 我们通过实施这几个访问控制操作验证我们方案的有效性，所有的记录都收集到区块链中，从而保证不可篡改，农场主、货运商、分销商等不同角色对日志的访问权限也受到限制。恶意的请求行为（如短时间高频率的请求）会被记录并判定设备是否被入侵。 LogicaCMG, “Making waves: Rfid adoption in returnable packaging,” 2004. ↩︎ L. Evers, P. Havinga, and J. Kuper, “Flexible sensor network reprogramming for logistics,” in Proceedings of the fourth IEEE international Conference on Mobile Ad-hoc and Sensor Systems, 2007, to be published. ↩︎ Moteiv, “Tmote sky,” http://www.moteiv.com/products/tmotesky.php. ↩︎ ","date":"2020-04-20","objectID":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/:4:0","tags":["论文笔记"],"title":"Supply Chain Management Automation using Wireless Sensor Networks","uri":"/2020/supply-chain-management-automation-using-wireless-sensor-networks/"},{"categories":["研究生的区块链学习之路"],"content":"Day Y, Xu D, Maharjan S, 等. Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond[J]. IEEE Network, 2019, 33(3): 10–17. DOI:10.1109/MNET.2019.1800376. ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:0:0","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引言 区块链和 AI 会在 6G 中扮演关键角色，前者可保证分布式网络安全，后者可用于智能资源管理。不过 PoW 共识需要大量计算资源和电力，很难用在无线网络中，MEC（mobile edge computing） 是一种可能的解决办法。 5G 中引入了异构网络和 D2D 通信来提高通信速率和保证无缝覆盖，MEC 同样可以起作用，主要通过计算卸载和分布式内容缓存来减少延迟并避免[回程拥塞]^(backhaul congestion)。但由于无线网络的时变特性，各种新兴应用和未知交通系统的多样化和严格的要求，设计一个解决这些问题（计算卸载或内容缓存）的高性能算法比较困难。AI 可以被引入处理该问题，例如，论文1利用深度强化学习（DRL）解决边缘计算和缓存资源分配的问题。 无论是区块链还是 AI，将它们引入无线网络的研究都已经存在，但这些研究并没有将两者结合。作者在这篇论文中同时集成了这两种技术到无线网络，提出了一个用于下一代无线网络的架构，该架构可以进行安全和智能的资源管理，例如频谱共享、内容缓存、能量交易和计算卸载。主要思路是，利用联盟链建立安全的内容共享环境，利用 DRL 算法设计缓存策略从而最大化系统[效用]^(utility)。我们的主要关注点如下 集成区块链和 AI 到无线网络的架构组成 频谱共享、内容缓存、能量交易和计算卸载四个场景的描述 基于内容缓存场景的方案设计与实现 引言部分提到的论文中有几篇值得参考。论文2 3利用区块链开发了一个安全的本地 P2P 电子交易系统，用于电动汽车间的电力交易。论文4利用区块链和智能合约设计了一个用于车辆边缘网络的基于信誉的数据共享方案。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:1:0","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"2. 架构 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:2:0","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 架构描述 整体架构如下图所示，共分三层：云、边缘和用户。 云层是一批计算、缓存和处理能力都相当强的服务器。一方面，可以利用数据挖掘和大数据等先进技术，通过预测一些事件或预分配一些资源，使 network-level orchestration shifting 从被动的网络操作转变为主动网络操作。另一方面，云服务器也可以处理一些对延迟容忍较高的应用，存储大容量或不受欢迎的内容。此外，云层还有一个中央权威，配备了防篡改硬件，用于管理所有实体的安全参数和密钥：宏基站（macro base station, MBS）、小型基站（small base station, SBS）、路边单元（roadside units, RSU）、移动设备和智能车辆。 边缘层是一些用户附近的网络基础设施（例如，MBS、SBS、RSU），这些设施在地理上是分离的，可以作为 MEC 服务器和区块链节点。它们可以为移动设备和车辆提供无缝覆盖和即时的无线通信。MEC 服务器具有一定的计算和缓存资源，也可以提供 AI 的功能，进而能够提供分布式智能无线计算和缓存，服务于计算密集型和延迟敏感型的应用，如最新的消息和紧急警报。区块链则可以记录无线网络中产生的所有交易，提高整个系统的安全性和隐私性。交易可以是频谱共享、计算/缓存资源分配、能量交易等。 为了构建一个可编程的、灵活的、弹性的移动边缘平台，采用了网络功能虚拟化和软件定义网络（SDN）两种技术。前者可以抽象物理资源，建立虚拟机，使边缘层忽略供应商和协议的差异，通过在分布式边缘实体之间创建、迁移和销毁虚拟机，实现快速的功能部署。后者可以将网络控制和管理功能与数据转发分离，这样边缘层可以进行动态资源管理和智能服务安排。 异构网络，V2X（vehicle-to-everything）和蜂窝网络共存于用户层，用于提高通信速率和确保无缝覆盖，以支持各种新型应用（如自动驾驶和 AR）所需的高度可靠的连接。 在异构网络中，每个移动设备都有一个计算密集且对延迟敏感的任务，例如导航、视频流和比特币。MBS 和 SBS 具有计算资源和 AI 功能，资源受限的移动设备可以将其任务卸载到异构的边缘基础设施，基站可以利用细粒度的计算资源分配策略来处理卸载的任务。由于移动设备和基站之间的交互是基于信任的，因此在这种情况下不需要使用区块链。 车辆网络场景支持 车辆到RSU 和车辆到车辆（V2V）通信。对于V2V通信，车辆之间可以共享内容或能量，由于车辆之间可能不信任对方，因此它们在共享内容或能量时需要使用[假名]^(pseudonyms)（区块链账户地址就是一种假名），以便更好地保护安全和隐私。为此，我们在 RSU 上部署区块链。 在蜂窝网络中，我们考虑一个更一般和更复杂的场景，同时支持 D2D 和 V2V 通信。MBS 通常具有有限的缓存资源，一些最先进的移动设备和车辆也都有一定数量的缓存资源。因此，基站、移动设备和车辆可以协同提供分布式边缘缓存，以充分利用可用资源。也就是说，特定的移动设备或车辆可以选择具有足够缓存资源的任何其他移动设备或车辆作为其内容缓存的服务提供商。由于 D2D 和 V2V 通信不可信，BSs 需要利用区块链技术来确保这种情况下的交易安全。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:2:1","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 架构分析 如何保证安全，如何适应动态的网络环境，我们通过分析上面的架构来明确这些内容 安全性：在该架构中，移动用户间的频谱管理、V2V 能量交易、缓存共享都会记录到区块链中防止篡改，从而保证安全的资源共享和分配。 灵活的网络：该架构中MBS、SBS、移动设备和车辆的共存为灵活的网络提供了机会。AI 可以准确地分析当前无线网络的拓扑结构、信道分配和干扰，然后选择最合适的无线接入模式（即蜂窝网络、V2V或D2D），以提高通信速率、降低能耗或增强用户体验。例如，该体系结构可以生成特定于用户的策略，使一些移动用户与 MBS 通信，而另一些连接到 RSU 以维护基本信息交换。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:2:2","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"3. 区块链赋能资源管理 由于缺乏标准化，无线网络的安全性面临挑战。此外，许多无线实体在不考虑个人隐私的情况下公开共享其资源或内容。为了建立一个安全和私有的无线通信环境，作者将联盟链（PBFT共识）集成到无线网络中，并讨论了四个潜在的区块链赋能的资源管理案例：频谱共享，D2D 缓存，能量交易和计算卸载。分别如下图 (a)、(b)、(c)、(d) 所示。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:3:0","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 频谱共享 由于需要适应不同类型的用户、具有不同性能要求的应用，以及需要将[异构空中接口]^(heterogeneous air interface)集成到下一代无线网络中，可能会使无线电频谱更加拥挤。认知无线电是一种能在时变无线环境中估计通信参数并自动进行频谱资源分配的频谱共享技术。在认知无线电系统中，无线电频谱属于主用户，主用户可以根据特定的频谱共享方案将频谱出租给次用户。但是，次用户必须共享他们的私有信息才能使用主用户的频谱。在这种情况下，可以利用区块链实现安全的频谱共享应用，同时集成对次用户的隐私保护。 上图 (a) 中展示了一个分布式频谱共享系统，其中每个 SBS 作为一个区块链节点。有许可频谱的 SBS 是主用户，没有许可频谱的 SBS 是次用户。如果主用户成功地将频谱出租给了次用户，则次用户向主用户支付报酬，同时形成频谱租赁交易，并被收集到区块链中。认知无线电可以利用人工智能设计最优的频谱共享策略，通过与射频环境的交互，实现长期回报的最大化。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:3:1","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 D2D 缓存 由传感器或多媒体应用生成的内容正在经历指数增长， MBSs 的容量可能不足。由于一些最先进的设备（如智能手机）具有一定的缓存资源，因此可以通过 D2D 通信将大规模内容缓存在这些实体中。在移动设备上缓存内容对于减少回程链路上的数据流量以及增强最终用户的 QoS 是一种很有潜力的方法。然而，由于内容通常涉及内容所有者的许多敏感和关键的个人信息，缓存请求者不愿意将其内容存储在不受信任的缓存提供程序中。区块链可以使不受信任的节点能够以安全的方式相互交互，因此它为 D2D 缓存提供了一种很有前途的方法。 上图 (b) 显示了区块链授权的 D2D 缓存系统。在该系统中，具有大规模内容的资源受限移动设备被定义为缓存请求者。具有足够缓存资源的设备被定义为缓存提供程序。MBSs 配备了 AI 算法来预测缓存请求者和缓存提供者之间的 D2D 通信持续时间，并执行缓存对匹配和资源分配以提高缓存命中率或系统实用性。如果内容成功存储在一个缓存提供程序中，则缓存请求程序将创建一个交易并将其发送到最近的 MBS。每个 MBS 将接收到的交易广播给其他 MBS，并在接收到一定数量的交易后构建一个新的区块。注意，MBSs 上的缓存资源用于存储有关 D2D 缓存的整个交易。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:3:2","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 能量交易 智能车辆不仅可以从固定充电点充电，还可以从其他有剩余电量的智能车俩获取电力。然而，由于隐私问题，拥有剩余电力的智能车辆可能不愿意在本地化的P2P能源交易市场中充当能源供应商。为鼓励电力过剩的汽车参与能源交易，有必要在交易过程中保护智能汽车的隐私。上图 (c) 显示了一个安全的 V2V 能源交易系统。有两种类型的车辆：一种需要充电，另一种有多余的电力。需要充电的车辆通过 V2R 通道向最近的 RSU 发送充电请求。RSU 将收到的请求广播给有剩余电力的当地车辆。然后，剩余电量的车辆以其充电状态响应 RSU。每个 RSU 使用一个AI算法，例如 DRL，来匹配能量交易对。在这里，汽车之间成功的能源交易被定义为 energy transactioin，并记录在区块链中。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:3:3","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"3.4 计算卸载 区块链可以被视为部署在移动设备上的应用程序。例如，如上图 (d) 所示，每个移动设备是一个挖矿类型的区块链的节点，例如比特币。为了支持比特币，移动设备必须解决PoW难题，然而，PoW难题是一个计算密集和能耗高的任务，资源受限的设备无法提供足够的计算资源和能量来维护比特币。在MEC框架中，移动设备可以将 PoW 任务卸载到附近的 BSs，并利用 BSs 支持的分布式计算。基站计算并向移动设备提供结果（即，关于交易的区块块和哈希指针）。 鉴于以上讨论的情况，区块链和无线网络是互补的。区块链可以为无线网络建立一个安全可信的资源分配和共享环境，无线网络也可为实现区块链提供分布式但可访问的计算资源和能量。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:3:4","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"4. 内容缓存实例 以内容缓存为例说明区块链和 AI 如何起作用，首先通过联盟链建立安全的内容缓存环境，然后利用 DRL 设计内容缓存方案从而最大化缓存资源效用。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:4:0","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 内容缓存区块链 下图是一个 D2D 网络中的内容缓存的框架，展示了缓存过程的一些细节。首先，区块链由 MBS 维持，D2D 缓存交易发生在移动设备间。如果内容成功缓存到了一个缓存提供者，缓存请求者应当创建一个交易记录并发送到最近的 MBS，MBSs 收集和管理它们本地的交易记录。经过共识后，交易记录被打包到区块并附加到区块链末尾，然后永久地存在每个 MBS 中。 过程中地一些关键步骤如下： 系统初始化：为了保护隐私，每个移动设备在系统初始化阶段需要在系统中注册一个合法身份。在 D2D 缓存区块链中，使用一个椭圆曲线签名算法和非对称加密来进行系统初始化。 一个移动设备 $d_i$ 可以在经过身份认证后获得一个合法身份，该身份保护公钥、私钥和证书（如$PK_i, SK_i,Cert_i$） 选择 D2D 缓存的角色：移动设备根据自己当前缓存资源可用性和未来的计划选择它们的角色，包括内容请求者和缓存提供者。有过剩缓存资源的移动设备可作为缓存提供者，用于为缓存请求者提供服务。 缓存交易：缓存请求者发送一定量缓存资源和期望的服务时间到最近的 MBS，MBS广播所有收到的缓存请求给本地缓存提供者。 缓存提供者反馈缓存资源量和未来计划给 MBS。然后每个 MBS 利用 DRL 算法匹配缓存需求对，决定每个缓存提供者提供的缓存资源，并分配 MBS 和移动设备的带宽。 收集到区块链：MBSs 通过运行 PBFT 共识将所有交易记录收集到区块链。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:4:1","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 DRL 算法 内容缓存问题可以被抽象为最大化系统效用的优化问题并用 DRL 算法解决。考虑一个有 $K$ 个BSs 的缓存网络，$M$ 个缓存请求者， $N$ 个缓存提供者。MBS 是区块链节点同时运行 DRL 算法。每个缓存请求有一个大规模内容 $d_i$ 如多媒体文件。如果缓存请求者 $i$ 的内容存在 缓存提供者 $j$ 中，$x_{ij} = 1$ ，否则为0。当两者间的距离小于预定义的通信范围时，两个移动设备可以通过 D2D 通信传输内容给彼此，系统效用由缓存效用和能量消耗组成。缓存效用为 $x_{ij} · d_i · B_i$，其中 $B_i$ 为所存内容的价格，花费分别是通信和缓存过程总的能量消耗。 通过所提出的架构，缓存能力、缓存请求者的需求、每个内容的规模等信息被收集和发送给代理，然后代理设计一个操作来匹配缓存对和分配资源。在深度强化学习过程中，这里有三个关键因素，分别是状态、操作和奖励。 [状态]^(State)：DRL 中的状态是一个反映环境的空间，可表示为 $S = (D_i, C_j, B_j)$，其中 $D_i$ 代表内容 $i$ 的状态，$C_j$ 代表可用缓存资源，$B_j$ 代表缓存提供者 $j$ 的可用带宽。每个 MBS 将上述信息组合成一个状态发送给代理。 [操作]^(Action)：代理的目标是将状态空间映射到操作空间，在该系统中，操作由两部分组成：$x_{ij}$ 和 $b_{ij}$，前者是二进制值，后者是带宽量。 [奖励]^(Reward)：基于当前状态和操作，代理可以从环境中获得一个奖励。因为奖励函数与目标函数相关，在该场景中，系统效用可以被视为奖励函数进行奖励。 设计内容缓存策略的 DRL 过程如上图 (b) 所示，其基于[深度确定性策略梯度方法]^(deep deterministic policy gradient method) 5。 在DRL中，主网络由两个深层神经网络组成，即 actor 网络和 critic 网络。actor 网络用来探索策略，而 critic 网络则评估策略的性能并提供 critic 值，这有助于 actor 了解策略的梯度。 目标网络可以定义为原始网络的旧版本，用于生成训练 Critic-P 的目标值，它包括目标参与者网络和目标批评者网络。目标网络的输入是来自重放存储器的下一个状态（即N-State），输出是训练critic-P 的临界值。 重放内存存储经验元组，包括当前状态、所选操作、奖励和下一个状态。存储的经验元组可以随机抽样用于训练主网络和目标网络。随机抽样经验元组的目的是减少数据相关性的影响。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:4:2","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"4.3 数值结果 作者通过大量的仿真来评估所提出的 DRL 赋能的 D2D 缓存方案的性能。该体系结构实现了两个部分：环境和代理。在该环境中，有5个缓存提供者和20个缓存请求者随机分布在 500m×500m 的区域内。缓存提供程序的缓存资源是从 [30、31、32、35、40]GB 中随机抽取的。缓存提供程序的最大带宽是从 [22、24、25、28、30]MHz 随机获取的。每个内容的数据大小是从3、6、7 GB中随机抽取的。 所提出的 DRL 赋能的 D2D 缓存方案同时进行缓存对匹配和动态带宽分配，以最大化系统效用，而DRL 赋能的基准缓存方案只进行缓存对匹配。下图中可以看出，论文所提方案的累积平均系统效用明显高于基准方案。这是论文所提方案可以为特定的缓存请求者选择最合适的缓存提供者，并优化缓存提供者和缓存请求者之间的带宽，以进一步提高系统的实用性。基准方案在不分配带宽的情况下进行缓存对匹配，从而导致较高的通信能量开销。此外，我们观察到，在学习过程开始时，不同方案的每个系统效用都很低，随着迭代数量的增加，系统效用在运行750个迭代之后达到一个相对稳定的值。 下图显示了在不同学习速率下所提出方案的收敛性能。首先，累积平均系统效用在所有学习率上实现收敛。其次，当学习率为$10^{-3}$时，累积平均系统效用明显高于学习率为$10^{-4}$和$10^{-5}$时的情况，这意味着较小的学习率可以获得更好的性能。然而，学习率为$10^{-3}$时的成绩也优于学习率为$10^{-2}$时的成绩。因此，我们可以得出结论，对于论文所提方案，$10^{-3}$是最佳的学习速率。事实上，一个合适的学习率取决于正在优化的模式的体系结构，以及当前优化过程中的环境状态。 ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:4:3","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["研究生的区块链学习之路"],"content":"5. 总结与收获 论文的核心问题是：区块链和 AI 如何服务于无线网络。作者首先描述了云-边缘-用户三层架构，得出的结论是只有在用户层的三种情况（异构网络、车辆网络和蜂窝网络）中，才需要区块链保证安全，而 AI 功能由边缘层提供，用于执行最优的资源分配策略。紧接着，作者介绍了四个区块链可以起作用的资源管理案例：频谱共享、D2D 缓存、V2V 能量交易和计算卸载。然后针对缓存场景，详细说明了区块链如何保证安全以及 AI 如何最大化资源利用率，数值结果说明了所提方案的有效性。 更进一步的，我们关心的是计算卸载场景下区块链如何保证 D2D 的安全，因此作者描述的四个资源管理案例有一定的作用。但是，作者的思路是 MBS 作为区块链节点，重新将基站和边缘服务器引入了方案中，我们使用 D2D 进行资源卸载的原因是节省频谱资源并弥补 MEC 场景的不足，将 MBS 引入不太合适。另一方面，MBS 维持区块链意味着这是一个小范围场景，最多整个城市的 MBS 都加入，移动设备或车辆在不同地域间的移动可能会带来数据访问问题，需要不同区块链的协作。最后的担心是，深度强化学习也是一种计算密集型任务，需要不断地训练，将 DRL 算法放在区块链中运行，资源消耗与收益是否匹配犹未可知。最后得到的一个启发是，不必局限于计算卸载，D2D 缓存也是一个方向。 注：插图源自原论文 Y. Dai et al., “Artifi cial Intelligence Empowered Edge Computing and Caching for Internet of Vehicles,” IEEE Wireless Commun., accepted, 2018. ↩︎ J. Kang et al., “Enabling Localized Peer-to-Peer Electricity Trading Among Plug-In Hybrid Electric Vehicles Using Consortium Blockchains,” IEEE Trans. Ind. Informat., vol. 13, no. 6, 2017, pp. 3154–64. ↩︎ Z. Li et al., “Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things,” IEEE Trans. Ind. Informat., 2017. ↩︎ J. Kang et al., “Blockchain for Secure and Efficient Data Sharing in Vehicular Edge Computing and Networks,” IEEE Internet of Things J., 2018. ↩︎ T. P. Lillicrap et al., “Continuous Control with Deep Reinforcement Learning”, Proc. Int’l. Conf. Learning Representations, 2016. ↩︎ M. A. Rahman et al., “Blockchain-Based Mobile Edge Computing Framework for Secure Therapy Applications”, IEEE Access, 2018. ↩︎ Y. Dai et al., “Joint Load Balancing and Offloading in Vehicular Edge Computing and Networks”, IEEE Internet of Things J., pp. 1-1, 2018. ↩︎ ","date":"2020-04-13","objectID":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/:5:0","tags":["论文笔记"],"title":"Blockchain and Deep Reinforcement Learning Empowered Intelligent 5G Beyond","uri":"/2020/blockchain-and-deep-reinforcement-learning-empowered-intelligent-5g-beyond/"},{"categories":["爱编程爱技术的孩子"],"content":"分治，字面意思就是分而治之，意思就是把一个复杂的问题分成两个或更多个相同或相似的子问题，解决子问题后再进行合并。典型的如归并排序和快排，都是以分治为基础的。 我们以 归并排序 来说明一个典型的分治算法的思路 分治算法可以分三步走：分解 -\u003e 解决 -\u003e 合并 分解原问题为结构相同的子问题。 分解到某个容易求解的边界之后，进行递归求解。 将子问题的解合并成原问题的解。 归并排序，我们就叫这个函数 merge_sort 吧，按照我们上面说的，要明确该函数的职责，即 对传入的一个数组排序 。OK，那么这个问题能不能分解呢？当然可以！给一个数组排序，不就等于给该数组的两半分别排序，然后合并就完事了。 void merge_sort(一个数组) { if (可以很容易处理) return; merge_sort(左半个数组); merge_sort(右半个数组); merge(左半个数组, 右半个数组); } 好了，这个算法也就这样了，完全没有任何难度。记住之前说的，相信函数的能力，传给它半个数组，那么这半个数组就已经被排好了。而且你会发现这不就是个二叉树遍历模板吗？为什么是后序遍历？因为我们分治算法的套路是 分解 -\u003e 解决（触底）-\u003e 合并（回溯） 啊，先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于 merge 函数，参考两个有序链表的合并，简直一模一样。 ","date":"2020-04-13","objectID":"/2020/algorithm-divide-and-conquer/:0:0","tags":["数据结构与算法"],"title":"算法-分治","uri":"/2020/algorithm-divide-and-conquer/"},{"categories":["爱编程爱技术的孩子"],"content":"首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。 递归是一种编程技巧，一种解决问题的思维方式； 分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）； 贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。 ","date":"2020-04-12","objectID":"/2020/algorithm-recursive/:0:0","tags":["数据结构与算法"],"title":"算法-递归","uri":"/2020/algorithm-recursive/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 递归原理 递归的基本思想是某个函数直接或者间接地调用自身，核心在于将原问题拆解为性质相同但规模更小的子问题，函数不断地调用自身来解决子问题，直到分无可分，也就是到了无需递归就可以解决的地步，原问题就顺利解决掉了。 因此我们在思考递归问题时应明确两点 明确递推关系，也就是原问题如何拆分到更小的子问题 明确结束条件，也就是最小的问题如何不使用递归来解决 我们将递归的基本思路概述为一个模板如下 func Recursive(传入数值) { if 结束条件 return 最小子问题解 Recursive(缩小规模) 利用递归结果进行计算[可选] } 下面以一个简单的问题「以相反的顺序打印字符串」来进行说明。我们将函数定义为 printReverse(str[0…n-1])，其中str[0] 表示字符串的第一个字符，然后进行分析 分解子问题。原问题可以拆解为先以相反的顺序打印子字符串 str[1…n-1]，然后打印第一个字符 str[0] 结束条件。结束条件为如果当前字符串为空，直接返回。 最终得到的代码如下 func printReverse(s []byte) { if len(s) == 0 { return } printReverse(s[1:]) fmt.Printf(\"%c\",s[0]) } 需要我们牢记的一个结论是：凡是可计算函数都是一般递归函数，这就是著名的丘奇-图灵论点。 继续以「反转链表」为例进行说明，虽然迭代的方法更优，但这里我们只介绍递归的思路。 结束条件是当前节点为 nil 或者当前节点的下一个节点为 nil，这两种情况不需要反转 子问题就是反转当前节点后面的部分 递归后要做的事情就是如何将当前节点添加到后面的反转的链表的末尾 因此最后得到的代码如下 func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } tmp := reverseList(head.Next) head.Next.Next = head head.Next = nil return tmp } 这里最后的处理过程可以这样理解，假设列表为： $$ n_1 → … → n_{k-1} → n_k → n_{k+1} → … → n_m → Ø $$ 若从节点 $n_{k+1}$ 到 $n_m$ 已经被反转，而我们正处于 $n_k$。 $$ n_1 → … → n_{k-1} → n_k → n_{k+1} ← … ← n_m $$ 我们希望 $n_{k+1}$ 的下一个节点指向 $n_k$, 那么只需要调整 $n_k$ 的指针即可，因为此时后面的链表末尾已经是节点 $n_{k+1}$ 了。所以执行 nk.Next.Next = nk nk.Next = nil // 处理边界条件 n1，否则产生循环 还应该明白代码最后返回的 tmp 不是当前处理节点的下一个节点，而是后面已反转链表的头结点，这个头结点的指针是一级一级递归传回来的。 写递归最重要的一点是： 明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。 如果跳进一层又一层的递归函数里思考，就会陷入无穷无尽的细节，人脑不是为了做这个的，递归本身就是在简化思维。比如上面的「反转链表」例子，我们确认了子问题具有与原问题相同的性质，因此 reverseList(head.Next) 可以翻转链表后面的部分，我们需要相信这一点，而不是跟随递归进入一层层的调用栈。 ","date":"2020-04-12","objectID":"/2020/algorithm-recursive/:1:0","tags":["数据结构与算法"],"title":"算法-递归","uri":"/2020/algorithm-recursive/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 记忆化技术 递归的过程可能出现大量重复的计算，以斐波那契数列为例，如果我们定义函数 F(n) 表示在索引 n 处的斐波那契数，那么你可以推导出如下的递推关系： F(n) = F(n - 1) + F(n - 2) 下面的树显示了在计算 F(4) 时发生的所有重复计算（按颜色分组）。 为了消除上述情况中的重复计算，采用的一种方法是将中间结果存储在缓存中，以便随时重用，而不需要重新计算。这种方式叫做记忆化。 记忆化与动态规划的 DP 数组非常相似，但用在递归过程中，一般作为全局变量声明，或者由父函数通过参数进行传递。斐波那契树计算的记忆化方法举例如下 var cache = map[int]int{0: 0, 1: 1} func fib(N int) int { if N \u003c= 1 { return N } return memoize(N) } func memoize(N int) int { if _, ok := cache[N]; ok { return cache[N] } cache[N] = memoize(N-1) + memoize(N-2) return memoize(N) } ","date":"2020-04-12","objectID":"/2020/algorithm-recursive/:2:0","tags":["数据结构与算法"],"title":"算法-递归","uri":"/2020/algorithm-recursive/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 复杂度分析 ","date":"2020-04-12","objectID":"/2020/algorithm-recursive/:3:0","tags":["数据结构与算法"],"title":"算法-递归","uri":"/2020/algorithm-recursive/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 时间复杂度 给出一个递归算法，其时间复杂度$O(T)$ 通常是递归调用的数量（记作 R） 和计算的时间复杂度的乘积（表示为 $O(s)$）的乘积： $$ O(T) = R * O(s) $$ 以反转字符串为例，由于每次将问题缩减为除第一个字符外的子串，因此函数一共被递归调用 n 次，n 为字符串长度。每次递归调用完毕后，仅仅将第一个字符输出，该操作的时间复杂度为 $O(1)$，因此总体时间复杂度为 $n * O(1) = O(n)$ 对于递推关系涉及多个递归调用的情况，比如斐波那契数，其递推关系被定义为 f(n) = f(n-1) + f(n-2)，最好使用执行树来分析时间复杂度。执行树是一棵用于表示递归函数执行流程的树，树中每个节点都表示递归函数的调用，因此树的节点总数就对应递归调用的数量。 递归函数的执行树将形成 n 叉树，其中 n 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树。 如果构成了一棵 n 层的完全二叉树，那么节点总数就是 $2^n - 1$，因此时间复杂度计算中的递归调用数量就是 $O(2^n)$，算上最后的结果处理 $O(1)$，总的时间复杂度为 $O(2^n)$ 但是如果我们使用了记忆化技术，从 1 到 n 每个值对应的斐波那契数计算只会发生一次，因此递归调用的数量变为 $O(n)$，最终的时间复杂度为 $O(n) * O(1) = O (n)$ ","date":"2020-04-12","objectID":"/2020/algorithm-recursive/:3:1","tags":["数据结构与算法"],"title":"算法-递归","uri":"/2020/algorithm-recursive/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 空间复杂度 空间复杂度考虑两部分：递归相关空间和非递归相关空间。 递归相关空间指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈，为了完成函数调用，系统会在栈中分配空间来保存三个重要信息 函数调用的返回地址 传递给函数调用的参数 函数调用的局部变量 该空间在函数调用时产生，在调用完成后释放，但对于递归，栈空间将逐渐累积直到结束条件。递归函数中如果没有额外的空间消耗，则递归调用引起的栈空间消耗是递归空间复杂度的主要来源。 仍以反转字符串为例，函数处理逻辑中只有打印首字符会使用常数级空间，递归调用 n 次一共会产生 n 级的栈空间，因此最终的空间复杂度为 $O(n)$。 由于为程序提供的栈空间通常是有限的，在递归调用层级过多时，可能会发生堆栈溢出的情况，此时无法分配新的栈空间进行下一步的递归调用，因此导致程序执行失败。所以在涉及递归算法时，应仔细评估在输入规模扩大时是否存在堆栈溢出的可能性。 非递归相关空间指与递归过程没有直接关系的内存空间，比如上面讨论中提到的打印首字符使用的空间，除此外还可能包括如全局变量等其它的空间使用，比如在利用记忆化优化递归时使用的全局数组，会占用 O(n) 的空间复杂度。 注意，这里递归相关空间与非递归相关空间不是相乘的关系。 ","date":"2020-04-12","objectID":"/2020/algorithm-recursive/:3:2","tags":["数据结构与算法"],"title":"算法-递归","uri":"/2020/algorithm-recursive/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 尾递归 尾递归是递归函数的一种特殊情况，其中递归调用是递归函数的最后一条指令，并且其返回值不是表达式的一部分。举个例子 // 非尾递归 func helper(start int, ls []int) int { if start \u003e= len(ls) { return 0 } return ls[start] + helper(start+1, ls) } // 尾递归 func helper(start int, ls []int, acc int) int { if start \u003e= len(ls) { return acc } return helper(start+1,ls,acc+ls[start]) } 说的更通俗一点就是，调用语句是函数最后一条语句，且返回值不会被用作其它计算。 尾递归的好处是避免递归调用期间栈空间的累积，因为每一层的返回不做处理直接返回，相当于不需要这一步直接返回元素调用。此时我们无需保存每一层递归的环境，这导致了从最高层级到结束条件我们始终重用一个栈空间。 尾递归当然也可以作为非尾递归函数来执行，此时不会重用栈空间，仍然会逐级累积，不过通常编译器会识别尾递归模式进行优化，但这需要编程语言的支持，C、C++支持尾递归优化，Java、Python，我当前使用的 Go 都不支持尾递归优化。 ","date":"2020-04-12","objectID":"/2020/algorithm-recursive/:4:0","tags":["数据结构与算法"],"title":"算法-递归","uri":"/2020/algorithm-recursive/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 原则 递归的作用非常强大，但可能出现堆栈溢出，因此，可能的情况下，尽量使用记忆化技术节省调用次数，使用尾递归节省栈空间。 ","date":"2020-04-12","objectID":"/2020/algorithm-recursive/:5:0","tags":["数据结构与算法"],"title":"算法-递归","uri":"/2020/algorithm-recursive/"},{"categories":["平日里的白日梦"],"content":"各主流平台提供了关闭个性化广告的功能，但操作一番之后发现，一是关闭入口藏的比较深给，二是我们反感的其实不是个性化广告，而是过多的广告和收集的隐私信息不知道会用到哪里的担忧。 关于第一点，减少广告的投送频率不是关闭个性化广告可以解决的，关于第二点，其实也没用，不投送，不代表不收集隐私和绘制用户画像信息的收集应该放在用户终端，给予用户对自己隐私的完全控制能力，但用户的浏览行为，购物记录，聊天信息，回答，点赞，各种都不是自己能决定的，尤其是支付宝这种拥有大量隐私信息的厂商。技术手段很难解决，一方面还是自己应该在个人资料中减少真实信息，另一方面需要看厂商自己的道德水准和完善的法律规定。 ","date":"2020-04-09","objectID":"/2020/about-personalized-advertising/:0:0","tags":["杂谈"],"title":"关于个性化广告","uri":"/2020/about-personalized-advertising/"},{"categories":["研究生的区块链学习之路"],"content":"1. 概念引入 论文1提到，一些邻近的用户设备（User Equipment, UE）组合其计算能力，服务于具有更高性能需求的应用可以叫做 ad-hoc cloud。实际应用需要解决几个关键的问题： 在保证处理后的数据能够返回到源 UE 的同时，在附近找到合适的计算 UE； 尽管没有用于促进可靠计算的控制信道，但必须启用计算 UE 间的协调； 考虑到电池消耗和额外的数据传输约束，必须激励计算 UE 向其它设备提供其计算能力； 安全和隐私问题。 ","date":"2020-04-03","objectID":"/2020/blockchain-for-d2d-cache-or-computing-offload/:1:0","tags":["科研记录"],"title":"研究记录12-区块链与D2D内容缓存/计算卸载方向探索","uri":"/2020/blockchain-for-d2d-cache-or-computing-offload/"},{"categories":["研究生的区块链学习之路"],"content":"2. 背景调查 如第一部分所述，我们主要谈论的问题被称作 ad-hoc cloud，在论文2中，将该方向的研究正式命名为移动自组织云（Mobile ad hoc cloud，MAC），这篇综述对2016年及之前的该方向论文进行了总结，我们总结一些可能有用的内容。 本地的计算密集型应用（如游戏、高清视频、AR、VR、图像识别等）需要大量的服务与资源，利用云提供这些资源的方式叫做移动云计算（Mobile Cloud Computing， MCC）。但是，考虑到网络连接的带宽和质量，这种方式不总是可行的，这种情况下，人们提出了 MAC，利用一组移动设备的共享资源，来实现一个共同的目标。MAC 不是用来取代原有技术的，而是一种补充，当网络质量不佳、附近基站不可用或其它情况时，使用这种方式。 以实时会议（conference）出席的例子来说明：移动用户拍摄会议参与者的快照，并将捕获的人脸和存储的照片进行匹配，从而确定谁在参加哪个会话（session）；此外，出于会议议程的规划，会议组织者希望获取不同 session 中参与者的最新情况。在该场景中，移动用户可能没有足够的资源在单个设备上执行该任务，因此选择使用 MAC 满足任务执行的实时性需求。假设每个 session 有 50 个参与者，其中 10 个愿意参与 MAC，任务被分解为如下步骤 检测快照中的人脸数量，并为每个人脸裁剪一个小图像； 分别提交每个人脸进行识别； 将与会者列表返回给用户。 假设第 1 步需要 15 秒，第2步需要 10 秒，第 3 步需要 6 秒，不使用 MAC 移动用户总共需要 15+10*50+6 = 512s，如果使用 MAC，任务 2 被分配给 10 个 MAC 参与者（provider），时间将大幅减少，假设与所有 provider 的通信开销是3s，那么总时间为 15+3 +10 * 5+6 = 74s。 实际的过程更加复杂，面对的问题包括：[构成 MAC 的移动设备的发现]^(MAC formation)、[任务卸载]^(task offloading)，任务调度与分配，安全与隐私，[移动性和激励]^(mobility and incentives)，资源管理。按这种分类总结相关解决方案如下图 由于通常参与 MAC 的移动节点是随机选择的，因此安全性和隐私性是一个重要问题。在 MAC 中加入任何恶意节点都会增加总体任务执行时间，从而导致性能下降。此外，位置的隐私性也是共享设备的用户的一个重要的问题。为了解决这些问题，需要合适的认证与授权机制，保护位置隐私及防止恶意节点参与 MAC。论文3提出一种可信算法，基于AES 加密保证节点间的安全通信，同时也可以管理节点的加入和退出。论文4则提出一种信任管理系统，监视参与 ad hoc 网络的节点，计算其信任值并存储，从而其它移动设备可验证其信任值，信任值越高越可靠，最终达到阻止恶意节点参与的目的。除此之外，有的方案建立和分发密钥来保护通信，有的方案利用 SaaS 或 PaaS 检测异常行为。 ","date":"2020-04-03","objectID":"/2020/blockchain-for-d2d-cache-or-computing-offload/:2:0","tags":["科研记录"],"title":"研究记录12-区块链与D2D内容缓存/计算卸载方向探索","uri":"/2020/blockchain-for-d2d-cache-or-computing-offload/"},{"categories":["研究生的区块链学习之路"],"content":"3. 引入区块链的例子 这一部分摘取自论文5，是一个利用区块链提供不可信 D2D 节点间信任的例子。 首先，随着智能手机和 IoT 设备的增多，移动通信已成为日常生活的一部分，传统的云计算不能满足实时性的需要，D2D-ECN(device-to-device edge computing and network)被提出，目的是共享移动设备的计算和通信资源提供一个灵活的边缘计算平台。这种情况下假设希望在一个期望的时间内执行一个计算密集型的任务，可以将计算任务卸载到有可用计算资源的移动设备上执行，数据传输延迟也可以通过购买空闲通信资源减少。 资源交换和任务分配本地的资源交换和任务分配 \" 资源交换和任务分配 区块链被引入用来解决分布式和点对点网络中不可信用户间的安全和可靠性问题。由于现有研究大部分使用 PoW 共识，在资源有限的 IoT 环境中不具备可行性，作者选择了一种基于信誉的共识（reputation-based consensus）6来协调设备和验证交易。整个系统的安全性靠该共识和一个信誉评估系统保证。 作者认为现有研究没有考虑计算卸载规则对基于区块链的边缘网络的性能的影响，整个计算卸载过程可以划分为资源交易和任务分配两部分，资源交易的目的是提供高效的资源定价和分配策略，从而平衡任务所有者的[效用]^(utility)和资源所有者的收益，任务分配则是在保证较低的执行时间和系统开销。论文实际做的事有两件 提出并使用智能合约实现了一个分布式的资源交易和任务分配方案，平衡资源定价与收益，最小化执行时间和系统开销； 提出一个信誉评估系统并和共识配合使用保证计算卸载环境的可靠性。 论文引入资源币激励用户参与，一个计算卸载过程的工作流如下图所示。设备首先在 LBS（Location Based Services，基于位置的服务） 中注册并被授予身份，通过{身份ID，证书，公钥，私钥，钱包地址}五元组追踪在区块链中的交易记录（资源交易和信誉度更新）；然后，任务所有者发送资源需求到 LBS，资源所有者发送可用资源数量和使用限制到 LBS，LBS 验证证书后将这些内容写入智能合约，并在达到条件后自动触发，资源的定价和交易被设定了规则；之后，根据可用的通信和计算资源，智能合约执行任务分配算法最小化总延迟，并在准确返回计算结果后对资源提供者的信誉进行评分；这些工作完成后，任务提供者按照资源价格支付资源币；最后，任务所有者签名后广播资源交易记录和更新后的信誉度，运行基于信誉的共识，由信誉度最高的节点将这些记录收集到区块并附加到区块链。实际过程需要经过多轮验证。 工作流基于区块链的资源交易和任务分配系统组成和工作流 \" 工作流 这里有3个关注的地方 作者使用公式推导得到了任务分配者效用和资源所有者收益的平衡函数，在资源交易智能合约中执行该函数得到合适的定价； 作者使用公式推导最小化了任务执行的总延迟，并在任务分配智能合约中执行； 对资源提供者的信誉度评估在得到正确的计算结果后执行，作者也提供了公式推导。 整个系统的安全性通过三个方面保证：共识和信誉评估系统保证计算卸载环境可靠；智能合约保证交易记录和信誉度不被篡改；LBS 保证通信安全。 除了这篇论文外还有一篇值得参考的论文7 ","date":"2020-04-03","objectID":"/2020/blockchain-for-d2d-cache-or-computing-offload/:3:0","tags":["科研记录"],"title":"研究记录12-区块链与D2D内容缓存/计算卸载方向探索","uri":"/2020/blockchain-for-d2d-cache-or-computing-offload/"},{"categories":["研究生的区块链学习之路"],"content":"4. 问题与思考 老师提出的问题： 移动群问题，考虑 IP、位置属性，考虑协作和信誉评估，要尝试利用伪匿名或其他机制隐藏位置信息，从而保证隐私。 前面几部分将场景和计算卸载的具体例子描述的比较清楚了，还举了一个引入区块链的例子，但我们现在还是存在以下疑问 区块链被引入是用来做什么的？现有方案中，通常是利用智能合约提供一个任务分发的平台，就像美团那样，发布任务，接取任务。这里面，区块链保证了发布的任务的可靠性，通过加入信誉系统，还可以基于历史行为保证接取任务的节点的可靠性，数据的传输一般不通过区块链，而是 D2D 或其它的方式，但是数据传输所需的密钥可以使用区块链分发。需要明确，区块链无法保证计算结果的可靠，结果的可靠可以使用多方安全计算（MPC）完成； 设备的恶意行为可能包括：接了任务未完成、未返回结果、返回恶意结果等； 第一点中提到的区块链作为任务分发的平台，接取任务的设备采用的是自由竞争的方式，但在传统方案中，如何确定完成计算任务的设备目前还不清楚； 接取关系建立后生成的密钥用于计算任务和计算数据的加密传输，公私钥体系中，加密和解密也是相当一部分工作量，因此有需要的话最好还是对称密钥体系，多数情况下，计算任务和计算数据都不重要，重要的只是计算的结果； 接任务的是一组设备，不是一个设备，要明确，无论是任务的分发，还是 D2D 的传输，都会涉及一组设备的协调，尤其是 D2D 传输，不是由发布者直接发给所有的设备，二是所有接任务的设备间有先后关系，它们可能需要彼此的计算结果； 再次重申第 2 部分提到的几个问题：移动设备的发现、任务卸载、任务调度与分配、安全与隐私、移动性和激励、资源管理； 在区块链平台中接取任务的限制是，需要保证接任务的设备在有效的 D2D 通信范围内，这是需要设备的地理位置信息的，这是隐私信息，需要加密存在区块链上，在任务分发中，需要根据计算要求和接任务中匹配，这里密文的直接匹配可以利用密码学的相关知识，如果涉及到加减等数学运算，可以使用同态加密，同态加密在链上是可以做的，因为同态中计算量大的部分可以放在链下； 隐私问题指的是节点在链上的位置信息隐私（地理位置或网络位置），D2D 通信过程中的隐私，即通信建立连接需要知道对方地址的问题，需要解决，但区块链无法完成； 对需要 IP 的理解是 D2D 通信需要知道对方的 IP； D2D 通信技术的理解包括蓝牙、5G； 隐私的保护一般使用的都是对称或非对称密钥加密，因此，核心在于一个密钥分发协议的设计和在区块链中的实现，这一点可以参考论文8，一个关于移动设备在区块链中隐私的更详细讨论是论文9； 计算结果的可靠性同样需要保证。一种可选的做法是 MPC（安全多方计算），另一个是将计算结果在链上返回，而不是通过 D2D，当结果在区块链上有了存证以后，便于之后发生问题时进行追溯，当然，这里还存在的问题是，计算结果需要具有可复现性，一些计算任务可能不具备这一要求； 由于完成计算任务的各设备间存在先后关系，这里有两种方案：一是任务发布者只获取最开始完成计算任务的设备地址，然后传输任务和数据，第一个或第一批设备完成任务后，结果上传区块链后，触发合约因此获得接下来要完成任务的设备地址，这样接续运行；二是确定完成任务的所有设备和它们完成任务的先后关系后，由区块链直接将各自设备需要的下一个完成任务的设备地址交给它，这样可以保证只有必要的人知道相关的位置隐私； 会不会以及什么时候用到访问控制系统。 下面是一个简单的流程描述，首先，所有参与任务分发的节点在链上进行注册，当任务发布者有一个计算任务或资源需求时，会签名后将其发布到链上，其它拥有资源节点根据签名验证任务有效性后，可以选择接取该任务，合约会自动根据任务需求和节点能力、位置、历史信誉进行匹配（隐私信息会进行密文匹配），然后确定接取任务的节点。角色确定后，任务发布者获取接任务节点的位置信息，通过 D2D 通信将计算任务和计算数据传输过去，计算完的结果直接利用区块链返回，而不是 D2D 连接，任务发布者确认后，将触发抵押作为酬劳的代币转移，同时计算信誉历史，如果接任务的节点发生了恶意行为，如不返回计算结果（中途推出）、故意返回错误结果等，均会计入信誉系统，影响下次接任务。 ","date":"2020-04-03","objectID":"/2020/blockchain-for-d2d-cache-or-computing-offload/:4:0","tags":["科研记录"],"title":"研究记录12-区块链与D2D内容缓存/计算卸载方向探索","uri":"/2020/blockchain-for-d2d-cache-or-computing-offload/"},{"categories":["研究生的区块链学习之路"],"content":"5. 一些思路 使用一个公链提供基于位置的服务，所有设备在区块链中注册获取其身份，可以更新自己的资源状态或发起资源请求，由于计算卸载是小范围的，设备还需要提供自身的位置，但位置信息应被加密保护，从而保证隐私。 此外区块链中还维持一个信誉评估系统，根据每次资源交易的结果更新设备信誉度。 访问控制系统在其中起到的作用是，接受到资源请求后，根据位置属性和信誉度获取附近设备的地址，设备地址应该作为一种资源提供。得到附近的设备地址后，发起请求建立资源请求者者和资源提供者的 D2D 通信，该D2D网络同时也是一个区块链，任务分配、计算卸载等过程都在这个本地区块链执行。资源请求者得到结果并验证正确后，将这个临时的区块链链接到公链相应的区块，并在主链中更新信誉度和支付数字货币。 该结构类似于哈希表，主链是不断延长的哈希表结构，每个区块是哈希表的一个元素，而每个哈希表元素对应一条或多条临时区块链。 核心思想是将支付、信誉评估、任务分配、计算卸载等功能分离，放在各自适合的区块链中。 ","date":"2020-04-03","objectID":"/2020/blockchain-for-d2d-cache-or-computing-offload/:5:0","tags":["科研记录"],"title":"研究记录12-区块链与D2D内容缓存/计算卸载方向探索","uri":"/2020/blockchain-for-d2d-cache-or-computing-offload/"},{"categories":["研究生的区块链学习之路"],"content":"5.1 功能划分 我们的基本思路是根据需求将各种功能划分到公链和私链上。基本的出发点是，公链的处理速度不够快，计算卸载和内容缓存都对速度有一定要求，而私链覆盖范围不够大，设备可能在任何时间任何地点有内容缓存或计算卸载的需求。因此最终决定将对处理速度有要求的功能放到私链，将设备发现和移动性等功能放到公链，然后通过一定的方法将两条区块链相关联。 公链 首先基于位置的服务（LBS）需要在公链上实现。论文5使用了一个可信 LBS，设备只有在其中注册后才能成为合法的 D2D-ECN （D2D边缘计算网络）参与者，然后 LBS 会分配设备ID 和证书（也可以是 IP 或 MAC 地址）用来唯一识别设备，接着发给设备一对公私钥用于通信，最后是钱包地址，用于资源交易（购买或出售存储或计算能力）。资源请求者将资源需求发到 LBS，资源所有者将可用资源数量和使用限制发到 LBS，LBS 验证它们的证书后将这些内容写入智能合约。因此在该论文中，LBS是独立于区块链之外的可信实体，我们知道，第三方的可信是相对的，尤其在关于位置的隐私上，我们更抱有戒心，因此可以直接利用智能合约在公链上提供基于位置的服务。 为了激励用户参与计算卸载和内容缓存，使用资源提供者的资源需要支付数字货币，我们可以直接使用公链的货币，如以太坊，因此如第一部分所述，资源请求者还需要知道资源提供者的钱包地址。 经过分析，我们应在公链上实施的功能包括：设备注册，位置管理，支付。支付可以直接使用公链的账户地址，注册需要维持一个注册表，以设备 ID 为主键，关联设备地址、IP或MAC地址以及设备的公链账户地址。鉴于可能发生的恶意行为，我们可以维持一个简单的恶意行为判决机制或一个信誉系统。这里的关键问题是设备位置的隐私，由于公链中信息是透明的，位置不可以直接进行存储，最好是对其进行加密，所以可能还需要在设备注册时传入一个公钥用于对设备地址加密。资源请求者发起请求后，公链中的 LBS 根据请求者的位置查找其附近的设备，并将这些设备的 IP/MAC 传给请求者，用于建立 D2D 网络。资源匹配、任务划分、计算卸载等其它功能都在D2D网络中进行。 这里不确定的是资源匹配的过程是否在公链中实施，也就是说，是直接将请求者附近所有设备的位置发送过去，还是进行资源匹配后将符合要求的设备位置发送过去。 私链 资源请求者收到附近设备的 IP/MAC 地址后，发起广播请求建立 D2D 网络，然后在 D2D 网络之上建立私有区块链，利用私有区块链提供的智能合约实现任务划分和计算卸载/内容缓存。任务完成后，将整条私链（或私链的哈希）交给公链存储，依附在公链当前的区块上，形成一种类似于如下的结构。 如同现有的线上支付系统，资源提供者完成任务后在公链中标记任务完成，资源请求者确认后，事先锁定在智能合约中的数字货币被支付。整个交易完成，最后可能会根据交易情况评估信誉或记录恶意行为。 ","date":"2020-04-03","objectID":"/2020/blockchain-for-d2d-cache-or-computing-offload/:5:1","tags":["科研记录"],"title":"研究记录12-区块链与D2D内容缓存/计算卸载方向探索","uri":"/2020/blockchain-for-d2d-cache-or-computing-offload/"},{"categories":["研究生的区块链学习之路"],"content":"5.2 多链关联 就是上面说的将临时区块链的数据链接到公链相关的区块，这一思路的来源是 Dorri 的论文10，论文关于 Local BC 包含的交易有一段说明如下 Besides the headers, each block contains a number of transactions. For each transaction five parameters are stored in the local BC as shown in the top left corner of the Figure 2. The first two parameters are used to chain transactions of the same device to each other and identify each transaction uniquely in the BC. The transaction’s corresponding device ID is inserted on the third field. ”Transaction type” refers to the type of transaction that can be genesis, access, store, or monitor transactions. The transaction is stored on the fifth field if it comes from the overlay network, otherwise, this filed is kept blank. The local BC is kept and managed by a local miner. 其中提到的 Figure 2 如下，Local BC的区块体是一系列交易的集合，每个交易的第一个字段填充相同设备上一个交易的交易号，用来将相同设备的所有交易链接到一起。每个交易的交易号是第二个字段，设备ID是第三个字段。如果交易来自 Overlay，交易内容存在第五个字段，否则留空。 ","date":"2020-04-03","objectID":"/2020/blockchain-for-d2d-cache-or-computing-offload/:5:2","tags":["科研记录"],"title":"研究记录12-区块链与D2D内容缓存/计算卸载方向探索","uri":"/2020/blockchain-for-d2d-cache-or-computing-offload/"},{"categories":["研究生的区块链学习之路"],"content":"5.3 当前难点 难点也是可行性问题在于 支付合约的设计实现 如何根据加密后的位置查找附近设备（链上的密文比较） 已知 IP/MAC 地址如何组建 D2D 网络 如何利用合约实现内容缓存/计算卸载（参考已有论文） 完成任务的私链如何存在公链上 如果存哈希，私链主体内容存在哪里 如果存内容，公链的区块是否能容纳 MACH P, BECVAR Z. Mobile Edge Computing: A Survey on Architecture and Computation Offloading[J]. IEEE Communications Surveys \u0026 Tutorials, 2017, 19(3): 1628–1656. DOI:10.1109/COMST.2017.2682318. ↩︎ YAQOOB I, AHMED E, GANI A, 等. Mobile Ad Hoc Cloud: A Survey: Mobile Ad Hoc Cloud[J]. Wireless Communications and Mobile Computing, 2016, 16(16): 2572–2589. DOI:10.1002/wcm.2709. ↩︎ Lacuesta R, Lloret J, Sendra S, Peñalver L. Spontaneous ad hoc mobile cloud computing network. The Scientific World Journal 2014; 2014: 1–19. DOI: 10.1155/2014/232419 ↩︎ Hammam A, Senbel S. A trust management system for ad-hoc mobile clouds. In Computer Engineering \u0026 Systems (ICCES), 2013 8th International Conference on, IEEE, 2013 ↩︎ Qiao G, Leng S, Chai H, et. al. Blockchain Empowered Resource Trading in Mobile Edge Computing and Networks[C]. ICC 2019 - 2019 IEEE International Conference on Communications (ICC). Shanghai, China: IEEE, 2019: 1–6. DOI:10.1109/ICC.2019.8761664. ↩︎ F. Gai et al., “Proof of Reputation: A Reputation-based Consensus Protocol for Peer-to-Peer Networks”, Proc. 2018 Int. Con. Dat. Sys. Adv. App. DASFAA, Feb. 2018. ↩ ↩︎ Zhou, Ao, Qibo Sun和Jinglin Li. BCEdge: Blockchain‐based Resource Management in D2D‐assisted Mobile Edge Computing. Software: Practice and Experience, 2019年10月21日, spe.2758. https://doi.org/10.1002/spe.2758. ↩︎ Huang, Junqin, Linghe Kong, Guihai Chen, Min-You Wu, Xue Liu和Peng Zeng. Towards Secure Industrial IoT: Blockchain System With Credit-Based Consensus Mechanism. IEEE Transactions on Industrial Informatics 15, 期 6 (2019年6月): 3680–89. https://doi.org/10.1109/TII.2019.2903342. ↩︎ Zyskind, Guy, Oz Nathan和Alex Sandy Pentland. Decentralizing Privacy: Using Blockchain to Protect Personal Data. 收入 2015 IEEE Security and Privacy Workshops, 180–84. San Jose, CA: IEEE, 2015. https://doi.org/10.1109/SPW.2015.27. ↩︎ Dorri A, Kanhers S S, Jurdak R, 等. Blockchain for IoT security and privacy: The case study of a smart home[C/OL]//2017 IEEE International Conference on Pervasive Computing and Communications Workshops (PerCom Workshops). Kona, HI: IEEE, 2017: 618–623. DOI:10.1109/PERCOMW.2017.7917634. ↩︎ ","date":"2020-04-03","objectID":"/2020/blockchain-for-d2d-cache-or-computing-offload/:5:3","tags":["科研记录"],"title":"研究记录12-区块链与D2D内容缓存/计算卸载方向探索","uri":"/2020/blockchain-for-d2d-cache-or-computing-offload/"},{"categories":["爱编程爱技术的孩子"],"content":"排序算法分为内部排序（待排序记录存放在内存中进行的排序过程）和外部排序（由于待排序记录数量大，以致内存一次不能容纳全部记录，在排序过程中需要对外存进行访问）。我们一般提到的基本都属于内部排序，一共可以分为5大类、8小类，如下 插入排序：直接插入排序、希尔排序 选择排序：简单选择排序、堆排序 交换排序：冒泡排序、快速排序 归并排序 基数排序 这篇文章对这 8 类排序算法进行详细说明，不过在此之前，先介绍排序稳定性的概念，因为时间复杂度、空间复杂度和排序稳定性是排序算法的三个重要度量。 排序稳定性其实就是相同的两个数在排序前后的先后位置是否发生了变化，具体的数学定义如下 假设 $r_i = r_j(1 \\le i \\le n, 1 \\le j \\le n, i \\ne j)$，且在排序前的序列中 $r_i$ 领先于 $r_j$ （即 $i \\le j$）。如果排序后 $r_i$ 仍领先于 $r_j$ ，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 $r_j$ 领先于 $r_i$，则称所用的排序方法是不稳定的。 注意，下面我们所有的讨论都是基于递增排序的 ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:0:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 直接插入排序 核心思想是：将序列的第一个记录看成是一个有序的子序列，然后从第二个记录开始逐个进行插入，直至整个序列有序为止。 可以使用两层循环实现，第一层循环遍历所有待比较数组元素，第二层循环将本轮选择的元素与已经排好序的元素进行比较。程序如下 func InsertSort(nums []int) []int { var i, j, tmp int // tmp用来临时存储本轮待比较元素 for i = 1; i \u003c len(nums); i++ { tmp = nums[i] // 临时存储本轮待比较元素 for j = i; j \u003e 0 \u0026\u0026 tmp \u003c nums[j-1]; j-- { nums[j] = nums[j-1] // 数组元素后移 } nums[j] = tmp // 在正确的位置插入元素 } return nums } 时间复杂度为$O(N^2)$，最好情况，也就是待排序数组有序情况下，时间复杂度为$O(N)$，即单纯的遍历一遍。 空间复杂度为$O(1)$。 直接插入排序是稳定的。 ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:1:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 希尔排序 核心思想是：先将整个待排序记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行直接插入排序。实现步骤如下： 按照增量分成子序列 对子序列进行排序（直接插入） 缩小增量，重复以上步骤，直到增量为1 增量选取待排序序列长度的一半，然后每次取当前增量的一半。 程序实现如下 func ShellSort(nums []int) []int { var i, j int // dk为增量，初始为待排序数组长度的一半，然后每轮循环减半 for dk := len(nums) / 2; dk \u003e 0; dk /= 2 { // 内层循环是间隔为dk的插入排序 for i = dk; i \u003c len(nums); i++ { tmp := nums[i] for j = i; j \u003e= dk \u0026\u0026 tmp \u003c nums[j-dk]; j -= dk { nums[j] = nums[j-dk] } nums[j] = tmp } } return nums } 希尔排序是不稳定的，其空间复杂度为$O(1)$，最好情况时间复杂度为$O(N)$，最坏情况为$O(N^2)$ 但这是我们按折半方式选取增量时得到的结果，这种情况下，因为增量不互质，小增量很可能不起作用，某些循环的插入排序没有意义。我们可以通过选择较好的增量序列来优化算法，有两个有名的增量序列是 Hibbard增量序列：$dk = 2^k -1$，该增量序列最坏情况的时间复杂度为$O(N^{3/2})$，理论上平均时间复杂度为 $T_avg = O(N^{5/4})$ Sedgewick增量序列：${1,5,19,41,109,……}$，计算公式为 $9 \\times 4^i - 8 \\times 2^i + 1$ 或 $4^i - 3 \\times 2^i +1$。理论上其时间复杂度为 $T_avg = O(N^{7/6}), T_worst = O(N^{4/3})$ 一般没有特别说明的情况下，增量序列可以选择… 3, 2, 1 或… 5, 3, 2, 1 这样从1开始的已知质数序列。程序实现时可以定义一个增量序列数组，然后遍历其内容。不过最常使用的依然是按折半方式选取的增量。 ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:2:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 简单选择排序 核心思想是：在要排序的一组数中，选出最小（或者最大）的一个数与第一个位置的数进行交换，然后在剩下的数中再找最小（或者最大）的与第二个位置的数交换，依次类推，直至第 n-1 个元素（倒数第二个数）与第 n 个元素 (最后一个数) 比较为止。 程序实现如下 func SelectionSort(nums []int) []int { var min int for i := 0; i \u003c len(nums)-1; i++ { min = i for j := i + 1; j \u003c len(nums); j++ { if nums[j] \u003c nums[min] { min = j } } if min != i { nums[i], nums[min] = nums[min], nums[i] } } return nums } 选择排序是不稳定的，空间复杂度是$O(1)$，时间复杂度为$O(N^2)$ ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:3:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 堆排序 我们知道一个堆的根元素永远是最小值（小顶堆）或最大值（大顶堆），所以堆排序的核心思想是：首先将传入的所有元素构造成堆，然后每次取出根元素加入新的数组，最后对堆进行调整。直到新的元素都被取出后，新的数组就是原来数组的有序序列。 程序代码： // 堆排序 func HeapSort(nums []int) []int { result := []int{} // 初始化堆 for i := (len(nums) - 1) / 2; i \u003e= 1; i-- { nums = heapAdjust(nums, i) } //每次取出根元素并重新调整堆 for len(nums)-1 != 0 { t := len(nums) - 1 nums[1], nums[t] = nums[t], nums[1] result = append([]int{nums[t]}, result...) nums = nums[:t] nums = heapAdjust(nums, 1) } return result } // 堆调整函数，调整数组使其符合堆的要求 func heapAdjust(nums []int, start int) []int { var parent, child int for parent = start; parent*2 \u003c len(nums); parent = child { child = parent * 2 if child+1 \u003c len(nums) \u0026\u0026 nums[child+1] \u003e nums[child] { child++ } if nums[child] \u003c= nums[parent] { continue } nums[child], nums[parent] = nums[parent], nums[child] } return nums } 堆排序是不稳定的，空间复杂度是 $O(1)$，时间复杂度是 $O（nlog_2n）$（注：一次堆调整的时间复杂度是 $O（log_2n）$） ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:4:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 冒泡排序 核心思想是：在要排序的一组数中，自上而下的对相邻的两个数依次进行比较和调整，较大的数往下沉，较小的数往上冒。 冒泡是最简单的排序，代码实现如下 func BubbleSort(nums []int) []int { for i := len(nums) - 1; i \u003e 0; i-- { for j := 0; j \u003c i; j++ { if nums[j] \u003e nums[j+1] { nums[j], nums[j+1] = nums[j+1], nums[j] } } } return nums } 冒泡是稳定的排序算法，空间复杂度是$O(1)$，最好情况下时间复杂度是$O(N)$，最坏情况下时间复杂度是$O(N^2)$。 上面的算法即使数组中途已经有序，也会一遍又一遍的判断，通过加入一个标志字段，可以节省一部分时间。 func BubbleSort(nums []int) []int { for i := len(nums) - 1; i \u003e 0; i-- { var flag bool for j := 0; j \u003c i; j++ { if nums[j] \u003e nums[j+1] { nums[j], nums[j+1] = nums[j+1], nums[j] flag = true } } if !flag { //如果当前数组已有序，跳出循环 break } } return nums } ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:5:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 快速排序 快排递归方法的核心思想是： 先在待排序的记录中选择一个数（通常是第一个数或者最后一个数）作为基准，设立两个指向标记，分别指向第一个元素和最后一个元素，然后进行第一趟划分，若最后一个数大于或等于基准值，则使指向最后一个数的指向标记向前移动；若最后一个数小于基准值，则将最后一个数与第一个数进行交换，此时将指向第一个数的指向标记向前移动。则第一趟得到的记录刚好以基准值为分界线，以上述同样的方法再对分界线两边的部分进行排序, 基准值就等于说找到了最终位置。 非递归方法的核心思想是：利用栈来存储两个指向标记的值，其它与递归的快速排序不相上下。 递归程序代码如下 /* 快速排序的递归解法, low 是第一个指向标记，high 是第二个指向标记。 初始参数传入时，low和high应该为第一个元素和最后一个元素 */ func QuickSort(nums []int, low, high int) []int { if low \u003c high { pivot := nums[low] i, j := low, high for i \u003c j { for ; i \u003c j \u0026\u0026 nums[j] \u003e= pivot; j-- { } nums[i], nums[j] = nums[j], nums[i] for ; i \u003c j \u0026\u0026 nums[i] \u003c= pivot; i++ { } nums[j], nums[i] = nums[i], nums[j] } nums[i] = pivot nums = QuickSort(nums, low, i-1) nums = QuickSort(nums, i+1, high) } return nums } 快速排序不稳定，平均情况下，时间复杂度为 $ O(nlogn) $，传入数组本身有序是最坏情况，时间复杂度为$O(n^2)$，空间复杂度（考虑递归调用的最大深度）在平均情况下为$O(logn)$，在最坏情况下为$O(n)$ ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:6:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"7. 归并排序 核心思想是：将两个（或者两个以上）的有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列都是有序的。然后再把有序子序列合并为整体有序序列，两个子序列归并时，准备两个指针从两个子序列从头扫描到尾，将扫描到的元素按序插入结果数组。 两个子序列归并的代码如下 // 归并两个子序列 func merge(left, right []int) []int { result := make([]int, 0) m, n := 0, 0 for m \u003c len(left) \u0026\u0026 n \u003c len(right) { if left[m] \u003e right[n] { result = append(result, right[n]) n++ } else { result = append(result, left[m]) m++ } } result = append(append(result, left[m:]...), right[n:]...) return result } 归并排序的递归程序代码如下 func MergeSort(nums []int) []int { if len(nums) \u003c 2 { return nums } i := len(nums) / 2 left := MergeSort(nums[:i]) right := MergeSort(nums[i:]) result := merge(left, right) return result } 归并排序的非递归程序如下 func MergeSort(nums []int) []int { for i := 1; i \u003c= len(nums); i *= 2 { var j int for ; j \u003c= len(nums)-2*i; j += 2 * i { result := merge(nums[j:i+j], nums[i+j:i*2+j]) copy(nums[j:i*2+j], result) } if i+j \u003c len(nums) { copy(nums[j:], merge(nums[j:i+j], nums[i+j:])) } } return nums } 归并排序是稳定的，时间复杂度为$O（nlogn）$，空间复杂度为$O(n)$ ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:7:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"8. 基数排序 以上的排序都是基于大小比较的，这种思路下的最坏时间复杂度的下界是$O(nlogn)$，想要更快，可以在比较大小的同时做一些其它的事情，这就是基数排序。 基数排序是基于桶排序的，假设我们有 N 个数字，每个整数的值在 0到99之间（于是有 M=100 个不同的值），线性时间内对它们进行排序的方法是：建立一个长度为100的数组，每个数组的值是一个指向链表的指针，遍历所有数字，将与数组下标相同的值添加到该数组元素对应的链表中，最后按下标从小到大输出所有非空的数组元素对应的链表。每个数组元素可以看作一个桶，桶里装着所有相同的值，这样排序的时间复杂度是$O(M+N)$ 依然假设我们有 N=10 个整数，每个整数的值在0到999之间（于是有 M=1000个不同的值），如果使用同样的方法构造数组，则数组太大，这里使用的办法就是基数排序了。对于序列：64，8，216，512，27，729，0，1，343，125，首先建立长度为10的数组（这里的10就是基数），然后按照个位数字将数据放入与数组下标相同的桶，这是第一趟排序，也就是下图 Pass 1（第2行）行，此时所有元素个位有序；第二趟排序按十位数入桶，对应第3行到第5行，此时得到的序列是：0，1，8，512，216，125，27，729，343，64；最后一趟排序按百位数入桶，对应第6行到最后一行，最终得到序列0，1，8，27，64，125，216，343，512，729，此时得到的序列就是有序的。关键字就是每一位的数字，顺序是从个位到百位，这叫做低位优先。 基数排序是稳定的，时间复杂度为$O(d(n+rd)$，d 代表关键字长度，上例为3（每个数字最多3位），n 代表要排序的数的总数，上例为10，rd代表关键字基数，上例为10（0~9 共10种情况）。空间复杂度为$O(n)$ 基数排序不仅用于数字的排序，也用于多关键字的排序，以扑克牌为例，有花色和面值两种关键字，排序如下 注意这里提到用了「主位优先」，在数字排序的例子里含义其实就是高位优先，与我们之前使用的低位优先正好相反。这里如果使用低位优先（也叫做次位优先），就是按面值建立桶。 ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:8:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"9. 排序算法比较 所有排序算法时间, 空间复杂度汇总 排序方法 最好时间 平均时间 最坏时间 辅助空间 稳定性 直接插入 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n)$ $O(n^{1.3})$ $O(n^2)$ $O(1)$ 不稳定 简单选择 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(logn)$ 不稳定 冒泡排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 基数排序 $O(d(r+n))$ $O(d(r+n))$ $O(d(r+n))$ $O(rd + n)$ 稳定 对于链表来说，可执行的排序包括直接插入、简单选择、快排、冒泡、和归并。 ","date":"2020-04-02","objectID":"/2020/algorithm-sort/:9:0","tags":["数据结构与算法"],"title":"算法-排序","uri":"/2020/algorithm-sort/"},{"categories":["爱编程爱技术的孩子"],"content":"搜索是最常用的算法之一，但线性的搜索进行介绍没有太大的意义，本文介绍搜索中一种广为使用的方法：二分查找。 ","date":"2020-03-29","objectID":"/2020/algorithm-search/:0:0","tags":["数据结构与算法"],"title":"算法-搜索","uri":"/2020/algorithm-search/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 原始问题 标准的二分查找问题描述为：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。二分查找程序如下 func search(nums []int, target int) int { if nums == nil { return -1 } l,r := 0, len(nums)-1 for l \u003c= r { mid := (l + r)/2 if nums[mid] == target { return mid }else if nums[mid] \u003c target { l = mid+1 }else{ r = mid-1 } } return -1 } 可以看出，二分查找是一种在每次比较后将查找空间一分为二的算法，每次需要查找集合中的索引或元素时，都应考虑二分查找。二分查找的前提条件是集合有序，因此在无序情况下需要先对集合进行排序。一个二分查找过程总结如下 预处理：如果集合无序，进行排序 二分查找：使用循环或递归在每次比较后将查找空间划分为两半 后处理：在剩余空间中确定可行的候选者 ","date":"2020-03-29","objectID":"/2020/algorithm-search/:1:0","tags":["数据结构与算法"],"title":"算法-搜索","uri":"/2020/algorithm-search/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 进阶 进阶的二分查找问题一般与当前元素的左右邻居有关。 我们以「第一个错误的版本」题目为例，解释这种情况，题目描述如下 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -\u003e false 调用 isBadVersion(5) -\u003e true 调用 isBadVersion(4) -\u003e true 所以，4 是第一个错误的版本。 线性扫描的思路很简单，但时间复杂度是 $O(n)$，二分查找是一种自然而然想到的办法，但实际的编程过程可能有一些问题。 我们将二分过程分为两个场景。场景一中，isBadVersion(mid) 返回 false，说明 mid 左侧（包括自身）所有版本都是正确的，因此令 left = mid + 1 场景一：isBadVersion(mid) =\u003e false 1 2 3 4 5 6 7 8 9 G G G G G G B B B G = 正确版本，B = 错误版本 | | | left mid right 场景二中，isBadVersion(mid) 返回 true，说明 mid 右侧版本都不是第一个错误的版本，但不确定 mid 自身是不是第一个错误的版本，因此令 right = mid 场景二：isBadVersion(mid) =\u003e true 1 2 3 4 5 6 7 8 9 G G G B B B B B B G = 正确版本，B = 错误版本 | | | left mid right 初始的条件设定是 left = 1, right = n，然后我们来讨论 for 循环结束条件的设定。 首先我们知道，由于 left 和 right 不断接近，最后一定能到达 left + 1 = right 的情况，由于 right 指向的一定是 false，所以可能有两种情况 情况一： G B G B | | —\u003e | left right left,right 情况二： B B B B | | —\u003e | left right left,right 此时 mid = (left + right)/2，由数学知识我们知道 mid == left，如果是情况一，left = mid + 1，也就是会等于 right，如果是情况二，right = mid，也就是会等于left。其实此时我们已经可以确定第一个错误版本，两种情况下，错误版本都是 left 或 right 指向的值，所以在 left == right 的时候就可以跳出循环了。最终的程序如下 func firstBadVersion(n int) int { left,right := 1,n for left \u003c right { mid := (left + right) / 2 if isBadVersion(mid) { right = mid }else{ left = mid + 1 } } return left } 那么，如果循环条件是 left \u003c= right 会发生什么呢，此时恒定为以下情况，循环体内 right = mid，并没有变，所以就陷入了无限循环。 B | left,mid,right 所以遇到 mid 和 左右邻居相关的情况时，采用上面这种思路来进行分析。 还有一些其它的情况，我们通常需要在查找完成后进行一些后处理。 ","date":"2020-03-29","objectID":"/2020/algorithm-search/:2:0","tags":["数据结构与算法"],"title":"算法-搜索","uri":"/2020/algorithm-search/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 总结 正所谓二分查找思路很简单，细节是魔鬼，大多数区别之处在于 mid 究竟是 +1 还是 -1，for 循环究竟是 \u003c 还是 \u003c=，要仔细地区分，还是要在练习中不断体会。 因为二分查找是不断折半的，其实就相当于对一棵二叉树的查找，其时间复杂度为 $O(logn)$ 同时，二分查找除了维持前后索引和中间索引三个值，不需要其它空间，因此空间复杂度为 $O(1)$ ","date":"2020-03-29","objectID":"/2020/algorithm-search/:3:0","tags":["数据结构与算法"],"title":"算法-搜索","uri":"/2020/algorithm-search/"},{"categories":["爱编程爱技术的孩子"],"content":"数组的访问时间为 $O(1)$，这是它最大的优势，但限于数组固定的大小，平常使用最多的是动态数组。在 Golang 中，其实就是[切片]^(slice)，动态数组的初始化、访问、修改、迭代、添加、删除等都是 Golang 语法的内容，这里不再介绍。事实上，一维数组的大部分问题都很好解决，我们在本文中仅介绍二维数组的一些典型问题，更多维的数组思路是相似，而且由于其复杂性，实际上很少出现。 ","date":"2020-03-20","objectID":"/2020/algorithm-array/:0:0","tags":["数据结构与算法"],"title":"算法-数组类问题","uri":"/2020/algorithm-array/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 方向转换 下面是一个叫做「对角线遍历」的例子，在这个例子中，我们可以理解如何在二维数组中转换前进方向，这是一个很有用的技巧。 螺旋矩阵是指一个呈螺旋状的矩阵，它的数字由第一行开始到右边不断变大，向下变大，向左变大，向上变大，如此循环。给定m和n，返回一个大小为m*n的螺旋矩阵 示例： input: 3 3 Output: 1 2 3 8 9 4 7 6 5 思路： 每一步走完，判断是否超出矩阵范围，若超出，计算向哪个方向转，无论是否转向，计算下一步所在位置的x,y坐标 螺旋矩阵的转向顺序是固定的，为右-\u003e下-\u003e左-\u003e上 代码： func spiralArray(m, n int) { var result [][]int for i := 0; i \u003c m; i++ { result = append(result, make([]int, n)) } //x,y为当前坐标，d为方向 x, y, d := 0, 0, 0 //以“右-\u003e下-\u003e左-\u003e上”顺序循环，dx,dy是每一种转向的坐标变化方式 dx := []int{0, 1, 0, -1} dy := []int{1, 0, -1, 0} for t := 0; t \u003c m*n; t++ { result[x][y] = t nx, ny := x+dx[d], y+dy[d] //计算下一个坐标 if nx \u003c 0 || nx \u003e= m || ny \u003c 0 || ny \u003e= n || result[nx][ny] != 0 { d = (d + 1) % 4 //下一个坐标有问题，采用下一种转向方式 nx = x + dx[d] ny = y + dy[d] } x = nx y = ny } w := bufio.NewWriter(os.Stdout) for i := 0; i \u003c m; i++ { for j := 0; j \u003c n; j++ { w.WriteString(fmt.Sprintf(\"%d\", result[i][j])) if j != n-1 { w.WriteString(fmt.Sprintf(\" \")) } } w.WriteString(fmt.Sprintf(\"\\n\")) } w.Flush() } ","date":"2020-03-20","objectID":"/2020/algorithm-array/:1:0","tags":["数据结构与算法"],"title":"算法-数组类问题","uri":"/2020/algorithm-array/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 对撞指针 对撞指针是数组类问题另一个常用的技巧，其含义是：将指针 i 和 j 分别指向数组第一个元素和最后一个元素，然后指针 i 不断向前，指针 j 不断递减，直到 i == j（终止条件是可以根据题目变化的）。 下面我们以两数之和为例给出一个对撞指针使用的示范。题目描述如下： 给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明： - 返回的下标值（index1 和 index2）不是从零开始的。 - 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素 示例 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 普通的办法需要两层循环，时间复杂度是$O(n^2)$，利用对撞指针，我们可以将复杂度降低到 $O(n)$ func twoSum(numbers []int, target int) []int { i,j := 0,len(numbers)-1 for i \u003c j { if numbers[i] + numbers[j] \u003e target { j-- }else if numbers[i] + numbers[j] \u003c target { i++ }else{ return []int{i+1,j+1} } } return nil } ","date":"2020-03-20","objectID":"/2020/algorithm-array/:2:0","tags":["数据结构与算法"],"title":"算法-数组类问题","uri":"/2020/algorithm-array/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 滑动窗口 对撞指针是两个指针向中间靠拢，滑动窗口是两个指针向同一侧移动，如果还记得计算机网络的内容，这里就非常容易理解。滑动窗口同样可以将时间复杂度控制在 $O(n)$ 级别。 我们以「长度最小的子数组」为例给出一个滑动窗口解题的例子，题目描述如下 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例 输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 暴力法的复杂度显然是 $O(n^2)$，我们尝试用滑动窗口求解 func minSubArrayLen(s int, nums []int) int { n := len(nums) i,j := 0,0 sum := 0 min := n+1 for i \u003c n { if j \u003c n \u0026\u0026 sum \u003c s { sum += nums[j] j++ }else{ sum -= nums[i] i++ } if sum \u003e= s \u0026\u0026 j-i \u003c min { min = j-i } } if min == n+1 { return 0 } return min } 滑动窗口最重要的是确定何时移动两个指针，当然，边界和初始值也非常重要。 当然，总体来看的话，其实后面两种方法都属于双指针的技巧。 ","date":"2020-03-20","objectID":"/2020/algorithm-array/:3:0","tags":["数据结构与算法"],"title":"算法-数组类问题","uri":"/2020/algorithm-array/"},{"categories":["平日里的白日梦"],"content":"记录一些触动人心的句子 1、一寸山河一寸血，十万青年十万军 2、因为不知道下辈子还能不能遇到，所以这辈子拼命给你温暖给你拥抱 3、人有贫富，但无贵贱 4、人生最可怕的事在于：每个人都有他的理由 5、我们都知道，如果可以回到过去，改变任何一件小事情，都将极大地改变未来。然而，几乎没有人想到，今天只要小小改变，就会改变自己的未来。 6、我口袋里有一个小设备，可以访问几乎全部的人类知识。我却用它与不认识的人进行毫无意义的争论，并看猫的照片。 7、年轻的时候就应该不去想那么多，想得越多，遗憾越多。 8、这世上，唯有感情在冲动的时候没有错。 9、按时长大，平安喜乐。 10、所谓的意义只是智慧生命为了体现自身价值而设定的一个概念，是生命活着的一种体现，既然没有外物赋予自身意义，那么为什么不可以给自己下一个有意义的定义呢？ 11、只是希望，能有一个可以在身边。两个人的生活圈子，是有着重叠的地方的，一个人生病了的时候，另外一个人就可以立马过来照顾。不需要心急如焚的，等待着去购买车票。哪怕是夜深了，也能够一起约出来，在附近的街道上吃着宵夜。哪怕是下雨了，忘记带伞也能够让对方，很快的就是给你送来一把雨伞。哪怕是下雪了，你也能够拍摄照片，和对方一起分享下雪时候的快乐，一起约好了去打雪仗堆雪人，而不是只能在朋友圈里对着照片点赞留言。这终究，缺少了现实接触的温度。每一句话，每一个呼吸，每一次心跳，都是幸福的味道。 12、「社交媒体是一种精心策划、过滤、经常修饰，有时甚至是一种生活方式的错觉。」 这句话出自于TED演讲：《为什么你要放弃追求完美》，非常有感触。随着社交媒体的兴起，每时每刻都有大量的事情可以伤害我们的自尊，而社交媒体是一种精心策划、过滤、经常修饰的，有时甚至是对生活方式的错觉，经过修饰的照片，拉长的美腿，以至于我们觉得自己怎么缺陷那么多！为什么我不够瘦！而,当你放弃追求完美的时候，你才会看到自己的成长。 13、「当斧头来到森林里的时候，好多树都说，至少他的把手，是我们自己人。」 含义和波士顿犹太人屠杀纪念碑一脉相承，非常有哲理。 14、我生怕自己本非美玉，故而不敢加以刻苦琢磨，却又半信自己是块美玉，故又不肯庸庸碌碌，与瓦砾为伍。于是我渐渐地脱离凡尘，疏远世人，结果便是一任愤懑与羞恨日益助长内心那怯弱的自尊心。——《山月记》 15、怕什么真理无穷，进一步有进一步的欢喜。 16、君子使物，不为物使。 ——《管子》 17、人们只愿意看到他们想要看到的。——电影《我是谁》 18、所有人都拥有一样的时间，如果你没有花在这里，那么你一定花在了其它地方。——2020年牛客跟谁学在线宣讲 ","date":"2020-03-20","objectID":"/2020/%E8%A7%A6%E5%8A%A8%E4%BA%BA%E5%BF%83%E7%9A%84%E5%8F%A5%E5%AD%90/:0:0","tags":["文摘"],"title":"触动人心的句子","uri":"/2020/%E8%A7%A6%E5%8A%A8%E4%BA%BA%E5%BF%83%E7%9A%84%E5%8F%A5%E5%AD%90/"},{"categories":["爱编程爱技术的孩子"],"content":"并查集是一种特别而实用的结构，主要作用是进行不相交集合的合并和判断两个元素是否在同一集合，时间复杂度为常数级。常见用途包括 Kruskal 算法和求最近公共祖先，本篇文章介绍该数据结构。 并查集的基本操作为3个，包括初始化、查找与合并 ","date":"2020-03-18","objectID":"/2020/data-structure-union-find-set/:0:0","tags":["数据结构与算法"],"title":"数据结构-并查集","uri":"/2020/data-structure-union-find-set/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 初始化 并查集的初始化是将每个元素所作集合初始化为其自身，对数组就是将集合号（元素值）设置为自身编号 func Init(int n) []int { father := make([]int,n) for i := 0; i \u003c n; i++ { father[i] = i } } 对链表则是令指针指向自己 ","date":"2020-03-18","objectID":"/2020/data-structure-union-find-set/:1:0","tags":["数据结构与算法"],"title":"数据结构-并查集","uri":"/2020/data-structure-union-find-set/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 查找 查找就是不断沿着父节点向上，直到根结点，为了将复杂度限制在常数级，可以令查找路径上每个节点都直接指向根结点 // 递归 func Find(x int) int { if x != father[x] { father[x] = Find(father[x]) } return father[x] } // 非递归 func Find(x int) { p := x for father[p] != p { p = father[p] } for x != p { t := father[x] father[x] = p x = t } return x } 最后的效果如下 ","date":"2020-03-18","objectID":"/2020/data-structure-union-find-set/:2:0","tags":["数据结构与算法"],"title":"数据结构-并查集","uri":"/2020/data-structure-union-find-set/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 合并 合并的操作也非常简单，就是让一个集合的树根指向另一个集合的树根 func Merge(a,b int) int { p,q := Find(a),Find(b) if p == q { return 0 }else if p \u003e q { father[p] = q }else{ father[q] = p } return 1 } ","date":"2020-03-18","objectID":"/2020/data-structure-union-find-set/:3:0","tags":["数据结构与算法"],"title":"数据结构-并查集","uri":"/2020/data-structure-union-find-set/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 复杂度 如果有n个节点、e条边（关系），每一条边（u, v）进行集合合并时，都要查找u和v的祖宗，查找的路径从当前节点一直到根节点。n个节点组成的树，平均情况下树的高度为logn，因此并查集中，合并集合的时间复杂度为O(elogn)。 ","date":"2020-03-18","objectID":"/2020/data-structure-union-find-set/:4:0","tags":["数据结构与算法"],"title":"数据结构-并查集","uri":"/2020/data-structure-union-find-set/"},{"categories":["爱编程爱技术的孩子"],"content":"本篇介绍B树（B-树），B+树和红黑树，参考自陈小玉，《趣学数据结构》。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:0:0","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1. B树 二叉搜索树可以将搜索效率提高到 $O(H)$，H 为树高，如果使其平衡，那么搜索效率可以进一步限制到 $O(log n)$，B树是一种在此基础上继续提高搜索效率的方法。 B树的思路是在每个节点不限于存储一个关键字，并保持它二叉搜索树的特性和平衡性，这样可以进一步降低树高，从而提高搜索效率。这样的一棵树就称为多路平衡搜索树，如下图所示。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:1:0","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 定义 B树，也叫做B-树，多路平衡二叉树。一棵 m 阶的 B 树，或者为空树，或者满足如下性质 每个节点最多有 m 棵子树； 根节点至少有两颗子树； 内部节点（除根和叶子之外的节点）至少有 $\\ulcorner m/2 \\urcorner$（向上取整）棵子树； 终端节点（叶子）在同一层上，并且不带信息（空指针），通常称为失败节点； 非终端节点的关键字个数比子树个数少1； 所以上面的图其实少了一层空指针叶子节点，一个完整的3阶B树例子如下图所示。根据定义，内部节点的子树个数为 2~3，所以每个节点可能有 1~2 个关键字，2~3棵子树，所有空指针叶子节点都在最后一层，该树又称为2-3树（因为子树个数范围为 2~3）。 B 树中所有叶子节点都在最后一层，所以是平衡的，B树同样遵循中序有序的特性，且每个节点可以有多个分支。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:1:1","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 树高与性能 要知道B树的性能，就要知道它的树高，m阶B树的树高计算方法如下。 首先，根结点至少有两棵子树，那么第二层至少有2个节点，所有内部节点至少有 $\\ulcorner m/2 \\urcorner$（向上取整）棵子树，那么第三层至少有 $2\\ulcorner m/2 \\urcorner$ 个节点……依此类推，第 h+1 层至少有 $2\\ulcorner m/2 \\urcorner^{h-1}$ 个节点，也就是叶子节点的个数，注意这里叶子节点为查找失败的空指针 假设该树含有 n 个关键字，查找失败的可能性有 n+1 种（每个间隔），空指针叶子节点的含义就是查找失败，因此空指针叶子节点的数目应小于等于查找失败的可能性，公式表达和推导如下 $$ n+1 \\ge 2\\ulcorner m/2 \\urcorner^{h-1} \\ log_{\\ulcorner m/2 \\urcorner}{\\frac{n+1}2} \\ge h-1 \\ h \\le log_{\\ulcorner m/2 \\urcorner}{\\frac{n+1}2} + 1 = O(log_mn) $$ 所以一棵含有 n 个关键字的 m 阶 B 树的最大高度为 $O(log_mn)$。对于对数函数来说，m 越大，越靠近 x 轴，所以值就越小，时间复杂度就越低。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:1:2","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 查找 B树通常用于大规模数据的分级存储搜索，就是将内存的「高速度」和外存的「大容量」结合起来，从而提高搜索效率。其原理是这样的，当数据规模较大时，无法全部放入内存进行搜索，就需要频繁访问外存，因为外存的访问速度通常比内存要慢好几个数量级，搜索的效率就会大幅降低。 由于外存访问时，访问一个数据和访问一段连续存储的数据时间差别不大，B树将多个关键词包含在一个节点中，一次读入内存比多次访问不同的关键字就会节省很多时间。一个节点中的多个关键词同时读入内存后，再利用顺序或折半查找等方式进行搜索。 仍以下面这张图为例，查找数字80。 首先将根结点65读入内存，与80比较，80\u003e65，进入根结点的第二个子树； 当前节点不是空指针叶子节点，将75和90一次读入内存，80\u003e75，80\u003c90，进入当前节点的第二个子树； 当前节点仍不是空指针叶子节点，将80读入内存，80=80，查找成功。 注意，在任何时刻，通常只有当前节点在内存，其它节点都在外存，需要时才会调入内存。 B树的查找时间包括将节点从外存调入内存和在内存中当前节点进行查找两个过程，由于内存操作与外存访问时间差距比较大，我们可以只考虑外存访问操作，整个过程外存最多走一条根结点到叶子节点的路径，因此时间复杂度就是树高 $O(log_mn)$，其中 n 为关键字个数，m 为树的阶数。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:1:3","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 插入 插入的前置操作是查找，如果查找成功，那么不进行插入，如果查找失败，则将关键字插入到失败节点的双亲节点中。例如，在上面的3阶B数种插入59，应该放在58和60中间。 这里要考虑到每个节点的关键字个数有个上限 m-1，插入关键字后如果仍满足该条件，插入成功，如果超过了该上限到了m，那么发生了上溢，需要采取一定的办法解除上溢，使整棵树重新满足 m 阶B树的条件。 解除上溢的操作叫做分裂，即取当前节点中间的关键字 $k_s, s=m/2$，将其上升到父节点 P，左右两部分作为 $k_s$ 的左右孩子，如下图 如果分裂操作导致父节点同样产生了上溢，则继续分裂操作向上，最远会到达树根，如果树根也发生上溢，那么将树根分裂，根结点的中间关键字分裂成新的树根，此时树的高度加1。 插入操作除了查找插入位置需要 $O(log_mn)$ 时间，如果发生上溢，分裂操作的个数不会超过树高，因此最终的插入操作时间复杂度为 $O(log_mn)$ ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:1:4","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.5 删除 删除操作相似，如果找不到，不进行删除，如果找到了，接下来的操作与二叉搜索树类似。 如果待删除关键字的子树非空，则使用左子树的最大值（直接前驱）或右子树的最小值（直接后继）代替； 如果待删除关键字子树为空，直接删除关键字即可。 与插入相反，删除操作可能出现的问题叫做下溢，因为内部节点至少应有 $\\ulcorner m/2 \\urcorner - 1$ 个关键字，下溢的处理方法有三种：左借，右借和合并。 首先，如果下溢节点 V 的左兄弟至少包含 $\\ulcorner m/2 \\urcorner$ 个关键字，少一个也可以维持条件，因此可以借出，借出的方法是，上溢节点向父节点拿一个关键字，然后父节点再向 V 的左兄弟拿一个关键字。如下图 如果 V 的左兄弟关键字不足 $\\ulcorner m/2 \\urcorner$ 个，无法借出，而右兄弟关键字的个数足够，则从右兄弟借，方法相似，先向父节点拿一个关键字，然后父节点从右兄弟拿一个关键字。 最麻烦的情况是左右兄弟关键字的个数都不够，这时候要做的事情是将父节点的一个关键字下移，然后和左兄弟、当前节点合并，组成新节点，然后删除多余指针，如果左兄弟不存在，就和右兄弟合并。 合并后父节点少了一个关键字，如果不再满足条件，同样用上面的三种方法分情况处理，最远也会到达根，如果根结点也发生下溢，最终会使树高减一。 删除操作的时间复杂度为 $O(log_mn)$ ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:1:5","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2. B+树 B+树是B树的变种，一般用于索引系统。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:2:0","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 定义 B+树的定义如下，一棵m阶B+树，或者为空树，或者满足如下条件 每个节点最多有 m 棵子树； 根节点至少有两颗子树； 内部节点（除根和叶子之外的节点）至少有 $\\ulcorner m/2 \\urcorner$（向上取整）棵子树； 终端节点（叶子）在同一层上，并且不带信息（空指针），通常称为失败节点； 非终端节点的关键字个数与子树个数相同； 倒数第二层节点包含了全部的关键字，节点内部有序且节点间按升序顺序链接； 所有非终端节点只作为索引部分，节点仅含子树中的最大（或最小）关键字； B+树定义的不同之处在于最后3条，一棵 m 阶的B+树，根结点至少有两个关键字，其它非终端节点关键字个数范围为 $[\\ulcorner m/2 \\urcorner，m]$ ，关键字个数等于子树个数，而B树关键字个数比子树少一个。 例如，一棵3阶B+树，其内部节点的子树个数2≤k≤3，关键字个数也是2≤n≤3，如下图所示。一般有两个指针，一个指向树根，一个指向倒数第二层关键字最小的节点。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:2:1","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 查找 B+树支持两种方式的查找，可以利用 t 指针从树根向下索引查找，也可以利用 r 指针从最小关键字向后顺序查找。尽管如此，仍不建议顺序查找，因为其时间复杂度为 O(n)，而索引查找效率要高得多。 若从树根向下查找，则首先在根节点中查找，然后在子树中查找，即使查找成功，也会继续向下，直到最后一层。也就是说，每次查找都要走一条从树根到叶子的路径，时间复杂度为树高$O(log_mn)$。 例如，在一棵3阶B+树中查找70，首先和65比较，70\u003e65；再和98比较，70\u003c98，到98的左分支查找；和70比较，相等，继续到70的左分支查找；和68比较，70\u003e68，继续比较，找到70，查找成功，如下图 B+树不仅支持单个关键字查找，还支持范围查找。例如，查找范围在[a, b]之间的关键字，首先查找a所在的位置，从根到最后一层，查找等于或大于a的关键字。如果找到，则继续在a所在的节点查找；如果未发现大于b的关键字，就可以沿着该节点的最后一个指针查找下一个节点，直到找到一个等于或大于b的关键字停止。 例如，在一棵3阶B+树中查找[60, 80]之间的关键字，首先查找60所在的位置，从根到最后一层，查找等于或大于60的关键字，未找到60，则找到比它大的关键字65；继续在该节点查找，在下下个节点找到了等于80的关键字，查找成功，如下图 可以看到，范围查找是直接在叶子间进行移动的，这是因为所有叶子节点之间有连接，所以事实上，B+树已经不属于树的范围了。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:2:2","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 插入 m阶B+树仅在最后一层节点插入，因为除了最后一层节点，其他非终端节点都表示索引。又因为m阶B+树的关键字个数要求不超过m，如果插入后节点的关键字个数超过m，则发生上溢，需要分裂操作。只不过分裂时，和B-树的分裂不同，上升到父节点的关键字，子节点中仍然保留。 刚刚发生上溢的节点V，插入之前满足条件（关键字个数小于等于m），插入之后大于m，因此V节点现在恰好有m+1个关键字。将该关键字进行分裂操作：取V节点中间的关键字ks（s=m+1/2），将ks上升到其父节点P，左右两部分作为ks的左右孩子，如下图 中间关键字上升到父节点后，需要检查父节点是否发生上溢，如果发生上溢，则继续分裂，一直向上传递，最远到达树根。如果根节点发生上溢，则需要做以下特殊处理。 树根分裂操作需要分裂的两个子节点的最大关键字一起上升，生成一个新的节点作为新树根，此时树高增1，如下图 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:2:3","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 删除 m阶B+树的删除只在最后一层进行，首先通过查找确定待删除关键字的位置，删除之，然后判断该节点是否发生下溢，还要判断是否需要更新父节点的关键字。如果关键字个数小于$\\ulcorner m/2 \\urcorner$，则发生下溢。如果发生下溢，则需要像B-树那样左借、右借或合并以解除下溢。解除下溢时要特别注意父节点中的最大关键字更新。 含有n个关键字的m阶B+树，查找、插入和删除操作的时间复杂度均为树的高度$O(log_mn)$。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:2:4","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 红黑树 AVL 树可以保证在最坏情况下，查找、插入、删除的时间复杂度均为 $O(logn)$，但插入和删除后重新调整平衡可能需要多达 $O(logn)$ 次旋转。红黑树通过放宽平衡条件：左右子树高度差不超过两倍，使任何不平衡都可以在3次旋转以内解决，因此红黑树被广泛应用。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:3:0","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 定义 红黑树（red-black tree）是满足如下性质的二叉搜索树。 每个节点是红色或黑色的； 根结点是黑色的； 每个叶子节点是黑色的（红黑树的叶子节点仍然指的是空指针叶子节点）； 如果一个节点为红色，则其孩子节点必为黑色； 从任一节点到其后代叶子的路径上，均包含相同数目的黑节点。 一棵红黑树示例如下 由于最后两条性质，从任一节点到叶子的路径上，可能都是黑节点，也可能黑节点和红节点交替出现，这就导致了对于任何一个节点，其左右子树的高度差不超过两倍。所以红黑树不是严格的平衡树，这里的平衡条件被放宽了。 从某个节点 x （不包含该节点）到叶子的任意一条路径上黑色节点的个数称为该节点的黑高，红黑树的黑高就是根结点的黑高，如上图，该红黑树的黑高为2。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:3:1","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 树高与性能 红黑树放宽了平衡条件，但是查找、插入、删除的复杂度仍然是 $O(logn)$，证明如下： 假设n个节点的红黑树高度为 h，根到叶子节点至少一半是黑色节点，其黑高为 h/2，一个黑高为 h/2 的二叉树节点数为 $2^{h/2}-1$，剩下的 $n-(2^{h/2}-1)$ 个节点分布在后面 h/2 高的树内，由此得到不等式 $$ n - (2^{h/2}-1) \u003e=0 $$ 推导得到 $n+1 \\ge 2^{h/2}$，两边取对数就可以得到 $h \\le 2log(n+1) = O(logn)$。查找、插入、删除的速度与树高成正比，因此红黑树的这三个操作时间复杂度还是 $O(logn)$。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:3:2","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 查找 红黑树本身是「适度平衡」的二叉搜索树，其查找和二叉搜索树的查找一样。 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:3:3","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 插入 在红黑树中插入 x，首先进行查找，查找成功什么都不做，查找失败在失败位置创建 x 节点，置为红色（如果是树根，则置为黑色）。 如果插入的节点置黑色，可能改变黑高，从而违反最后一条性质，置红色不会，不过可能违反第4条性质（红节点必然有黑孩子）。 将插入分为两种情况 新插入节点 x 的父亲为黑色，满足条件，插入成功； 新插入节点 x 的父亲为红色，出现两个连续的红色，需要调整； 调整的方法是将 x 的父亲和祖父记为 p（parent）、g（grandpa），x 的叔叔记为 u（uncle），红黑树插入节点后调整分两种情况：u 为黑色和u 为红色，下面分别讨论 u 为黑色，如果 g 到 x 的路径为 LL，执行LL型旋转。如下图，将 g 右旋，然后将旋转后的根染黑，两个孩子染红。 而如果 g 到 x 的路径为 LR，执行 LR型旋转。如下图，先将 x 左旋，再将 g 右旋，然后将旋转后的根染黑，其两个孩子染红。 还有两种情况是 RR型和RL型，相似，不再赘述。 u 为红色，可以简单粗暴的将父亲和叔叔染黑，将祖父染红（保持黑高不变，如果祖父为树根，染黑），因为 g 的父亲有可能是红色，将 g 看作新插入的节点，采用同样的方法处理，每处理一次，上升两层，直到树根。 插入的几种方法总结如下 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:3:4","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.5 删除 在红黑树中删除x，首先通过查找，如果查找失败，什么也不做，直接返回。如果查找成功，则需要判断后处理：如果x节点仅有左子树（或右子树），则删除x节点，令其左子树（或右子树）子承父业代替其位置。如果x节点有左子树和右子树，则令x的直接前驱（或直接后继）代替其位置，然后删除其直接前驱（或直接后继）即可。在删除节点的过程中，有可能违反红黑树的性质2、4、5，即根为黑色，红节点必有黑孩子，左右子树黑高相等。简而言之，根为黑、无“双红”、黑高相等。 令r指向实际被删除节点s的接替者，p指向x的父亲。s必有一个孩子为空。 如果实际被删除节点s为红色，直接删除即可；如果s为黑色，则需要根据情况修正，因为黑色节点对黑高有影响，删除一个黑色节点，黑高会减少。 删除分以下3种情况 s 为红色：删除s后，r接替其位置，满足红黑树的条件（根为黑、无“双红”、黑高不变）。根据红黑树的性质，红节点必有黑孩子，s为红色，其两个孩子必为黑色，s的其中一个孩子为空，另一个孩子也必为空，因为左右子树黑高相等 s 为黑色，接替者r为红色：因为s为黑色，删除s后，黑高减少。又因为p为黑色或红色，接替者r为红色，有可能出现“双红”。可以直接将r置为黑色，既维护了黑高（删除一个黑色的s，置r为黑色，黑高不变），又避免了“双红 s为黑色，接替者r为黑色：接替者r为黑色，根据左右子树黑高相同原则，r必为空。因为s为黑色，删除s后，黑高减少。被删除节点及其两个孩子都为黑色，这种情况称为“双黑”。为维护红黑树特性，需要分情况处理。将s的兄弟记为b（brother）, s的父亲仍然为p，分以下4种情况 b 为黑色，b有红孩子。LL路径则右旋，旋转后的根保留原树根颜色，两个孩子染黑，LR、RR、RL相似 b为黑色，b 无红孩子，p为红色。简单粗暴，b、p直接换色 b为黑色，b无红孩子，p为黑色。将 b 直接染成红色，此时等效于p的父节点被删除，继续双黑修正，直到根。 b为红色。这种情况先右旋（LL），b、p换色，转换为第1种或第2种情况继续处理。 所有的删除方法总结如下表 ","date":"2020-03-18","objectID":"/2020/data-structure-b-tree-and-red-black-tree/:3:5","tags":["数据结构与算法"],"title":"数据结构-B树与红黑树","uri":"/2020/data-structure-b-tree-and-red-black-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:0:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 图的定义 用 V(Vertex) 表示顶点的集合，用 E(Edge) 表示边的集合，则图可以看作由一个非空的有限顶点集合 V 和一个有限边的集合 E 组成，记作G(V, E)。其中 边可以表示为顶点对：(v, w) ∈ E，其中 v, w ∈ V 无向边使用小括号包含两个顶点来表示，如上一条所示，有向边可以用 \u003cv, w\u003e 表示 不考虑重边和自回路（这样的图称为简单图，我们只考虑这种图） 一些概念解释如下 概念 解释 弧（Arc） 边的另一种称呼 无向图（Digraph） 图中所有的边没有特定的指向 有向图（Undigraph） 图中所有的边是有向的 完全图 任意两个顶点间都有边相连 权（Weight） 与图的边有关的数，可能表示顶点的距离或花费 顶点的度（Degree) 对无向图，顶点所连接的边的数量 顶点的入度（Indegree） 对有向图，指向顶点的边的数量 顶点的出度（Outdegree） 对有向图，从顶点出发的边的数量 路径（Path） 从一个顶点到另一个顶点的顶点序列 路径长度 路径上边的数目 连通图 从一个顶点开始，可以到达图中任意一个其它顶点 非连通图 图中存在不可达的顶点 连通分量 对非连通图，它的极大连通子图称为连通分量 网 带权的连通图 关于图的操作集有很多，但最基本的如下 Create()：建立并返回空图 InsertVertex(Graph G, Vertex V)：将顶点 V 插入图 G InsertEdge(Graph G, Edge E)：将边 E 插入图 G DFS(Graph G, Vertex V)：从顶点 V 出发深度优先遍历图 G BFS(Graph G, Vertex V)：从顶点 V 出发广度优先遍历图 G ShortestPath(Graph G, Vertex V, int Dist[])：计算图 G 中顶点 V 到任意其它顶点的最短路径 MST(Graph G)：计算图的最小生成树 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:1:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 图的表示 图的表示有很多种方法，包括邻接矩阵、邻接表、十字链表和多重邻接表，最常用的是邻接矩阵和邻接表。 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:2:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 邻接矩阵 通过邻接矩阵$G[N] [N]$表示图，首先将 N 个顶点从0到 N-1 编号，然后按如下公式填入数值。即如果两个顶点有边连接，填入1，如果没有边，则填入 0 $$ G[N][N] = \\begin{cases} 1\u0026 若\u003cv_i,v_j\u003e是G中的边 \\\\ 0\u0026 否则 \\end{cases} $$ 下面是一个无向图的邻接矩阵表示 实际编程时，通常使用二维数组的形式存储。对于无向图而言，邻接矩阵是对称的，因此通过只存储下三角矩阵或上三角矩阵的形式，可以节省一半的存储空间（矩阵压缩）。无向图的度是对应行（或列）非0元素的个数。 对于有向图来讲，邻接矩阵并不是对称的，因此不能采用这种方式。有向图对应行非0元素的个数是「出度」，对应列非0元素的个数是「入读」。 以上我们谈到的都是无权图，如果是有权图，如果两个顶点有边连接，填入边的权值，如果没有边连接，为$\\infty$ 如果是稠密图（边很多），使用邻接矩阵比较合适。如果是稀疏图（点很多而边很少），存在大量的无效元素，使用邻接矩阵会浪费大量的存储空间。 邻接矩阵结构可以定义为 type Graph struct { VNum,ENUM int // 顶点和边的个数 Vertex []int // 每个顶点的值 AdjMatrix [][]int // 邻接矩阵 } ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:2:1","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 邻接表 邻接表适用于稀疏图的情况。将所有顶点用一个指针数组$G[N]$表示，每个元素表示一个节点，其值指向该顶点所有相邻顶点构成的链表（顺序不重要，可以随意），一个有向图的邻接表示例如下 邻接表结构可以定义为 type ENode struct { V int //顶点编号 Weight int //边的权重(可选，无权图没有这个值) NextEdge *ENode //指向下一个邻接点 } type VNode struct { data int //顶点信息 FirstEdge *Enode //指向第一个邻接点 } type Graph struct { VNum,ENum int //顶点和边的个数 AdjList []VNode //存顶点 } 邻接表方便寻找任一顶点的所有邻接点，可以节省存储空间，但对有向图无法计算顶点的出度，需要构造「逆邻接表」，上面有向图的逆邻接表如下 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:2:2","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 十字链表 十字链表可以看作将图的邻接表和逆邻接表结合的产物。和邻接表相同，图的顶点信息存在顶点数组中，数组元素有三个域：data域，存放与顶点相关的信息；FirstIn域，指向第一条指向它的弧；FirstOut域，指向一个单链表，单链表中存放所有该结点发出的弧。单链表的每个表结点对应一条弧，每个表结点有5个域：vtail和vhead分别是该弧两个顶点在图中的位置，weight存储弧的权重（可选），vtail指向同一弧尾的下一条弧，vhead指向同一弧头的下一条弧。 type ENode struct { vtail,vhead int //弧尾和弧头顶点编号 Weight int //边的权重(可选，无权图没有这个值) nexttail,nexthead *ENode //指向同弧尾和同弧头的弧结点 } type VNode struct { data int //顶点信息 FirstIn,FirstOut *Enode //指向第一个邻接点 } type Graph struct { VNum,ENum int //顶点和边的个数 AdjList []VNode //存顶点 } 一个十字链表如下图所示，A只有出弧没有入弧，所以第一个指针为nil，第二个指针指向弧\u003cA, B\u003e。弧结点\u003cA, B\u003e没有同弧尾的结点，即除了A没有其它结点指向B，所以第一个指针为nil，但同弧头的还有弧结点\u003cA, C\u003e。这里的同弧头和同弧尾都是相对于弧来说的，因此，对弧结点\u003cA, C\u003e，同弧尾的还有\u003cB, C\u003e，但同弧头的到此为止。 可以看出，基本结构是邻接表结构，只是添加了一个额外的指针域。 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:2:3","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 邻接多重表 邻接多重表是邻接表的一种改进，只适用于无向图。在此存储结构中，图的顶点信息存放在顶点数组中，数组元素有两个域：data域，存放与顶点相关的信息；FirstEdge域，指向一个单链表，此单链表存储所有依附于该顶点的边的信息。这些单链表的一个表结点对应一条边，表结点有4个域：vexi和vexj分别存放该边两个顶点在图中的位置；nexti 指向下一条依附于顶点vexi的边对应的表结点，nextj 指向下一条依附于顶点vexj的边对应的表结点。 type ENode struct { vexi,vexj int //边的两个顶点 nexti,nextj *ENode //两个顶点所依附的下一条边 } type VNode struct { data int //顶点信息 FirstEdge *Enode //指向第一条边 } type Graph struct { VNum,ENum int //顶点和边的个数 AdjList []VNode //存顶点 } 一个示例如下 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:2:4","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 图的构建 我们以邻接矩阵形式存储，定义图的结构体如下 type Graph struct { VNum int // the number of Vertices ENum int // the numver of Edges AdjMatrix [][]int // adjacency matrix } 为了方便测试，不建立 CreateVertex() 和 CreateEdge() 函数，而是直接对结构体进行初始化从而创建图，创建了一个无向图和一个有向图 func CreateUndirectedGraph() *Graph { g := \u0026Graph{} g.VNum, g.ENum = 6, 6 for i := 0; i \u003c 7; i++ { //为了便于操作和理解，从下标为1开始 g.AdjMatrix = append(g.AdjMatrix, make([]int, 7)) } g.AdjMatrix[1][2], g.AdjMatrix[1][3], g.AdjMatrix[1][4] = 1, 1, 1 g.AdjMatrix[2][1], g.AdjMatrix[2][5] = 1, 1 g.AdjMatrix[3][1], g.AdjMatrix[3][5] = 1, 1 g.AdjMatrix[4][1] = 1 g.AdjMatrix[5][2], g.AdjMatrix[5][3], g.AdjMatrix[5][6] = 1, 1, 1 g.AdjMatrix[6][5] = 1 return g } // 初始化一个图，顶点和边的数量、权值都预设好 func CreateDirectedGraph() *Graph { g := \u0026Graph{} g.VNum, g.ENum = 7, 12 for i := 0; i \u003c 8; i++ { //为了便于操作和理解，从下标为1开始 g.AdjMatrix = append(g.AdjMatrix, make([]int, 8)) } g.AdjMatrix[1][2], g.AdjMatrix[1][4] = 2, 1 g.AdjMatrix[2][4], g.AdjMatrix[2][5] = 3, 10 g.AdjMatrix[3][1], g.AdjMatrix[3][6] = 4, 5 g.AdjMatrix[4][3], g.AdjMatrix[4][5], g.AdjMatrix[4][6], g.AdjMatrix[4][7] = 2, 2, 8, 4 g.AdjMatrix[5][7] = 6 g.AdjMatrix[7][6] = 1 return g } ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:3:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 图的遍历 有深度优先（Depth First Search, DFS）和广度优先（Breadth First Search, BFS）两种，前者类似于树的先序遍历，后者类似于树的层次遍历。下面图的遍历算法以下图为例 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:4:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 深度优先遍历 递归解法的程序实现如下 func DepthFirstSearch(g *Graph, vertex int, result []int) []int { g.AdjMatrix[0][vertex] = 1 result = append(result, vertex) for k, v := range g.AdjMatrix[vertex] { if v \u003e 0 \u0026\u0026 g.AdjMatrix[0][k] != 1 { result = DepthFirstSearch(g, k, result) } } return result } 以结点0为入口，深度优先的遍历结果为[0 1 4 2 5 3] ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:4:1","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 广度优先遍历 func BreadthFirstSearch(g *Graph, vertex int) []int { result := []int{} g.AdjMatrix[0][vertex] = 1 queue := list.New() queue.PushBack(vertex) for queue.Len() != 0 { vertex := queue.Remove(queue.Front()).(int) result = append(result, vertex) for k, v := range g.AdjMatrix[vertex] { if v \u003e 0 \u0026\u0026 g.AdjMatrix[0][k] != 1 { g.AdjMatrix[0][k] = 1 queue.PushBack(k) } } } return result } 以结点0为入口，广度优先的遍历结果为[0 1 2 3 4 5] ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:4:2","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 最短路径 最短路径问题可以抽象为：在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径，这条路径就是两点之间的最短路径（Shortest Path）。其中，第一个顶点为源点（Source），最后一个顶点为终点（Destination）。 最短路径问题不是一个单独的问题，而是一系列问题的综合，包括 单源最短路径问题：从某固定源点出发，求其到所有其它顶点的最短路径 （有向）无权图 （有向）有权图 多源最短路径问题：求任意两顶点间的最短路径 最短路径使用的示例图如下 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:5:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 单源最短路径 在理解最短路径算法前有两个问题需要注意 无向图和有向图都适用，虽然多数示例是有向图 无权图是有权图的特例（权值为1），因此不单独介绍 图中不可以存在权值为负的边，否则 Dijkstra(迪杰斯特拉)算法不起作用 如第3条所述，单源最短路径的典型算法称为 Dijkstra(迪杰斯特拉)算法，算法的基本思想为以起始点为中心层层向外扩展，直到扩展到终点为止。因此，该算法和广度优先搜索有一定的相似性。 输入上面的示例图，Dijkstra算法的输出为：[0 2 3 1 3 6 5] func DijkstraShortestPath(g *Graph, vertex int) { count := 1 // 已收录的顶点数目，用于控制循环 find := make([]bool, g.VNum+1) //标记已访问过的结点 prevVertex := make([]int, g.VNum+1) //当前节点的前驱结点 distance := make([]int, g.VNum+1) //当前结点的最短路径 //初始化 for i := 1; i \u003c= g.VNum; i++ { if g.AdjMatrix[vertex][i] \u003e 0 { distance[i] = g.AdjMatrix[vertex][i] prevVertex[i] = vertex } else { distance[i] = MAX_INT prevVertex[i] = -1 } } distance[vertex] = 0 find[vertex] = true v, d := vertex, 0 //用来迭代顶点的变量和初始距离 for count \u003c g.VNum { d = MAX_INT for i := 1; i \u003c= g.VNum; i++ { if !find[i] \u0026\u0026 distance[i] \u003c d { d = distance[i] v = i } } find[v] = true count++ for k, t := range g.AdjMatrix[v] { if !find[k] \u0026\u0026 t \u003e 0 \u0026\u0026 distance[v]+t \u003c distance[k] { distance[k] = distance[v] + t prevVertex[k] = v } } } fmt.Println(distance[1:]) } ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:5:1","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 多源最短路径 多源最短路径使用Floyd算法，这是一个经典的动态规划算法，核心思想是：从任意节点 i 到任意节点 j 的最短路径不外乎2种可能，1是直接从 i 到 j，2是从 i 经过若干个节点 k 到 j。所以，我们假设 Distance(i,j) 为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查 Distance(i,k) + Distance(k,j) \u003c Distance(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，我们便设置Distance(i,j) = Distance(i,k) + Distance(k,j)，这样一来，当我们遍历完所有节点 k，Distance(i,j) 中记录的便是 i 到 j 的最短路径的距离。 整个过程可以描述为两个步骤 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是，更新它。 程序实现如下 func FloydShortestPath(g *Graph, vertex int) { var D [][]int var path [][]int var i, j, k int for i := 0; i \u003c g.VNum; i++ { D = append(D, make([]int, g.VNum)) path = append(path, make([]int, g.VNum)) } for i = 1; i \u003c= g.VNum; i++ { for j = 1; j \u003c g.VNum; j++ { D[i][j] = g.AdjMatrix[i][j] path[i][j] = -1 } } for k = 1; k \u003c= g.VNum; k++ { for i = 0; i \u003c g.VNum; i++ { if D[i][k]+D[k][i] \u003c D[i][j] { D[i][j] = D[i][k] + D[k][j] path[i][j] = k } } } } ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:5:2","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 拓扑排序 如果图中从 v 到 w 有一条有向路径，则 v 一定排在 w 之前。满足此条件的顶点序列称为一个拓扑序，获得一个拓扑序的过程就是拓扑排序。 一个最典型的例子是排课表，一个专业很多课程都有先修课，因此排课时必须考虑先修课的存在，以每门课程为结点，若课程间存在先修课关系则有边，这样构成的网络叫做AOV（Activity On Vertex）网，也是拓扑排序使用的网络。 拓扑排序用一句话描述就是「每次删除入度为0的顶点并输出它」，以下图为例，拓扑排序的结果为：V1,V2,V3,V4,V5。拓扑排序的结果是不唯一的。 拓扑排序必定是一个有向无环图（DAG），因此，该算法也可以用于判断一个图是否为有向无环图。程序实现如下，返回的result是拓扑排序结果，ve是关键路径需要用到的事件最早发生时间。 func TopologicalSort(g *Graph) ([]int, []int) { result := make([]int, 1) //拓扑排序的结果数组 ve := make([]int, g.VNum+1) count := 0 //判断图中是否有环 //计算各结点的入度并存储 indegree := make([]int, g.VNum+1) for i := 1; i \u003c= g.VNum; i++ { for j := 1; j \u003c= g.VNum; j++ { if g.AdjMatrix[i][j] \u003e 0 { indegree[j]++ } } } queue := list.New() //入度为0的结点入队 for i := 1; i \u003c= g.VNum; i++ { if indegree[i] == 0 { queue.PushBack(i) } } for queue.Len() != 0 { vertex := queue.Remove(queue.Front()).(int) result = append(result, vertex) count++ for k, v := range g.AdjMatrix[vertex] { if v \u003e 0 { indegree[k]-- if indegree[k] == 0 { queue.PushBack(k) } if ve[vertex]+v \u003e ve[k] { ve[k] = ve[vertex] + v } } if v == 0 { if ve[vertex]+v \u003e ve[k] { ve[k] = ve[vertex] + v } } } } if count != g.VNum { fmt.Println(\"This is a DAG!\") return nil, nil } return result, ve } ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:6:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"7. 关键路径 拓扑排序应用在AOV网络上，每个顶点表示一个活动或任务。如果每条边表示一个活动或任务，就是AOE（Activity On Edge）网络，多用在安排一个庞大生产流程的工序上，工序之间有先后关系。 如下图所示，在AOE网络中，事件 i 发生后，其后继活动 a(i,*) 都可以开始，但只有所有先导活动 a( *,j ) 都结束后，事件 j 才可以发生。 假设一个工程的 AOE 网如下，最常求的就是 a) 整个工程完工需要多长时间？ b) 哪些活动影响工程进度？或求关键路径。图中的虚线表示事件有先后关系，但是这个活动不存在。 对事件（顶点）i，令最早发生时间为 ve(i)，最晚发生时间为 vl(i)； 对活动（边）a(i,j)，令最早开始时间为 e(i,j)，最晚开始时间为 l(i,j)。 那么整个工程的完工时间就是终点的最早发生时间；关键路径就是路径长度最长的路径。求关键路径的算法如下： 将所有顶点进行拓扑排序； 计算 ve(j)， $ve(j) = max{ve() + a(,j)}$ ，其中*为任意前驱事件，有ve(1) = 0； 计算 vl(i)， $vl(i) = min{vl() - a(i,)}$ ，其中*为任意后继事件，有vl(n) = ve(n)； 计算 e(i,j) 和 l(i,j)，$e(i,j) = ve(i)$，$l(i,j) = vl(j)-a(i,j)$ 结论：工程总用时 ve(n)，关键活动是 e(i,j) = l(i,j) 的活动 a(i,j) 如果只求工程总用时，那么只需要第1，2步。关于两个核心公式可以这样理解：事件 j 在所有前驱活动都完成后发生，所以其最早发生时间为 $ve(j) = max{ve() + a(,j)}$ ，即取决于最慢的前驱活动。另一方面，事件 i 发生后所有后继活动都可以开始了，所以其最晚发生时间为 $vl(i) = min{vl() - a(i,)}$，即不耽误最慢的后继活动。 简单理解的话，就是按照拓扑有序排列顶点，然后从前往后计算事件的最早发生时间得到总时间，再从后往前计算事件的最晚发生时间，最后计算活动的最早和最晚开始时间得到关键活动和关键路径。求上面示例图的关键路径过程如下表 事件 最早发生时间ve 最晚发生时间vl 活动 最早开始时间e 最晚开始时间l v1 0 0 a(1,2) 0 0 v2 6 6 a(1,3) 0 2 v3 4 6 a(1,4) 0 1 v4 5 6 a(2,5) 6 6 v5 7 7 a(3,5) 4 6 v6 7 7 a(4,6) 5 6 v7 12 13 a(5,6) 7 7 v8 11 11 a(5,7) 7 8 v9 15 15 a(5,8) 7 8 a(6,8) 7 7 a(7,9) 12 13 a(8,9) 11 11 最终得到工程完工需要时间为15，关键路径是 1,2,5,6,8,9 程序实现如下 func CriticalPath(g *Graph) (int, []int) { path, ve := TopologicalSort(g) if len(path) == 1 || path == nil { return 0, nil } vl := make([]int, len(path)) for i := 1; i \u003c len(vl); i++ { vl[i] = MAX_INT } vl[len(ve)-1] = ve[len(ve)-1] for i := len(vl) - 2; i \u003e 0; i-- { for k, v := range g.AdjMatrix[i] { if v \u003e= 0 \u0026\u0026 vl[k]-v \u003c vl[i] { vl[i] = vl[k] - v } } } result := []int{} for i := 1; i \u003c g.VNum+1; i++ { for j := 1; j \u003c g.VNum+1; j++ { if g.AdjMatrix[i][j] \u003e= 0 { if ve[i] == vl[j]-g.AdjMatrix[i][j] { result = append(result, i) } } } } result = append(result, path[len(path)-1]) return ve[len(ve)-1], result } ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:7:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"8. 最小生成树 生成树指包含全部顶点且树的 V-1 条边全部在图里的树，其中 V 为顶点数目。最小生成树（Minimum Spanning Tree）就是边的权重和最小的生成树。需要注意两点 向生成树中任加一条边都一定会构成回路 最小生成树存在等价于图连通 生成最小生成树最常见的有 Prim 和 Kruskal 两种算法，这两种都是贪心算法。 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:8:0","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"8.1 Kruskal算法 算法的核心思想用一句话描述就是「不构成环的情况下，每次选取最小的边」，最小边的选取可以使用最小堆，环的判断可以使用并查集。 代码实现如下，最小堆的实现使用了 标准库中的container/heap，usetFind是并查集的查找函数 func usetFind(x int, uset []int) int { for x != uset[x] { x = uset[x] } return x } func KruskalMiniSpanTree(g *Graph) (int, []int) { var total int result := []Edge{} h := \u0026Heap{} heap.Init(h) for i := 1; i \u003c g.VNum+1; i++ { for j := i; j \u003c g.VNum+1; j++ { if g.AdjMatrix[i][j] \u003e 0 { heap.Push(h, Edge{i, j, g.AdjMatrix[i][j]}) } } } uset := make([]int, g.VNum+1) //用数组表示并查集 for i := 1; i \u003c len(uset); i++ { uset[i] = i } for h.Len() != 0 { e := heap.Pop(h).(Edge) if usetFind(e.from, uset) != usetFind(e.to, uset) { result = append(result, e) uset[uset[e.to]] = uset[e.from] total += e.weight } } return total, uset } ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:8:1","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"8.2 Prim算法 记 V 是联通网的顶点集，U 是求得的生成树的顶点集，TE 是求得的生成树的边集。普利姆算法步骤如下 开始时，$U={v_0}, TE = \\emptyset$ 计算 U 到其余顶点 V-U 的最小代价，将该顶点纳入 U，边纳入TE 重复第二步直到 U=V 一个例子如下 代码实现如下 func PrimMiniSpanTree(g *Graph, start int) (int, []int) { total := 0 parent := make([]int, g.VNum+1) dist := make([]int, g.VNum+1) parent[start] = -1 for i := 1; i \u003c len(dist); i++ { if i == start { continue } if g.AdjMatrix[start][i] \u003e 0 { dist[i] = g.AdjMatrix[start][i] } else { dist[i] = MAX_INT } } count := 1 vertex, mini := start, MAX_INT for count \u003c g.VNum { mini = MAX_INT for i := 1; i \u003c len(dist); i++ { if dist[i] != 0 \u0026\u0026 dist[i] \u003c mini { vertex, mini = i, dist[i] } } total += dist[vertex] dist[vertex] = 0 count++ for k, t := range g.AdjMatrix[vertex] { if dist[k] != 0 \u0026\u0026 t \u003e 0 \u0026\u0026 t \u003c dist[k] { dist[k] = t parent[k] = vertex } } } return total, parent } ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:8:2","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["爱编程爱技术的孩子"],"content":"8.3 两种算法比较 Kruskal的算法时间复杂度为$O(eloge)$，只和边的数目 e 有关，与顶点个数 n 无关，适用于稀疏图 Prim算法时间复杂度为$O(n^2)$，只和顶点个数 n 有关，与边的数目 e 无关，适用于稠密图 ","date":"2020-03-16","objectID":"/2020/data-structure-graph/:8:3","tags":["数据结构与算法"],"title":"数据结构-图","uri":"/2020/data-structure-graph/"},{"categories":["研究生的区块链学习之路"],"content":"这场年初爆发的疫情在国内控制住以后，反而开始在全世界其它国家蔓延，如大数据、5G等技术均在当前这场疫情中产生了自己的作用，区块链能做些什么，可以引起我们的思考。本篇文章总结网上提到的和自己想到的一些方面，并作一些思考。 ","date":"2020-03-16","objectID":"/2020/what-can-blockchain-do-during-the-covid-19/:0:0","tags":["区块链","杂谈"],"title":"面对疫情区块链可以做些什么","uri":"/2020/what-can-blockchain-do-during-the-covid-19/"},{"categories":["研究生的区块链学习之路"],"content":"1. 疫情预警 据有关报道显示，新型冠状病毒在2019年12月其实就已经有迹可循了，但直到2020年1月中下旬才正式有公告通知，对于这种重要信息的滞后性，严重影响了相关病例的治疗和有关部门的防控工作。 我国早在2008年就开始建立了国家传染病自动预警机制，采用的是自下而上的数据回馈及分析方式，在上报过程中会经过多层核实，在面对突然爆发的传染类疾病时，会有严重的滞后性。同时，医院在保护病人隐私的前提下，难以做到完全的共享数据，对疾病的评估也会有一定的难度。 **区块链能解决的就是如何做到数据的同步更新，而不完全依赖于自下而上的现有预警机制，**利用目前已有的公共卫生数据交换平台作为每级数据的交换节点，形成实时自动化的数据交换机制。将医疗数据的上报下沉到各个环节，医疗机构上报初次传染病历；再由相关机构进行核实补充；最后由国家预警部门根据大数据预警，这就解决了多重审核的问题。同时构建出一个跨省、市、区等的医疗数据防疫链，上传的数据自动同步实时更新，也就解决了医院之间的数据孤岛问题。相较而言，疫情预警将会更快捷准时。 下面是来源于链上观的一份关于区块链+传染病自动预警系统优化升级的解决方案： 以省级为单位，由当地疾控中心主导建立一条“疾控联盟链”，首批成员是当地省、市、区、县级的大小医院。疾控中心应设定一套奖惩制度补贴各个医院，鼓励医院积极地提交各类传染病性质的病例，包括已有传染病例和未知传染病例及疑似传染病例等。 每一次新数据提交后都会向全联盟链的各大医院发送广播，各个医院都设定专人负责审核上链。这么做可以对上链数据信息进行跨医院交叉验证。这样一来，医生不必担心组织体系内的上报压力，只负责呈现客观的临床数据，确保了上报数据的及时性和完整性。而且交叉验证过程需要由2/3以上的医院共同确认，极大地确保了数据的真实性。 一旦一项新数据上链成功后，就会被加以时间戳，之后新产生的上链数据，只要病例相似度高达95%以上（阀值仅供参考）就会自动归类成链。如果一个新病例上链后成为了孤块，可视为临床病例尚未形成较大传染性，仅做一定预防和监控即可。如果一个新病例上链后，很快就形成了一条数据链，可设定一个阈值，达到一定数量后，疾控中心可协调当地政府力量进行匹配的防控举措（听数据的调度）。 同理在地方联盟链之上，还会有一个以省级疾控中心为联盟链主体单位的国家级的疾控联盟链。地区在采集到异常数据并进行相应预防措施之后的同时应将当地的传染数据情况统一汇报给国家级疾控中心，并在链上进行广播，以便其他各省市地区能及早高度重视并做好预防防护工作。 初期疾控链上链上的数据初期只对联盟链的成员开放，一旦达到一定的传播阈值之后再接入权威媒体进行透明化披露展示，让公众享有充分的知情权，避免不必要的猜忌和恐慌情绪滋生。 疫情初期的问题是确诊标准问题，本来以为这个问题不解决数据无法上链，区块链无法起到太大作用，但这套系统中直接将病例数据上链，自动判断相似度从而归类疾病，最后触发预警系统，很好的解决了现有问题。但和其它区块链项目相同，现在面临的难题依然是基础设施建设问题，没有完善的基础设施，各医院不参与，就无法建成这套系统。 ","date":"2020-03-16","objectID":"/2020/what-can-blockchain-do-during-the-covid-19/:1:0","tags":["区块链","杂谈"],"title":"面对疫情区块链可以做些什么","uri":"/2020/what-can-blockchain-do-during-the-covid-19/"},{"categories":["研究生的区块链学习之路"],"content":"2. 谣言防治 在疫情警报拉响之后，关于疫情状况就是全国人民最关心的问题了。在近一个月的时间里，我们能够在网络中看到各种各样关于疫情的消息，一旦某个现像激发了群众的慷慨激昂后往往就会爆出其实是谣言，这种状况对于控制舆论有很大的不利影响，那么我们对于疫情的知悉究竟怎样才不会落入散发谣言中呢？ 关于普遍提到的流动人员追踪问题，因为涉及太多的隐私问题，我认为很难得到民众的认可，如果一个人的身份信息，所有出行、交往记录全部记载在区块链上，相当于将一个人完全公开在了网络上，而且这些数据还不可撤销，将会永久存在。即使这种作法确实对疫情防控有意义，但很难被大家接受，没有人希望自己的一举一动都被记录并被所有人随意阅览。 另一个方面是感染人数等疫情信息的公开，民众对疫情真实进度不了解、对医院公布的数据不信任催生了大量的网络谣言。目前，国务院面向民众信息公开接受瞒报举报，微信也开了谣言识别功能，官方媒体每天都对各种谣言进行甄别和公示。首先可以确定的是，如果使用区块链，可以防止医院主管领导等因为职位绩效，或者舆论压力而隐瞒或者更改统计数据，只要信息上链和审核足够及时，由于区块链的分布式特性，消息就能以足够快的速度散发出去，切断谣言的传播。但这建立在基于区块链的疫情公示系统拥有足够多受众的情况，因为很多人轻易的就能相信微信群里各种难辨真假的消息、科普和视频。 另外一个优点是上传到区块链平台的数据被权威节点确认后，可以一路追溯，追踪到消息的原始发布者，奖惩机制可以依赖这点起作用。 目前，山东、青岛、浙江、济南等多个省市的官方机构以及学术机构已陆续上线了基于区块链的防控平台，可以对疫情的上报信息实施可溯源的上链管理。 ","date":"2020-03-16","objectID":"/2020/what-can-blockchain-do-during-the-covid-19/:2:0","tags":["区块链","杂谈"],"title":"面对疫情区块链可以做些什么","uri":"/2020/what-can-blockchain-do-during-the-covid-19/"},{"categories":["研究生的区块链学习之路"],"content":"3. 公益捐赠 武汉红十字会的情况使大家对现有公益体系产生了严重怀疑，如何使捐款及物资的流动透明，区块链能起到一定的作用。在这里基础设施依然非常重要，但我们不再提及，下面的描述都是在假设区块链已经铺设好正常运行之后可以达成什么样的目标。 万向区块链有一个慈善平台1是针对这种业务场景的，在疫情之下，也做了一场线上直播2来介绍他们的系统。 捐款及物资被用到哪里，什么时候用出去，用出去又经历了多少环节才用到需要帮助的人，每个环节上被损耗了多少，这些都是需要公开透明的信息。对捐赠人的服务中，由于各类文件有不可篡改的时间戳，此外如果捐赠人先后出具了多份意愿书，记录意愿的先后顺序，也可以避免纠纷的发生。因此区块链在公益捐赠中的核心作用有两个 捐款、物资等捐赠信息的存证。 事务管理过程和财产管理、使用情况进行存证，锚定每笔钱和物资的去向。 第二点很重要，需要去跟踪每分钱最终去哪儿了，中间损耗多少，只有用到最终受益人时，才成为可以支出的状态花出去，捐赠人很明确的想知道捐钱没问题，一些示例如 万向慈善信托账户管理平台 ↩︎ 疫情之下，区块链如何服务于慈善场景 ↩︎ ","date":"2020-03-16","objectID":"/2020/what-can-blockchain-do-during-the-covid-19/:3:0","tags":["区块链","杂谈"],"title":"面对疫情区块链可以做些什么","uri":"/2020/what-can-blockchain-do-during-the-covid-19/"},{"categories":["爱编程爱技术的孩子"],"content":"普通的队列是一种先进先出的数据结构，在此基础上，还有一种叫做 优先队列 的结构。顾名思义，优先队列就是具有优先级的队列，其中，元素被赋予优先级，具有最高优先级的元素将最先被访问。 优先级队列的一个典型使用场景是计算机的进程调度，在进程调度算法中有一种称为优先级法，就是使用优先队列这种结构。优先队列可以使用（有序）数组或（有序）链表实现，但最常用的实现方法是 堆。 注：这里的堆不是堆栈 ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:0:0","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 什么是堆 堆是一棵树，其中每个节点的值都大于等于/小于等于其子孙节点的值。每个节点的值都大于等于其子孙节点值的堆叫做大顶堆，否则叫做小顶堆。 习惯上，不加限定提到「堆」时往往指二叉堆。二叉堆是一棵用数组表示的完全二叉树，它满足堆的性质： 每个结点中存有一个元素（或者说一个权值） 任一结点的权值是其子树所有结点的最大值（或最小值） 下面是大顶堆和小顶堆的一个例子 二叉堆和二叉搜索树虽然乍一看有相似之处，但它们的区别很大： 结点顺序。在二叉搜索树中，左子树中的节点必须比当前节点小，右子树中的节点必须比当前节点大，但最大堆中不论左右子树，节点都必须比当前节点小或者大； 平衡：二叉搜索树必须在平衡状态下，大部分操作复杂度才能达到O(log n)，而二叉堆一定是平衡的，构建树的方式决定了它的复杂度。 搜索：二叉树搜索很快，堆则不一定，因为堆的主要任务不是搜索，而是及时获取最大或最小结点。 二叉搜索树必须是严格的大小关系，堆可以有等于。 ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:1:0","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 堆的基本操作 堆的最基本操作是插入和删除，除此之外，给定一组值快速构建堆也是常见的问题。在Go中，我们将堆定义为一个切片，为了便于操作，下标从1开始 var heap = make([]int, 1) 注：下面的例子均以最大堆为例 ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:2:0","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 堆的插入 插入操作是指向二插堆中插入一个元素，其基本流程如下 将插入的元素放在数组的最后一个元素 如果新插入的结点的值大于它父亲节点的值，就与之交换，重复此过程直到不满足或者到根。这一过程叫做向上调整 一个例子如下 程序实现如下 func Insert(heap []int], key int) { heap = append(heap, key) child = len(heap)-1 for { parent := (child-1)/2 if parent \u003c 0 || heap[parent] \u003e= heap[child] { break } heap[parent],heap[child] = heap[child],heap[parent] child = parent } } ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:2:1","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 堆的删除 删除操作指删除堆中最大的元素，即删除根结点。其基本流程如下 读取根结点（最大值）元素 交换根结点和最后一个结点，然后删除最后一个结点 在新的根结点的儿子中，找一个最大的，与该结点交换，重复此过程直到底层。这一过程叫做向下调整 一个例子如下 程序实现如下 func Delete(heap []int) int { var parent, child int Max,t := heap[0],len(heap)-1 heap[0], heap[t] = heap[t], heap[0] heap = heap[:t] for parent = 0; parent*2 +1 \u003c len(heap); parent = child { child = parent * 2 + 1 if child + 1 \u003c len(heap) \u0026\u0026 heap[child+1] \u003e heap[child] { child++ } if heap[child] \u003c= heap[parent] { break } heap[child], heap[parent] = heap[parent], heap[child] } return Max } ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:2:2","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 堆的建立 通过将一组元素逐个插入到一个初始为空的堆，可以建立一个最大堆，但这种方法的复杂度为$O(n log_2n)$。实际上，这里存在一种可以在线性时间内$O(log_2n)$建立堆的方法，流程如下 将 N 个元素按输入顺序构造切片，使其满足完全二叉树的特性 从倒数第一个非叶子结点起，逐个往前按照向下调整的思路调整各结点位置，使其满足堆的特性 一个例子如下 程序实现如下 //假设传入的数组已经按顺序填好元素 func build(heap []int) { for i := (len(heap)-2)/2; i \u003e= 0; i-- { for parent = i; parent * 2 + 1\u003c len(heap); parent = child { child = parent * 2 + 1 if child + 1 \u003c len(heap) \u0026\u0026 heap[child+1] \u003e heap[child] { child++ } if heap[child] \u003c= heap[parent] { break } heap[child], heap[parent] = heap[parent], heap[child] } } } ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:2:3","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 实现优化 实际上我们注意到，关于堆的操作，最重要的有两个，一个是向上调整，用于插入，一个是向下调整，用于删除和建立堆。我们将这两个操作提取出来 // 向上调整 func up(heap []int) { child := len(stones)-1 for { parent := (child-1) / 2 if parent \u003c 0 || heap[parent] \u003e= heap[child] { break } heap[parent],heap[child] = heap[child],heap[parent] child = parent } } // 向下调整 func down(heap []int, i int) { var parent,child int for parent := i; parent * 2 + 1 \u003c len(heap); parent = child { child = parent * 2 + 1 if child + 1 \u003c len(heap) \u0026\u0026 heap[child+1] \u003e heap[child] { child++ } if heap[child] \u003c= heap[parent] { break } heap[child],heap[parent] = heap[parent],heap[child] } } 这样，插入、删除和建堆函数可以简化为 // 插入 func Insert(heap []int], key int) { heap = append(heap, key) up(heap) } // 删除 func Delete(heap []int) int { Max := heap[0] heap[0]= heap[len(heap)-1] heap = heap[:len(heap)-1] down(heap, 0) return Max } // 建堆 func build(heap []int) { for i := (len(heap)-2)/2; i \u003e= 0; i-- { down(heap,i) } } Go 的标准库也提供了堆的相关实现，位于 container/heap 包中，该包提供了对任意类型（实现了heap.Interface接口）的堆操作。 heap 包默认使用最小堆，但在正式应用前需实现如下接口 type Interface interface { sort.Interface Push(x interface{}) // 向末尾添加元素 Pop() interface{} // 从末尾删除元素 } 该接口的示例实现如下 // An IntHeap is a min-heap of ints. type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u003c h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents. *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } 实现了该接口后，就可以利用 Init 函数初始化一个堆，利用 Push 插入和利用 Pop 删除。相关的函数原型如下 func Init(h Interface) func Push(h Interface, x interface{}) func Pop(h Interface) interface{} 使用这些方法的一个示例如下 // This example inserts several ints into an IntHeap, checks the minimum, // and removes them in order of priority. func Example_intHeap() { h := \u0026IntHeap{2, 1, 5} heap.Init(h) heap.Push(h, 3) fmt.Printf(\"minimum: %d\\n\", (*h)[0]) for h.Len() \u003e 0 { fmt.Printf(\"%d \", heap.Pop(h)) } // Output: // minimum: 1 // 1 2 3 5 } ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:3:0","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 优先队列 如我们开头所说，堆用来实现优先队列，下面给出一个利用标准库实现优先队列的例子 // This example demonstrates a priority queue built using the heap interface. package heap_test import ( \"container/heap\" \"fmt\" ) // An Item is something we manage in a priority queue. type Item struct { value string // The value of the item; arbitrary. priority int // The priority of the item in the queue. // The index is needed by update and is maintained by the heap.Interface methods. index int // The index of the item in the heap. } // A PriorityQueue implements heap.Interface and holds Items. type PriorityQueue []*Item func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Less(i, j int) bool { // We want Pop to give us the highest, not lowest, priority so we use greater than here. return pq[i].priority \u003e pq[j].priority } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] pq[i].index = i pq[j].index = j } func (pq *PriorityQueue) Push(x interface{}) { n := len(*pq) item := x.(*Item) item.index = n *pq = append(*pq, item) } func (pq *PriorityQueue) Pop() interface{} { old := *pq n := len(old) item := old[n-1] item.index = -1 // for safety *pq = old[0 : n-1] return item } // update modifies the priority and value of an Item in the queue. func (pq *PriorityQueue) update(item *Item, value string, priority int) { item.value = value item.priority = priority heap.Fix(pq, item.index) } // This example creates a PriorityQueue with some items, adds and manipulates an item, // and then removes the items in priority order. func Example_priorityQueue() { // Some items and their priorities. items := map[string]int{ \"banana\": 3, \"apple\": 2, \"pear\": 4, } // Create a priority queue, put the items in it, and // establish the priority queue (heap) invariants. pq := make(PriorityQueue, len(items)) i := 0 for value, priority := range items { pq[i] = \u0026Item{ value: value, priority: priority, index: i, } i++ } heap.Init(\u0026pq) // Insert a new item and then modify its priority. item := \u0026Item{ value: \"orange\", priority: 1, } heap.Push(\u0026pq, item) pq.update(item, item.value, 5) // Take the items out; they arrive in decreasing priority order. for pq.Len() \u003e 0 { item := heap.Pop(\u0026pq).(*Item) fmt.Printf(\"%.2d:%s \", item.priority, item.value) } // Output: // 05:orange 04:pear 03:banana 02:apple } ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:4:0","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["爱编程爱技术的孩子"],"content":"参考 [1] Golang: 详解container/heap [2] B站-浙江大学数据结构课程 ","date":"2020-03-11","objectID":"/2020/data-structure-heap/:5:0","tags":["数据结构与算法"],"title":"数据结构-堆","uri":"/2020/data-structure-heap/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第十期，由于经历了图床转换，本文图片已丢失。 注：文中图片大部分来自网络，侵删。 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"时讯 1、新冠肺炎疫情 截至2020年3月6日0:00，新冠肺炎国内累计确诊80714人，死亡3045人，治愈53827人，确诊人数已下降到23842人。说明国内的疫情基本已经得到控制，但与之相反的是，国外疫情持续爆发，累计已达到18031人，其中韩国、意大利、伊朗和日本最为严重，韩国甚至已经超过6500人。新冠肺炎有发展成为全球性大流行病的趋势。 有趣的是，为了避免传播病毒，各国民众不再握手、亲吻、拍背，而是采用了一些新的问候方式，比如拱手、注视、送花、比划十字架和碰脚等，最后一种也是非常有意思了。 2、土耳其开放边境放难民入欧 为了向欧盟施压，换取其在叙利亚问题上的支持，土耳其上周宣布“放行难民前往欧盟”。连日来，在土耳其与希腊边境，数以万计的难民继续试图通过陆路和海路进入希腊境内。土耳其称希腊对难民使用了催泪瓦斯并开枪导致死伤，希腊予以否认。据联合国难民署3日估计，已有约2万难民来到土希边界土耳其一侧。这些难民试图穿越边境进入希腊，并将最终去往德国等经济更发达的欧盟成员国。希腊政府已暂时关闭希土陆地边境，并将边防等级提升至最高级。 3、美国大选 3号是美国总统大选预选的重要节点，投票结果在3月4号之后逐步揭晓，前副总统拜登和联邦参议员桑德斯在民主党竞选人阵营中领先，现任总统特朗普则在共和党竞选人阵营中呈现压倒性优势。 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"小事 1、03.01，开始追番《因为太怕痛就全点防御力了》，虚拟游戏类，看的很开心，打算追下去。 2、03.04，大年初一以来首次出门，和老妈去超市买菜，人依然不算很多，大家防护都很到位。 3、03.06，本周开启两个习惯养成，一是对早起早睡背单词和健身每天进行打卡，二是将遇到的文章统一加入pocket留待固定时间查看，而不是立即打开。 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"视频 1、TED演讲-为什么我们的工作方式会降低效率 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"工具 1、tern 一款字幕翻译软件，官方介绍说适合字幕组人员或普通观众（对于字幕的质量要求不是很高的人）。它通过调用相应的翻译引擎对字幕文件进行翻译，支持谷歌、彩云小译、微软 Azure、Yandex、亚马逊、腾讯、百度、搜狗、小牛 9 家翻译服务商；平台覆盖上则同时支持 Windows 和 macOS 两个平台，支持翻译处理 srt、ass、vtt 等常见格式的字幕。 2、markdown-here 一款浏览器插件，可以用来将Markdown形式书写的邮件渲染成普通的邮件格式，但这里提到它主要是作为zotero插件，从而可以用markdown格式来写笔记。关于如何将该插件提取并重新打包，然后安装到zotero中，可以参考这篇文章 3、zotfile 另一款有名的zotero插件，可以完成论文原文的同步而不必设置软链接。也可以完成其它很多功能，是一款非常实用的插件。说实话，虽然插件是zotero的优势，但我直到本周才意识到这一点并开始使用。 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"概念 1、蛋白石 蛋白石是一种可以展现出彩虹般颜色的宝石，其中的贵重蛋白石有游彩，意即颜色会不断变化，是一种非常漂亮和受人喜爱的石头。 2、vivo APEX 2020 vivo最近发布了第三代概念机—APEX 2020，吸引了一众人士的视线，所使用的各项技术和最终的成品都满足了大家的想象，包括但不限于屏下摄像头、机械防抖和60W快充等。从我的角度来说，在这个级别的量产机型出来前，已经不打算换机器了，各种水滴挖孔接受不能，而5G也属于初期还比较贵。 3、古北水镇 古北水镇位于北京密云，是司马台长城脚下独具北方风情的度假式小镇。背后的北京古北水镇旅游有限公司成立于2010年7月，由IDG战略资本、中青旅控股股份有限公司、乌镇旅游股份有限公司和北京能源投资（集团）有限公司共同投资建设。本周在司徒建国带博步和韩梅梅旅游的视频中了解到该景点，感觉还可以。 额外注意到的是，背后的中青旅控股成立于1997年，是共青团中央直属企业，乌镇旅游也是其旗下的产业。 4、笔记本安全锁孔 正如电脑上的SD卡插槽，安全锁孔是有一个我现在才发现存在但完全没使用过的部分，而且，在本周前我完全没有听说过这个东西，更不必说知道如何使用了。笔记本的安全锁孔是配合安全锁使用的，主要是为了在暂时离开笔记本时将其锁到附近的物体上防止被偷走。笔记本安全锁孔的使用频率很低，绝大多数人都不知道这个部分的存在，因此现在越来越多的笔记本已经取消了该接口。 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"资源 1、GIA GIA 成立于 1931 年，是全球最权威的钻石、有色宝石和珍珠研究机构。 GIA 是一个非营利的公益性机构，是宝石与珠宝知识、标准和教育的主要来源。在GIA的官网可以查询到许多关于宝石的知识，包括一份宝石百科全书和相关的分析和分级，下面是一颗海蓝宝石。 2、杨可爱 本周在B站发现的宝藏UP主，以古风弹唱为主，视频制作十分精良。当然，杨可爱也是真的可爱。 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:3:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"句子 1、「社交媒体是一种精心策划、过滤、经常修饰，有时甚至是一种生活方式的错觉。」 这句话出自于TED演讲：《为什么你要放弃追求完美》，非常有感触。随着社交媒体的兴起，每时每刻都有大量的事情可以伤害我们的自尊，而社交媒体是一种精心策划、过滤、经常修饰的，有时甚至是对生活方式的错觉，经过修饰的照片，拉长的美腿，以至于我们觉得自己怎么缺陷那么多！为什么我不够瘦！而,当你放弃追求完美的时候，你才会看到自己的成长。 2、「当斧头来到森林里的时候，好多树都说，至少他的把手，是我们自己人。」 含义和波士顿犹太人屠杀纪念碑一脉相承，非常有哲理。 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:3:5","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["日程及周刊"],"content":"文章 1、请回答2010s，那些独属于韩国电影的高光时刻 2010年来，韩国电影的质量不断飙升，2019年《寄生虫》的获奖为这十年画了一个完美的句号。这篇文章就十年间值得观看的韩国电影做了列举。 2、科研中慎防这十种逻辑谬误 论文为导向的现实环境下，无论是老师还是学生都陷入了一种狂热的状态，而没办法安心研究，导致了一些错误很容易犯，这里介绍了一些科研中常犯的错误。 3、腾讯大三实习生不到两个月独立完成开发项目交付，她有哪些秘诀？ 不仅仅是一份实习指南，也是一份如何从学习研究和兴趣过渡到工作的指南，2020年腾讯暑期实习招聘正在进行，这篇文章也算得上十分应景了。 4、五款改变储蓄体验的以太坊 DeFi 应用 现如今，整个世界的利率都萎靡不振，对世界经济前景的预期也普遍悲观。但在以太坊区块链上，有一类被称为DeFi的去中心化金融应用，借助这些应用可以获得更大的收益。这类应用的本质是一种放贷，由于使用区块链，参与者可以不必担心被携款跑路，但投资永远存在风险，不要期待太多。 5、“斯大林式楚门秀”，一场平行世界中的社会实验 2月17日，巴黎刚刚结束一场恐怕是迄今为止，全世界工程最庞大、最难以想象的影像展映——在法国巴黎的蓬皮杜艺术中心以及另外两个剧院里，人们可以沉浸式地感受一个被复制还原的前苏联社会，以及生活其中的人们。这个“前苏联社会”是真实存在于21世纪，位于乌克兰东北部哈尔科夫的某个地区，仿佛前苏联遗留的一个幽灵。而处于其中的人们，与其说他们是在表演，不如说他们是生活其中，就像生活在另一个平行空间。如此浩大的实验性项目，只因为当初的一个电影计划，它有一个相当简洁的名字：《DAU》。当然这个电影计划早已“变质”，有人形容它为“斯大林式楚门秀”，一场人类学社会实验。 这篇文章我们详细讲述了这一场实验，真的非常非常新奇。同时，这篇文章也作为知乎回答-如何评价俄罗斯导演伊利亚·赫尔扎诺夫斯基的「DAU」系列的电影项目的优秀答案被知乎日报收录。 ","date":"2020-03-06","objectID":"/2020/life-weekly-10/:3:6","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 10 期 (20200306)","uri":"/2020/life-weekly-10/"},{"categories":["平日里的白日梦"],"content":"波士顿犹太人大屠杀遇难犹太人纪念碑位于该市市中心的小公园中，由六个玻璃空心塔组成，塔壁上刻有集中营囚徒代号和幸存者的语录。在玻璃空心塔的旁边有一个记载着铭文的小石碑。全世界纪念二战中被纳粹屠杀的犹太人的纪念地有多处，此地的纪念碑之所以较为著名，原因是碑的铭文（牧师马丁·尼莫拉的忏悔)诗发人深省。 纳粹杀共产党时， 我没有出声 ——因为我不是共产党员； 接着他们迫害犹太人， 我没有出声 ——因为我不是犹太人； 然后他们杀工会成员， 我没有出声 ——因为我不是工会成员； 后来他们迫害天主教徒， 我没有出声 ——因为我是新教徒； 最后当他们开始对付我的时候， 已经没有人能站出来为我发声了。 ","date":"2020-03-06","objectID":"/2020/engraved-in-st-pauls-church-in-1962/:0:0","tags":["文摘"],"title":"波士顿犹太人屠杀纪念碑碑文","uri":"/2020/engraved-in-st-pauls-church-in-1962/"},{"categories":["平日里的白日梦"],"content":"纵然 你已去远 想此刻又已隔了几重山 我依然停顿在水流的中央 努力回溯 那刚刚过去的时光 想你从千里之遥奔赴到我的身边 原也只为了这一刻的低徊和缱绻 从云到雾到雨露 最后汇成流泉 也不过只是为了想要这世界知道 反复与坚持之后 柔水终成雕刀 注：席慕容的一首诗歌，非常喜欢，尤其是最后三句。 ","date":"2020-03-06","objectID":"/2020/%E9%9B%95%E5%88%80/:0:0","tags":["文摘"],"title":"雕刀","uri":"/2020/%E9%9B%95%E5%88%80/"},{"categories":["爱编程爱技术的孩子"],"content":"二叉搜索树是二叉树的一种特殊形式，由于它对查找的良好特性，使用较为广泛，本篇文章我们对其进行介绍，同时也包括二叉搜索树的各种进阶，比如二叉平衡树。 ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:0:0","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 二叉搜索树 ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:1:0","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 定义 二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树。其定义如下 二叉搜索树：是一颗二叉树，可以为空，如果不为空，满足下列性质 非空左子树的所有结点值小于其根结点的结点值 非空右子树的所有结点值小于其根结点的结点值 左右子树都是二叉搜索树 一种最常见的题型就是判断一棵树是否为二叉搜索树，我们可以利用递归的思路来解决该问题，示例代码如下，每个节点有一次递归调用，因此时间复杂度为O(n)，递归深度为树高，因此空间复杂度为O(h)，h 为树高。 func isValidBST(root *TreeNode) bool { return helper(root, math.MinInt64, math.MaxInt64) } func helper(root *TreeNode, lower, upper int) bool { if root == nil { return true } if root.Val \u003c= lower || root.Val \u003e= upper { return false } return helper(root.Left, lower,root.Val) \u0026\u0026 helper(root.Right, root.Val, upper) } 另外，我们还应该知道，对于二叉搜索树，中序遍历可以得到一个递增的序列，所以利用中序遍历也可以进行判断。代码如下，因为完全遍历一遍，时间复杂度为O(n)，栈的大小为节点数目，因此空间复杂度也为O(n) func isValidBST(root *TreeNode) bool { stack := make([]*TreeNode,0) preNum := math.MinInt64 // 用一个变量记录上一个数，和当前值比较 for root != nil || len(stack) != 0 { for root != nil { stack = append(stack,root) root = root.Left } if len(stack) != 0 { root = stack[len(stack)-1] stack = stack[:len(stack)-1] if root.Val \u003c= preNum { return false } preNum = root.Val root = root.Right } } return true } 两种写法中都要注意，二叉搜索树必须左子树的所有节点都小于当前节点值，右子树的所有节点都大于当前节点值，等于是不可以的。换句话说，序列是严格递增的。 ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:1:1","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 基本操作 二叉搜索树的基本操作包括查找、插入和删除。 查找 查找的基本思路是从根结点开始，如果树为空，返回NULL，如果树非空，则将根结点的值和X进行比较，分情况处理： 如果X小于根结点的值，在左子树中继续搜索 如果X大于根结点的值，在右子树中继续搜索 若两者值相等，搜索完成，返回指向该结点的指针 递归的实现思路如下，空间复杂度O(h)，时间复杂度O(h) func searchBST(root *TreeNode, val int) *TreeNode { if root == nil || root.Val == val { return root } if val \u003c root.Val { return searchBST(root.Left,val) }else{ return searchBST(root.Right,val) } } 迭代的实现思路如下，空间复杂度O(1)，时间复杂度O(h) func searchBST(root *TreeNode, val int) *TreeNode { for root != nil { if val \u003c root.Val { root = root.Left }else if val \u003e root.Val { root = root.Right }else{ return root } } return nil } 插入 二叉搜索树插入节点的方法是将其作为某个叶节点的子节点，核心是找到待插入的叶节点，一个递归的实现如下，时间和空间复杂度都是O(h) func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { root = \u0026TreeNode{val, nil, nil} } if val \u003e root.Val { root.Right = insertIntoBST(root.Right, val) } else if val \u003c root.Val { root.Left = insertIntoBST(root.Left, val) } return root } 迭代的实现如下，时间复杂度为O(h)，空间复杂度为O(1) func insertIntoBST(root *TreeNode, val int) *TreeNode { newNode := \u0026TreeNode{Val:val} cur := root for cur != nil { if val \u003c cur.Val { if cur.Left == nil { cur.Left = newNode return root }else{ cur = cur.Left } }else if val \u003e cur.Val { if cur.Right == nil { cur.Right = newNode return root }else{ cur = cur.Right } } } return newNode } 删除 二叉树的删除比较复杂，要考虑三种情况 要删除的是叶节点，则直接删除，并修改其父结点指针为NULL 要删除的结点只有一个孩子，则将其父结点的指针指向要删除结点的孩子结点 要删除的结点有左右两颗子树，则用另一个结点替代被删除的结点，可以是右子树的最小结点，也可以是左子树的最大结点 所以删除操作会涉及两个额外的操作，查找最大和最小元素，这两个操作只需要记住两点： 最大元素一定在树的最右分支的端结点上 最小元素一定在树的最左分支的端结点上 查找最小元素的递归方法参考实现如下 func FindMin(root *TreeNode) *TreeNode { if root == nil return nil else if root-\u003eLeft == nil return root else return FindMin(root-\u003eLeft) } 查找最大元素的迭代方法参考实现如下 func findMax(root *TreeNode) *TreeNode { if root != nil { for root.Right != nil { root = root.Right } } return root } 最后，删除操作的参考实现如下，时间复杂度和空间复杂度都是O(h) func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if key \u003c root.Val { root.Left = deleteNode(root.Left, key) } else if key \u003e root.Val { root.Right = deleteNode(root.Right, key) } else { if root.Left != nil \u0026\u0026 root.Right != nil { root.Val = findMin(root.Right).Val root.Right = deleteNode(root.Right, root.Val) } else { if root.Left == nil { root = root.Right } else if root.Right == nil { root = root.Left } } } return root } ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:1:2","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 最近公共祖先 最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 虽然我们这里讨论二叉搜索树的最近公共祖先，但对于普通的二叉树，也有求最近公共祖先的题型，其递归解法遵循这样的思路 如果根结点为 nil，那么最近公共祖先为 nil 如果根结点等于两个节点中的任何一个，那么最近公共祖先就是根结点 此时我们递归调用分别求以左节点和右节点为根，针对 p,q 两个节点的最近公共祖先，如果两边返回的值都不为空，那么最近公共祖先是根结点。这里的逻辑是这样的，因为我们前面的条件中只要 p或q 任何一个节点等于根结点，就会返回，所以这一步递归调用的结果只能说明子树中包含 p 或 q，所以如果两个子树的返回值都不为空，说明 p,q 分别位于两个子树中，那么最近公共祖先是根结点； 这一步我们就能确定最近公共祖先不是在左子树就是在右子树，返回非空的一方即可 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026\u0026 right != nil { return root } if left == nil { return right } return left } 递归解法的时间和空间复杂度都是O(n)，如果用迭代解法，其实就是遍历二叉树，然后用哈希表记录每个节点的父节点，然后遇到 p 和 q 就往祖先节点回溯，找到公共的祖先。 如果求二叉搜索树的最近公共祖先，二叉树的解法当然是适用的，但是没有充分利用二叉搜索树的特性，如果我们利用其二叉搜索树的特性，递归的思路更加简单。我们可以这样想 从根结点开始 如果节点 p 和节点 q 的值都小于根结点的值，那么最近公共祖先一定在左子树； 如果节点 p 和节点 q 的值都大于根结点的值，那么最近公共祖先一定在右子树。 代码如下，时间复杂度和空间复杂度都是O(h)，h为树高 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if p.Val \u003c root.Val \u0026\u0026 q.Val \u003c root.Val { return lowestCommonAncestor(root.Left,p,q) } if p.Val \u003e root.Val \u0026\u0026 q.Val \u003e root.Val { return lowestCommonAncestor(root.Right,p,q) } return root } 如果我们用迭代的话，还是同样的思路，但是空间复杂度可以到O(1) func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { for root != nil { if p.Val \u003c root.Val \u0026\u0026 q.Val \u003c root.Val { root = root.Left }else if p.Val \u003e root.Val \u0026\u0026 q.Val \u003e root.Val { root = root.Right }else{ return root } } return nil } ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:1:3","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 平衡二叉树 平衡二叉树（Balanced Binary Tree），它要么是一颗空树，要么满足任一结点左右子树高度差的绝对值不超过1。一般使用「平衡因子（Balance Factor, BF）」来描述这一高度差，设HL和HR分别为树T左右子树的高度，则BF满足： $$ BF(T) = \\left|H_L - H_R\\right| \\le 1 $$ 此外，平衡二叉树的高度为$O(\\log_2n)$,证明如下 设$f_n$为高度为n的AVL树所包含的最少结点数，则有 $$ f_n= \\begin{cases} 1\u0026(n=1)\\ \\\\ 2\u0026(n=2)\\ \\\\ f_{n-1}+f_{n-2}+1\u0026 (n\u003e2) \\end{cases} $$ 显然$\\{ f_n + 1 \\}$是一个斐波那契数列，由于斐波那契数列以指数的速度增长，因此AVL树的高度为$O(\\log_2n)$ 注意，给定节点数，树高可能有两种情况，我们对树高和这个高度允许的节点数列表如下， 树高 节点数范围 1 1 2 2-3 3 4-7 4 7-15 5 12-31 所以给定节点数N，其高度可能是 $log_2n- 1$ 或 $log_2n$ 或 $log_2n +1$ 给定高度，最少节点数就只能通过递推得到，或者通过通项公式，最多节点数就是满二叉树的节点个数。 判断一棵二叉树是否为平衡二叉树，根据定义，我们有两种思路 计算节点总数和树的高度，从而确定树是否平衡（实际实践有难度，因为通项公式不容易求）； 分别计算左右子树的深度，然后判断差是否为1 以第二种方法为例，代码如下 func isBalanced(root *TreeNode) bool { if root == nil { return true } t := height(root.Left) - height(root.Right) if t \u003e 1 || t \u003c -1 { return false } return isBalanced(root.Left) \u0026\u0026 isBalanced(root.Right) } func height(root *TreeNode) int { if root == nil { return 0 } return max(height(root.Left), height(root.Right))+1 } func max(a,b int) int { if a \u003e b { return a } return b } ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:2:0","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 平衡二叉搜索树 平衡二叉搜索树的意义在于将针对二叉搜索树的算法复杂度限制到 O(logN)，因为二叉搜索树的复杂度通常为O(h)，最坏情况下，树成为链，树高将等于树中节点个数，我们将二叉搜索树调整为平衡的，就可以令树高最小，即 logN。 有许多方法可以实现平衡二叉搜索树，包括红黑树、AVL树、伸展树、树堆等。下面仅介绍 AVL 树，红黑树在后面的文章中介绍，不过在此之前，先介绍一个有意思的题型：将二叉搜索树变平衡。 ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:3:0","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 将二叉搜索树变平衡 给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。 该题当然不是要我们利用后面的 AVL 或红黑树，而是要重复利用二叉搜索树这一个条件。思路很简单，就是将二叉搜索树利用中序遍历变为递增序列，然后以中间节点为根结点重新构造二叉搜索树，这是一个贪心的思路。最后实现的代码如下 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func balanceBST(root *TreeNode) *TreeNode { // 先中序遍历排序 if root == nil { return root } var seqList []int midOrder(root, \u0026seqList) // 然后用二分法分别构建左右子树 return build(0, len(seqList) - 1, seqList) } func midOrder(root *TreeNode, list *[]int) { if root == nil { return } midOrder(root.Left, list) *list = append(*list, root.Val) midOrder(root.Right, list) } func build(l, r int, list []int) *TreeNode { if r \u003c l { return nil } mid := (l + r) \u003e\u003e 2 root := \u0026TreeNode{Val: list[mid]} root.Left = build(l, mid - 1, list) root.Right = build(mid + 1, r, list) return root } ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:3:1","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 AVL树 AVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的，它是最先发明的平衡二叉查找树。 由于AVL树同样是一颗二叉搜索树，插入和删除的算法和二叉搜索树相同，但是插入和删除结点后，会造成树高和平衡因子的变化，从而不满足平衡二叉树的条件，因此需要对其进行调整。 以插入为例，将所有情况和对应的处理措施分为四种 RR 意为插入的结点在失衡点右子树的右子树中（左右孩子处理办法都一样），其解决办法是进行一次左旋转，如下图所示，14为新插入的结点。需要注意的是失衡点不一定是根结点。 简单的代码实现如下 func leftRotate(root *TreeNode) *TreeNode { tmp := root.Right root.Right = tmp.Left tmp.Left = root root.Height = max(getHeight(root.Left), getHeight(root.Right)) + 1 tmp.Height = max(getHeight(tmp.Left), getHeight(tmp.Right)) + 1 return tmp } RL 意为插入的结点在失衡点右子树的左子树中（左右孩子都一样），其解决办法是先进行一次右旋转，再进行一次左旋转，如下图所示，插入结点分别为10.5和11.5 简单的代码实现如下 func rightThenLeftRotate(root *TreeNode) *TreeNode { tmp := rightRotate(root.Right) root.Right = tmp return leftRotate(root) } LL 意为插入的结点在失衡点左子树的左子树中（左右孩子都一样），其解决办法是进行一次右旋转，如下图所示，6为插入的新结点 简单的代码实现如下 func rightRotate(root *TreeNode) *TreeNode { tmp := root.Left root.Left = tmp.Right tmp.Right = root root.Height = max(getHeight(root.Left), getHeight(root.Right)) + 1 tmp.Height = max(getHeight(tmp.Left), getHeight(tmp.Right)) + 1 return tmp } LR 意为插入的结点在失衡点左子树的右子树中（左右孩子都一样），其解决办法是先进行一次左旋转，再进行一次右旋转，如下图所示，插入结点为8.5和9.5 简单的代码实现 func leftThenRightRotate(root *TreeNode) *TreeNode { tmp := leftRotate(root.Left) root.Left = tmp return rightRotate(root) } 对于AVL树的所有操作都建立在这四个基本操作之上，在插入和删除操作完成后，调用调整函数，然后在调整函数中分情况调用这四个函数。调整函数的实现如下 func ajust(root *TreeNode) *TreeNode { if root == nil { return nil } compare := getHeight(root.Right) - getHeight(root.Left) if compare == 2 { if getHeight(root.Right.Right) \u003e getHeight(root.Right.Left) { root = leftRotate(root) } else { root = rightThenLeftRotate(root) } } else if compare == -2 { if getHeight(root.Left.Left) \u003e getHeight(root.Left.Right) { root = rightRotate(root) } else { root = leftThenRightRotate(root) } } return root } 其中用到寻找最大值和获取高度两个工具函数，实现如下 func getHeight(root *TreeNode) int { if root == nil { return 0 } return root.Height } func max(a int, b int) int { if a \u003e b { return a } else { return b } } ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:3:2","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 哈夫曼树 ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:4:0","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 定义 设二叉树有 n 个叶子结点，每个叶子结点带有权值 wk，从根结点到每个叶子结点的长度位 lk，则每个叶子结点的带权路径长度（WPL）之和为： $$ WPL = \\sum_{k=1}^{n} w_k l_k $$ WPL 最小的二叉树就叫做哈夫曼树（或者最优二叉树）。其特点有 没有度为1的结点 n个叶子结点的哈夫曼树共有2n-1个结点，因为对二叉树而言有$n_0=n_2+1$ 哈夫曼树的任意非叶节点的左右子树交换后仍然是哈夫曼树 对同一组权值存在不同构的两棵哈夫曼树，例子如下 ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:4:1","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 构造 构造哈夫曼树的思路极为简单，即每次把权值最小的两棵二叉树合并，以{1，2，3，4，5}这组数为例，构造过程如下 其构造的关键在于每次寻找剩余结点中的最小值，最简单的实现是使用堆 type TreeNode struct { Weight int Left *TreeNode Right *TreeNode } func Huffman(H MinHeap) { //假设MinHeap类型已实现标准库中堆的相关接口，H已存好所有权值 var T TreeNode heap.Init(H) for i := 1; i \u003c H.Len(); i++ { T = TreeNode{} T.Left = H.Pop(H) T.Right = H.Pop(H) T.Weight = T.Left.Weight + T.Right.Weight H.Push(H, T) } T = H.Pop(H) return T } ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:4:2","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"4.3 哈夫曼编码 该问题的描述为：给定一段字符串，如何堆字符进行编码，可以使得该字符串的编码存储空间最少 例：假设有一段文本，包含58个字符，并由以下7个字符构成：a，e，i，s，t，空格(sp)，换行(nl)；这7个字符出现的次数不同，如何对这7个字符进行编码，可以使得总编码空间最少 如果用等长ASCII编码，则一共 58×8=464 位；如果用等长3位编码，则一共 58×3=174位；最后一种方法是不等长编码，即出现频率高的字符编码短，出现频率低的字符编码长。 使用不等长编码时，为了避免二义性，可以使用前缀码（prefix code），即任何字符的编码都不是另一字符编码的前缀。将二叉树用于编码，遵循下面的规则 左右分支：0，1 字符只在叶节点上 假设四个字符的频率分别为：a-4, u-1, x-2, z-1，两个可用的编码树如下 字符 a e i s t sp nl 权值 10 15 12 3 4 13 1 按照构造哈夫曼树的方法，可以构造棵编码代价最小的二叉树，假设之前例子中的7个字符权值如上表，则可构造得到如下的哈夫曼编码树 ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:4:3","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"参考资料 [1] CSDN-Golang实现平衡二叉树 ","date":"2020-03-03","objectID":"/2020/data-structure-binary-search-tree/:5:0","tags":["数据结构与算法"],"title":"数据结构-二叉搜索树","uri":"/2020/data-structure-binary-search-tree/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第九期，由于经历了图床转换，本文图片已丢失。 ","date":"2020-02-28","objectID":"/2020/life-weekly-9/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 9 期 (20200228)","uri":"/2020/life-weekly-9/"},{"categories":["日程及周刊"],"content":"时讯 1、新冠肺炎疫情 截至2020年2月28日0:00，新冠肺炎国内累计确诊78824人，死亡2788人，除湖北外其它省份的疫情均已得到控制，大部分省份每日新增病例已经为0。另外需要注意的是，本周其它国家的病例增长总数首次超过国内，世界范围内疫情形势严峻，其中尤以日本、韩国、意大利最为严重，多数患者可能与「钻石公主号」邮轮有关。 2、研究生扩招 首疫情影响，今年毕业生和农名工就业压力陡然增大，教育部鼓励毕业生到国家重点工程、重大项目、重要领域就业，鼓励入伍参军，同时扩大硕士研究生招生规模，比去年增加18.9万，同时扩大普通高校专升本，同比争取增加32.2万人。 ","date":"2020-02-28","objectID":"/2020/life-weekly-9/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 9 期 (20200228)","uri":"/2020/life-weekly-9/"},{"categories":["日程及周刊"],"content":"小事 1、02.27，今年生日难得在家过，一家人都在，疫情也不是没有好的方面。 2、02.28，老爸复工了，上午开车走的，而我复学还不知道什么时候。 ","date":"2020-02-28","objectID":"/2020/life-weekly-9/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 9 期 (20200228)","uri":"/2020/life-weekly-9/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-02-28","objectID":"/2020/life-weekly-9/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 9 期 (20200228)","uri":"/2020/life-weekly-9/"},{"categories":["日程及周刊"],"content":"工具 1、CrystalDiskInfo 磁盘检查工具，主要用来评估磁盘读写速度和使用寿命，防止哪天磁盘突然损坏丢失数据。动漫版的界面让人非常喜欢。 2、dropIt 文件分类的利器，预设规则，将一堆文件拖到图标上就可以根据文件类型、创建时间等属性自动化地处理，包括移动到指定文件夹，压缩解压，重命名等。 ","date":"2020-02-28","objectID":"/2020/life-weekly-9/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 9 期 (20200228)","uri":"/2020/life-weekly-9/"},{"categories":["日程及周刊"],"content":"概念 1、几种酒 练习英语听力的时候学到的几种酒类，就顺便查了一下。第一种是马提尼(martini)，一种强化葡萄酒，即在葡萄酒酿制完成的后期，加入烈性白酒和蜜糖，将酒质改变，而成为另一种酒。在西方多作为开胃酒在饭前饮用，也可掺水加冰后饮用。第二种是玛格丽特(margarita)，世界上知名度最高的传统鸡尾酒之一，是一位洛杉矶的酒吧调酒师Jean Durasa在1949年美国举行的全国鸡尾酒大赛上的作品，获得了当年的冠军。之所以命名为Margarita cocktail，是想纪念他的已故恋人Margarita。1926年，Jean Durasa去墨西哥，与Margarita相恋，墨西哥成了他们的浪漫之地。然而，有一次当两人去野外打猎时，玛格丽特中了流弹，最后倒在恋人Jean Durasa的怀中，永远离开了。于是，Jean Durasa就用墨西哥的国酒Tequila为鸡尾酒的基酒，用柠檬汁的酸味代表心中的酸楚，用盐霜意喻怀念的泪水。mojito，也是鸡尾酒的一种，并不浓烈，但是喝一杯下去，脸上会泛起红晕，像少女的羞涩。味道很清新，有一点青涩、有点甜蜜，象单纯青柠般的初恋。是美国作家海明威最喜欢的酒之一。 2、MECE分析法 Mutually Exclusive Collectively Exhaustive，中文意思是「相互独立，完全穷尽」。 也就是对于一个重大的议题，能够做到不重叠、不遗漏的分类，而且能够借此有效把握问题的核心，并解决问题的方法。「相互独立(ME)」意味着问题的细分是在同一维度上并有明确区分、不可重迭的，「完全穷尽(CE)」 则意味着全面、周密。 举个例子，比如音乐分类，按歌手性别分为男歌手和女歌手，是 MECE 的； 按音乐类别分为摇滚、爵士、民谣等等，也是 MECE 的； 按语言分为外语、粤语、闽南语等等，也是 MECE 的； 按地理位置分为欧美、日本、港澳、台湾、内地也是 MECE 的。 但如果你分为流行、经典、网络、KTV、汽车这样的，分类即会有遗漏，也会有重复，就非 MECE 了。 ","date":"2020-02-28","objectID":"/2020/life-weekly-9/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 9 期 (20200228)","uri":"/2020/life-weekly-9/"},{"categories":["日程及周刊"],"content":"文章 1、Manu’s Guide To Minimalism. Manu Moreale关于极简主义的一个系列文章，他提到所谓的「极简」不关乎视觉、设计、美学──甚至不是一种生活方式，而是一种 「mindset」。还没有完全的看一遍。 2、2019 我的极简生活 作者对极简主义的一些理解和Notion的一些实践，虽然在多次使用后我还是习惯不了Notion，但不妨碍这篇文章写的真的还可以。 3、如何阅读一篇论文 作者介绍了自己总结的一种阅读论文的方法，称为「三步法」 4、7天用 Go 从零实现系列 使用 Go 语言，从零开发一些常用 App 的代码示例。 ","date":"2020-02-28","objectID":"/2020/life-weekly-9/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 9 期 (20200228)","uri":"/2020/life-weekly-9/"},{"categories":["爱编程爱技术的孩子"],"content":"树是反映事物之间层次关系的一种结构，比如家谱树、硬盘目录结构树等。 使用树的原因是这种层次结构在管理上有更高的效率，以查找为例，顺序查找的时间复杂度是O(n)，而二分查找的时间复杂度是O(log2n)，可以看到查找效率得到了很大的提高，这是因为二分查找本质上是对一颗树的查找。 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:0:0","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 树 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:1:0","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 定义 树（Tree）是由 n（n$\\geq$0）个结点构成的有限集合，当 n=0 时，称为空树，而对于任一颗非空树（n\u003e0），它具有如下性质： 树中有一个称为「根（Root)」的特殊结点，用 r 表示 其余结点可分为 m(m\u003e0) 个互不相交的有限集 T1, T2, … , Tm，其中每个集合本身又是一棵树，称为原来树的「子树（SubTree）」 在判断是否是一颗树的时候，有以下注意点： 子树是不相交的； 除根节点外，每个节点有且仅有一个父节点； 一颗 N 个结点的树有 N-1 条边 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:1:1","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 术语 与树相关的一些术语如下表所示 术语 英文 描述 结点的度 Degree 结点的子树个数 树的度 树的所有结点中最大的度数 叶结点 Leaf 度为0的结点 父结点 Parent 有子树的结点是其子树的根结点的父节点 子结点 Child 若A结点是B结点的父结点，则称B结点是A结点的子结点； 子结点也称孩子结点 兄弟结点 Sibling 具有同一父结点的各结点彼此是兄弟结点 路径 Path 从结点n1到nk的路径为一 个结点序列n1 , n2 , … , nk , ni是 ni+1的父结点 路径长度 路径所包含边的个数为路径的长度。 祖先结点 Ancestor 沿树根到某一结点路径上的所有结点都是这个结点的祖先结点 子孙结点 Descendant 某一结点的子树中的所有结点是这个结点的子孙 结点的层次 (结点的深度) Level 规定根结点在1层，其它任一结点的层数是其父结点的层数加1 树的深度 Depth 树中所有结点中的最大层次是这棵树的深度 结点的高度 Height 结点的深度从上往下数，而结点的高度从下往上数 以定义中的树T解释如下图 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:1:2","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 表示方法 树的表示使用儿子兄弟表示法，如下图所示，可以在合理表示的同时最大限度节省存储空间 上图经过旋转，就可以形成一颗二叉树，因此，对数的处理就变成对二叉树的处理过程 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:1:3","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 二叉树 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:2:0","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 定义 二叉树T：一个有穷的结点集合，可以为空。不为空时，是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。 二叉树有如下五种基本形态 同时，这里还有几种特殊的二叉树 斜二叉树（Skewed Binary Tree) 完美二叉树（Perfect Binary Tree），也称作满二叉树（Full Binary Tree） 完全二叉树（Complete Binary Tree）：有n个结点的二叉树，对树中结点按从上到下、从左到右顺序进行编号，编号为i（1≤ i ≤ n）结点与满二叉树中编号为i结点在二叉树中位置相同 二叉树有几个重要性质 一个二叉树第 i 层的最大结点数为：$2^{i-1}, i\\ge1$ 深度为 k 的二叉树有最大结点总数为：$2^k-1, k\\ge1$ 对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点个数，那么两者满足关系$n_0=n_2+1$，推导过程如下： 设$n_0$为叶结点的个数，$n_1$是度为1的结点个数，$n_2$为度为2的结点个数 按照边的数量建立等式 $$ n_0 + n_1 + n_2 -1 = 0 \\times n_0 + 1 \\times n_1 + 2 \\times n_2 $$ 移项可得结果 $n_0=n_2+1$ 现在对二叉树的抽象数据类型进行定义 类型名称：二叉树 数据对象集：一个有穷的结点集合。若不为空，则由根结点和其左、右二叉子树组成 操作集：BT∈BinTree, Item∈ElementType，重要操作有： 1. Boolen IsEmpty(BinTree BT)：判断BT是否为空； 2. void Traversal(BinTree BT)：遍历，按某顺序访问每个结点； 3. BinTree CreatBinTree()：创建一个二叉树。 常用的遍历方法有： void PreOrderTraversal( BinTree BT )：先序遍历—根、左子树、右子树 void InOrderTraversal( BinTree BT )：中序遍历—左子树、根、右子树 void PostOrderTraversal( BinTree BT )：后序遍历—左子树、右子树、根 void LevelOrderTraversal( BinTree BT )：层次遍历—从上到下、从左到右 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:2:1","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 存储结构 数组 完全二叉树可以按照从上到下、从左到右的顺序进行存储，如下图所示，一个n个结点的完全二叉树的结点序号有如下规则： 非根结点（序号i\u003e1）的父结点的序号$i/2$； 结点（序号为i）的左孩子结点的序号是$2i$，需要满足$2i \\le n$，否则没有左孩子； 结点（序号为i）的右孩子结点的序号是$2i+1$，需要满足$2i+1 \\le n$，否则没有右孩子。 一般的二叉树也可以采用这种结构，只要按照完全二叉树的形式将空结点在数组中对应的值置空即可，但会造成空间的浪费… 链表 链表是最常用的表示一般二叉树的方法。一个简单表示如下 type TreeNode struct{ Data ElementType Left *TreeNode Right *TreeNode } 以一个简单的二叉树为例，基本的结点结构和完整的二叉树链表如下所示 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:2:2","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 遍历 先序遍历 先序遍历的过程为： 访问根结点； 先序遍历其左子树； 先序遍历其右子树； 对应的程序实现如下 func PreOrderTraverse(root *TreeNode) { if root != nil { visit(root.Data) PreOrderTraverse(root.Left) PreOrderTraverse(root.Right) } } 上述程序使用了递归的方法，也可以使用非递归的方法，基本的思路是使用堆栈。 如上图所示，在树的遍历过程中，每个结点被遇到三次，在第一次遇到时，我们将结点入栈，在最后一次离开时，我们将结点出栈。先序遍历就是在第一次遇到结点(入栈)时访问结点，因此程序如下： func PreOrderTraversal(root *TreeNode) stack := CreatStack() for root != nil || stack.Len() != 0 { for root != nil { stack.PushBack(root) visit(root.Data) root = root.Left } if stack.Len() != 0 { root = stack.Remove(stack.Back()).(*TreeNode) root = root.Right } } } 中序遍历 中序遍历的过程为： 中序遍历其左子树 访问根结点 中序遍历其右子树 对应的程序实现如下 func InOrderTraverse(root *Treenode) { if root != nil { InOrderTraverse(root.Left) visit(root.Data) InOrderTraverse(root.Right) } } 中序遍历也可以使用非递归的方法实现。实际上，前序、中序和后序走的路线是相同的，唯一的区别是访问结点的时机不同，在中序遍历中，是在第二次遇到结点时访问结点，如上图所示，因此中序非递归遍历的程序如下 func InOrderTraversal(root *TreeNode) stack := CreatStack() for root != nil || stack.Len() != 0 { for root != nil { stack.PushBack(root) root = root.Left } if stack.Len() != 0 { root = stack.Remove(stack.Back()).(*TreeNode) visit(root.Data) root = root.Right } } } 中序遍历的特殊之处在于，对于二叉搜索树，通过中序遍历可以得到一个递增的有序序列。 后序遍历 后序遍历的过程为： 后序遍历其左子树 后序遍历其右子树 访问根结点 对应的程序实现如下 func PostOrderTraverse(root *TreeNode) { if root != nil { PostOrderTraverse(root.Left) PostOrderTraverse(root.Right) visit(root.Data) } } 后序遍历是在第三次遇到结点时访问结点，它的非递归实现要复杂一点，需要增加一个栈标记到达结点的次序 func PostOrderTraversal(BinTree BT) { stack := Creatstack() tag := make(map[*TreeNode]bool) for root != nil || stack.Len() != 0 { for root != nil { stack.PushBack(root) root = root.Left } if stack.Len() != 0 { root = stack.Back().Value.(*TreeNode) if !tag[root] { tag[root] = true root = root.Right } else { root = stack.Remove(stack.Back()).(*TreeNode) visit(root.Data) root = nil } } } } 层次遍历 二叉树遍历的核心问题是二维结构的线性化，层次遍历的思想是利用队列，首先将根结点入队，然后开始执行循环： 从队列中取出一个元素 访问该元素所指结点 若该元素所指结点的左右孩子结点非空，则将其左右孩子的指针顺序入队 程序实现如下 func LevelOrderTraversal(root *TreeNode) { if root == nil { return } queue := CreatQueue() queue.PushBack(root) for queue.Len() != 0 { root = queue.Remove(queue.Front()).(*TreeNode) visit(root.Data) if root.Left != nil { queue.PushBack(root.Left) } if root.Right != nil { queue.PushBack(root.Right) } } } 树的层序遍历其实就是对树执行广度优先搜索。 注：还有一种遍历方法叫做 莫里斯（Morris）遍历，可以将空间复杂度降到 O(1) ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:2:3","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 运用递归求解问题 树本身就是通过递归定义的，因此很多与树相关的问题都可以通过递归来解决。每个递归层次中，我们只关注当前节点的问题，子节点通过递归调用函数来解决。 递归的思路共有两种：自顶向下和自底向上。自顶向下指的是先对当前节点值进行处理，然后将处理结果通过递归调用函数传递给子节点。自底向上则指在每个递归层次首先调用递归函数处理子节点，然后根据返回值和当前节点的值得到答案。 下面以一些最常见的题目来说明如何用递归法求解二叉树问题，使用的二叉树节点的定义如下 type TreeNode struct { Val int Left *TreeNode } ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:3:0","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。树的深度是指从根节点到最远叶节点的最长路径的节点数。 自顶向下的方法中，基本思想是，如果我们知道当前节点深度，那么子节点的深度就是当前节点深度加1，在递归调用时，将当前节点深度作为参数，这样所有节点都可以知道自己的深度，我们只需要在遇到叶节点时更新树的深度即可。初始条件定义为根结点深度=1. var answer int func maxDepth(root *TreeNode, depth int) { if root == nil { return } if root.Left == nil \u0026\u0026 root.Right == nil { if depth \u003e answer { answer = depth } } maxDepth(root.Left, depth + 1) maxDepth(root.Right, depth + 1) } 自底向上的方法中，当前节点的最大深度就等于以左节点为根的子树和以右节点为根的子树的深度最大值+1 func maxDepth(root *TreeNode) int { if root == nil { return 0 } HL := maxDepth(root.Left) HR := maxDepth(root.Right) if HL \u003e HR { return HL + 1 }else{ return HR + 1 } } 与深度相对的，有时候也会求解二叉树的最小深度，最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 func minDepth(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil \u0026\u0026 root.Right == nil { return 1 } HL := minDepth(root.Left) HR := minDepth(root.Right) if root.Left == nil { return HR + 1 }else if root.Right == nil { return HL + 1 }else{ if HL \u003c HR { return HL + 1 }else{ return HR + 1 } } } ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:3:1","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 对称二叉树 给定一个二叉树，检查它是否是镜像对称的。 func isSymmetric(root *TreeNode) bool { return isMirror(root, root) } func isMirror(l,r *TreeNode) bool { if l == nil \u0026\u0026 r ==nil { return true } if l == nil || r == nil { return false } if l.Val != r.Val { return false } return isMirror(l.Left, r.Right) \u0026\u0026 isMirror(l.Right, r.Left) } ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:3:2","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-\u003e4-\u003e11-\u003e2。 递归的思路非常简单 func hasPathSum(root *TreeNode, sum int) bool { if root == nil { return false } sum -= root.Val if root.Left == nil \u0026\u0026 root.Right == nil { return sum == 0 } return hasPathSum(root.Left,sum) || hasPathSum(root.Right,sum) } 迭代的解题思路是利用遍历，不断更新目标和并与当前节点比较。所有的遍历方式都可用，下面是 BFS 的示例。 func hasPathSum(root *TreeNode, sum int) bool { if root == nil { return false } queue := list.New() queue.PushBack(root) for queue.Len() != 0 { root = queue.Remove(queue.Front()).(*TreeNode) if root.Left == nil \u0026\u0026 root.Right == nil { if root.Val == sum { return true } } if root.Left != nil { root.Left.Val += root.Val queue.PushBack(root.Left) } if root.Right != nil { root.Right.Val += root.Val queue.PushBack(root.Right) } } return false } 如果需要记录路径，可以使用如下方案 func pathSum(root *TreeNode, sum int) [][]int { var ret [][]int var path []int return dfs(root,path,ret,sum) } func dfs(root *TreeNode,path []int,ret [][]int,sum int) [][]int{ if root == nil { return ret } sum -= root.Val path = append(path,root.Val) if root.Left == nil \u0026\u0026 root.Right == nil { if sum == 0 { slice := make([]int,len(path)) copy(slice,path) ret = append(ret,slice) } return ret } if root.Left != nil { ret = dfs(root.Left,path,ret,sum) } if root.Right != nil { ret = dfs(root.Right,path,ret,sum) } return ret } ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:3:3","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 其它常见题型 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:4:0","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 翻转二叉树 对一棵二叉树进行镜像翻转，比如输入为 4 / \\ 2 7 / \\ / \\ 1 3 6 9 那么翻转后的输出为 4 / \\ 7 2 / \\ / \\ 9 6 3 1 递归的理解是翻转后的树是将左子树和右子树分别翻转后再进行翻转，写出来的程序有点像后序遍历 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left = invertTree(root.Left) root.Right = invertTree(root.Right) root.Left, root.Right = root.Right, root.Left } return root } 第三条翻转语句也可以放在左右子树翻转之前，即先对当前结点的左右子树翻转，再分别翻转左右子树。 func invertTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = root.Right, root.Left root.Left = invertTree(root.Left) root.Right = invertTree(root.Right) } return root } ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:4:1","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 二叉树的锯齿形层次遍历 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。例如：给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回锯齿形层次遍历如下 [ [3], [20,9], [15,7] ] 与层次遍历的想法基本相同，只是添加了一个层次判断，在奇数层按原来的方法构造切片，在偶数层反向构造切片。由于Go的特性，这种方法很容易实现。 func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return nil } result := [][]int{} queue := list.New() queue.PushBack(root) for tmp := 1; queue.Len() != 0; tmp++ { level := []int{} currentLevel := queue.Len() for i := 0; i \u003c currentLevel; i++ { root := queue.Remove(queue.Front()).(*TreeNode) if tmp % 2 == 1 { level = append(level, root.Val) }else{ level = append([]int{root.Val},level...) } if root.Left != nil { queue.PushBack(root.Left) } if root.Right != nil { queue.PushBack(root.Right) } } result = append(result, level) } return result } ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:4:2","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"4.3 由树的两种遍历序列还原二叉树 假设树中没有重复元素，根据两种遍历序列构造出原来的二叉树。需要注意的是，两种遍历序列中必须有中序遍历，也就是说，只给出先序和后序是无法确定棵二叉树的。 首先介绍如何根据先序和中序遍历确定一棵二叉树，步骤如下 根据先序遍历序列的第一个结点确定根结点 根据根结点在中序遍历序列中分割出左右两个子序列 对左子树和右子树分别递归使用相同的方法继续分解 func buildTree(preorder []int, inorder []int) *TreeNode { if len(inorder) == 0{ return nil } idx := -1 for i,v:=range inorder{ if v == preorder[0]{ idx = i } } root := \u0026TreeNode{Val:preorder[0]} root.Left = buildTree(preorder[1:idx+1],inorder[:idx]) root.Right = buildTree(preorder[idx+1:],inorder[idx+1:]) return root } 后序遍历的思想类似 func buildTree(inorder []int, postorder []int) *TreeNode { if len(inorder) == 0 { return nil } idx := -1 for i,v := range inorder { if v == postorder[len(postorder)-1] { idx = i } } root := \u0026TreeNode{Val:postorder[len(postorder)-1]} root.Left = buildTree(inorder[:idx], postorder[:idx]) root.Right = buildTree(inorder[idx+1:], postorder[idx:len(postorder)-1]) return root } ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:4:3","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"参考资料 [1] 中国大学MOOC平台-浙江大学数据结构 [2] bilibili-浙江大学数据结构 ","date":"2020-02-24","objectID":"/2020/data-structure-tree-and-binary-tree/:5:0","tags":["数据结构与算法"],"title":"数据结构-二叉树","uri":"/2020/data-structure-tree-and-binary-tree/"},{"categories":["爱编程爱技术的孩子"],"content":"队列与栈是最常使用的两种数据结构，其中，队列的核心特征是先入先出，栈的核心特征是后入先出，只要符合这两个特征，就属于队列（栈），不因实现形式的不同（数组或链表）而有差别，可以根据具体情况选择使用起来更方便的实现形式。 在本文中，我们对队列与栈的核心功能，循环队列这种特殊结构，以及队列和栈的主要应用，尤其是广度优先搜索和深度优先搜索进行介绍。 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:0:0","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 队列 队列是一个先入先出的数据结构，插入时新元素只能添加到队列末尾，取出时只能获取第一个元素。也因此我们需要维护两个指针。 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:1:0","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 队列实现 队列的实现可以使用动态数组或链表，最基本的功能包括：插入，删除，取第一个元素以及判空。由于 Golang 切片的易操作性，队列的实现即为简单，front 和 rear 指针被隐藏了起来。 queue := make([]int,0) // 建立队列 queue = append(queue, value) // 插入元素 queue = queue[1:] // 删除元素 value := queue[0] // 取第一个元素 if len(queue) == 0 {} // 判空 但当我们使用链表实现时，头尾指针是必需的，维持头和尾两个指针可以将插入和删除操作的复杂度保持在$O(1)$。 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:1:1","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 利用标准库实现 Go 没有提供内置的队列库，是因为可以很容易使用链表实现，只要保证新元素添加到链表尾，取元素从链表头取即可。 queue := list.New() // 建立队列 queue.PushBack(value) // 入队：添加新元素到末尾 queue.Front().Value.(valueType) // 获取队首元素 queue.Remove(queue.Front()).(valueType) // 出队：删除队首元素 queue.Len() // 队列长度 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:1:2","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 循环队列 队列对空间的浪费比较严重，这从上面的程序中可以看出，因为数组在在不停地延长，而头指针之前指向的空间都没有被释放。循环队列是解决该问题的一种办法，主要思路是重用之前被浪费的存储。 循环队列使用一段固定的空间，当尾指针指向队列尾时，如果有新元素添加进来而队列非空，可以将尾指针重新指向最开始的存储空间。循环队列的核心是队列空和满的判定，我们少用一个元素来区分队列空和队列满，约定 front 指向队列头元素，rear 指向队列尾元素的下一个位置，队列内容为 $[front,rear)$。 // 循环队列结构定义 type MyCircularQueue struct { queue []int front,rear int // front指向第一个元素，rear指向最后一个元素的下一个位置 } /** Initialize your data structure here. Set the size of the queue to be k. */ func Constructor(k int) MyCircularQueue { return MyCircularQueue{make([]int,k+1),0,0} } /** Insert an element into the circular queue. Return true if the operation is successful. */ func (this *MyCircularQueue) EnQueue(value int) bool { if this.IsFull() { return false } this.queue[this.rear] = value this.rear = (this.rear + 1) % len(this.queue) //尾指针防止溢出 return true } /** Delete an element from the circular queue. Return true if the operation is successful. */ func (this *MyCircularQueue) DeQueue() bool { if this.IsEmpty() { return false } this.front = (this.front + 1) % len(this.queue) //头指针防止溢出 return true } /** Get the front item from the queue. */ func (this *MyCircularQueue) Front() int { if this.IsEmpty() { return -1 } return this.queue[this.front] } /** Get the last item from the queue. */ func (this *MyCircularQueue) Rear() int { if this.IsEmpty() { return -1 } return this.queue[(this.rear - 1 + len(this.queue)) % len(this.queue)] //尾指针返回正确的位置 } /** Checks whether the circular queue is empty or not. */ func (this *MyCircularQueue) IsEmpty() bool { if this.front == this.rear { return true } return false } /** Checks whether the circular queue is full or not. */ func (this *MyCircularQueue) IsFull() bool { if (this.rear + 1) % len(this.queue) == this.front { return true } return false } 使用链表实现循环队列时在细节上可能有所不同。 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:1:3","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 队列与BFS 广度优先搜索（BFS）的实现与队列是密不可分的，最常用在树和图中，使用非常普遍。下面使用伪代码提供两个模板，一个是遍历，一个是找最短路径，这两个模板足够应付绝大多数题目。 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:2:0","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 遍历 遍历的伪代码模板如下，核心思想就是将初始节点入队，然后在循环中对队列头元素的所有邻居节点进行处理，如果没有被访问过就入队。 func BFS(root Node) { create queue // 创建队列，存储所有待处理结点 create visited // 标记已访问过的结点 add root to queue // 根结点入队 // BFS for queue is not empty { var cur Node = the first node in queue remove the first node from queue // 实际情况可将以上两步合并为一步 add cur to visited // 标记当前结点为已访问 for curNeighbor := range the neighbors of cur { if curNeighbor not in visited { add next to queue } } } } 以「岛屿数量」题目为例，给出一个改模板的使用示例。leetcode题目地址 // 题目描述 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或 垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例输入: 11000 11000 00100 00011 输出: 3 // 程序 func numIslands(grid [][]byte) int { var res int for i := 0; i \u003c len(grid); i++ { for j :=0 ; j \u003c len(grid[i]); j++ { // 将连成一篇的陆地算作1个 if grid[i][j] == '1' { BFS(grid,i,j) res++ } } } return res } type point struct { x,y int } func BFS(grid [][]byte, x,y int) { queue := []point{} queue = append(queue,point{x,y}) grid[x][y] = '0' //以“右-\u003e下-\u003e左-\u003e上”顺序循环，dx,dy是每一种转向的坐标变化方式 dx := []int{0, 1, 0, -1} dy := []int{1, 0, -1, 0} for len(queue) != 0 { cur := queue[0] queue = queue[1:] for i := 0; i \u003c 4; i++ { nx,ny := cur.x + dx[i],cur.y + dy[i] // 坐标超出界限或当前邻居结点为水域，进入下一个循环 if nx \u003c 0 || nx \u003e= len(grid) || ny \u003c 0 || ny \u003e= len(grid[cur.x]) || grid[nx][ny] == '0' { continue } queue = append(queue,point{nx,ny}) grid[nx][ny] = '0' // 入队时标记已访问，防止重复入队，陷入循环 } } } ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:2:1","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 最短路径 寻找最短路径的伪代码模板如下 // 如果找到返回最短路径 func BFS(root, target Node) int { create queue // 创建队列，存储所有待处理结点 create visited // 标记已访问过的结点 var shortestPath int // 根结点到当前节点的最短路径 // 初始化 add root to queue add root to visited // BFS for queue is not empty { shortestPath++ int size = queue.length(); for i = 0; i \u003c size; i++ { var cur Node = the first node in queue; return shortestPath if cur is target; for curNeighbor := range the neighbors of cur { if curNeighbor is not in visited { add next to queue add next to visited } } remove the first node from queue } } return -1; // 找不到最短路径 } 注：如果确定没有循环（比如树中）或者确实希望将结点多次加入队列，则不需要使用 visited 标记已访问结点。 这里有一些总结的技巧 已访问列表可充分利用原题的数组或链表值实现 已访问列表可使用 map 实现 使用 map 实现时，值类型为 bool 或 int 可用于不同的场景 对当前节点的所有邻居节点进行访问，如果是数组，可使用方向数组完成，其它场景则根据具体情况决定 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:2:2","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 栈 如下图，栈是一个后入先出的数据结构，插入（Push）和删除（Pop）都只能在栈顶操作。 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:3:0","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 栈实现 使用动态数组的简单实现如下 var stack []int // 初始化 func Constructor() { stack = make([]int,0) } // 入栈 func Push(value int) bool { stack = append(stack, value) return true } // 出栈 func Pop() bool { if len(stack) == 0 { return false } stack = stack[:len(stack)-1] return true } // 获取栈顶元素 func Top() int { if len(stack) == 0 { return -1 } return stack[len(stack)-1] } // 判空 func IsEmpty() bool { if len(stack) != 0 { return false } return true } ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:3:1","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 内置库 与对了相同，栈也可以很容易地使用 Go 提供的链表库实现 stack := list.New() // 建立队列 stack.PushBack(value) // 入队：添加新元素到末尾 stack.Back().Value.(valueType) // 获取队首元素 stack.Remove(queue.Back()).(valueType) // 出队：删除队首元素 stack.Len() // 队列长度 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:3:2","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 例子：有效括号 这是一个最经典也最简单的栈使用的例子，题目描述如下，leetcode题目地址 给定一个只包括 ‘('，')'，'{'，'}'，'['，']’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 func isValid(s string) bool { a := map[rune]rune{ '(': ')', '[': ']', '{': '}', } stack := []rune{} for _, v := range s { if len(stack) != 0 \u0026\u0026 a[stack[len(stack)-1]] == v { stack = stack[:len(stack)-1] continue } stack = append(stack, v) } if len(stack) != 0 { return false } return true } ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:3:3","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 栈和DFS 类似的，深度优先搜索（DFS）是栈的一种核心使用场景。DFS有两种实现方式，一种是递归，尽管递归的实现看起来没有使用栈，但实际上使用的是系统提供的隐式栈，也称为调用栈（Call Stack）；另一种就是显式的使用栈。 DFS 无法像 BFS 一样计算最短路径。 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:4:0","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 递归（隐式栈） 递归的模板如下 func DFS(cur, target Node, visited map[Node]bool) bool { create visited // 标记已访问结点 return true if cur is target for next : each neighbor of cur { if next is not in visited { add next to visted; return true if DFS(next, target, visited) == true; } } return false; } 仍以队列中的「岛屿数量」一题为例，DFS 递归解法如下 type point struct { x, y int //x,y分别为行号和列号 } func numIslands(grid [][]byte) int { var res int for i := 0; i \u003c len(grid); i++ { for j := 0; j \u003c len(grid[i]); j++ { // 连在一起的陆地算一个 if grid[i][j] == '1' { res++ DFS(grid, i, j) } } } return res } func DFS(grid [][]byte, row, col int) { //以“右-\u003e下-\u003e左-\u003e上”顺序循环，dx,dy是每一种转向的坐标变化方式 dx := []int{-1, 0, 1, 0} dy := []int{0, -1, 0, 1} grid[row][col] = '0' for i := 0; i \u003c 4; i++ { nx, ny := row+dx[i], col+dy[i] if nx \u003c 0 || nx \u003e= len(grid) || ny \u003c 0 || ny \u003e= len(grid[row]) || grid[nx][ny] == '0' { continue } // 当前邻居结点满足条件，标记为已访问，并递归对该结点执行DFS grid[nx][ny] = '0' DFS(grid, nx, ny) } } ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:4:1","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 显式栈 显式栈的模板如下 func DFS(root,target Node) { create stack create visited add root to stack; for stack is not empty { var cur Node = the top element in stack remove cur from stack return true if cur is target for Node next : the neighbors of cur { if next is not in visited { add next to stack add next to visited } } } return false } 「岛屿数量」一题的 DFS 显式栈解法如下 type point struct { x,y int //x,y分别为行号和列号 } func numIslands(grid [][]byte) int { var res int for i := 0; i \u003c len(grid); i++ { for j := 0; j \u003c len(grid[i]); j++ { if grid[i][j] == '1' { res++ DFS(grid,i,j) } } } return res } func DFS(grid [][]byte, row,col int) { stack := []point{} stack = append(stack,point{row,col}) grid[row][col] = '0' //以“右-\u003e下-\u003e左-\u003e上”顺序循环，dx,dy是每一种转向的坐标变化方式 dx := []int{-1,0,1,0} dy := []int{0,-1,0,1} for len(stack) != 0 { cur := stack[len(stack)-1] stack = stack[:len(stack)-1] for i := 0; i \u003c 4; i++ { nx,ny := cur.x+dx[i],cur.y+dy[i] if nx \u003c 0 || nx \u003e= len(grid) || ny \u003c 0 || ny \u003e= len(grid[row]) || grid[nx][ny] == '0' { continue } // 满足条件的结点标记为已访问并入栈 grid[nx][ny] = '0' stack = append(stack,point{nx,ny}) } } } ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:4:2","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 其它 最后一部分介绍两种非常常见的问法：用栈实现队列，用队列实现栈 ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:5:0","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 用栈实现队列 使用两个栈实现，最普通的思路是，每次出队时，将栈中的元素弹入一个临时栈，然后取出栈底元素，最后将临时栈的元素再放回去。但这样时间复杂度比较高，另一种合适的做法是，设立一个入栈，一个出栈，入队时将元素放入入栈，出队时从出栈的栈顶取元素，如果出栈为空，将此时入栈的所有元素弹入出栈，然后取栈顶元素。这样做可以将时间复杂度缩减到 $O(1)$ type MyQueue struct { in []int out []int } /** Initialize your data structure here. */ func Constructor() MyQueue { return MyQueue{} } /** Push element x to the back of queue. */ func (this *MyQueue) Push(x int) { this.in = append(this.in,x) } /** Removes the element from in front of queue and returns that element. */ func (this *MyQueue) Pop() int { if len(this.out) == 0 { for i := len(this.in)-1; i \u003e= 0; i-- { this.out = append(this.out,this.in[i]) } this.in = nil } pop := this.out[len(this.out)-1] this.out = this.out[0:len(this.out)-1] return pop } /** Get the front element. */ func (this *MyQueue) Peek() int { if len(this.out)==0{ for i:=len(this.in)-1; i\u003e=0; i--{ this.out = append(this.out, this.in[i]) } this.in = nil } return this.out[len(this.out)-1] } /** Returns whether the queue is empty. */ func (this *MyQueue) Empty() bool { if len(this.in) == 0 \u0026\u0026 len(this.out) == 0{ return true }else{ return false } } ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:5:1","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 用队列实现栈 使用两个队列实现，只能使用笨办法，每次出栈将所有元素放到临时队列，取队尾元素，然后再将临时队列的元素放回去。如果使用链表实现，可以将最后一步简化为交换两个队列的头指针。 type MyStack struct { q []int t []int } /** Initialize your data structure here. */ func Constructor() MyStack { return MyStack{} } /** Push element x onto stack. */ func (this *MyStack) Push(x int) { this.q = append(this.q,x) } /** Removes the element on top of the stack and returns that element. */ func (this *MyStack) Pop() int { if this.Empty() { return -1 } for len(this.q) \u003e 1 { this.t = append(this.t,this.q[0]) this.q = this.q[1:] } pop := this.q[0] this.q = nil if this.t != nil { for i := 0; i \u003c len(this.t); i++ { this.q = append(this.q,this.t[i]) } } this.t = nil return pop } /** Get the top element. */ func (this *MyStack) Top() int { if this.Empty() { return -1 } for len(this.q) \u003e 1 { this.t = append(this.t,this.q[0]) this.q = this.q[1:] } pop := this.q[0] this.q = nil this.t = append(this.t,pop) if this.t != nil { for i := 0; i \u003c len(this.t); i++ { this.q = append(this.q,this.t[i]) } } this.t = nil return pop } /** Returns whether the stack is empty. */ func (this *MyStack) Empty() bool { if len(this.q) == 0 { return true }else{ return false } } ","date":"2020-02-22","objectID":"/2020/data-structure-queue-and-stack/:5:2","tags":["数据结构与算法"],"title":"数据结构-队列与栈","uri":"/2020/data-structure-queue-and-stack/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第八期，由于经历了图床转换，本文图片已丢失。 ","date":"2020-02-21","objectID":"/2020/life-weekly-8/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 8 期 (20200221)","uri":"/2020/life-weekly-8/"},{"categories":["日程及周刊"],"content":"时讯 1、新冠肺炎疫情好转 截至2020年2月21日0:00，新冠肺炎国内累计确诊75465人，死亡2236人，日增病例正在不断下降，出院人数在不断增加，各地已逐渐开始开放交通和恢复生产，预计三月初可以得到有效控制，应该就可以返校了。 由于无法正常开学，各地展开网上教学，实现了大家在家上学的梦想，可惜画风有点不太对 😂 ","date":"2020-02-21","objectID":"/2020/life-weekly-8/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 8 期 (20200221)","uri":"/2020/life-weekly-8/"},{"categories":["日程及周刊"],"content":"小事 02.21，虽然已经开始工作，但整个人都快废掉了，一方面担心夏天找工作，需要复习相关知识，一方面总结工作和创新点努力发论文，就是不知道可不可以，第一次真难。 ","date":"2020-02-21","objectID":"/2020/life-weekly-8/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 8 期 (20200221)","uri":"/2020/life-weekly-8/"},{"categories":["日程及周刊"],"content":"本周收藏 1、soap box derby 中译名为皂飞车大赛，由红牛赞助，自2000年以来已经在世界各地举办了超过1000次，每场活动都有成千上万的观众，爱好者们驾驶自制的各种外形的皂飞车由重力滑下赛道，中途遇到台阶、稻草等各种障碍，玩的人开心看的人也开心。B站有一个皂飞车大赛的纪录片。 2、厨房温度计 一直以为做饭用天平、量杯、温度计是开玩笑，但最近注意到不少没事UP主其实用温度计还是蛮多的，有点意外，不过可能真的很好用，以后会试一试的。 本周注意力不在素材积累上，同时在怀疑这件事是否有意义，因此内容不多，下周开始的素材积累可能就随缘了。 ","date":"2020-02-21","objectID":"/2020/life-weekly-8/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 8 期 (20200221)","uri":"/2020/life-weekly-8/"},{"categories":["爱编程爱技术的孩子"],"content":"链表是一种最为基础的数据结构，由一系列结点组成，每个结点不仅包含值，还包含指向下一个结点（有时也包括上一个结点）的指针。相比于数组，在链表中访问指定的元素则需要$O(N)$的复杂度，但进行插入和删除操作只需要$O(1)$的复杂度 ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:0:0","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 单链表 一个单链表的例子如下，蓝色箭头显示链表中的结点是如何相连的 关于结点的最常见的定义如下 //单链表结点 type node struct { val int // 结点的值 next *node // 指向下一个结点的指针 } 多数情况下，我们使用头结点来表示整个链表，并将链表的长度存储其中。虽然增加了一个结点的存储，但带来的好处却是巨大的 //头结点，也是单链表的起始 type singlyLinkedList struct { length int // 链表长度 next *node // 指向第一个结点的指针 } 定义了头结点的情况下，需要事先对链表进行初始化 /* @description: 初始化链表(头结点) @author: shuzang 2020-03-28 @param: 无 @return: _ *singleLinkedList 指向单链表(头结点)的指针 */ func constructor() *singlyLinkedList { return \u0026singlyLinkedList{0, nil} } ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:1:0","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 获取指定结点的值 本质是对链表的遍历，修改操作也是相同的算法，只是需要遍历到指定元素后进行修改即可，程序实现如下 /* @description: 如果索引有效，获取链表中第 index 个结点的值 @author: shuzang 2020-03-28 @param: index int 要获取的元素位置 @return: _ int 获取元素的值; _ error 索引无效时返回错误 */ func (list *singlyLinkedList) Get(index int) (int, error) { if index \u003c 1 || index \u003e list.length { return -1, errors.New(\"param - index is invalid\") } cur := list.next for i := 1; i \u003c index; i++ { cur = cur.next } return cur.val, nil } ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:1:1","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 插入结点 如果我们想在 prev 结点后插入新结点，基本操作步骤如下 初始化新结点 newNode 将新结点的 Next 指针指向 prev 结点的下一个结点 将 prev 结点的 Next 指针指向新结点 在开头插入结点和在结尾插入结点是两种特殊情况，前者需要考虑头结点的存在，后者需要遍历到链表结尾，我们不再详述。三种插入的程序实现如下 /* @description: 在链表的第一个元素之前插入结点，插入后，新结点将成为链表的第一个结点 @author: shuzang 2020-03-28 @param: val int 要添加的元素的值 @return: 无 */ func (list *singlyLinkedList) AddAtHead(val int) { list.next = \u0026node{val, list.next} list.length++ } /* @description: 将新结点追加到链表的最后一个元素 @author: shuzang 2020-03-28 @param: val int 要添加的元素的值 @return: 无 */ func (list *singlyLinkedList) AddAtTail(val int) { newNode := \u0026node{val, nil} if list.next == nil { list.next = newNode } else { cur := list.next for cur.next != nil { cur = cur.next } cur.next = newNode } list.length++ } /* @description: 在链表的第 index 个结点前添加结点，插入后新结点成为第 index 个结点， 如果 index 大于链表长度，结点添加到链表末尾，如果 index 小于 1，则在头部插入结点 @author: shuzang 2020-03-28 @param: index int 要插入的位置，起始数字为 1; val int 要插入的元素的值 @return: 无 */ func (list *singlyLinkedList) AddAtIndex(index, val int) { if index \u003e list.length { list.AddAtTail(val) } else if index \u003c= 1 { list.AddAtHead(val) } else { cur := list.next for i := 1; i \u003c index-1; i++ { cur = cur.next } cur.next = \u0026node{val, cur.next} } list.length++ } ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:1:2","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 删除结点 删除结点只需要将前一个结点的 Next 指针指向当前结点的下一个结点，需要注意的是我们只需要遍历到待插入结点的前一个结点即可 程序实现如下 /* @description: 如果索引有效，删除链表第 index 个位置的结点 @author: shuzang 2020-03-28 @param: index int 要删除的元素位置 @return: _ error 索引无效时返回错误 */ func (list *singlyLinkedList) DeleteAtIndex(index int) error { if index \u003c 1 || index \u003e list.length { return errors.New(\"param - index is invalid\") } else if index == 1 { list.next = list.next.next } else { cur := list.next for i := 1; i \u003c index-1; i++ { cur = cur.next } cur.next = cur.next.next } list.length-- return nil } ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:1:3","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 打印链表 一个工具函数，不是必要的，但是很常用，打印输出整个单链表 /* @description: 工具函数，打印单链表 @author: shzuang 2020-03-28 @param: 无 @return: 无 */ func (list *singlyLinkedList) PrintList() { cur := list.next fmt.Println((\"当前单链表为: \")) for ; cur.next != nil; cur = cur.next { fmt.Printf(\"%v-\u003e\", cur.val) } fmt.Println(cur.val) } ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:1:4","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 双指针技巧 双指针是一种经典的链表操作技巧，对很多问题都有非常好的作用，下面通过几个经典问题进行介绍 ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:2:0","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 环形链表 关于环形链表的经典问法是：给定一个链表，判断链表中是否有环。更多扩展的问题包括： 如果存在环，找出环的入口结点 如果存在环，求环中的结点个数 如果存在环，求链表长度 这些问题都可以通过Floyd判环算法解决，算法的基本思想可以拿跑圈来举例说明：假设两个人在一条环形跑道上跑步，同时出发，但速度一个快一个慢，我们知道，如果一直跑下去，快的人总能追上慢的一方，此时快的一方多跑的路程一定是跑道长度的整数倍，即我们所说的「套圈了」 有人也拿龟兔赛跑举例，但思想是相同的。基于上述思想，Floyd提出了双指针算法（快指针和慢指针），算法分两个阶段。 第一阶段可以用来判断是否有环。慢指针（龟）每次前进一步，快指针（兔）每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。 第二阶段确定环的起点。假设链表起点到环的起点距离为$F$（这里我们提到的距离是结点个数），第一阶段相遇时的结点距离环的起点为$a$，环的周长为 $n = a + b$。那么第一阶段两者相遇时，慢指针移动的总距离为 $d = F + r_1 n + a$，由于快指针移动速度是慢指针的两倍，其移动的总距离为$2d = F + r_2 n + a$，其中$r_1$为慢指针第一次相遇时转过的圈数，$r_2$为快指针第一次相遇时转过的圈数。我们令两者相减（快减慢），那么得到 $d = (r_2 - r_1)n$，意为 $d$ 是环长度的倍数。 因此，我们将慢指针移动到链表的起点，快指针保持在第一次相遇的结点，然后两者同时开始移动，但这次两者每次都只移动一步。当慢指针前进了 $F$ 到达环的起点时，快指针距离链表起点 $d + F$，由于 $d$ 是环长度的倍数，这个距离可以看作快指针从链表起点出发，走到环的起点，然后绕环转了几圈，但此时停在了环的起点。即两个第二次的相遇点就是环的起点。 程序实现如下，需要注意的有两点 调用 Next 字段前，检查结点是否为空 仔细考虑循环的结束条件 func detectCycle(head *LinkedList) *Node { slow, fast := head.Next,head.Next //第一阶段，循环退出条件为fast指针或fast.Next为nil，因为fast始终在slow前面，所以不需要判断slow for fast != nil \u0026\u0026 fast.Next != nil { slow = slow.Next fast = fast.Next.Next if fast == slow { slow = head break } } //退出循环要么是到达相遇点，要么是没有环，没有环时返回nil if fast == nil || fast.Next == nil { return nil } //第二阶段,每次移动一步直到相遇，slow指针已经调整完毕 for fast != slow { slow = slow.Next fast = fast.Next } return fast //此时fast == slow，返回任一个都可以 } 得到环的起点后，快指针再跑一圈就可以得到环的长度，相应的，慢指针移回链表起点再走一遍然后和环的长度相加可以得到链表长度。 ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:2:1","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 相交链表 经典问法是：判断两个无环链表是否相交，如果相交，求相交的起始结点。如下图在 c1 结点相交。 基本求解步骤如下 创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。 当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (注意，是链表 B)；类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。 若在某一时刻 pA 和 pB 相遇，则该结点为相交结点。 可以这样理解，除去相交部分（3个结点），A 有 2 个结点，B有 3 个结点。重定位后，A多走的距离正好是重定位前少走的距离，这样直到相交，两者都走了 2+3+3 个结点距离。 程序实现如下，正常情况两个链表不相交的条件是最后一个结点不相同，但是实际上如果任意一个链表为空或两者不相交，根据循环最后都会走到 nil，因此也会跳出循环，而且返回pA或pB的值 nil 也是我们想要的返回值，如果相交，同样直接返回pA或pB的值即可。 func getIntersectionNode(headA, headB *LinkedList) *Node { pA,pB := headA.Next, headB.Next for pA != pB { if pA == nil { pA = headB.Next }else{ pA = pA.Next } if pB == nil { pB = headA.Next }else{ pB = pB.Next } } return pA } ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:2:2","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["爱编程爱技术的孩子"],"content":"其它资料 Leetcode刷题总结之链表 ","date":"2020-02-20","objectID":"/2020/data-structure-linkedlist/:3:0","tags":["数据结构与算法"],"title":"数据结构-链表","uri":"/2020/data-structure-linkedlist/"},{"categories":["我所热爱的生活啊"],"content":"我现在面临的一个重要问题是：想做的事情太多，而时间不够用。 六千年的人类文明史，创造了一个难以想象的庞大知识体系，到现在，人类社会已经形成了一个复杂而精密的整体，分工愈趋细化，每个人都在用自己的知识或智慧维持着这个体系的运转。但对于个人来说，有限的生命无法探索这个美好世界的全貌，该是多么遗憾的一件事情啊！数千年历史涌现的光辉人物、璀璨事迹和爱恨情仇，万万里世界所诞生的瑰丽的自然景观和人类所创造的充满艺术魅力的人文景观，探究世界真理的哲学……任何一个人都不可能在有限的一生中掌握所有的这些知识，但它们却以独特的魅力吸引人们追寻。 ","date":"2020-02-17","objectID":"/2020/how-to-do-if-no-enough-time/:0:0","tags":["杂谈"],"title":"时间不够用怎么办","uri":"/2020/how-to-do-if-no-enough-time/"},{"categories":["我所热爱的生活啊"],"content":"我想做什么 我想学很多知识，也想做很多事情，但所有的东西不是一成不变的，因此我只能将现在我想学想做的尽力描述出来。我将其划分为三个维度：工作、生活和兴趣。工作是赖以谋生的技能，生活是人存于世的方法，兴趣是所有其它的东西，但幸运的是，工作同样是兴趣所在，所有的东西都源自对生活的热爱，所以它们不是相互独立的。这里列举的东西可以当作人生清单来看，至于一些更具体的事情，将在第三部分「如何进行取舍」描述。 ","date":"2020-02-17","objectID":"/2020/how-to-do-if-no-enough-time/:1:0","tags":["杂谈"],"title":"时间不够用怎么办","uri":"/2020/how-to-do-if-no-enough-time/"},{"categories":["我所热爱的生活啊"],"content":"工作 14年高考报志愿，我选择了「物联网工程」这个专业，因为我相信未来是万物互联的时代，但大学四年我发现，一个时代不是一个专业能描述的，加上学校的培养计划设置，我在计算机的路上一去不返。18年步入研究生，我选择了计算机，因为我认为云计算、大数据、人工智能这些计算机前沿学科是万物互联时代的基础，但阴差阳错，我的方向是区块链。入学第一年，国家开始支持区块链发展，但我即将开始找工作的2020年，依然没有企业在校招中开发区块链这个职业，因此我选择后端。所幸这些都是兴趣所在，因此从工作来讲，我想做或者在应该做的事情包括： 扎实编程基本功，掌握Golang语言、常用算法与数据结构 构建全面扎实的软件知识体系，掌握计算机网络、操作系统、数据库系统、软件工程、设计模式等专业课程知识 熟悉TCP/UDP、HTTPS等网络协议，掌握Golang Web编程相关知识 了解MYSQL及SQL语言、编程、了解NoSQL，key-value存储原理，掌握数据库系统的理论 了解一到两门脚本语言，比如Python或shell 收集招聘信息，掌握简历制作技巧和面试相关技巧（剑指Offer） 基本的英文文档阅读能力和交流能力 同时，硕士期间的研究进度和毕业条件还要求做以下事情： 整理相关工作、撰写研究论文并投稿发表 寻找新的创新点并进行下一步的研究工作 除此之外，出于对计算机学科的兴趣，还希望掌握的知识包括 HTML/CSS/JS、Vue等前端开发的相关知识 Golang编程的完整知识体系建立，包括基本语法、开发框架、社区、合作、项目经验积累的 微服务、容器、分布式等开发的进阶方向 步入岗位后的职业进阶路径和需要掌握的知识和技能 计算机前沿学科了解和入门，包括云计算、大数据、人工智能、NLP等 除此之外，不排斥学习任何新的东西，包括新的语言、新的架构、新的开发方向（比如客户端开发）等。对于区块链来说，虽然目前在该方向找工作的概率不高，但不排除工作一段时间后向该方向转型的可能，毕竟有一定基础，而且是未来发展的大方向。又鉴于现在的研究工作的需求，需要梳理一下已掌握的知识和技能体系并进一步学习： 从中本聪论文理解比特币运行机制和PoW共识 从以太坊的白皮书和黄皮书理解以太坊的运行机制 掌握PoW、PoS、DPoS、PBFT等主流共识算法，了解其它非主流的共识算法 掌握分布式系统、密码学(安全协议和加密算法)等区块链领域基础知识 了解Hyperledger，EOS，IOTA等其它著名区块链平台 了解扩容、侧链、切片等前沿理论知识 参与社区追踪以太坊的演变进程 掌握以太坊开发的相关技能，包括私链搭建、钱包开发、智能合约开发、Dapp项目开发等，掌握truffle等开发相关工具的使用 积累区块链研究和项目开发的相关经验 吾生也有涯，而知也无涯。以有涯随无涯，殆已！ ——庄子 ","date":"2020-02-17","objectID":"/2020/how-to-do-if-no-enough-time/:1:1","tags":["杂谈"],"title":"时间不够用怎么办","uri":"/2020/how-to-do-if-no-enough-time/"},{"categories":["我所热爱的生活啊"],"content":"生活 一个人独立的标志应该是行为与心理的独立。行为的独立包括能够自己不依赖他人独立的生活，当然，现代社会没有人可以离开别人而生存，男耕女织也变成了历史，没有人可以自给自足，或者说经历了现代生活的便利后没人愿意回到那种生活。我的意思是关于衣食住行等的基本技能，比如穿衣、吃饭等，虽然这两样在我们孩童时代就已经掌握，但类似于做饭这种，怕是直到成年也依然有人无法独立完成。当前能够想到的基本生活技能包括： 饮食相关 常见作物、水果、蔬菜、调味料辨识和挑选 常见餐具和厨房电器使用 基本的主食和家常菜的做法 健康相关 生活中的常见疾病和本职业职业病了解和预防 家庭常备药和常备医疗物品的了解和储备 医院就医流程和医疗保险相关知识 健身相关常识 服装相关 常见服装的分类、面料识别、收纳 各种面料的服装洗涤、熨烫过程所涉及的所有知识和技能 自身穿衣风格的养成和服装搭配的基本技巧 服装购买的途径和技巧，常用品牌和店铺的收集和整理 住宿相关 租房/买房的注意事项 常用电器的使用规范 房屋清洁和保持整洁的动力与技巧 住房公积金、水电煤气、供暖、网费、电话费、物业费等了解 其它 常见交通工具的使用和乘坐方式 掌握与人沟通和相处的技巧 如何维持稳定的人际关系 养老、工伤、生育保险，一定的理财知识保证财富的稳定和增长，为年老和各种意外作保障 心理的独立也是一个人独立生活的重要一部分，关于这方面，需要做的包括 通过阅读养成正确的三观，不断思考形成自己对世界和万物的看法 心理上不依赖于父母、长辈、老师、权威或者伴侣 ","date":"2020-02-17","objectID":"/2020/how-to-do-if-no-enough-time/:1:2","tags":["杂谈"],"title":"时间不够用怎么办","uri":"/2020/how-to-do-if-no-enough-time/"},{"categories":["我所热爱的生活啊"],"content":"兴趣 这里的兴趣是狭义的兴趣，因为工作也可能是兴趣所在，而生活部分的每一件事，比如整理房屋，都有可能发展成为兴趣。 人们说，身和心，要有一个在路上。读书和旅行都是我喜欢的事情，这出自于对世界的好奇，我认为，人的一生就是对世界不断探索和认知的过程，读书和旅行是最直接的满足这一点的方式。而且我也相信，对生活的热爱来自于不断产生的新鲜感，而新鲜感产生于探索未知的过程。以爱情为例，爱情中的新鲜感不是和不同的人体验相同的生活，而是和同样的人探索未知的世界，生活同理。 相应的，我将兴趣方面的事情划分为两部分，读书对应求知，包括： 建筑、室内设计：建筑知识用于旅行中的建筑审美，室内设计用于提升生活舒适度 乐理、简单的绘画，色彩，美学：乐理知识用于理解音乐，绘画用于表达思维，美学则从理论上学习审美 经济学基础：世界的发展也是经济的发展，从经济学理解世界 心理学、哲学：塑造三观，向内探索自己的内心，向外理解他人和世界 历史和文学：纯粹的爱好，沉迷于历史的恢弘壮阔和文学典籍的优雅与深度 旅行对应行动，包括： 游览探索各地的人文和自然景观 尝试各类没有尝试过的运动，如攀岩、蹦极、马拉松等等，体会世界的精彩 参加各种有趣的集会，如演唱会、音乐会、舞台剧、夜市、各类展览、兴趣小组的线下活动等等 尝试各种各样的美食 除此之外，还有其它常见的娱乐形式，包括看电影、听歌、追剧、看动漫等等。 ","date":"2020-02-17","objectID":"/2020/how-to-do-if-no-enough-time/:1:3","tags":["杂谈"],"title":"时间不够用怎么办","uri":"/2020/how-to-do-if-no-enough-time/"},{"categories":["我所热爱的生活啊"],"content":"时间都用到哪儿了 以上就是我想做的事情，它们是如此的多以至于时间远远不够用，但我最近意识到，我的很多时间和精力并没有投入正确的地方。正如刚刚阅读的一篇文章中提到的：在无畏的地方浪费了大量的时间和精力，忙碌不已只是麻痹自己，滴水不漏的计划只是欺骗自己。那么，现在我就从一周与一年两个维度看看时间都用在哪儿了。 首先肯定的是，除去吃饭睡觉通勤，剩下的时间基本都在手机和电脑上。在过去的一周中，手机的使用时间约43小时，但从长期看，周平均使用时间为45小时，相当于每天有六个半小时（1/4）的时间在手机上，更加恐怖的是，这些时间近乎百分之百是毫无意义的。 而在电脑上的时间，有很大一部分用于博客维护和文档的写作，诚然，这是有意义的，但所占比例过大，已经超过了它实际的意义，如果记录的时间超过了实践，那么它是不健康的。除此外，逛B站、看电影等各种事情也会占用一定的时间，可以想象最后落在工作上的时间有多少。 一周的时间是一年的缩影，在过去的460天的时间里，我花在微信读书上的时间一共是644小时，考虑到直接使用浏览器的时间更多，有理由认为过去的2019年时被「浪费」掉了，而不是我所想象中的「充实而忙碌地度过」。得出的结论是，不是想做的太多而时间不够用，而是时间和精力被花费到了不值得的事情上。 ","date":"2020-02-17","objectID":"/2020/how-to-do-if-no-enough-time/:2:0","tags":["杂谈"],"title":"时间不够用怎么办","uri":"/2020/how-to-do-if-no-enough-time/"},{"categories":["我所热爱的生活啊"],"content":"时间和精力管理 从上面的总结中得到的两个改进建议是： 减少手机使用时间：大部分时间是无意义的 减少博客维护和文档写作的时间：行动永远在记录前，而且不是所有的行动都有记录的必要，以及不要做重复性的工作 将第一部分提到的所有工作按照四象限法归类，如下图所示 当前时间和精力的划分应当按照这一分类来指定，而不是博客维护这种虚假的努力，避重就轻，同时也要尽量减少手机使用时间，避免无意义的浪费。效率提升、极简生活等领域浪费的精力可以避免，生活和兴趣类事件的精力在短时间内（找到工作前）应当转投到第一象限的工作中。 牢记几条原则： 每天使用手机的时间不应超过5小时 背单词、喝水、健身一定要每天做，以及不要久坐 不要在白天的工作时间维护博客和写一些不相干的文档，比如本文 ","date":"2020-02-17","objectID":"/2020/how-to-do-if-no-enough-time/:3:0","tags":["杂谈"],"title":"时间不够用怎么办","uri":"/2020/how-to-do-if-no-enough-time/"},{"categories":["研究生的区块链学习之路"],"content":"Yu, Yue \u0026 Zhang, Sheng \u0026 Chen, Chao \u0026 Zhong, Xiaoxiong. (2018). LVChain: A Lightweight and Vote-based Blockchain for Access Control in the IoT. 870-874. DOI: 10.1109/CompComm.2018.8780687 KeyWord: IoT, security, Blockchain, access authorization, BLE-based devies 注：插图经过重新绘制，照片来自原论文截图。 ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:0:0","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引言 IoT与生活联系的越来越紧密，因此安全和隐私问题逐渐得到人们的关注。访问控制是安全的一个重要领域，一个完整而有效的访问控制系统应该满足机密性、完整性和可用性，并包括认证、授权和审计三个部分，这篇文章只关心授权部分。 传统授权架构是中心化的，比如著名的有XACML、OAuth和UMA，这种架构很难解决单点故障问题和提供良好的可扩展性，因此正在朝着分布式的方向演变。 作者设计了一条区块链(LVChain)来克服了上面提到的缺点，可以很好的用于蓝牙设备构成的家庭无线自组织网络。作者的主要贡献如下 提出了一个新的基于区块链的分布式架构，是轻量级、可扩展和容错的； 在架构中引入和实施了一个基于投票的共识算法，对计算和存储资源依赖更少； 对性能进行了全面地分析，比较了本文架构、传统中心化架构和现有的分布式架构，在虚拟环境中运行了一个实验证实了本文架构在IoT环境下的可行性。 论文其余部分组织如下，第二部分为背景和相关工作，第三部分为架构总览，第四部分为性能评估和安全分析，第五部分总结全文。 ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:1:0","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2. 相关工作 FairAccess1利用智能合约实现了基于token的访问控制，但是有较大的计算和时间开销，预设的授权规则也不可变。 BlendCAC2同样基于token，利用智能合约完成访问授权的注册、传播和撤销。该模型具有较大的计算和存储开销，并且在具有足够资源的树莓派上实现，无法代表多数IoT设备。 ControlChain3使用了四种区块链，分别负责记录设备和用户的关系、存储传感器收集的环境信息、存储授权或拒绝访问的权限信息和保存授权规则。该架构只是理论没有仿真或实现，复杂性较高而兼容性较差。 ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:2:0","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3. 方案 本文的工作用于解决蓝牙设备构成的家庭无线自组织网络中的安全问题，具有如下特征： 分布式结构，克服中心化结构的缺点，更好地满足IoT的开发需求； 基于投票的共识，减小资源有限的IoT设备的计算压力，因此是轻量级的 离线工作，因为控制和授权信息不需要通过连接的蓝牙设备扫描和广播 架构总体结构如下图所示，分为三层：数据层、网络层和共识层。 数据层包括时间戳、控制信息和授权信息，存储在本地来避免泄露隐私。用户控制设备(如switch等)的行为会生成控制信息，并按时间戳顺序链接在一起，这样做同样有利于接下来的审计工作。授权信息是授权用户的身份信息，通过哈希表存储，从而加快查询速度。 网络层利用P2P协议构建蓝牙设备组成的网状网，由于蓝牙设备的广播和扫描状态，该架构是无连接的。网络中的设备结点是点对点的，一个设备接收到信息，会通过蓝牙转发和广播出去。另外，为了防止网络拥塞，限制了每个消息的转发次数，期间验证机制会验证控制信息的有效性和投票信息是否来自授权用户。 受限于蓝牙设备的计算能力，使用了基于投票的共识算法。为了减少通信开销，共识算法设计为：请求授权的用户在收到大部分授权用户的投票信息时被授权。 整个架构的工作流程如上图，当一个用户尝试操作一个设备时，设备会首先根据数据层的授权信息将用户区分为授权用户和非授权用户。如果是非授权用户，设备向整个P2P网络的授权用户发送授权请求，然后授权用户进行投票，每个用户对每个请求只有一票，同意则进行投票，不同意什么都不做。接下来，在共识层中，设备接收投票回应，检查回应的有效性并计算有效投票数量。在一段确定的时间内，如果投票用户的数量超过了授权用户数量的一半，请求者被授权，其信息存储在数据层中并添加到授权信息。如果是授权用户，一方面设备转发控制请求并将控制信息按时间戳添加到区块链，另一方面如果请求针对自己，设备直接进行响应。 ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:3:0","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4. 性能评估 ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:4:0","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 方案比较 论文中的架构和其它架构的比较如下表，其中(*)表示取决于证明类型和块的生成速度 Scalability Fault Tolerant New Authorization Get Authorization Off-Line working XACML - - + + - OAuth - - + + - UMA - - + + - FairAccess + +- - - +- BlendCAC + +- - + +- ControlChain + + -(*) + +- LVChain +- + +- + + 可扩展性：FairAccess、BlendCAC、ControlChain和本文的LVChain都是分布式结构，具有良好的可扩展性，但由于授权信息的不断增加可能对网络造成影响，LVChain的可扩展性可能略逊于其它三种。 容错性：分布式结构具有更好的容错性，但FairAcess和BlendCAC使用token，带有一定的中心化特征，因此略逊于另外两种。 新授权：评估改变一个授权的延迟。中心化架构更改授权的延迟较低，本文的LVChain使用基于投票的共识，避免和挖矿过程，延迟稍微好点。 获取授权：评估获取一个授权的延迟。FairAccess获取权限需要挖掘两个区块，因此比其他方案略差 离线工作：评估设备离线工作的可能性，中心化结构都需要稳定的连接，分布式结构都可以从本地副本查询。 ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:4:1","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 仿真 作者如上图所示实施了文中提出的架构，使用智能手机代表用户，配备MCU和蓝牙的智能家庭设备代表终端设备。与树莓派相比，这里设备的计算和存储能力更弱，因此能证明本文架构在资源有限的IoT环境下的适用性。软硬件具体情况如下 设备 详细信息 IoT设备 arm cortex-m3，maximum working frequency 48MHz, RAM 80K, ROM 256K（硬件） Keil arm 5.22（软件） 用户设备 BLE 4.0， theoretical rate 60Mbps（硬件） ios 8.0（软件） 当一个未授权用户想要操作设备时，设备查找授权信息确定用户未授权，然后通过蓝牙将授权请求广播给所有授权用户，授权用户接到请求后，如下图所示做出是否同意的决策，选择「NO」不会发送任何信息，选择「YES」发送投票信息。 一系列测试的结果如下表所示，共使用了两个嵌入式设备，并使授权用户的数量逐渐增加，反映了网络扩张的过程。结果中可以看出，投票用户超过一半时用户被授权。 The number of authorized users The number of voting 「YES」 The number of voting 「NO」 The operability of the user requesting access 1 0 1 × 1 1 0 √ 2 0 2 × 2 1 1 × 2 2 0 √ 3 0 3 × 3 1 2 × 3 2 1 √ 3 3 0 √ ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:4:2","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.3 安全分析 理论上，由于本文架构是分布式的，信息在每个设备中都有一个备份，单个设备的故障不会影响其它设备的正常运行。不过恶意用户不得超过一半，否则该架构难以正常运行。 ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:4:3","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["研究生的区块链学习之路"],"content":"5. 总结与启发 很多访问控制方案都是利用原来的区块链或智能合约，本文则设计了一条完全用于访问控制的新链，这也是一种思路。而且作者构建的区块链是完全建立在IoT设备上的区块链，由蓝牙设备作为节点，这种纯粹底层的区块链还没见到过。 不过，家庭自组织网络中，授权用户的数量不会太多，受到攻击时，一半以上的授权用户被控制的概率比较大，因此，这种场景使用区块链完成访问控制是否有必要值得讨论。 最后，家庭自组织网络中，蓝牙、WIFI和ZigBee三种协议都有使用，限于一种协议显然是不适合的，以设备为终端节点，需要对各种无线协议做适配，工作量大且更新繁琐，不是最好的选择。 A. Ouaddah, A. Abou Elkalam, and A. Ait Ouahman, “Fairaccess: a new blockchain-based access control framework for the internet of things.” Security and Communication Networks, pp. n/a–n/a, 2017, sCN-16-0184. ↩︎ R.H. Xu, Y. Chen, et al, “BlendCAC: A BLockchain-ENabled Decentralized Capability-based Access Control for IoTs.” IEEE Internal Conference on Blockchain IEEE, 2018. ↩︎ Pinno, Otto Julio Ahlert, A. R. A. Gregio, and L. C. E. D. Bona, “ControlChain: Blockchain as a Central Enabler for Access Control Authorizations in the IoT.” GLOBECOM 2017 - 2017 IEEE Global Communications Conference IEEE, 2018. ↩︎ ","date":"2020-02-14","objectID":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/:5:0","tags":["论文笔记"],"title":"LVChain： A Lightweight and Vote-based Blockchain for Access Control in the IoT","uri":"/2020/lvchain-a-lightweight-and-vote-based-blockchain-for-access-control-in-the-iot/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第七期。由于经历了图床转换，本文图片已丢失。 注：本文图片均已丢失 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"时讯 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"疫情 2月8日，国务院联防联控机制发布会上，肺炎被暂命名为「新型冠状病毒肺炎」，简称新冠肺炎，英文 Novel Coronavirus Pneumonia，简称NCP。2月11日，世卫组织正式将新冠肺炎命名为COVID-19，象征19年发现的冠状病毒，该名称将此病毒和地域、动物或个人相关联，尽力避免歧视。 截至2020年2月14日00:00，新冠肺炎累计确诊人数63851人，死亡1380人，没有看到局势好转。 2月11日，湖北省委将省卫健委书记和主任更换为王贺胜，2月13日，中共中央更换湖北省委书记为原上海市长应勇，2月13日，武汉市长更换为王忠林。希望临危受命的这些人能起作用。 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:1:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"灾害 林火还未扑灭，澳大利亚新南威尔士州又迎来一场强降雨，并引发了洪水。 东欧冬季风暴「西娅拉」过境1，最高时速180多公里，波兰、捷克等多国受损严重。 2月13日早5:16，印尼中爪哇著名火山莫拉比早上喷发2，喷出的浓烟高达2000米，喷发时间持续了150秒，有关部门已经宣布火山周边3公里范围为禁区。 自去年末以来，非洲蝗灾愈演愈烈3，至少有 3 场蝗灾在非洲之角、印巴边境与伊朗南部，以及红海两侧持续涤荡，其中尤以非洲之角的蝗灾最为严重。盘踞在这里的蝗群破坏力极大，规模为一平方公里的蝗群一天就能吃掉 3.5 万人的口粮，该地区 1190 万人的粮食供应受到蝗灾直接威胁。 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:1:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"其它 02.10，伊朗发射了「胜利」号国产人造卫星，但卫星未被送至预定轨道，卫星发射失败。4， 02.10日CNN新闻，印度新德里女子大学发生大规模性骚扰事件5，对于印度，这类事件已不是第一次发生，印度女性仍处于弱势地位，这种社会性的问题，在政府不作为的情况下，不知道最后会以什么样的方式解决。 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:1:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"小事 1、02.09，做了一次九型人格测试，偏向6号怀疑者。 2、02.14，情人节，在家隔离快一个月了，疫情依然严重，本周开始恢复工作。 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"视频 1、七朵组合《哪吒》录音室版MV，总之，七朵的歌曲从不会让我失望 2、老奶奶马林达·赫曼(Malinda Herman)的吉他弹唱，在YouTube6有82.5万的订阅，七十多的她是吉他界当之无愧的励志者，60多岁为了治疗面瘫开始学吉他，弹得特别好听，激励了无数年轻人踏上这条路，虽然大多数不久就放弃了。B站没有官方视频，也没有专门的搬运者，但还是找到了几个视频，这里放一个我比较喜欢的。 3、速度与激情9曝首支预告片，一如既往吸引人，还以为自特别行动后没了呢，没想到不仅有9，后续也已经在制作了。 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"文章 1、著名的设计失败汽车 德罗宁 DMC-12 DeLorean DMC-12，通常翻译为德罗宁 DMC-12，是德劳瑞恩汽车公司(DeLorean Motor Company, DMC)生产的车型，也是该公司唯一一款车型。 第一辆 DeLorean DMC-12 诞生于1976年3月，由威廉·柯林斯（William.T. Collins）制作完成 ，当时的公司总裁是约翰·德罗宁，正式他提出了这台车的概念并努力找人设计制作完成。这台养车完全符合人们当时对未来汽车的幻想，仅凭这台样车，约翰·德罗宁就从好莱坞和英国政府筹措到了巨额的资金用于生产，可惜除了外观设计外，该车的其它部分并不成功，导致出现各种问题迟迟无法量产，直至1982年停产时这个型号的车大约生产了9000辆，现在大约还有6500辆仍旧存在（随着时间的流逝，它很可能大幅度减少）。 DMC-12虽然不算成功，但它的概念征服了无数创作者和汽车爱好者，公司倒闭后，它成了一种精神象征，表达人们对未来未来狂热又不切实际的想象，也是朋克风格的代表之一。 DMC-12的爱好者们重建了该公司，1997年，工厂开始负责汽车某些部分的升级以及修理工作。在该公司的官网，可以进行该型号所有剩余汽车的买卖，注意，现在并不生产新车。同时，DMC-12的形象大量出现在动漫、游戏、电影、小说等文学作品中，对一代又一代人产生了深远的影响。 80年代的科幻电影《回到未来》被美国国会图书馆的美国国家电影登记处列为在文化、历史和艺术上具有重大意义的电影，电影中的座驾正是DMC-12。2018年的热门电影头号玩家中，导演再一次进行了致敬，男主驾驶的车就是DMC-12的改装型，这些改装使其更加科幻和前卫。 2、世界上著名的三座水桥 水桥是一种走船不走车的桥梁，如果不曾看到，根本想不到世界上会有这种东西。世界上著名的水桥有Magdeburg Water Bridge、Pontcysyllte Aqueduct和Barton Swing Aqueduct等，其中以德国的Magdeburg Water Bridge最漂亮。水桥的一个特点是不论大船还是小船，甚至没有船的时候，桥面受到的压力（几乎）总是相同的。只要船能浮起来，桥就不会塌。这主要是因为浮力基本抵消了船的重力，更具体的原理可以在网上查阅到。 3、中国网络小说发展史 网络小说已是生活的重要部分，在知乎这个问题的回答力，介绍了中国网络小说的起源和发展。 4、烧纸钱在全球的流行 详细介绍了给祖先烧纸钱这种习俗是如何在全世界范围内流行起来的，并介绍了如今世界的殡葬用品现状，印象最深的是对巴黎「极乐天堂」殡葬用品艺术展的介绍，插图中的物品简直令人叹为观止。 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"图片 1、老勃鲁盖尔 1562 年的名画《死亡的胜利》，最著名的一幅瘟疫题材作品，意在展现死亡的平等。 ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["日程及周刊"],"content":"资源 1、相爱的100件事 应该是某个程序员制作的网页，列举了可以和女朋友(爱人)一起去做的100件事，目前来看，主人已经成功划掉很多了。当作参考喽，以后找到女朋友可以一起去做，很浪漫的事情。不是有那句话吗，爱情中的新鲜感不是和不同的人体验相同的生活，而是和同样的人探索未知的世界。 2、Mike Dane的YouTube频道 各类编程语言的完整教学，不过注意到该频道主要还是因为有Hexo和Hugo开发的完整教学。 冬季风暴西娅拉过境东欧 ↩︎ 印尼莫拉比火山喷发 持续150秒 浓烟高达2000米 ↩︎ 2020年初的非洲蝗灾 ↩︎ 伊朗国产人造卫星发射失败 ↩︎ 印度新德里女子大学大规模性骚扰事件 ↩︎ Malinda Herman YouTube主页 ↩︎ ","date":"2020-02-14","objectID":"/2020/life-weekly-7/:3:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 7 期 (20200214)","uri":"/2020/life-weekly-7/"},{"categories":["研究生的区块链学习之路"],"content":"Benhadj Djilali H., Tandjaoui D. (2019) Efficient Distributed Authentication and Access Control System Management for Internet of Things Using Blockchain. In: Renault É., Boumerdassi S., Leghris C., Bouzefrane S. (eds) Mobile, Secure, and Programmable Networking. MSPN 2019. Lecture Notes in Computer Science, vol 11557. Springer, Cham DOI：https://doi.org/10.1007/978-3-030-22885-9_5 Keywords：Internet of Things, Access controls system management, Authentication, Blockchain, Security. ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:0:0","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["研究生的区块链学习之路"],"content":"1. Introduction IoT现在的身份认证体系主要是基于PKI(公钥基础设施)的，以Certificate Authority(CA)作为第三方可信机构，通过数字证书来认证和管理身份。该体系有如下缺点： 以CA为核心的中心化体系具有单点故障的问题，容易被侵入导致安全问题 使用数字证书在验证过程中引入了计算开销，在带宽角度还有较高通信开销 为了在消息中包含证书，每条消息长度额外增加，导致通信量大、网络拥塞和资源耗尽， 许多方案致力于减少计算和通信开销，作者提出利用区块链技术构建一个用于IoT的安全的轻量级访问控制系统，核心思路是： 利用区块链存储PKI体系中的数字证书，缓解单点故障问题 对每条消息中嵌入的数字证书的验证过程转换为区块链中存储的数字证书的查询过程，减少认证过程(证书交换和验证)的开销 论文其余部分组织如下：第二部分总结相关工作，第三部分描述所提出的方案，第四部分讨论和评估系统性能，第五部分总结全文。 第二部分没有实质性的东西，略过。 ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:1:0","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["研究生的区块链学习之路"],"content":"2. Proposal 作者所提出的方案是一个用于物联网网络的基于区块链的访问控制系统管理机制，设计目的是消除单点故障、减少原本的中心化PKI体系的通信和验证开销。为了实现这一目的，必须确保下面的功能集的实现： IoT设备注册公钥 验证IoT设备公钥的成员身份 查找/验证物联网公钥的有效性。 从网络中撤销物联网的公钥。 这些函数的细节描述分别在下面各小节中，在此之前，会先进行一次系统总览。 由于IoT设备的有限能力，作者使用椭圆曲线加密ECC和数字签名ECDSA，而不是普通的公钥加密RSA。 ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:2:0","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 System Overview 作者的目标是保证物联网安全的同时，实现物联网的大规模部署。区块链可以为任何类型的数据提供分布式、安全和不可变的记录，如果把认证信息(比如证书)存入区块链，交换和验证这些信息就会变得不再必要。另外，区块链分布式的特性还消除了对可信第三方的需要，从而避免了单点故障发生的可能性。 下图是系统的总体结构。其中，区块链网络（这篇文章中是permissioned BC）覆盖在现有的物联网网络之上，「验证者」是城市中的一组有一定处理和存储能力的智能实体，如智能交通灯、基站、智能路灯和其它路边的单元等，负责执行共、验证交易有效性。「权威(Authorities)」类似于传统的CA，在智慧城市场景下可能是车辆部门、电子政府、制造商或公司等，作用是证明特定IoT设备是网络的一员。 在该方案中，不是将来自不同权威的证书收集到一个单独的地方进行决策，而是将所有证书推送到区块链网络，然后由验证者以完全分布式的方式进行决策。IoT设备加入/离开网络的时候，相关的准入/撤销消息以交易形式发送到区块链中，由验证者进行验证并做出最终决策。以IoT设备退出网络为例，检测到恶意行为的某个IoT设备会发送交易到区块链，然后验证者们根据预定义的规则做出从网络中删除可疑IoT设备的决策。 一个IoT设备不再需要将证书附加到每条消息中，接收者只需要做一个简单的查找来检查发送者在区块链中的有效状态。通过这种方式，IoT设备间可以以最小的通信和计算开销进行相互认证。 ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:2:1","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 Details IoT Device Registration 一个 IoT 设备首先需要在网络中进行注册。以设备 IoTi 为例，首先自己生成公私钥对 (pkIoTi，skIoTi) 用于签名和验证。为了在区块链中拥有一个有效的成员状态，IoTi  需要从相应的权威处获取注册证书，验证合法的情况下，权威 aj 使用其私钥 skaj 发布一个已签名的证书给IoTi，通过注册交易将证书推送到区块链网络中。证书具有如下格式，其中 cert 是生成的证书，sig是证书的签名，证书主要包含IoT设备公钥和有效期。 $$ \u003ccert, registered, sig\u003cska_j, cert\u003e $$ IoT Device Admission 当区块链网络从一个权威处接收到注册交易时(可能是授权新设备或重新授权被撤销的设备)，如果来自一个经过认证的机构，则被接受。当收到关于 IoTi 足够的证书时，某个验证者就会生成一个新的准入交易，从而在区块链中将IoT设备的公钥标记为有效，其它的验证者随之会验证其有效性并将其添加到本地区块链的副本，验证有效性包括检查验证者签名和 IoTi 是否拥有足够的证书。准入交易的格式如下： $$ \u003c pkIoT_i, valid, sig(skm_j, pkIoT_i) \u003e $$ IoT Device Authentication 一旦 IoTi 被标记为有效，他就可以加入网络并开始发送消息。每个接收到来自 IoTi 的消息的设备都会检查该设备公钥是否在区块链中存在以及是否被标记为有效，这一步骤通过在区块链中进行简单的公钥值匹配完成。 IoT Device Revocation 设备 IoTj 检测到恶意行为后，必须发送一个恶意行为交易通知区块链网络，该交易格式如下 $$ \u003c pkIoT_i, misbehavior, sig(skIoT_j, pkIoT_j) \u003e $$ 其中 pkIoTi 是被怀疑的IoT设备的公钥，skIoTj 是检测到恶意行为的设备的私钥。如果交易来自有效的IoT设备，验证者会将交易收集到区块链中，这些交易稍后会被验证从而决定是否将被怀疑的设备从网络中删除。撤销资格的规则由权威设置，由验证者强制执行，例如，如果24小时内超过 n 个关于 IoTi 的恶意交易被收集到区块链中，则将其驱逐出网络。这一过程通过验证者发起撤销交易并广播到整个区块链实现，撤销交易的格式如下，其中skmj 是验证者的私钥 $$ \u003c pkIoT_i, revoked, sig(skm_j, pkIoT_i) \u003e $$ 一旦收到撤销交易，其它的验证者在验证其来源后就会将其添加到区块链。 以上提到的四种交易总结如下表 交易类型 发送者 交易格式 注册(Registration) 权威 \u003c cert, registered, sig(skaj, cert) \u003e 准入(Admission) 验证者 \u003c pkIoTj, valid, sig(skmj, pkIoTi) \u003e 恶意行为(Misbehavior) IoT设备 \u003c pkIoTi, misbehavior, sig(skIoTj, pkIoTj) \u003e 撤销(Revocation) 验证者 \u003cpkIoTi, revoked, sig(skmj, pkIoTi) \u003e ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:2:2","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["研究生的区块链学习之路"],"content":"3. Discussion ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:3:0","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 存储优化 Multiple blockchains：不是将注册、准入、恶意行为和撤销等所有消息都保存到一条区块链中，而是不用类型的数据可以存储在不同的区块链。这种情况下，设备可以只使用准入和撤销区块链，只用这两种已经足够认证任何接收到的消息的来源，因此能节省一定的存储空间。 Cryptographic accumulator：思路是将一组有效的IoT设备累加到一个智能对象中，每个IoT设备在累加器中都有一个见证者可以证明它已注册。这种情况下，只需要在区块链中保存累加器即可，IoT设备只需要在消息中包含其见证者，接收者就可以通过一个简单的函数检查其成员资格。这种方法能大大减小区块链的大小，并且可以在不影响存储性能的情况下扩展到非常大的网络规模。 ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:3:1","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 性能分析 通过使用区块链，设备消息的验证变成了一个简单的查询函数，为了比较本文方案和传统方案的验证时间，做了如下实验。 为了测试实际场景下查询函数的性能，使用比特币区块链。在比特币区块链中，为了加速访问和搜索操作，需要使用LevelDB 数据库。比特币主要使用两个数据库，一个包含所有已知区块的元数据，存在硬盘，另一个包含UTXO信息，值得注意的是，可以定制数据库从而满足特定需要。在本文方案中，加速了在区块链数据库中搜索特定交易的响应时间。通过使用LeveDB C++，可以直接访问数据库并通过交易标识符(TXID)搜索特定交易。实验使用的硬件和数据库的总结如下表所示 配置类型 详细信息 CPU 8 ∗ Intel R Core(TM) i7-6700HQ 2.60 GHZ CPU-cache 6144 KB LevelDB Version 1.1 Number of transactions 36328994 结果显示，1000次查询的平均查找时间为0.012ms，传统方案对于长度为256的密钥，验证时间为0.1ms，使用区块链的优势很明显，延迟几乎减少了10倍。 ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:3:2","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["研究生的区块链学习之路"],"content":"4. Idea 这篇论文的偏向是认证，没有使用任何访问控制模型，就是简单的将PKI体系中的证书保存到区块链中，并做了一定的适应性调整。性能有实际的提升，同时具有很大的可行性，能够进行大规模的实际部署。缺点在于这种方式实现的访问控制是粗粒度的，最基本的单元是IoT设备，无法具体到每个资源，而且权限区块链本身对节点准入就会进行控制，功能上可能有一定重合。 最大的启发在于没有完全抛弃原来的CA，权威依然作为区块链的一部分参与进来，对于区块链监管体系的建立有一定参考价值。 ","date":"2020-02-09","objectID":"/2020/efficient-distributed-authentication-and-access-control-system/:4:0","tags":["论文笔记"],"title":"Efficient Distributed Authentication and Access Control System","uri":"/2020/efficient-distributed-authentication-and-access-control-system/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第六期。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"时讯 本周疫情发展比较严重，一周内确诊人数达到近两万人，同时世界局势风云变幻，各地灾害频发，心思比较杂乱，把这三方面以专题的方式做一下总结。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"自然灾害 1、澳大利亚山火持续 02.02 2日，澳大利亚新南威尔士州林火继续蔓延，高温和强风助推林火逼近首都堪培拉及周边地区，林火造成的浓烟弥漫在堪培拉城市上空。截至2日晚，新南威尔士州有超过60处林火仍在燃烧，过火面积超过550平方公里。 2、阿根廷丘布特省大风 02.03 当地时间2月1日下午，阿根廷南部丘布特省沿海地区突然开始刮起大风，风速达到100公里/小时以上，狂风所过之处大树被连根拔起、房顶被吹翻，风和日丽的一天结束于一片狼藉，所幸目前未有人员伤亡的记录。丘布特省位于阿根廷东南部，有马德林港、特雷利乌等著名海滨城市，是深受阿根廷人喜爱的度假胜地 3、新西兰暴雨引发洪水 02.03 据新西兰媒体报道，2月2日到3日，在新西兰南岛，暴雨引发了洪水和滑坡，导致通往著名旅游地米佛峡湾（Milford Sound）的公路受损严重，包括游客在内的多达400人被困沿线。当地已宣布进入紧急状态，紧急部门计划在天黑之前派直升机前往营救被困人员。预计这条旅游公路会关闭到本周结束。 4、冬季强风暴席卷美国东海岸 02.07 当地时间6日，据美国当地媒体报道，冬季强风暴由南至北席卷美国东海岸，由此带来的龙卷风已经在阿拉巴马州造成一人死亡，一人受伤。据报道，此次的冬季强风暴已经一路沿途从路易斯安那州到田纳西州带来了几十场破坏性风暴，其中仅密西西比州就有十二起龙卷风。目前美国东南部许多城市发布了强降雨和洪灾警告，预计这场风暴将会使美国30个州受到雨雪和暴风的袭击，对数百万人造成影响。 5、土耳其东部凡省雪崩 02.06 据土耳其灾害和应急管理部门的消息，土耳其东部凡省4日和5日接连发生雪崩，已造成38人死亡，其中第二次雪崩的遇害者多是进入现场的救援人员。 短评：近年来，世界各地自然灾害频发，全球变暖加剧，阿根廷国家气象局6日发布的消息称，其在南极的科考站测下两项南极最高温记录。也许，将更多的注意力和资源投入气候问题已经刻不容缓了。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:1:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"国际局势 1、英国正式脱欧 02.01 当地时间1月31日23点，也就是北京时间早上7点钟，英国正式脱离欧盟，向47年的盟友说再见，也为历时3年多的脱欧历程划上句号。英国脱欧后进入过渡期。过渡期从2月1日开始，到2020年12月31日结束。期间，英国仍留在欧盟关税同盟和欧洲单一市场，双方贸易关系维持现状；人员也可以自由流动；遵守欧盟所有规则，但不再参与欧盟决策进程。 脱欧支持者当天在多地举行了规模不等的庆祝活动，晚上9点到11点，议会广场上举行了大型庆祝活动。白厅和唐宁街都上演了灯光秀，寓意英国的团结；首相府从晚上10点钟开始显示倒计时。下午3点，约300万枚脱欧纪念币正式开始流通。 2、美国公布的“新中东和平计划”遭到抗议 02.02 美国总统特朗普1月28日公布了所谓推动解决巴以问题的“新中东和平计划”，巴方明确表示了拒绝。舆论普遍认为，美方公布计划可能会进一步加剧巴以冲突，导致地区局势升级。连日来，在耶路撒冷、约旦河西岸城市伯利恒、约旦首都安曼、土耳其伊斯坦布尔等多地也都举行了大规模的游行示威活动，人们声援巴勒斯坦，抗议美国推出所谓“新中东和平计划”。 3、土耳其局势愈发复杂 02.04-02.06 今日，土耳其局势变得越来越复杂。 当地时间3日，叙利亚政府军当天在叙利亚西北部伊德利卜省进行炮击，已造成土方8人死亡、多人受伤，土方称已对这次炮击事件采取了报复行动。近期，叙利亚政府军不断在叙利亚西北部的伊德利卜省以及阿勒颇省展开军事行动，打击当地叙利亚反对派武装和恐怖组织，并收复了马雷特努曼等战略重镇。有消息说，土耳其不愿见此事态继续发展，已向伊德利卜省增兵。 当地时间5日，土耳其萨比哈·格克琴国际机场。一架波音738客机滑出跑道断成三截。据土耳其卫生部公布的最新消息，此次事故目前已造成1人死亡，至少157人受伤。 当地时间6日，俄罗斯外交部就叙利亚伊德利卜省冲突降级区局势发布消息，称近期该地区紧张局势加剧，暴力冲突升级。1月中旬，俄罗斯和土耳其军方再次试图在伊德利卜冲突降级区实行“寂静制度”。但恐怖分子不仅没有减少其战斗活动，反而增加了袭击。仅1月份近两周，就发动了1000多次袭击。冲突降级区外的叙政府军和平民死伤人数达到数百人，俄罗斯和土耳其军事专家也在冲突中丧生。另外恐怖组织使用打击无人机攻击俄罗斯的赫梅米姆空军基地的企图一直没有停止。 4、美国国会参议院投票最终结果出炉 特朗普免遭弹劾 02.05 当地时间5日，美国国会参议院就针对美国总统特朗普的弹劾条款进行最终投票表决。在对特朗普的两项弹劾条款：滥用职权和妨碍国会的投票中，参议院投票结果都认定不成立，美国总统特朗普也因此免遭弹劾。按照美国宪法，要将总统定罪和罢免须获得至少三分之二参议员支持。但鉴于目前参议院有53名共和党议员、45名民主党议员和2名独立派议员，因此在此次投票之前，舆论普遍认为，特朗普被定罪及罢免的可能性很小。特朗普是美国历史上第三位遭众议院弹劾的总统。当地时间2月6日，特朗普在白宫就弹劾案”无罪“裁决发表讲话。 短评：世界局势依然在我们不知道的地方风云变幻，巴以冲突、叙利亚局势、俄罗斯和土耳其、巴基斯坦，纷争从未停止，美国一刻不停的在努力维持世界霸权地位，从去年末开始，香港、台湾相继出现各种问题，只希望国家在解决疫情的同时积极面对国际局势，不被影响，也希望多数国人能给予理解，毕竟，有国才有家。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:1:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"肺炎疫情 截至今日(2月7日)，全国新型肺炎确诊人数已到达31161例，累计死亡636例，更多信息如下图所示。 在抗击肺炎的过程中，有人奋战在一线，有人投机倒把、散播谣言，活生生一幅世间百态像。在这一过程中，感受深的有两件事。第一个是造谣，人们说的「造谣一张嘴、辟谣跑断腿」，从口罩到双黄连，到各种疫情信息，人们真的是盲从的，微信群、朋友圈流出的话，轻易地就被相信，无数医护人员和其它各行各业地人员在一线奋战，更多隔离在家闲着没事地人却指手画脚，诚然，红十字会、李文亮等等各种事情必须有人监督，也必须处理，群众的监督是必不可少的，但不能因此怀疑国家的执政举措，我认为我们应该看到国家所作的努力，无论是建国以来长远的规划举措，还是应对各种突发事件的反应能力，都是积极和努力的，身边有不少同学依然在不断地指责政府，只看到了各种负面信息，却没看到国家所作的努力和中国的发展，我觉得这是有问题的，尤其是自己没出任何力气，空口白话大发评论，恐怕这就是所谓的键盘侠吧。第二个是人们的反应，国家的隔离措施和通知已经足够深入，但依然有大量的人不管不顾，导致病毒持续爆发，我也不清楚这是人性的问题还是受教育程度的问题，可能任何时候都少不了这种人，但这正是为什么需要我们努力让社会更美好。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:1:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"小事 1、02.01，学校下发通知，返校延期，不知疫情什么时候能过去，已经退过两次票了。 2、02.06，朋友公司复工，结果火车和汽车都停运，根本走不了，现在疫情管控真的很严格，只是很多人真的不自觉。 3、02.06，弟弟买的乒乓球拍到了，附送了10个带表情的乒乓球，很有意思。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"视频 1、凤凰传奇在经典咏流传演唱的《别董大》，真的惊艳，凤凰传奇的唱功是真的好，可能就是广场舞放太多审美疲劳了。 2、胡歌和刘亦菲，大龄单身，UP主剪了两人的片段凑CP，还以为两人一起拍电影了，剪的太好。 3、疫情之下我们看到了太多真实景象，很多东西需要反思，动漫《转折点》讲述了当人类与动物互换身份的故事 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"文章 1、草原雕欠下巨额话费，科学家被逼众筹充钱 俄罗斯猛禽研究与保护网络（Russian Raptor Research and Conservation Network）在俄罗斯社交媒体服务机构VK上2019年10月24日发布的一篇文章称，他们标记的草原雕太能飞，飞出了服务圈（基本上是指哈萨克斯坦），在飞到伊朗后恢复了信号，产生了巨额国际漫游短信费，一下子用光了整个项目的研究费用，为了填这个大坑，研究团队甚至发起了众筹。好在运营商得知此事后，已经退还这头雕和其他12头草原雕几个月的漫游费，并为该项目提供优惠价格，已经众筹的钱研究团队将用于之后的研究工作。实际上点击标题链接进入该团队主页，他们发布的动物保护的图片都很有趣。 2、抗疫在家，怎样让自己不那么无聊？ 首先，向奋战在疫情一线的各行各业的人致以敬意。刚刚过去的春节假期，大多数人都只能待在家里为抗击新冠疫情献一份力。由于情况特殊，很多人都被「困」在了老家或者工作的城市……那么问题来了：抗疫在家，你是怎样让自己的生活不那么无聊的？少数派出了这么一期文章，总结了一些少数派作者在家做的事。我比较感兴趣的是ElijahLee推荐的一组设计方面的书，加入待读清单里： 《色彩设计的原理》by [日] 伊达千代。这本书从最基本的色彩、视觉原理讲起，具有实操性，提供了大量的色彩搭配案例，比较基础，可以用于提高配色方面的审美，推荐★★★★☆； 《写给大家看的设计书》by [美] Robin Williams。这本书核心是提出了简单实用的四条设计原则，还有大量案例。它适合绝大多数人看，正如其名 Non-Designer’s Design Book，尤其是学生、职员、教师等需要制作PPT、名片、海报、传单等的人，最推荐★★★★★； 《你好，这是我们的名片》by 蒋友柏。蒋友柏写十多年来自己开设计公司的经历，不能说很有设计或者商业方面的大道理，但读完之后会有很多启发，值得一看。推荐★★★★☆； 《由内向外看世界》by [日] 佐藤大，日本设计师佐藤大的设计心得，适合专业人士读吧，门外汉看看就行了😂。推荐★★★☆☆。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"图片 1、迪丽热巴 看跑男的时候开始喜欢，主要可能是吃货形象戳中了我的萌点，在壁纸商店看到过一张一身鲜衣的小迪，把这张图片收藏在这里。 因为小米主题商店的壁纸无法直接下载，这里记录下如何获取壁纸图片。到MIUI文件夹，显示隐藏文件，出现的.wallpaper文件夹中保存有所有应用过的壁纸原图。因此需要哪张图片，先设置为壁纸，然后到该文件夹就可以找到。 2、大火后的澳大利亚 澳大利亚大火依然在持续，但2009年澳洲大火后维多利亚金莱克国家公园的一组图片，能够让我们提前感觉到大自然的自我修复力，虽然这并不是我们为所欲为的借口。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"资源 1、CodePen CodePen 是一个在线的前端代码编辑和展示网站，能够编写代码并即时预览效果。你在上面可以在线分享自己的 Web 作品，也可以欣赏到世界各地的优秀开发者在网页中实现的各种令人惊奇的效果。我在为博客一个页面设计时间线的时候找到的该网站，现将两个心仪的时间线样式收藏在这里。 Timeline by Mana Timeline by Mert Cukuren 2、八段锦 疫情期间，大家呆在家闲得慌，世界武术冠军、北京体育大学刘晓蕾副教授教大家练习八段锦，帮助大家足不出户锻炼身体。 3、知乎书店 主要包括知乎周刊、一小时和知乎盐系列，是对知乎中一些高质量回答的总结，还是很有意思的。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:3:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["日程及周刊"],"content":"概念 1、分娩阵痛体验仪 爱情公寓第23级看到的，觉得这真是是一个很有用的东西，帮助丈夫感受妻子分娩的痛苦，感同身受更能加倍呵护。 2、PUA 看到吕子乔再一次想起来PUA的概念。PUA，全称（Pick-up Artist），起初指的是一群受过系统化学习、实践、和不断自我完善情商的男性。后来泛指很会吸引异性，让异性着迷的男女们。字面上的解释，PUA指的是搭讪艺术家，但因为PUA文化的变迁和进步，PUA的定义已从简单的搭讪扩展到整个两性交往流程。去年这个概念火爆一时，主要是一个女学生因此自杀，造成了恶劣后果，虽然自己不用，但一定要知道，防止掉入该陷阱。 ","date":"2020-02-07","objectID":"/2020/life-weekly-6/:3:5","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 6 期 (20200207)","uri":"/2020/life-weekly-6/"},{"categories":["研究生的区块链学习之路"],"content":"Imen Riabi, Yosr Dhif, Hella Kaffel Ben Ayed, Khaled Zaatouri. A Blockchain based access control for IoT[C]. International Wireless Communications \u0026 Mobile Computing Conference (IWCMC), 2019. DOI: 10.1109/IWCMC.2019.8766506 Keywords: Access control, Blockchain, Smart Contract, Internet of Things 注：本文图片来自原论文。 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:0:0","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引入 作者的考虑主要基于三点 传统中心化的访问控制带来的单点故障和可扩展性问题； 资源有限的IoT设备需要轻量级访问控制方案(对CPU、内存、功耗的低需求) 对低延迟的需求 文章其它部分的组织结构为：第二部分为相关工作，第三部分为区块链技术介绍(阅读时略过)，第四部分为区块链安全机制介绍，第五部分阐述提出的访问控制模型，第六部分通过实验实施提出的方案，最后总结全文。 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:1:0","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2. 相关工作 该部分说明了已有物联网访问控制方案不合适的原因 RBAC：the Role based access control，物联网环境高度动态且用户数量巨大，纯RBAC无法应对。 ABAC：the Attribute based access control，规则的数量随着用户、属性的增长迅速增加，不适用于物联网高度动态和实时的环境。 Cap-BAC：Capability based access control，主要指OAuth-IoT，主要的问题是中心化结构会带来可扩展性问题和高延迟，同时该模型不支持可移动性。 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:2:0","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3. 区块链安全机制 该部分讨论区块链的安全机制从而评估其安全级别，区块链提供的安全服务和对应的实现机制如下表所示： 区块链安全服务 使用的机制 完整性 哈希函数 交易真实性 数字签名 机密性 非对称加密 可用性 多个副本分布于整个网络 匿名性 公钥用作节点地址 可追溯性 所有交易记录在区块链中 防篡改 需要大量的算力才能破坏区块链 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:3:0","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4. 方案 作者选择将 Capability-BAC 和 Identity-BAC 两个模型相结合，利用token向请求者授权(Capability-BAC)，利用访问控制列表ACL记录请求者和对应的访问权限(Identity-BAC)。资源所有者在智能合约中存储ACL，资源请求者发起请求从而逐步填充ACL的内容，从而令区块链替代传统的中心化授权服务器。 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:4:0","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 Actor 方案中涉及的角色如下 资源所有者：区块链中拥有资源的节点，部署智能合约并在智能合约中定义ACL，接收来自区块链中其它节点(请求访问资源的节点)的注册请求。 矿工：区块链中有一定计算能力的节点，替代传统的授权服务器，对来自请求者的请求进行管理，基于资源所有者部署的智能合约中的ACL生成和授予token。 请求者：区块链中想要以指定权限访问特定资源的节点，希望获取对应的访问token。 一个传统访问控制和基于区块链的访问控制角色对应表如下 传统访问控制 基于区块链的访问控制 资源所有者 区块链中的资源所有者节点 请求者 区块链中的请求者节点 授权服务器 区块链中的矿工节点 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:4:1","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 Proposal 作者提出的方案使用智能合约存储和管理ACL，每个资源所有者在自己部署的智能合约中定义和资源相关的ACL，这些ACL被矿工用于验证请求者的访问权限，从而生成访问token并给予对应的请求者。节点间的通信使用区块链本身的交易机制。 注册过程 一个新的资源请求者在智能合约中注册的时序图如下 mermaid图 sequenceDiagram participant Resource Requester participant Resource Owner participant ACL Smart Contract Resource Requester -» Resource Owner: 1. Registration Request Transaction(resource privilege) Resource Owner -» Resource Requester: 2. Registration Response Transaction alt if Registration Response == True Resource Owner -» ACL Smart Contract: 3. AddToACL(@RR, resource, privilege) end 资源请求者在对资源发起访问控制前，必须先在智能合约中定义的ACL里进行注册，然后才能向矿工申请到访问用的token。为了实现这一点，资源请求者发送一个注册请求到资源所有者来申请对特定资源的访问权限，如果资源所有者通过该请求，就会将请求者加入到合约中的ACL中，并返回一个接受注册请求的交易，如果拒绝该请求，就会返回一个拒绝注册请求的交易。 授权过程 一旦请求者收到资源所有者返回的接受注册请求的交易，就发送一个授权请求交易到矿工，其中包含资源与权限。矿工通过智能合约中定义的ACL验证其是否真的拥有对所请求资源的权限。如果确认拥有权限，就生成一个token，包含请求者地址、资源、权限和表示token生命周期的时间戳，矿工对token进行签名并加密，利用授权响应交易将其发送给请求者节点。如果验证后发现没有权限(智能合约返回无效请求)，矿工就发送一个拒绝授权响应交易给请求者的地址。接收到token后，请求者发送包含token的访问请求交易到资源请求者的地址，资源所有者解密token，验证是否被矿工签名，如果是，访问通过，否则拒绝访问请求。 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:4:2","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"5. 仿真 作者使用V2X(Vehicle to everything)通信系统验证方案的可行性，使用该系统意味着和汽车通信的对象可能是其它汽车、基础设施或任意连接到汽车网络的其它对象。将驾驶员辅助系统ADAS作为资源，汽车作为资源所有者，任何已连接的对象都可以是资源请求者。 选择以太坊平台进行实验，使用Truffle框架编译、测试和部署智能合约，使用Geth作为客户端操作区块链节点，使用Node.js编写代码调用web3.js API和区块链节点通信。 实验使用的设备为电脑和树莓派，两者均安装以太坊节点，电脑中的节点作为矿工和资源请求者，树莓派中的节点作为资源所有者(汽车)。一旦存储ACL的智能合约部署到区块链，资源请求者就可以从矿工申请访问token。 作者实现了以下接口用于交互： 资源所有者节点接口：运行后显示所连接的汽车节点的地址和汽车节点部署的智能合约的地址，另外，还会显示汽车所有者可执行的操作列表，包括检查以前的请求、设置新的ACL属性、响应注册或访问请求、退出列表。 请求者节点接口：该接口要求请求者输入自己的账户地址和密码，验证通过后显示资源请求者可执行的操作列表，包括检查之前接收到的交易，发送注册请求、申请token的请求或访问请求，退出列表。 矿工接口：该接口显示节点地址和矿工可执行的操作列表，包括检查之前的请求、响应对token的申请和退出列表。 授权过程被划分为两阶段，第一阶段矿工基于智能合约中的ACL验证和授予token，第二阶段资源所有者基于验证token有效性授予访问权限。 矿工基于ACL中定义的权限进行授权，发送对应的token 资源所有者验证token有效后授予访问权限 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:5:0","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"6. 总结与启发 作者确实利用区块链设计了一个完整可行的访问控制方案，解决了单点故障和可扩展性问题。在该方案中，作者将矿工纳入权限授予过程，保证了权限的不可篡改，和区块链结合的较为深入，这是一个亮点。但依然存在以下两个问题： 请求者发起一次访问请求需要经过2~3次通信过程。当第一次发起对某个资源的访问请求时，需要首先向资源所有者发起注册请求并获取回应，然后向矿工发起请求获取token，最后再一次向资源所有者发起请求获取权限，总计3次通信过程，之后每次发起请求，依然需要获取token和获取权限两次通信。由于方案中通信的实质是区块链中的交易，而交易打包到区块并经过验证拥有一段确认时间，多次往返通信会造成一个较大的延迟，不利于物联网环境中的实际操作。 资源所有者利用ACL定义请求者对资源的访问权限，从方案设计来看，每次有新的请求都需要资源所有者主动识别和确认是否授权，物联网环境设备数量较大，因此单位时间产生的访问请求量级也比较大，这种授权方式工作量较大，不利于操作。 ","date":"2020-02-06","objectID":"/2020/a-blockchain-based-access-control-for-iot/:6:0","tags":["论文笔记"],"title":"A Blockchain based access control for IoT","uri":"/2020/a-blockchain-based-access-control-for-iot/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第五期。 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"时讯 1、欧盟领导人正式签署英国“脱欧”协议 01.24 当地时间24日，欧洲理事会主席米歇尔与欧盟委员会主席冯德莱恩正式签署英国“脱欧”协议，该文件在布鲁塞尔签署后，欧盟和英国官员将其带到唐宁街，英国首相鲍里斯将在周五签署该文件。随后该协议将返回布鲁塞尔，并将其副本保留在伦敦。 2、新型肺炎已蔓延至全国 01.26 截至1月25日24时，新型肺炎确诊病例1975例，现有重症病例324例。累计死亡病例56例，累计治愈出院病例49例。现有疑似病例2684例。现已蔓延至除西藏外全国，在武汉封城之后，全国各省都启动了重大突发公共卫生事件一级响应，并开始限制公共交通，电影上映等各类春节活动全部取消或推迟，春节的走亲访友也在宣传下停止，希望事态早日得到控制。 3、NBA球星科比·布莱恩特及13岁女儿在坠机事故中身亡 01.27 当地时间1月26号，多家美国媒体报道称，NBA退役球星科比·布莱恩特在加州一起坠机事故中身亡。其13岁的女儿吉安娜也在事故中遇难。科比于2016年从NBA退役，在20年的职业生涯中，科比共为洛杉矶湖人队赢得5次NBA总冠军，代表美国国家队赢得两枚奥运男篮金牌，堪称历史上最伟大的篮球运动员之一。 4、阿富汗一载有83人的客机坠毁 伤亡不明 01.28 27日，阿富汗阿里亚纳航空公司的一架客机在阿富汗加兹尼省坠毁。 加兹尼省政府一位发言人说，事故发生在当地事件27日下午1点10分左右，失事的是一架波音飞机。另据俄罗斯卫星网报道，机上共有83人。 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"小事 1、01.25，春节已到，鼠年吉祥，本命年，希望自己一切皆好。 2、01.26，初二应当去舅舅家，但疫情严重，手机拜年，不出去了。 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"视频 1、【无线桌面】五分钟了解一个桌面为何如此整洁：桌面理线心得分享 UP主: 喃书生 2、俄罗斯短片 不要让他们白白牺牲 纪念卫国战争爆发 UP主: 日出昢昢 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"文章 1、若相关程序员不幸逝世：他的开源软件会有人维护吗 一个很严肃但不得不思考的问题，尤其是目前越来越多的项目开始依赖开源代码库，而开源代码库之间相互依赖，形成了相互依存的复杂软件网络。GitHub目前拒绝讨论其关于转移项目控制的政策，虽然多数包管理系统的维护人员有一个专门的流程来转移对库的所有权，但这个过程取决于是否有人能发现某个项目已不被更新并自愿接管它。 2、打发时间的100种方式 表面是打发时间，其实不如说是如何热爱生活，通过这些小事，能感受生活的美好，成为一个内心温暖的人。 3、Git 的提交信息怎么写？（英文） 提交代码的时候，需要写提交信息。本文介绍如何规范地写提交信息。已经整理过这方面的知识，但这篇文章总结的比较全。 4、5分钟看懂开源协议 以前关心过，也查阅过一些资料，但一直都没弄懂，这篇文章写的算足够全面且清晰明了了。最关键的其实只需要记住三点： 如果想省事，不关系别人用自己的代码去做什么，直接选 MIT 或者 BSD 就好 如果想代码修改以后做出声明，选择 Apache 协议 如果想“繁衍”后代，那么使用 GPL 协议 更详细的总结可以具体看文章最后的思维导图。 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"图片 1、杨子姗 从电脑《南极之恋》知道并喜欢的该演员，端庄大气，演技也可以，真的是很喜欢了。 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"工具 1、奶牛快传 大文件的线上分享，不需要注册就可以直接上传和下载文件，并且上传和下载速度都非常快，不限速，单个文件大小不超过20G，分享的文件免费下载次数根据文件大小确定，如下图所示，下图同时还演示了不注册情况下如何上传和共享文件。一般使用是网页版，有IOS客户端，但没有安卓客户端，在大文件共享方面相当有优势。 2021年更新，果然做大了就变了，奶牛快传已不值得使用。 2、slack 最优秀的团队即时沟通工具，把线上沟通分成不同的小会议室，可以选择开发或私密，灵活管理。 3、teambition 任务看板工具，团队协作中对个人任务的另一种呈现方式，可以按照不同的项目或者流程来定制看板，查看进度，和即时沟通、文档协作一起服务于团队。 4、MiroVideoConverter 音视频格式转换，简单易用。 5、极客阅读 一个安卓 App，技术阅读的入口，汇聚了国内外技术博客、产品动态、公众号文章。试用了一下，主界面挺好，但每篇文章都会跳到具体的文章来源网站，比如掘金等，理论上是没有问题的，也可以避免版权问题，但在视觉上可能不是很舒服。 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:3:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"资源 1、MDN web docs 一开始是寻找HTTPS协议的具体内容找到了这里，但又看见了HTML、CSS和Javascript的具体内容，以及大量关于Web开发的其它内容，讲解又比w3school浅显易懂，是一个非常棒的网站。 2、iNaturalist 该项目最早在2008年作为Nate Agrin、Jessica Kline和Ken ichi-Ueda的硕士项目启动，2014年，iNaturalist成为加州科学院的一项倡议，并在2017年与国家地理学会联合发起。这是一个全球性协作项目，全世界用户拍摄自己周围大自然的照片，然后上传到网站，由专家鉴定，其它用户打开地图，就能在该位置看到这些照片。该项目帮助普通人更多的了解大自然，同时帮助保护自然的科学家创建高质量的研究数据。 3、unDraw 一个商用的免费插图网站，风格还蛮符合我心意的。 ","date":"2020-01-31","objectID":"/2020/life-weekly-5/:3:5","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 5 期 (20200131)","uri":"/2020/life-weekly-5/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第四期。 ","date":"2020-01-24","objectID":"/2020/life-weekly-4/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 4 期 (20200124)","uri":"/2020/life-weekly-4/"},{"categories":["日程及周刊"],"content":"时讯 1、习近平访问缅甸 01.18 应缅甸总统温敏邀请，中华人民共和国主席习近平于2020年1月17日至18日对缅甸联邦共和国进行国事访问，并发布了《中华人民共和国和缅甸联邦共和国联合声明》，这是最近几天新闻联播的主要内容。 2、新型冠状病毒感染的肺炎疫情受到全国关注 01.20 湖北武汉发生的新型冠状病毒感染的肺炎疫情在持续发展，前段时间没有太过关注，但最近在上海、北京等多地都发现了感染者，国家的疾控管理等级也不断上升。截至20日，我国境内确诊218例，其中武汉198例、北京5例、广东14例、上海1例，日本通报1例、泰国通报2例、韩国通报1例，钟南山院士领导的专家组已经确认有人传人的症状，甚至已经有医务人员感染。让人不经想到当年的「非典」，不过从现在来看，早期就已经被控制在了武汉，国家的疾控管理还是很好的，在做好防护措施的同时，希望相关疫苗早日研发出来，疫情得到很好处理。 3、武汉封城 01.23 武汉疫情进一步发展，武汉市新型冠状病毒感染的肺炎疫情防控指挥部1月23日发布公告，23日10时起，武汉市城市公交、地铁、轮渡、长途客运暂停运营，机场、火车站离汉通道暂时关闭。截至1月22日24时，累计感染人数已达571例，其中重症95例，死亡17例(均为湖北省)。 ","date":"2020-01-24","objectID":"/2020/life-weekly-4/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 4 期 (20200124)","uri":"/2020/life-weekly-4/"},{"categories":["日程及周刊"],"content":"小事 1、01.18，整理旧书，高中以前的书都用不着了，打算卖掉，从旧书中掉落一片银杏叶标本，有点惊喜。 2、01.20，早上打开电脑，屏保变成了外滩烟花图，非常好看，有了过年的气氛。 3、01.21，花娟姐帮忙拿了10枚鼠年纪念币，今天逛街买年货去取了一下 4、01.24，除夕快乐！ ","date":"2020-01-24","objectID":"/2020/life-weekly-4/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 4 期 (20200124)","uri":"/2020/life-weekly-4/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-01-24","objectID":"/2020/life-weekly-4/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 4 期 (20200124)","uri":"/2020/life-weekly-4/"},{"categories":["日程及周刊"],"content":"文章 1、How To Get Nick Wooster’s Syle Nick Wooster被誉为「世界上最会穿衣的型男」，曾做过著名公司的时尚总监，现在经营者自己的时尚造型公司，他的穿着总能给人眼前一亮的感觉，如何学习他的穿衣风格，可以参考这篇文章。 2、(-)(–)(—)(−)这几个符号你都用对了吗 这篇文章来自中国科学出版社的微信公众号，帮助我们正确的区分和使用这几个符号，不过实际上，以后用起来可能还是不会注意 😂 3、Will Bullet Comments be Popular in America? KrASIA上的一篇文章，介绍了为什么弹幕网站在中日两国之外流行不起来，主要包括 语言障碍。Youtube的网站面向多种语言，弹幕形式很难被所有人理解 可能的高成本。习惯干净屏幕的用户可能无法接受弹幕形式，不当评论可能会显示到比原来更重要的位置，从而给观众带来不适 弹幕更吸引年轻观众，但美国法律对未成年保护更严格和全面，Youtube等可能因此面临严重诉讼，与带来的创收不匹配 从语言学上分析，知乎有一个问答为什么全世界只有中日两个国家弹幕视频网站成为流行？说的可能更明白 ","date":"2020-01-24","objectID":"/2020/life-weekly-4/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 4 期 (20200124)","uri":"/2020/life-weekly-4/"},{"categories":["日程及周刊"],"content":"工具 1、Inpaint 老照片修复、去水印、去除特定的人或物、去除时间戳、简单的皮肤美颜等等，一款傻瓜式但很有用的工具。 ","date":"2020-01-24","objectID":"/2020/life-weekly-4/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 4 期 (20200124)","uri":"/2020/life-weekly-4/"},{"categories":["日程及周刊"],"content":"图片 1、A Man Feeding Swans in the Snow Marcin Ryczek拍摄的照片，极具美感 ","date":"2020-01-24","objectID":"/2020/life-weekly-4/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 4 期 (20200124)","uri":"/2020/life-weekly-4/"},{"categories":["我所热爱的生活啊"],"content":"租房是现在和未来几年逃不开的话题，这里总结租房时要注意的事情 ","date":"2020-01-23","objectID":"/2020/life-skills-notes-on-renting/:0:0","tags":["生活技能"],"title":"生活技能-租房注意事项","uri":"/2020/life-skills-notes-on-renting/"},{"categories":["我所热爱的生活啊"],"content":"找房子 可以通过熟人、网络、小区广告等了解情况，节省费用，但耗时耗力。 找中介是可以的，但要找正规中介，别被坑 可以找知名的互联网租房平台，但一定要看房 一次性只有很小的可能找到心仪的房子，可以先短租一段时间，利用这段时间不断走访和看房，最终挑选自己喜欢的房子 租房有时会花费很长时间，不要等到上一个房子快到期的时候才招。一般至少提前2周左右开始找房 最好选择和同学或者熟人合租。如果是和不认识的人合租，一定要互相留下身份证复印件和联系电话 自己租房的要查看所租房子的产权证、房东的身份证明等。如果是与中介签订出租合同，要查看中介机构与房东的委托代理协议，了解中介机构的代理时间 法律上，二房东如果将租赁的房屋转租，必须要经过原房东的同意，否则无效。因此租房者可以要求查看二房东与原房东所签订的租赁合同。此外，转租合同的终止日期不得超过原租赁合同规定的终止日期，否则租房者会承担比较大的风险 ","date":"2020-01-23","objectID":"/2020/life-skills-notes-on-renting/:1:0","tags":["生活技能"],"title":"生活技能-租房注意事项","uri":"/2020/life-skills-notes-on-renting/"},{"categories":["我所热爱的生活啊"],"content":"看房子 房子不要靠近繁忙的马路，隔音不好的话影响睡眠质量 选择采光和通风比较好的房子 周边生活配套设施要齐全方便，如菜市场、超市、公共交通、快递点、就医条件等等 应检查屋内家具、电器、门窗、阀门等是否老化或损坏，所有的物品列清单并和房东商量好损坏赔偿细节，并写入租房合同中。 不能使用的物品或者使用过程中损坏，可以要求房东维修，如果房东承诺变更，有必要在合同中说明。 物业交验应作为合同的附件：如果通过中介租的房，交接时中介公司会提供一张物业清单作为合同附件且注明损坏程度。而如果是自己租房，需要记录水、电、气三表的具体数值、内部电器的使用情况、业主暂存物品的状况等，并作为合同附件一一说明。 房屋交接完后尽快更换锁芯，正式入住后，如果碰到设施正常使用中出现故障等情况，应当第一时间找房东或中介。 水电、物业、取暖、卫生等费用都要实现商量好并写进合同，电表、水表的初始计数要记录 确认房东对房子的所有权，要求查看其身份证、房产证 押金支付要慎重，一般是一个月 商量好付房租的周期，年付、季付或月付，对自己来讲，越短越好 询问周围邻居，不要有太吵闹或不易相处的 ","date":"2020-01-23","objectID":"/2020/life-skills-notes-on-renting/:2:0","tags":["生活技能"],"title":"生活技能-租房注意事项","uri":"/2020/life-skills-notes-on-renting/"},{"categories":["爱编程爱技术的孩子"],"content":"作为一款成熟的商业系统，windows提供了大量实用的功能，尤其是到了win10后，很多功能的体验变得越来越好，本篇对这些功能做总结。 值得注意的是，很多功能其实只需要设置一次就不需要再理会，或者干脆微软默认已经进行了最佳设置，这对于我们追求效率和极简是一件非常棒的事。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:0:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 搜索 首先介绍win10的搜索功能。win10系统出现以来，Cortana就一直是任务栏的常驻功能，在响应语音的同时，也兼职文件搜索，不过并不好用。直到1903版本之后，Cortana和搜索功能拆分，新的搜索可以搜索电脑中的文档、照片、邮件、应用、系统设置、文件夹等等，并且提升了视觉效果，使用体验高了一倍不止。除此之外，在设置中也增加了「搜索」板块，可以排除不查看的文件夹，缩短搜索时间。 事实证明，新的搜索功能非常好用，在下面的内容中，我们会大量使用该功能。唤起搜索的快捷键是win+Q。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:1:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 磁盘优化 win10的磁盘优化分两种。对机械硬盘来说，指的是碎片整理，磁盘碎片是机械硬盘读写过程中产生的不连续存放空间，随着使用时间的增加，磁盘碎片会不断增长，并影响文件的读写速度，碎片整理是将这些不连续的空间整合成一个大的存储空间，目的是提升我们复制粘贴文件(读写文件)的速度。对于固态硬盘(SSD)来说，指的是TRIM，是把已删除文件标记为无用，避免磁盘将其当成有用数据重复移动，从而影响读写速度和硬盘寿命。 关于磁盘碎片整理和TRIM的说明，可以查阅一个知乎问答。 win10系统中对硬盘类型做了自动识别，从而采取对应的优化策略，并且默认每周执行一次优化，因此不需要我们手动设置，如果想调整执行优化的周期，可以下面的方式执行 按「windows 徽标键 + Q」快捷键唤起搜索，输入关键词「磁盘优化」 选择搜索结果中的「碎片整理和优化驱动器」，一般是第一个结果 选择「更改设置」，然后更改频率即可 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:2:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 自动垃圾清理 在介绍win10提供的自动垃圾清理功能前，我们先来理解第三方软件清理垃圾时是清理哪些内容，以火绒为例，清理项包括 系统垃圾：系统运行产生的垃圾，包括常用软件日志、回收站垃圾、系统缓存、系统临时文件、系统日志等 常用软件垃圾：软件缓存垃圾，如Internet缓存 注册表垃圾：无效注册表 快捷方式：用不到的快捷方式 系统垃圾，尤其是其中的回收站垃圾所占比重最大。从出发点来看，垃圾清理的目的是释放磁盘空间，适用于磁盘空间不足的情况。但很多人其实清理垃圾已经成为了一种习惯，与磁盘空间不足无关，常见的操作是定期清空回收站，至于安全软件提供的垃圾清理功能，往往只有在想起来的情况下才会使用。所以，如果win10可以定期清理回收站呢，甚至定期清理系统缓存、临时系统文件、软件日志等安全软件进行垃圾清理的主要内容，更进一步还包括经常被我们遗忘的「下载」文件夹，以及占用大量空间的windows.old文件夹。win10中的「存储感知」功能可以做到这些事情。 搜索「存储设置」，点击「配置存储感知或立即执行」，可以设置运行存储感知的频率。我当前设置为「在可用磁盘空间不足时」，可以将其调整为每周或每月。设置中还包括定期清理回收站、下载文件夹和长时间未使用的OneDrive文件，可以说考虑到了绝大部分的使用情况。 关于定期运行的「存储感知」，其查找并删除的文件包括但不限于： 临时设置文件 旧的索引内容 系统缓存文件 Internet 缓存文件 设备驱动程序包 系统下载的程序文件 系统日志文件已过期 系统错误内存转储文件 系统错误小型转储文件 临时系统文件 Windows 更新临时文件已过期 因此，开启存储感知功能后，垃圾清理将不再是我们需要考虑的事情，能够节省一些宝贵的时间和精力。当然，如果闲着没事还是想时不时的手动清空一下回收站，谁也拦不住，也没有任何影响。 理论上，配合windows安全中心，我们是不需要安装第三方安全软件的，不过类似于弹窗拦截等功能，win10系统就无能为力了。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:3:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 专注助手 win10提供的「专注助手」功能可以让我们在需要集中注意力时消除让人分心的通知，比如每天固定学习或工作的时间段。在桌面右下角的操作中心中通过点击打开或关闭专注助手，可以在三个设置中循环切换：仅优先通知、仅限闹钟和关闭。 搜索「专注助手」，打开其设置页面，可以看到系统提供了一系列的场景，比如使用投影时和全屏模式下启用仅限闹钟、玩游戏时或每天固定的时间段启用仅优先通知。此外，在仅优先通知选项的下面，可以设定自定义的优先列表，但其中的选项对我们都是无意义的，包括来自手机的通知(但win10的这一功能国内不可用)、系统应用的通知等，所以不介绍。 我们启用该功能的目的还是提供的这几个场景：游戏、投影、全屏、固定时间段，启用后可以过滤操作中心弹出的大量通知，有经验的应该知道操作中心弹出的通知真的很烦人。不过1909版本后，可以自定义操作中心的通知，将从来不用的系统应用的通知全部关掉就好，搜索「通知和操作设置」可以打开设置页面。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:4:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 跨设备剪贴板同步 将剪贴板的内容进行同步，从而可以在多个设备进行粘贴。搜索「剪贴板」可以打开该设置 按「Windows 徽标键 + V」可以查看剪贴板的内容 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:5:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 快速添加提醒 win10现在可以从任务栏的时间和日期处快速添加事件或提醒，对于以Outlook为主力日历应用的人来说是非常方便了，但对于以手机日历为主力的人来说没有什么用。 对于小米手机来讲，可以将小米日历和win10的日历进行同步，这样，「快速添加提醒」这一功能对我们就变得非常有用了，操作步骤如下 在win10日历应用中添加Exchange账户，但账户名为outlook邮箱，并在日历设置里把账户同步打开 在win10邮件应用中登录Exchange账户，账户名依然为outlook邮箱 在小米手机的电子邮件应用中以Exchange账户登录，账户名还是outlook邮箱 查看日历的账户设置，发现此时已经拥有两个账户，日历应用中也有了同步过来的所有事件和提醒 日历的同步间隔跟随邮箱，我设置为1小时一次，以除夕合成五福这一提醒为例，我在电脑上添加的该提醒，现在已经同步到了手机 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:6:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"7. 就近共享 两台电脑进行文件传输，我们通常使用QQ、微信或者一些第三方软件，但在近距离情况下，使用蓝牙和WIFI其实是最简单的方式。win10系统将文件传输的功能集成到了右键菜单里，非常方便。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:7:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"8. 热点共享 手机开热点共享WIFI给电脑已经是很常用的操作，电脑共享网络给手机就不是很常见了，通常使用的解决方案是购买随身WIFI。但其实win10本身可以利用内置的无线网卡直接开启热点，而不需要其它的设备。 搜索「移动热点设置」，可以打开设置页面，开启该功能，并设置网络名和密码，就可以开启一个热点网络，如图所示，现在开启的「书藏的热点」已经被我的手机搜索到并接入，该界面会显示设备名、IP地址和MAC地址。在操作中心可以快捷的打开和关闭热点。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:8:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"9. 分屏与虚拟桌面 在介绍桌面的那篇文章已经介绍过这两个功能，但有些细节没有提到，这里重提一下。 将不同的工作窗口朝边缘拖动可以看到分屏的框，虽然看到网上说最多四部分，但我实际操作过程中只能同时分三个窗口。分屏操作是工作和学习中一个非常实用的功能，但该功能其实在win10以前就有，win10所作的改动是，不需要单击某个窗口才能操作，而是将鼠标移动到该窗口的范围就可以执行滚动页面等操作，这个小改进为我们带来了巨大的效率提升。 如果说分屏是一个工作同时开启多个窗口，虚拟桌面就是在不同的工作间切换，比如我将论文阅读和博客写作两件事分到不同的桌面。使用「windows 徽标键 + Tab」可以进行切换不同的桌面，同时也可以查看时间线并跳转查看之前的工作。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-5-system-function-use/:9:0","tags":["win10"],"title":"win10效率优化5-系统功能的充分利用","uri":"/2020/efficient-use-of-win10-5-system-function-use/"},{"categories":["爱编程爱技术的孩子"],"content":"对win10中使用的软件体系进行整理，在满足需要的同时，选择每一类软件中最适合的一种，同时尽量减少安装的软件数量。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:0:0","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 系统管理 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:1:0","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 火绒 抛弃腾讯和360的全家桶，火绒简单易用，只保留必需的功能，在后台默默工作，没有需要甚至意识不到它的存在。火绒的弹窗拦截功能也非常好用。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:1:1","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 IObit Uninstaller 软件管理，能把安装的软件卸载的干干净净，而不是残留一堆注册表和空文件夹。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:1:2","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 7zip 免费开源的压缩软件，有更强的压缩能力，体积足够小(1M)且软件足够简单，只提供必要的功能，集成到右键就像系统自带的一样，不会像WinRAR或2345好压那样每次弹出那个丑陋的界面。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:1:3","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 OneDrive 文件同步，必备软件，坚果云限制流量不限制空间，OneDrive限制空间不限制流量，后者更适合我。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:1:4","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 生活 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:2:0","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 迅雷影音 很多人推荐PotPlayer，但少有人注意迅雷影音现在已经移除了所有的广告和推荐，只留下干干净净的界面，论功能足够强大，论颜值也比PotPlayer强，所以我换到了它的阵营。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:2:1","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 Edge Edge chromium的使用体验挺好的，相比于原版的Edge，支持Chrome商店的所有应用，又有能打的颜值、阅读模式等等实用功能，之前一直用Dev版，1月16日发布正式版后立马跟进。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:2:2","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 Microsoft To Do ToDo类应用，颜值非常高，同时功能全面，还可以和Outlook账户关联同步，手机端也有应用，我现在的待办和备忘是通过它和小米便签协同工作的。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:2:3","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 迅雷 下载软件，没有选择余地，IDM付费且颜值确实低，FDM的下载速度跟不上，Aria2需要复杂的配置，我平常一般只下载一些电影，得不偿失，所以最后还是用了迅雷。关闭开机启动，用火绒拦截弹窗之后倒也还能用，不会造成太大的困扰。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:2:4","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"2.5 PanDownload 网盘文件下载，限于百度云不开会员限速到几K的策略，虽然我自己已经不再用网盘，但网上大量的资源依然以网盘的形式分享出来，我使用的下载工具就是PanDownload，现在还集成了资源搜索功能，不用费力的去网上搜索资源，不过有段日子没用该软件了，不知道现在怎么样。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:2:5","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"2.6 其它 只需要提一个名字，不需要过多介绍的软件，包括 QQ 微信电脑版 网易云音乐 office套件 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:2:6","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 美化 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:3:0","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 Win10萌化通用工具箱 本质就是一个Win10美化工具箱，用它透明化任务栏、设置文件夹背景、跳转库文件和快速访问的显示等，一个软件可以完成TranslucentTB的多个软件的作用。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:3:1","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 Rainmeter 仅使用其时钟插件，尽可能减少资源消耗。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:3:2","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 工作 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:4:0","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 Chocolatey 包管理工具，方便安装和卸载，我用它安装的软件包括：Golang、Hugo、Git、nvs，对于编程相关的这些软件来说再方便不过了。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:4:1","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 VScode 代码编辑器，足够轻量，功能也足够。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:4:2","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"4.3 Typora Markdown文档编辑器，所见即所得，写作工具。下载地址 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:4:3","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"4.4 Snipaste 截图工具，功能全面，不用必须登录QQ，从win10应用商店搜索下载即可。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:4:4","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"4.5 Zotero 文献管理工具，科研必备，转了半天还是它最好用。下载地址 大量的工具都可以通过 chocolately 安装，包括 Edge，Github Desktop，VSCode，Go，Typora，pandoc，iobit uninstaller，git，rainmeter，zotero，uplay 和 steam，openVPN，NZXT，Notion，7zip。 ","date":"2020-01-19","objectID":"/2020/efficient-use-of-win10-6-software-collection/:4:5","tags":["win10"],"title":"win10效率优化6-软件体系整理","uri":"/2020/efficient-use-of-win10-6-software-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"文件管理是效率提升、电子资料极简化的重要部分，本文探索如何有效的对win10中的文件进行管理，核心包括三部分：分类、命名和备份。 ","date":"2020-01-17","objectID":"/2020/efficient-use-of-win10-4-file-management/:0:0","tags":["win10"],"title":"win10效率优化4-文件管理","uri":"/2020/efficient-use-of-win10-4-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 分类 win10中，最大的分类是磁盘。我的电脑有两块硬盘，划分情况如下 三星SSD 120G：系统盘(C盘) 西部数据机械硬盘 1T D盘 852G：个人资料 F盘 80G：其它 SSD只有120G，将其整个作为系统盘，从而提示系统运行流畅度，因为安装的软件不算多，不需要在机械硬盘中单独划分软件安装盘。同时，将软件直接安装在系统盘也可以提升运行流畅度，目前，C盘只占用了50G，因此对于我来说，这种划分方式是合适的。对于游戏来说，一般容量比较大，在安装时就会选择较大的D盘，安装在专门的游戏文件夹。 硬盘其实作为一个完整的磁盘存在比较好，因为划分后文件的复制粘贴都会浪费大量的时间，但出于秩序的考虑，还是将机械硬盘划分成了两个磁盘。F盘划分了少量的空间，主要有如下用途 OneDrive同步文件夹 Github本地仓库 网易云等软件设置的默认下载文件夹 我使用OneDrive作为同步策略，免费的情况下能获得的最大容量是15G，Github的仓库一般对应某个开发项目，在有限的时间和精力下，一个人同时开发的项目不会很多，另外，Github每个仓库的存储上限是1G，以同时开发5个项目算(已经很多了，而且很少有项目真的占到1G容量上限)，这两部分内容大概会用到20G容量，剩下的容量足够作为网易云等软件的缓存。 D盘划分的空间占用了绝大多数，日常的使用以看电影、看剧、收藏动漫和软件、游戏存档和资料、照片为主，因此建立了如下文件夹 电影：故名思意，存放下载的电影，会注意及时删除看过的电影，遇到喜欢的会收藏的移动硬盘中 剧集：存放电视剧和动漫，我目前有两个子文件夹，宫崎骏和老友记 软件：一些解压即用的、小众不易寻找的软件，以及各种系统镜像 虚拟：存放VMware的虚拟机，强迫症发作才把名字改成两个字，好在自己明白它是做什么的，因为虚拟机通常都在几十G，放在C盘会占用大量空间，因此放在此处。 游戏：以游戏名建立不同的子文件夹，正在玩的游戏存放游戏本体，以前的游戏存放游戏存档和当初收集的游戏资料等。 照片：照片的分类整理是最为繁琐的，为了保持相互之间最大的独立，大部分照片按时间线分类，目前有三部分：高中、本科、硕士，除此之外，根据具体情况，还有三个文件夹如下 家人：因为家人照片贯穿整个时间线，单独建立文件夹 旅游：平时经常出去玩，因此单独建立文件夹，里面按景点名建立子文件夹 待用：存放比如身份证照片、化验单等等工作和生活中可能用到的照片 以上是整体的框架体系，OneDrive同步文件夹中的结构在本文第三部分介绍。接下来说明日常生活工作的基本流程。 电影在下载时直接下载到D盘的电影目录，其它下载的文件默认位置可能是win10默认的下载文件夹和迅雷等下载软件的默认下载目录，注意要及时的做好分类，解压即用的软件放到D盘软件目录，需要收藏的软件也放到这里，一般的软件安装完成后将安装包删除，其它各种文件按这种办法及时的归类和用完删除。 在此电脑下，win10会默认提供几个文件夹，比如图片、文档、下载、桌面等，其它几个使用频率较小，因此我只保留了这四个。去除该页面不想要的文件夹的方式可以在网上搜索，我使用的是坑晨大佬的Win10萌化通用工具箱，除了自定义资源管理器这些文件夹的显示外，还用它来透明化任务栏、半透明资源管理器背景和在资源管理器右下角添加喜欢的背景人物。我的此电脑界面如下，同时，此电脑也是文件资源管理器的默认打开页面。 以上保留的四个文件夹都可以作为单独的文件夹被OneDrive同步，文档经常被各种软件作为默认的数据存放目录，我们可能经常需要到这里找东西，因此在初始页面保留，下载前面已经谈到，主要作为浏览器的默认下载目录，打开的频率很高，桌面就是电脑桌面，我习惯不在桌面放置任何文件，只有在工作时放置一些临时文件，但都是用完即删，但也因此有一定的使用频率。图片是唯一一个添加到OneDrive同步的，和D盘的照片不同的是，这里存放的是使用频率较高的或需要在多个电脑使用的图片，当前有四个子文件夹 壁纸 收藏 头像 截图 图片目录也是系统截图等很多情况下的默认使用目录。 除此之外使用频率较高的只有D盘照片目录，定期对新照片进行整理存放即可。F盘的Github本地仓库也根据开发工作进行调整。 ","date":"2020-01-17","objectID":"/2020/efficient-use-of-win10-4-file-management/:1:0","tags":["win10"],"title":"win10效率优化4-文件管理","uri":"/2020/efficient-use-of-win10-4-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 命名 我们这里谈到的命名是自己经常接触的，需要命名的文件，如Github仓库的项目文件、游戏本体、虚拟机、解压即用的软件等，本身自己作为一个单独的文件夹存在，内部已经有着完善的目录体系，虽然涉及大量不同的文件类型，但我们通常不需要对其进行操作，强行重命名甚至可能导致文件不可用，所以不进行讨论。比如某个虚拟机的目录如下 test.nvram test.vmx test-000002.vmdk test-Snapshot2.vmem test-Snapshot5.vmsn vmware-1.log test.vmdk test.vmxf test-c948472c.vmem test-Snapshot2.vmsn vmware.log vmware-2.log test.vmsd test-000001.vmdk test-c948472c.vmss test-Snapshot5.vmem vmware-0.log 一个好的文件命名应满足如下需求 良好的可读性 传达一个清晰的含义 易于检索 我们大致将所有存放的文件划分为如下几类 视频：mp4、mkv等各种格式的视频 图片：jpg、png等各种格式的图片 文档：docx、txt、md、xlsx、pptx等各种格式的文档，我们这里将表格和PPT也算作文档类型 对于视频文件，主要分布在D盘的电影和剧集两个目录下。对于电影来说，我关注的只有电影名，清晰度、是否蓝光或高清、字幕类型等都是下载之前挑选的，下载之后，去除所有的冗余字段，简单的重命名为电影名即可。对于下载的剧集或动漫，一般情况本身具有完整的目录和命名体系，比如我电脑中的老友记，每一季分属不同文件夹，以第一季为例，文件夹和其中每一集的名称如下，完全不需要我们过多的改动。当然，下载的文件没有完善的分类和命名时，可以按一种简化的方式，每一季建立单独文件夹，每一集以剧名和集数命名。 ./Friends.S01.1994.BluRay.720p.x264.AAC-iSCG: Friends.S01E01.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E13.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E02.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E14.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E03.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E15.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E04.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E16.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E05.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E17.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E06.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E18.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E07.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E19.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E08.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E20.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E09.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E21.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E10.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E22.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E11.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E23.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E12.1994.BluRay.720p.x264.AAC-iSCG.mp4 Friends.S01E24.1994.BluRay.720p.x264.AAC-iSCG.mp4 对于图片，如前所述，主要是D盘的照片目录和OneDrive的图片目录，基本的命名结构为序号+图片描述+时间戳，三部分之间以下划线_连接。 序号：序号主要是为了进行区分和对图片合理排序 图片描述：对图片内容的简单描述，不需要包含时间，因为命名结构的第三部分有时间戳，不需要包含人物，因为我们通常可以一眼辨识出图片中的人物，不要和所属目录的描述字段重复，比如目录已经命名为某个地点，在图片命名时重复添加地点字段 时间戳：一个格式示例为20200116，意为2020年1月16日，只精确到天，因为精确到时分秒会在重命名时增加大量的工作量 图片描述部分的说明不是绝对的，命名结构的三部分也都是可选的，不是每张图片名都包含这三部分。比如下面的照片，是我最喜欢的歌手J.Fla，因为电脑里只有一张她的照片，所以命名没有序号字段，同时这种照片添加时间戳是没有意义的，因此也没有时间戳字段，简单起见，该图片直接命名为她的名字，简单易懂，是最合适的命名方法。 以张氏帅府说明完整的命名示例 对于文档，依然遵循三部分的命名结构，但需根据情况适当调整，命名的目的是便于阅读和检索，在某些字段没有必要时，不必添加，而在标准字段外还需要添加说明，也可以附加其它字段，一切要灵活。比如对书籍的命名可以在前面添加作者名字段。 ","date":"2020-01-17","objectID":"/2020/efficient-use-of-win10-4-file-management/:2:0","tags":["win10"],"title":"win10效率优化4-文件管理","uri":"/2020/efficient-use-of-win10-4-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 备份 我的备份方案主要分为两部分，OneDrive和移动硬盘，这两种方式选择的主要依据是使用频率。 移动硬盘保存的是使用频率极小的文件，包括 看过的非常喜欢的电影、剧集、动漫等 私密性要求较高的照片。实际上大部分的生活照片都会在移动硬盘中保存一份。相机拍摄的照片一般当天就会分类整理并存放到电脑和备份到移动硬盘，手机拍摄的照片在每周末进行总结的时候整理备份，实际上对我个人来说，拍摄照片的频率并不高，因此这样的更新频率对我比较合适，即使某次忘记了，影响也比较小 很难找却很有用的软件 课程资料、书籍等。本科和研究生上课的各种资料、作业，自己学习某个东西时收集的资料等，通常都有一个备份在移动硬盘中，一般是在学习结束的时候做一次完整的备份，然后查看有哪些不会再用了，删掉。 OneDrive保存的是使用频率比较高的文件，通常是需要在家里、实验室等多个地点处理的，对同步的需求比较高。以我自己为例，OneDrive文件夹下包括如下几个子文件夹 博文：出于个人博客的更新需求，写的文章对同步的要求比较高，在实验室写，回家接着写，因此放在OneDrive文件夹下 课题：研究课题的相关资料，包括论文、工作总结、期刊会议列表等资料，随时需要查看，因此也放在OneDrive文件夹下 学业：培养方案、各门课的课件、电子学历、各种公务群发的公示文件，随时可能查看 应用：微软应用商店里很多软件使用OneDrive作为数据同步的中转 文档：书签备份、日程表、收入支出记录、密码提示符等 这些都是自己建立的文件夹，实际上，OneDrive提供对其它位置的文件夹同步的功能，不过限制很大，只支持前面提到过的桌面、下载等windows自有的文件夹。 我只选择了图片文件夹，并在其中存放了壁纸、头像和收藏的一些喜欢的图片，鉴于大量软件使用文档目录存放数据文件，很多游戏也使用它存放存档，可以将其勾选一起同步。 最后提示的一点是，OneDrive可获得的免费空间为5G，但如果有别人点击我们分享的链接开通OneDrive，微软会提供扩容奖励，最大可以扩容到15G。很多人在贴吧等各种地方散布链接，但出于时间和精力的考虑，推荐淘宝直接购买OneDrive扩容服务，只要2块钱，几分钟之后就可以看到扩容成功。 ","date":"2020-01-17","objectID":"/2020/efficient-use-of-win10-4-file-management/:3:0","tags":["win10"],"title":"win10效率优化4-文件管理","uri":"/2020/efficient-use-of-win10-4-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 常用快捷键 很多快捷键非常有用，只是需要前期的熟悉，将这些快捷键记录如下 ","date":"2020-01-17","objectID":"/2020/efficient-use-of-win10-4-file-management/:4:0","tags":["win10"],"title":"win10效率优化4-文件管理","uri":"/2020/efficient-use-of-win10-4-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 Win系列 Win + D：所有窗口消失，显示桌面 Win + E：打开文件资源管理器 Win + L：快速锁屏 Win + I：打开设置页面 Win + R：打开运行功能 Win + V：打开剪切板 Win + 方向键：分屏 Win + 数字键：快速打开任务栏第N个程序 Win + Q：搜索 ","date":"2020-01-17","objectID":"/2020/efficient-use-of-win10-4-file-management/:4:1","tags":["win10"],"title":"win10效率优化4-文件管理","uri":"/2020/efficient-use-of-win10-4-file-management/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 Ctrl系列 Ctrl + X/C/V：剪切/复制/粘贴 Ctrl + Z/Y：撤销/恢复 Ctrl + W：关闭当前窗口 ","date":"2020-01-17","objectID":"/2020/efficient-use-of-win10-4-file-management/:4:2","tags":["win10"],"title":"win10效率优化4-文件管理","uri":"/2020/efficient-use-of-win10-4-file-management/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好，当前为第三期。 ","date":"2020-01-17","objectID":"/2020/life-weekly-3/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 3 期 (20200117)","uri":"/2020/life-weekly-3/"},{"categories":["日程及周刊"],"content":"时讯 1、蔡英文当选台湾地区领导人 01.11 台湾地区领导人选举11日举行投票，民进党候选人蔡英文当选连任台湾地区领导人。 2、伊朗军方承认意外击落乌航客机 01.12 前情提要：美国和伊朗的冲突升级之际，一架飞往巴格达的乌航客机失事，机上人员全部遇难。 北京时间11日，伊朗军方发表声明，证实由于军方操作失误，意外击落乌航客机。声明中表示，当时该航班离开伊玛目霍梅尼国际机场，靠近了伊朗伊斯兰革命卫队的一个敏感的军事中心。当时正值轮换，且该中心处于高级警戒状态。在此情况下，飞机被意外的人为错误击中。 3、菲律宾塔尔火山喷发 01.13 1月12日下午1时，菲律宾旅游胜地大雅台（Tagaytay）附近的塔尔火山（Taal Volcano）开始喷发，火山灰高达1公里。13日继续喷出大量火山灰，周边民众持续撤离。 塔尔火山距首都马尼拉65公里，是菲律宾第二活跃的火山，有记录的喷发达33次。它也被认为是世界上最危险的火山之一，最严重的一次发生在1911年，当时夺去了岛上1300多人的生命。 4、青海西宁路面地陷，已致9人遇难 01.14 青海西宁市南大街长城医院门前，13日突发路面地陷，地陷面积约80平方米，导致正在行驶的一辆17路公交车陷入坑内。截至目前，已致9人遇难。14日16时应急管理部已派出工作组赶赴现场指导事故处置和原因调查。 5、《中华人民共和国政府和美利坚合众国政府经济贸易协议》文本发布 01.15 美东时间2020年1月15日，中美双方在美国华盛顿签署《中华人民共和国政府和美利坚合众国政府经济贸易协议》（以下简称《协议》）。现发布《协议》中英文签字文本。 6、俄罗斯政府重组 01.15 俄罗斯总理梅德韦杰夫15日宣布俄罗斯政府全体辞职，之后俄罗斯政府将进行重组。 7、中国年末总结 2019年我国国内生产总值（GDP）为99.0865万亿元，居世界第二位；人均GDP首次超过1万美元。同时，2019年末，中国大陆总人口（包括31个省、自治区、直辖市和中国人民解放军现役军人，不包括香港、澳门特别行政区和台湾省以及海外华侨人数）超过14亿。 ","date":"2020-01-17","objectID":"/2020/life-weekly-3/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 3 期 (20200117)","uri":"/2020/life-weekly-3/"},{"categories":["日程及周刊"],"content":"小事 1、01.11 从秦皇岛离开，发现火车站可以刷身份证进站，但是买票时并没有提示为电子客票，不过感觉真的很方便。 2、01.12 从太原回家的火车上，人非常非常多，这还没到春运高峰，幸亏运气比较好，拿到了坐票。 3、01.13 老妈做了一个面食老鼠，在里面包了一颗丸子，非常好吃。 4、01.14 在华丽港超市购物，发现存取包裹使用了人脸识别，不再需要打印纸质小票，有点小惊喜，因为家里这种小地方竟然有这个，反而在沈阳和秦皇岛没见过。人脸识别用在这种场景下感觉挺有用的，一方面节约了纸张，另一方面也不需要担心小票丢失以及包裹被冒领。 5、01.14 晚上和弟弟一起看爱情公寓5，本来不抱希望，但看完发现虽然总是突然出现的音乐剧场景很奇葩，但总体还可以。最重要的是诸葛大力这一角色塑造的很讨喜，有点想看下去的冲动。搜了一下，演员叫成果，B站用户名犬来八荒，尽管不怎么更新，还是关注了小姐姐。 ","date":"2020-01-17","objectID":"/2020/life-weekly-3/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 3 期 (20200117)","uri":"/2020/life-weekly-3/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-01-17","objectID":"/2020/life-weekly-3/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 3 期 (20200117)","uri":"/2020/life-weekly-3/"},{"categories":["日程及周刊"],"content":"工具 1、Gitmind 最近新出了一款工具Gitmind，可以在线制作思维导图、流程图、UML图、ER图、拓扑图和组织结构图等。在线编辑、实时保存、多人合作，思维导图有大纲模式，就是类似于幕布那种，但导出格式只支持文本、图片和PDF，也没有Zhimap绘制的好看，不过可能和我不会用有关。鉴于Gitmind还是新产品，有潜力替代ProcessOn和Zhimap两个工具在我日常生活中的使用。 ","date":"2020-01-17","objectID":"/2020/life-weekly-3/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 3 期 (20200117)","uri":"/2020/life-weekly-3/"},{"categories":["日程及周刊"],"content":"图片 1、2D咖啡馆 日本东京一家咖啡馆，整个咖啡馆看起来像一幅平面图片。 内部看起来虽然像二次元，窗帘、盆栽等很多东西也确实是画的，但桌椅是实物。 ","date":"2020-01-17","objectID":"/2020/life-weekly-3/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 3 期 (20200117)","uri":"/2020/life-weekly-3/"},{"categories":["研究生的区块链学习之路"],"content":"根据之前几篇文章的分析，我们对优化后的新方案进行了实现，本篇介绍新方案的一些测试与验证过程。代码可以参考 BBRAC 仓库的 truffle 分支，但是该分支包括后面添加的恶意行为检测的内容，是进行了二次完善后的代码。 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:0:0","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"1. 智能合约 新的合约系统中依然包含Register Contract（注册合约，RC），Access Control Contract（访问控制合约，ACC）和 Judge Contract（判决合约，JC）三种合约。 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:1:0","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 Gas消耗统计 三个合约部署的Gas消耗统计如下 合约名 transaction cost execution cost RC 3285811 gas 2457443 gas ACC 5380922 gas 4047334 gas JC 1375161 gas 1002445 gas 消耗的代币数量 = gas × gasprice，gasprice的货币单位决定代币的货币单位。 在Quorum网络中，这些Gas消耗没有实际意义，因为gasprice = 0，合约部署前会判断用户是否拥有足够的gas，但不会真的扣除。 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:1:1","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 合约功能说明 RC实现的功能大致分为两类，第一部分对合约进行管理，第二部分对属性进行管理 ACC实现的功能分为三类，第一部分对设备自身拥有的资源属性进行管理，第二部分对访问控制策略进行管理，第三部分是访问控制函数 JC实现两个函数，第一个是恶意行为判决，第二个用来查询恶意行为 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:1:2","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"2. 审计 智能合约的安全性非常重要，行业内对智能合约进行安全性分析称之为「审计」 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:2:0","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 工具选取 基本的思路是选取合适的自动审计工具来对编写完成的合约进行分析，参考了 关于形式化验证两大工具 (Vass \u0026 Mythril) 测试对比 这篇文章。 在经过大量查找后发现，商业化应用的审计工具以上文中提到的这两款（Vass 和 Mythril） 最为普及。我们首先使用成都链安的 Vass 工具进行分析，然而发现，在合约中存在内联汇编时，Vass 无法编译合约，更谈不上审计，然而内联汇编在我们的合约中是必要的，因此换用 Mythril。 工具是由以太坊开源社区所提供的安全分析工具，而建立在Mythril上的合约分析平台 MythX具有更高的可用性并覆盖了更广泛的安全问题，因此最终使用MythX 完成统计分析。MythX 拥有 Remix、VScode 和 Truffle 的插件，因此无论以哪种方式编辑合约，都可以轻松的进行安全分析，但首先需要拥有 MythX 的账户。 首先在 https://dashboard.mythx.io/#/registration 页面使用邮箱进行注册，之后关联 MetaMask 以太坊账户，MythX 将提供一个密码供 Remix 等工具中的插件使用，也可以自己设定，但设定的密码要求长度为 6-64 位，至少一个小写字符，一个大写字符，一个数字和一个符号，该要求的原文如下： Password needs to contain: Length: 8 and 64 characters; One lowercase (a-z) and uppercase (A-Z) letter; One digit (0-9); One symbol (e.g. !\"#$%\u0026/()., ) ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:2:1","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 审计 打开 Remix 界面，在插件列表搜索 MythX，点击Activate将插件激活。 以 Remix 自带的示例合约 ballot.sol 为例，首先编译该合约，然后切换到 MythX 选项卡，输入之前关联到 MythX 的以太坊账户地址，MythX 提供的或自己更改后的密码，点击Save，然后点击Analyze 经过一段时间的等待后，将可以在Report界面查看到安全分析结果 也可以点击上图 Log 记录中的链接进入 MythX Dashboard 查看详细结果 点击Analysed Files查看错误的详细位置与说明，然后更改源代码，重新测试，直到合约安全性达到自己想要的结果。 检测到的合约弱点(漏洞)以SWC-XXX编号的形式出现，由 https://swcregistry.io/ 可查看完整的安全问题列表和解释。但是，免费的 MythX 只能检测10种安全问题，Pro版和企业版可以检测26种安全问题，具体对每种安全问题的支持程度见该页面： https://mythx.io/swc-coverage/ 当前调试过程种，遇到的典型安全问题是 SWC-101:Integer Overflow and Underflow 问题，问题的具体分析可参考 solidity-issue #796 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:2:2","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 审计结果 我们所编写的 RC，ACC 和 JC 三个合约在经过多次修改后，将出现的安全问题降低到了可接受的程度，如下图所示 三个合约出现的低级安全问题均为SWC-103: Floating Pragma ，即编译器的版本指定为一个范围，但这样具有更好的适用性，因此不进行修改 pragma solidity \u003e=0.4.22 \u003c0.6.0; ACC出现的15个中级安全问题在详情列表中无法查看 邮件询问后官方的回复如下，字节码级别的错误如果不依靠安全工具很难检出并修正，因此我们只能忽略掉这些安全问题。 Josh Reid (MythX) Dec 5, 11:11 AST Hello, Thanks for reaching out to MythX support! We are currently investigating any potential issues that may be causing these vulnerabilities to not be displayed fully, however this may also be due to the vulnerabilities being detected only on the bytecode. Unfortunately, at this time we do no have the ability to display bytecode vulnerabilities as we cannot specify where they are. However, this is something we are looking to evaluate and differentiate on more as we go forward. I apologize for any confusion this may have caused and will be sure to update you if we find any issues as we continue to look into this. In the meantime, thanks so much for your patience and cooperation! Is there anything else I can help you with at this time? Best, Josh ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:2:3","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"3. 系统测试 本节介绍合约在 Quorum 区块链网络中的部署过程和访问控制的测试实现。由于论文复现的时候发现手动配置的复杂性太高，极易出错，而一旦出错就必须重来，因此这次的优化实验决定使用 truffle 进行部署测试。 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:3:0","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 账户设置 按设计，Raspberry Pi 3B+ 是 lightnode1，Raspberry Pi 3B 是 linghtnode2。区块链网络启动后，四个 validator 各有 1050 wei(1018是 1 ether)，但是后面加入区块链网络的两台树莓派是普通节点，余额为 0，所以首先由 node0 向两个账户分别转账 1 ether。 # lightnode1账户地址为：\"0x77c22157a3b8840d34b8ed5975b5f2597bd6a7a2\" # lightnode2账户地址为：\"0xa31d40508da63fb00d7e2f4db57c3774384aa299\" 在 node0 的 geth console 中解锁账户，并分别向 lightnode1 和 lightnode2 转账 1 ether \u003e eth.accounts [\"0xbffe4ff0cbd0a7590fb71966d1e6bb1a4c2359e0\"] \u003e eth.getBalance(eth.accounts[0]) 1e+50 \u003e personal.unlockAccount(eth.accounts[0]) Unlock account 0xbffe4ff0cbd0a7590fb71966d1e6bb1a4c2359e0 Passphrase: true \u003e \u003e eth.sendTransaction({from:eth.accounts[0], to:\"0x77c22157a3b8840d34b8ed5975b5f2597bd6a7a2\", value:1*1e18}) \"0x3ed3cbc568a64dff3c3fe4a00b87d259d2299953c47e284b19253299eb8c4725\" \u003e eth.sendTransaction({from:eth.accounts[0], to:\"0xa31d40508da63fb00d7e2f4db57c3774384aa299\", value:1*1e18}) \"0xc9e4193164d38d94502960fcc0d1d7c2e22a9f04307145945c4ae525c6d99aee\" \u003e eth.getBalance(eth.accounts[0]) 9.9999999999999999999999999999998e+49 在 lightnode1 和 lightnode2 的 geth console 执行下列命令查询余额，由结果可知转账成功。 \u003e web3.fromWei(eth.getBalance(eth.accounts[0]), \"ether\") 1 两台树莓派担任的角色是网关，用于管理 IoT 设备，因此分别在 lightnode1 和 lightnode2 中建立新账户，用来代表 IoT 设备，由网关向各自管理的设备转账 107 wei，以供使用。 # lightnode1 \u003e personal.newAccount() Passphrase: Repeat passphrase: \"0x9a4aa696f85c6bf96733cc5385ccaf2b7ee13f17\" \u003e personal.listAccounts [\"0x77c22157a3b8840d34b8ed5975b5f2597bd6a7a2\", \"0x9a4aa696f85c6bf96733cc5385ccaf2b7ee13f17\"] \u003e personal.unlockAccount(eth.accounts[0]) Unlock account 0x77c22157a3b8840d34b8ed5975b5f2597bd6a7a2 Passphrase: true \u003e eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:1*1e7}) \"0x35bda063bc28ff3ef68b78962f427e930824390c4d1a8857c98e2dcf70485e17\" \u003e eth.getBalance(eth.accounts[1]) 10000000 # lightnode2 \u003e personal.newAccount() Passphrase: Repeat passphrase: \"0x016b71d115f1da36de58d2b78369fd3228bef3dd\" \u003e personal.listAccounts [\"0xa31d40508da63fb00d7e2f4db57c3774384aa299\", \"0x016b71d115f1da36de58d2b78369fd3228bef3dd\"] \u003e personal.unlockAccount(eth.accounts[0]) Unlock account 0xa31d40508da63fb00d7e2f4db57c3774384aa299 Passphrase: true \u003e eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:1*1e7}) \"0x96bc2b359219c72ff4f2ce910c27d4c76649685a8f9cfd1b879938317c9a1fe1\" \u003e eth.getBalance(eth.accounts[1]) 10000000 至此账户设置完成，接下来将 truffle 连接到 quorum 网络，部署合约 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:3:1","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 安装Truffle 在 Ubuntu18.04 下安装运行，要求 Node.js 版本高于 v8.9.4，这里全都升级到了最新 $ sudo apt-get install npm $ sudo npm install npm@latest -g $ sudo npm install n -g $ sudo n lts 安装 Truffle $ sudo npm install -g truffle $ truffle version Truffle v5.1.5 (core: 5.1.5) Solidity v0.5.12 (solc-js) Node v12.14.0 Web3.js v1.2.1 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:3:2","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 创建项目和基本配置 建立空项目 $ mkdir AC $ cd AC 初始化项目 $ truffle init ✔ Preparing to download box ✔ Downloading ✔ cleaning up temporary files ✔ Setting up box 项目文件夹中出现相关文件说明成功，此时没有任何合约和测试代码 $ ls contracts migrations test truffle-config.js 修改truffle-config.js文件进行配置，使其关联到已建立的 quorum 网络 // truffle-config.js module.exports = { networks: { development: { host: \"192.168.191.2\", // Localhost (default: none) port: 22000, network_id: \"10\", gasPrice: 0, gas: 100000000, type: \"quorum\" }, lightnode1: { host: \"192.168.191.3\", port: 22000, // Standard Ethereum port (default: none) network_id: \"10\", gasPrice: 0, gas: 10000000, type: \"quorum\", from: \"0x9a4aa696f85c6bf96733cc5385ccaf2b7ee13f17\", provider: new Web3.providers.WebsocketProvider(\"ws://192.168.191.3:8545\") }, lightnode2: { host: \"192.168.191.4\", port: 22000, // Standard Ethereum port (default: none) network_id: \"10\", gasPrice: 0, gas: 10000000, type: \"quorum\", from: \"0x016b71d115f1da36de58d2b78369fd3228bef3dd\", provider: new Web3.providers.WebsocketProvider(\"ws://192.168.191.4:8545\") } } }; 建立了三个网络development、lightnode1和lightnode2。第一个网络development是 node0，用来部署 RC 和 JC，第二个网络是 lightnode1，用来部署ACC，第三个网络是 lightnode2，用来发起访问控制做演示。 因为在最后设置了provider，使用 websocket 进行访问，所以实际上定义的host和port两个参数是被屏蔽的，主要是因为基于 http 的远程连接好像已经被启用了，只能使用 websocket。 参数的设置主要参考了以下两篇文档 Truffle Configuration Building Dapps for Quorum:Private Enterprise Blockchains ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:3:3","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.4 部署 将 RC，ACC 和 JC 三个合约放入contracts文件夹，然后在项目根目录执行truffle compile编译命令，编译所有合约，不过编译命令可以不执行，因为下面的truffle migrate无论是否执行过编译都会再检查一遍，如果编译过，就忽略，如果没有编译，会自动执行编译命令。 在migrations文件夹新建文件2_deploy_contracts.js，用于部署合约，编写内容如下 var Register = artifacts.require(\"Register\"); var Judge = artifacts.require(\"Judge\"); var AccessControl = artifacts.require(\"AccessControl\"); module.exports = function(deployer, network) { if (network == \"lightnode1\") { deployer.deploy(AccessControl, Register.address, Judge.address); } else { deployer.deploy(Register); deployer.deploy(Judge, 2, 3); } }; 首先从 node0 部署 RC 和 JC 两个合约，truffle migrate命令默认连接truffle-config.js配置中的development网络，我们之前已将该网络设置为 node0 的 ip 和端口。 注：所有truffle migrate和truffle exec命令执行前都要先对相应的账户解锁，否则无法成功 $ truffle migrate Compiling your contracts... =========================== \u003e Compiling ./contracts/ACC.sol \u003e Compiling ./contracts/JC.sol \u003e Compiling ./contracts/Migrations.sol \u003e Compiling ./contracts/RC.sol \u003e Artifacts written to /home/shuzang/AC/build/contracts \u003e Compiled successfully using: - solc: 0.5.12+commit.7709ece9.Emscripten.clang Starting migrations... ====================== \u003e Network name: 'development' \u003e Network id: 10 \u003e Block gas limit: 0x6dcd11a0 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- \u003e transaction hash: 0xefb249903f558ccd7b6326f73a886356b55377a4262b34b81f5f9f2940b4347e \u003e Blocks: 0 Seconds: 4 \u003e contract address: 0x4EC4F8BA5aEcA93955f67CFA58dbe4C57b21b37c \u003e block number: 2922 \u003e block timestamp: 0x5e02bcb5 \u003e account: 0xbfFe4ff0cBd0A7590Fb71966D1E6bb1a4c2359e0 \u003e balance: 99999999999999999999999999999998 \u003e gas used: 263741 \u003e gas price: 0 gwei \u003e value sent: 0 ETH \u003e total cost: 0 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0 ETH 2_deploy_contracts.js ===================== Deploying 'Register' -------------------- \u003e transaction hash: 0xa49e8d423980248e9c03eb52ecd3b46c15209e867285d2bc718a20620f3addd2 \u003e Blocks: 0 Seconds: 4 \u003e contract address: 0x8980FC2bBD25958d0c72F5ba5fa3e5faF1A48c05 \u003e block number: 2924 \u003e block timestamp: 0x5e02bcbf \u003e account: 0xbfFe4ff0cBd0A7590Fb71966D1E6bb1a4c2359e0 \u003e balance: 99999999999999999999999999999998 \u003e gas used: 3227866 \u003e gas price: 0 gwei \u003e value sent: 0 ETH \u003e total cost: 0 ETH Deploying 'Judge' ----------------- \u003e transaction hash: 0xaf538d559ecc72949d40bbc4d1dde67dfa535c7d5a78267c4de414b51fef4bf9 \u003e Blocks: 0 Seconds: 4 \u003e contract address: 0x2C2Fb0DD2440e72318Fb018f923F78Ff86541D08 \u003e block number: 2925 \u003e block timestamp: 0x5e02bcc4 \u003e account: 0xbfFe4ff0cBd0A7590Fb71966D1E6bb1a4c2359e0 \u003e balance: 99999999999999999999999999999998 \u003e gas used: 1349320 \u003e gas price: 0 gwei \u003e value sent: 0 ETH \u003e total cost: 0 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0 ETH Summary ======= \u003e Total deployments: 3 \u003e Final cost: 0 ETH 然后部署 ACC，truffle migrate命令指定连接网络lightnode1，--f指定部署脚本，否则因为之前该脚本已成功执行会略过，而又因为没有新的脚本而没有任何操作。truffle-config.js配置中的lightnode1网络已设置为 raspberry pi 3B+ 的 ip 和端口，默认账户设置为第二个账户，也就是新建的用于表示 IoT 设备的账户。 $ truffle migrate --network linghtnode1 --f 2 Compiling your contracts... =========================== \u003e Everything is up to date, there is nothing to compile. Starting migrations... ====================== \u003e Network name: 'lightnode1' \u003e Network id: 10 \u003e Block gas limit: 0x67a09e29 2_deploy_contracts.js ===================== Deploying 'AccessControl' ------------------------- \u003e transaction hash: 0xf49cca809ad273812de75225dcfe50b624bfe2a93fd2b44653491e8ee0edeb04 \u003e Blocks: 1 Seconds: 4 \u003e contract address: 0x05455fa63e5a7cb6575D75c99855cF3A1Adc72b1 \u003e block number: 3160 \u003e block timestamp: 0x5e02c15b \u003e account: 0x9A4aa696F85C6bF96733Cc5385cCaf2b7ee13f17 \u003e balance: 0.00000000001 \u003e gas used: 5263918 \u003e gas price: 0 gwei \u003e value sent: 0 ETH \u003e total cost: 0 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0 ETH Summary ======= \u003e Total deployments: 1 \u003e Final cost: 0 ETH ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:3:4","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.5 合约交互 尝试了三种方式，在这里最后只有 truffle console 这种方式真正完成了，但理论上三种都可行，而且事实证明利用 web3.js 完成交互最方便，truffle console 还是有点繁琐。 truffle-contract truffle使用 truffle-contract 接口(原文是contract abstraction，合约抽象)来交互，truffle develop的控制台、migrate写的部署脚本和基于 JS 的单元测试等都用的是这个抽象接口。 主要方式是编写JavaScript代码，使用提供的抽象接口可以调用已部署合约的函数，无论是发起交易改变合约状态还是仅仅调用获得返回结果。 在项目根目录(和trufffle-config.js同文件夹)创建文件JCRegister.js，用于注册判决合约，文件内容如下 var Register = artifacts.require(\"Register\"); var Judge = artifacts.require(\"Judge\"); module.export = function(done) { console.log(\"Getting deployed Register contract...\") Register.deployed().then(function(instance) { console.log(\"Register Judge contract...\"); return instance.contractRegister(\"Judger\", \"JC\", \"0xbffe4ff0cbd0a7590fb71966d1e6bb1a4c2359e0\", Judge.address); }).then(function(error, result) { if(!error) { console.log(\"Transaction:\", result.tx); console.log(\"Finished!\"); } else console.log(error); }).catch(function(e) { console.log(e); done(); }); }; 解锁node0账户，然后执行下列命令 $ truffle exec JCRegister.js truffle exec执行错误，错误信息如下 $ truffle exec JCRegister.js Using network 'development'. TypeError: fn is not a function at Object.exec (/usr/local/lib/node_modules/truffle/build/webpack:/packages/require/require.js:124:1) at /usr/local/lib/node_modules/truffle/build/webpack:/packages/core/lib/commands/exec.js:89:1 at processTicksAndRejections (internal/process/task_queues.js:93:5) Truffle v5.1.5 (core: 5.1.5) Node v12.14.0 web3.js 使用 web3.js，在用户根目录建立 web3 文件夹，本地安装 web3.js 模块 $ cd .. $ pwd /home/shuzang $ mkdir web3 \u0026\u0026 cd web3 $ npm install web3 $ npm list --depth 0 /home/shuzang/web3 └── web3@1.2.4 创建文件1_Register_JC.js用于注册判决合约，命名方式参考了 truffle 的命名方式文件内容如下，ABI 过长，本文以省略号代替。 var Web3 = require('web3'); if(typeof web3 !=='undefined'){ //检查是否已有web3实例 web3=new Web3(web3.currentProvider); }else{ //否则就连接到给出节点 web3=new Web3(); web3.setProvider(new Web3.providers.WebsocketProvider(\"ws://localhost:8545\")); } var rcAbi = [...] web3.eth.getBlock(0, function(error, result){ if(!error) console.log(\"connection succeed\"); else console.log(\"something wrong, connection failed\"); }); var rcAddress = \"0x8980FC2bBD25958d0c72F5ba5fa3e5faF1A48c05\"; var jcAddress= \"0x2C2Fb0DD2440e72318Fb018f923F78Ff86541D08\"; var register = new web3.eth.Contract(rcAbi); register.options.address=rcAddress; register.methods.contractRegister(\"Judger\", \"JC\", \"0xbffe4ff0cbd0a7590fb71966d1e6bb1a4c2359e0\", jcAddress).send({ from: \"0xbffe4ff0cbd0a7590fb71966d1e6bb1a4c2359e0\", gas: 10000000 }, function (error, result){ if(!error){ console.log('Transaction: ' + result); console.log('Finished!'); } else console.log(error); }) register.methods.getContractAddr(\"Judger\").call({ from: \"0xbffe4ff0cbd0a7590fb71966d1e6bb1a4c2359e0\", gas: 10000000 }, function (error, result){ if(!error){ console.log('Judge contract address:' + result); } else console.log(error); }) web3.js执行合约交易不成功，全部陷在交易池了 \u003e txpool.status { pending: 5, queued: 0 } 日志记录里提示 VM returned with error err=\"evm: execution reverted\" truffle console truffle的文档里提到与已部署的合约交互可以使用truffle console，故尝试 首先注册判决合约，需要在node0中进行，进入development网络 $ truffle console 命令执行完毕后进入truffle console控制台，注册合约并查询合约地址进行验证 truffle(development)\u003e Register.deployed().then(function(instance) {instance.contractRegister(\"Judger\", \"JC\", \"0xbffe4ff0cbd0a7590fb71966d1e6bb1a4c2359e0\", Judge.address);}) undefined truffle(development)\u003e Register.deployed().then(function(instance) {return instance.getContractAddr(\"Judger\");}) '0x2C2Fb0DD2440e72318Fb018f923F78Ff86541D08' 退出重新执行truffle console命令，进入lightnode2网络 truffle(development)\u003e .exit $ truffle console --network lightnode2 进入lightnode2的truffle console控制台，注册设备相关属性，然后查询属性进行验证 truffle(lightnode2)\u003e let instance = await Register.deployed() undefined truffle(lightnode2)\u003e instance.subjectRegister(\"0x016b71d115f1da36de58d2b78369fd3228bef3dd\", \"0xa31d40508da63fb00d7e2f4db57c3774384aa299\", \"thermostat\", \"subject\") ... truffle(lightnode2)\u003e instance.getAttribute(\"0x016b71d115f1da36de58d2b78369fd3228bef3dd\", \"deviceType\") 'thermostat' truffle(lightnode2)\u003e instance.g","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:3:5","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.6 错误测试 之前的实验验证的是访问权限被授予的情况，现在测试被拒绝的情况 在 lightnode2 建立新的IoT设备账户，这次代表摄像头(Camera)， \u003e personal.newAccount() Passphrase: Repeat passphrase: \"0x42b97b26ed5f53693bcc9b58ad8c724718ea0a15\" \u003e personal.listAccounts [\"0xa31d40508da63fb00d7e2f4db57c3774384aa299\", \"0x016b71d115f1da36de58d2b78369fd3228bef3dd\", \"0x42b97b26ed5f53693bcc9b58ad8c724718ea0a15\"] \u003e personal.unlockAccount(eth.accounts[0]) Unlock account 0xa31d40508da63fb00d7e2f4db57c3774384aa299 Passphrase: true \u003e eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[2],value:1*1e7}) \"0x9f36de89d44db23e63e4fa0d3135d1c17e800cca73f0661ae276f20c0e3d1902\" \u003e eth.getBalance(eth.accounts[2]) 10000000 修改truffle-config.js文件中 lightnode2 网络的执行账户为新建立的账户 ... lightnode2: { host: \"192.168.191.4\", port: 22000, // Standard Ethereum port (default: none) network_id: \"10\", gasPrice: 0, gas: 10000000, type: \"quorum\", from: \"0x42b97b26ed5f53693bcc9b58ad8c724718ea0a15\", ... 进入lightnode2的 truffle console $ cd AC $ truffle console --network lightnode2 注册新设备的属性 truffle(lightnode2)\u003e Register.deployed().then(function(instance) {instance.subjectRegister(\"0x42b97b26ed5f53693bcc9b58ad8c724718ea0a15\",\"0xa31d40508da63fb00d7e2f4db57c3774384aa299\", \"camera\", \"subject\");}) undefined truffle(lightnode2)\u003e Register.deployed().then(function(instance) {instance.getAttribute(\"0x42b97b26ed5f53693bcc9b58ad8c724718ea0a15\",\"deviceType\");}) 'camera' truffle(lightnode2)\u003e Register.deployed().then(function(instance) {instance.getAttribute(\"0x42b97b26ed5f53693bcc9b58ad8c724718ea0a15\",\"deviceRole\");}) 'subject' 建立requester2.js，内容和requester.js相似，只是发起访问控制的是lightnode2新建立的camera设备账户，也就是说与requester.js的不同仅在于发起访问控制的账户 错误测试的结果如下 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:3:6","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.7 步骤总结 总结一下本篇中需要做的事情 node0 部署RC，获取RC合约地址 node0 部署JC，传入参数base=2、interval=3，获取JC的合约地址 JC 合约在RC中注册 node0 分别转给lightnode1和lightnode2 1 ether lightnode1 新建IoT设备账户，从第一个账户向该账户转入1000 0000wei lightnode2 新建两个IoT设备账户，从第一个账户分别向这两个账户转入1000 0000wei lightnode2 的两个IoT设备账户在RC中注册设备属性(事实上所有节点都应注册设备属性，这里是因为实验只需要它们两个发起访问控制) lightnode1 的IoT设备账户部署ACC，传入RC和JC的合约地址，获取ACC的合约地址 lightnode1 在RC中注册ACC lightnode1 在ACC中注册资源属性，设置访问控制策略 lingtnode2 的两个IoT设备通过调用ACC向lightnode1的IoT设备发起访问控制 ","date":"2020-01-15","objectID":"/2020/optimize-the-implementation-and-testing-of-the-system/:3:7","tags":["科研记录"],"title":"研究记录11-新访问控制方案的实现与测试","uri":"/2020/optimize-the-implementation-and-testing-of-the-system/"},{"categories":["日程及周刊"],"content":"本周刊目的是记录生活，发现生活中的美好。当前为第二期 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["日程及周刊"],"content":"时讯 1、伊朗高级军官在伊拉克巴格达遭遇美军空袭身亡 01.03 央视新闻持续更新中。1月3日凌晨， 美军在伊拉克巴格达国际机场附近展开空袭，导致伊朗“圣城旅”指挥官苏莱曼尼丧生。在此之前， 伊拉克北部基尔库克附近一处军事基地2019年12月27日遭火箭弹袭击，美方称该袭击为什叶派武装组织“真主旅”所为，并指该组织与伊朗伊斯兰革命卫队下属“圣城旅”关系密切。 美伊关系自去年5月以来不断恶化，海湾局势持续紧张。这次空袭事件导致了一系列后续变化，伊朗方面强烈谴责并声称将进行报复，中国大使馆已发出声明提醒在伊拉克的公民尽快离开或注意安全。 2、中国工程院院士李宁贪污科研经费 一审获刑12年 01.03 2020年1月3日，吉林省松原市中级人民法院公开宣判中国工程院院士、中国农业大学教授李宁及同案被告人张磊贪污一案，对被告人李宁以贪污罪判处有期徒刑十二年，并处罚金人民币三百万元，对被告人张磊以贪污罪判处有期徒刑五年八个月，并处罚金人民币二十万元；对贪污所得财物予以追缴，上缴国库。 3、美术馆价值1.8亿元毕加索名画被撕 01.04 在伦敦的泰特现代美术馆，一名20岁男子把一幅价值约2千万英镑、约合人民币1.8亿的画作撕毁。被毁画作名为《女子半身像》，由毕加索在1944年创作，原型是毕加索的情人朵拉·玛尔。目前，这名男子已被警方逮捕，并以刑事毁坏罪被起诉。美术馆方面已经把这幅名画撤下，并请专业人士对损失进行评估。 4、乌克兰客机在伊朗机场附近坠毁，所有成员全部遇难 01.08 1月8日早上， 乌克兰航空公司一架波音737在伊朗德黑兰坠毁， 飞机上载有167名乘客和9名机组人员， 所有成员全部遇难。 5、澳大利亚山火持续，损失严重 01.08 澳大利亚山火已持续数月，截至8日，过火面积已增加至1030万公顷，死亡25人，造成5亿动物葬身火海。 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["日程及周刊"],"content":"小事 1、01.08返回秦皇岛，在沈阳北站候车大厅看到机器人巡警 2、01.09学生证学期注册及火车票优惠券充磁，发现导员换了 3、01.10日晚，和舍友在秦皇岛万达吃自助烤肉，非常好吃 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["日程及周刊"],"content":"视频 1、54号树洞《我的所有物品》 在B站发现的极简生活UP主，是个小姐姐，把自己的东西打理的井井有条，通过展示自己的所有物品，勾勒出了一个极简精致的生活形象。UP主的其它视频也都很有价值，虽然不多，但都很有干货，对追求极简的我有很大帮助 这个系列分为上下两篇，如下。 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:3:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["日程及周刊"],"content":"文章 1、科研新手全面入坑指南 说实话，少数派上的这个系列我已经很多次遇到了，每次涉及论文相关的问题，总能搜到该系列的文章，作者的笔名玉树芝兰也越来越熟悉，后来整套文章被整理成一个系列，从选题、文献研究、论文阅读、写作、答辩及其它六大方面详细介绍学术研究的各种技巧，非常实用。作者王树义老师是天津师范大学管理学院副教授，硕士研究生导师 ，有丰富的教学和写作经验，技能树也和我比较相似，因此写的这些文章具有极大借鉴价值。虽然少数派这个系列需要付费，但知乎的专栏是免费的。 2、 上班族便当：如何做一个坚持带饭半年的靓仔 以前就一直在想这个问题，上班以后午饭和晚饭要这么解决，看日剧里基本都是自带便当，现在的话，更大的可能是点外卖，但是每天点外卖不说每个月的支出会多一大笔，卫生方面也存有疑虑。本周这篇文章描述了作者自己如何安排自己上班的便当的过程，算是一种解决方案。 3、Building an awesome CLI App in Go 这是 Steve Francia 和 Ashley McNamara 在 OSCON 2017 上做的一个介绍，展示了构建一个用户友好的命令行工具所需的技术、原则和相关的库，覆盖了从如何设计和构建命令到使用和解析标志、配置文件和远程配置系统，以及如何设置环境变量等12个方面，学习完之后，我们将拥有足够的知识构建自己的Go命令行工具。 其实本质就是Cobra命令行框架的使用介绍，该框架当前已被Kubernetes，Docker，Hugo等应用使用。幻灯片如下 4、中国人在发表英文论文时汉字姓名究竟应该如何写 如题，作者描述了一个我们最为疑惑的问题，然而，当前查阅文献汉字姓名的格式依然不统一，各种格式都有，这导致了文献统计时的大量问题。 5、How to pick a Carrer 如何选择职业，是每个尚处于学校的学生都面临的问题，甚至步入社会也依然会思考该问题。这篇文章以一种形象的方式给了一些建议。 6、无需编程进行数据可视化 数据可视化多利用Python、R等编程语言，大多有一定的技术门槛，这篇文章介绍了一种无需编程知识进行数据可视化的方法。 7、一个合格的程序员应该读过哪些书 都是一些经典的书籍，值得每个学习编程的人去阅读。 8、如何学习数据结构 知乎的一个问题，其回答有很大的参考价值。 9、什么叫工业4.0 从工业1.0讲到工业4.0，作者的思路很清晰，观点不知道是否正确，但对这个话题确实讲透了。 10、Building Blockchain in Go 一个系列教程，教授如何用Go实现一个区块链。Github有人翻译成了中文版，仓库地址，在线书籍 11、如何用一个登机箱舒适地完成 7-10 天的旅行 文章设计大量整理物品的知识，被种草了很多东西，比如压缩袋手卷。 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:3:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["日程及周刊"],"content":"工具 1、WinSnap 功能全面的截图工具，之所以在 Snipaste 之外还要使用它，是因为它可以编辑本地图片，为图片添加阴影效果和反射效果，让图片变得更美观和视觉上更有层次感。 2、果识 水果、蔬菜、坚果如何挑选，如何食用，在日常生活中是一些经常用到的知识，但我们一般只能用到时用浏览器去查。果识就像是一本针对果蔬的百科全书，目前已经收纳了 73 种水果、77 种蔬菜和 15 种坚果的相关信息和资料。每种果蔬的介绍页面不仅包含有成熟季节、食疗功效、食用禁忌、应用成分这类基本信息，这些内容能够迅速解答购买和食用时的大部分问题，尽可能让我们少走弯路。 果识还提供了不少具备健康参考价值的信息，比如热量、血糖指数、血糖负荷等，可用于膳食和减肥的需求。 3、TLDR 一个命令手册，名字取自“Too long, Don’t read”，即”太长不读“。主要应对Linux系统下繁杂无比的命令，用简单的说明和一个常用场景来让人们一看就知道命令如何使用。该工具使用依赖于node.js。 $ sudo apt-get install npm $ sudo npm install -g npm $ sudo npm install -g tldr $ tldr --update 一个使用示例如下 $ tldr ls ls List directory contents. - List files one per line: ls -1 - List all files, including hidden files: ls -a - Long format list (permissions, ownership, size and modification date) of all files: ls -la - Long format list with size displayed using human readable units (KB, MB, GB): ls -lh - Long format list sorted by size (descending): ls -lS - Long format list of all files, sorted by modification date (oldest first): ls -ltr 4、AimWriting 微软亚洲研究院推出的免费在线英文写作、语法检查、用词建议网站，能够围绕小学、中考、高考、四六级、考研、托福雅思等 8 个重点考试阶段与考试方向，通过不同的角度为我们写的英文文章进行检查评判。 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:3:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["日程及周刊"],"content":"电影 1、《赤道》 韩国秘密核武器神秘失踪，在香港引发的警匪交手与地下关系动荡，整体情节扣人心弦，挺不错的，只是看起来像一个预告片，期待第二部。 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:3:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["日程及周刊"],"content":"概念 1、邓巴数字 Dunbar’s number，也叫150定律（Rule Of 150），由牛津大学的人类学家邓巴在20世纪90年代提出。 该定律根据猿猴的智力与社交网络推断出：人类智力将允许人类拥有稳定社交网络的人数是148人，四舍五入大约是150人。邓巴数字有时候也不止用于社交领域，举个例子，当一个人文献库中的论文数量超过邓巴数时，他将没有精力完全了解和整理这些文献。 2、U盘量产 字面意思就是，批量生产U盘。是指批量对U盘主控芯片改写数据，如，写生产厂商信息、格式化等，用来对U盘完成该操作的软件程序就是U盘量产工具。平常生活中U盘损坏，有时候也可以通过量产的方式来恢复。首先通过ChipGenius检测U盘详细信息，然后下载对应厂商的量产工具进行量产恢复。量产工具可以从U盘量产网下载。 ","date":"2020-01-10","objectID":"/2020/life-weekly-2/:3:5","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 2 期 (20200110)","uri":"/2020/life-weekly-2/"},{"categories":["爱编程爱技术的孩子"],"content":"Ubuntu环境下，Unable to acquire the lock这类问题时有发生，本文对该问题的解决方案做一个总结 E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable) E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it? ","date":"2020-01-03","objectID":"/2020/ubuntu%E4%B8%AD%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:0:0","tags":["linux"],"title":"Ubuntu中无法获得锁相关问题的解决方案","uri":"/2020/ubuntu%E4%B8%AD%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["爱编程爱技术的孩子"],"content":"第一种情况 进程中存在与apt相关的正在运行的进程，首先检查是否在运行apt,apt-get相关的进程 ps aux | grep -i apt 如果存在与apt相关的正在运行的进程，kill掉进程 sudo kill -9 \u003cprocess id\u003e 或者直接简单粗暴的： sudo killall apt apt-get 如果进行完上面的步骤还是无法顺利执行apt-get 操作，则属于第二种情况 ","date":"2020-01-03","objectID":"/2020/ubuntu%E4%B8%AD%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:0","tags":["linux"],"title":"Ubuntu中无法获得锁相关问题的解决方案","uri":"/2020/ubuntu%E4%B8%AD%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["爱编程爱技术的孩子"],"content":"第二种情况 进程列表中已经没有与apt,apt-get相关的进程在运行，但依然报错，在这种情况下，产生错误的根本原因是lock file。 loack file用于防止两个或多个进程使用相同的数据。 当运行apt或apt-commands时，它会在几个地方创建lock files。 当前一个apt命令未正确终止时，lock file未被删除，因此它们会阻止任何新的apt / apt-get命令实例，比如正在执行apt-get upgrade，在执行过程中直接ctrl+c取消了该操作，很有可能就会造成这种情况。 要解决此问题，首先要删除lock file。 使用lsof命令获取持有lock file的进程的进程ID,依次运行如下命令： lsof /var/lib/dpkg/lock lsof /var/lib/apt/lists/lock lsof /var/cache/apt/archives/lock 需要注意的是，以上命令执行结果如果无返回，说明没有正在运行的进程；如果返回了相应的进程，需要kill掉。 删除所有的lock file sudo rm /var/lib/apt/lists/lock sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock 最后重新配置一下dpkg： sudo dpkg --configure -a 如果上述命令不出任何错误，就没有问题了，但执行配置命令时可能会出现以下错误 dpkg: error: dpkg frontend is locked by another process 这需要我们额外进行一些操作： 找出正在锁定lock file的进程： lsof /var/lib/dpkg/lock-frontend kill掉输出的进程（如果输出为空则忽略） sudo kill -9 PID 删除lock file并重新配置dpkg: sudo rm /var/lib/dpkg/lock-frontend sudo dpkg --configure -a ","date":"2020-01-03","objectID":"/2020/ubuntu%E4%B8%AD%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:2:0","tags":["linux"],"title":"Ubuntu中无法获得锁相关问题的解决方案","uri":"/2020/ubuntu%E4%B8%AD%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["爱编程爱技术的孩子"],"content":"附注 最直接的办法是重新启动 ","date":"2020-01-03","objectID":"/2020/ubuntu%E4%B8%AD%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:3:0","tags":["linux"],"title":"Ubuntu中无法获得锁相关问题的解决方案","uri":"/2020/ubuntu%E4%B8%AD%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["日程及周刊"],"content":"本系列受阮一峰大神的科技爱好者周刊启发，目的是记录生活。先前博客中的读书笔记、影评、游记、接触到的新的知识、收集的文章和句子、每周计划等内容，全部统合到本周刊中，第一期自2020年1月3日起，之后每周五更新一期。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:0:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"时讯 1、“胖五”火箭发射成功 12.27 12月27日20时45分，长征五号遥三运载火箭(别名“胖五”)在中国文昌航天发射场点火升空，2000多秒后，与实践二十号卫星成功分离，将卫星送入预定轨道，任务取得圆满成功，这是长征系列运载火箭第323次发射。 对这个事有印象是因为火箭别名太可爱了。 2、“尼德兰Netherlands”取代“荷兰Holland”成为荷兰新国家标识 12.29 荷兰政府近日宣布，为重塑国际形象，将从2020年开始更换国家标识，原来使用的“荷兰Holland”一词将变为“尼德兰Netherlands”，郁金香图案也将被设计成郁金香形状的“NL”所取代。 从2020年1月起，荷兰政府机构、使领馆、企业、学校、各城市及体育机构在对外项目中都将使用这一标识。 “荷兰Holland”一词仅指荷兰的两个省，包括著名的阿姆斯特丹、鹿特丹和海牙等城市，但实际上，该国共有十二个省，“Holland”只是尼德兰的一小部分。而且荷兰的官方名也不是Holland，而是The Kingdom of the Netherlands，这次的行动大概只能算正名。不过虽然荷兰政府做出了这一决定，但叫顺口的普通民众是否会改口很难说。 3、日产前董事长戈恩上演“神秘大逃亡” 12.30 前日产董事长兼 CEO， Carlos Ghosn 涉嫌财务犯罪被捕。在得到保释后，这名年逾花甲的金领嫌疑犯，居然在日本当局严密监控之下「人间蒸发」，毫无征兆地在黎巴嫩现身，上演一出金蝉脱壳的好戏。 4、习近平主席2020新年贺词 01.01 2020年在即将过去的这一周到来，各平台都推出了各种年度总结，习近平主席也通过中央广播电视总台和互联网发表了新年贺词。书藏的生活周刊第一期也即将发布，不管2019年充实还是虚度，不管问心无愧还是有所遗憾，一切都已经过去，2019年初制定的计划完成了大半，现在回顾，发现自己改变了很多，在迅速的成长，也希望自己在2020年开开心心，万事顺利。2020，你好！ 5、台湾一\"黑鹰\"直升机坠毁，多名高级军官罹难 台湾防务部门一架黑鹰直升机1月2日上午在新北市乌来山区坠毁，台湾防务部门证实，包括“参谋总长”沈一鸣、“政战局”副局长于亲文等多名台军高级军官都在机上。13人目前有5位获救，其他8位没有生命迹象，罹难者包括“参谋总长”沈一鸣。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:1:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"小事 1、2019.12.26，陪同学去换医保卡，顺便到辽宁大学崇山校区逛了一圈，食堂的饭是真便宜啊，为什么会有这么大区别呢。 2、2019.12.31晚，和实验室几个师兄一起去全运万达吃烤鱼，致敬逝去的2019。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:2:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"2019年终总结 类别 内容 读书 阅读了12本专业以外的书籍，另外还有四本未读完，共写了11篇读书笔记 旅游 游览了20个左右的景点，写了五篇游记 饮食 未曾对美食有过多的偏好，但日常饮食较为规律 健身 前半年坚持健身和跑步，体重降到了140以下，体脂也到了18% 后半年较为懈怠, 不再每天坚持锻炼。 尝试了三项新的运动：滑雪、射箭和网球，但都是浅尝辄止，未能坚持 英语 六级成绩超过500，基本的英文阅读没有压力 仍没有背完一次完整的六级单词，听力、写作和口语也没有进步 记账 全年累计花费在3万左右，但国家补助6000，奖学金10000，净支出大概只有一半 生活 熬夜、长时间玩手机、看小说、久坐不动等坏习惯依然没有改善，也未能坚持练字 养成了一些好习惯，比如早晚刷牙洗脸、每月记账、定期收拾屋子等 尝试了新的生活方式（独居、每个月看电影和旅行等） 了解和整理了疾病、用药、衣物护理、五险一金等生活基本常识或技能，在独立的路上又迈出了一步 编程 学习并整理了全部Go的基础语法，练习了一些PAT的题目，温习了基本的数据结构 工作 从新手正式进入到区块链研究的世界，对区块链和物联网结合面临的问题、当前的解决方案、区块链的发展方向等有了大致的把握，也有自己的看法 在访问控制、存储、异常检测等领域进行了一定的工作，完成了使用智能合约实现对物联网的访问控制这一工作(基于ABAC访问控制模型) 掌握了区块链搭建、以太坊智能合约编写(solidity)、智能合约测试与部署(truffle框架和web3.js)等区块链领域的技能，有能力独立完成相关的开发和实现提出的想法 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:3:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"2020年度计划 类别 内容 读书 阅读至少10本非专业类的书籍(包括各种经典小说、普及读物、治愈漫画等) 阅读至少10本专业性较强的书籍，如各领域(心理学、美学等)的入门书籍，设计模式等专业经典书籍，人工智能的本学科前沿领域知识 旅游 每月至少参观一个新的景点(也可以是画展和文物展等展览、舞台剧等表演) 策划一次长途旅行，因为工作以后可能很少有这么多的空余时间 饮食 在旅行的同时尽可能尝试各地美食，平时也可以积极寻找新的美食，记录自己的饮食偏好(毕竟唯美食与爱不可辜负) 健身 保持良好的饮食和生活习惯 坚持跑步与健身，全年跑步里程超过300公里，健身的日子超过全年2/3 体重保持到140以下，体脂降到17%，减掉侧腹的赘肉 继续尝试滑雪，以及尝试其它新的运动项目(2两个) 英语 背完一次完整的六级单词表 着重练习听力，能做到无字幕看电影和美剧 独立完成英文论文的能力 记账 坚持每月记账 更换新的记账方式，统一支付宝、微信和银行卡的收入支出，便于年末统计分析 生活 纠正熬夜、长时间看手机、长时间看小说的习惯 继续整理相关生活常识，并在生活中践行 不断优化生活方式，践行极简主义，尝试改善生活的小物件，发现生活中的美好 尝试添加灵活的时间用于交际，维持朋友的关系，找个女朋友 编程 数据库相关知识，包括Mysql和Nosql Golang网络编程 实践2个Golang项目，Todo CLI、百度网盘或者一条区块链 基础的数据结构和算法 Makefile和Linux常用命令 工作 完成剩下的一半毕设内容 发一篇论文 梳理总结区块链的知识体系 使用Golang实现一个区块链 实现一个完整的Dapp（记事本、投票，最好是类似加密猫的项目） 实习一次 找到工作 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:4:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"本周收藏 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:5:0","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"视频 1、腾格尔《芒种》 不管什么歌，腾格尔都能唱出自己的味道，不过之前翻唱的歌都没有什么感觉。这次的《芒种》却有了不同的感觉，是一种不同于原唱的好听。正如李宇春的哪吒，都有自己的味道。 2、李宇春《哪吒》 上面提到了李宇春在金鸡奖典礼上唱的《哪吒》，是真的空灵美好，少了一分不羁，却多了一份仙气，真是神仙嗓音。这里就把它给补上。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:5:1","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"文章 1、品质生活离你没那么远，10 条建议帮你过好 2020 少数派2020年第一天的推荐文章，从饮食、运动、数字生活到生活环境改善，总结了大量可以提高生活品质的技巧，相信对2020年一定会有用。 2、子弹笔记-你所需要的仅仅是笔和本 介绍了子弹笔记，这是一种类似于康奈尔笔记的笔记方式，一种可定制的、宽松的笔记系统，通过主题、页码、短句和简单的符号完成整个笔记，较容易实现和坚持。 3、Github Action 教程：定时发送天气邮件 Github在2019年11月发布的新功能，是一个持续集成工具，也可以用作代码运行环境，可以做很多事情，比如每天定时运行一次脚本，获取天气预报，然后发送电子邮件，链接中是一个使用Github Action的简单示例。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:5:2","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"电影 2019年看的电影不少，但写的影评没几篇，而且写的不怎么样，或许是没有掌握这方面的写作技巧，包括读书笔记和游记也写得像流水账一样。读书笔记篇数不少，而且能帮助有效地回忆所读内容，游记图片过多，都不太适合整合到这里，但影评就无所谓了，之前的影评全部都集合到这里。 1、终结者：黑暗命运 2019年11月02日看的电影，当初不想跑太远，于是从最近的影院唯一上映的三部电影中选择了《终结者》，不过看完后发现很不错，值回票价了。 琳达·汉密尔顿老年气质大涨，是真的令人着迷，州长也变得有了人情味，足够令人感慨。新的终结者和守护者形象设计也挺好的，这种电影，看的开心就好。 2、攀登者 大家都说攀登者不怎么样，不过我觉得还可以，起码看的时候情绪确实被调动起来了，最后的感受就是，每个人在特定时刻做出的决定其实是没有对错的，都代表了他当时的认知。人生就是选择的过程，无论是方五洲为了救曲松林放弃摄像机，还是曲松林愿意保护摄像机而牺牲自己，是李国梁在第一次登顶失败后毅然决定再次带队登顶，还是徐缨为了帮助方五洲登顶带病上山获取更详细的气象资料而牺牲，亦或者是几十年后的杨光带着残疾之身也要完成登顶梦想，或者两次攀登中那些默默无闻的人们，普通的登山队员，气象组的小姑娘，无论艰难险阻，一声令下就跟着方五洲他们前进。每个人做出了自己的选择，也获得了自己生命的意义。曲松林活下来最终领悟了生命更重要，但如果当时牺牲了同样是登山英雄，虽然想法改变了，但并不是当初的决定是错的。短短一辈子，选择平平淡淡也好，选择轰轰烈烈也好，自己觉得过的有意义就好。 看完之后还去了解了以下相关的资料，最后发现了一个牛人，王勇峰，中国登山队队长，和李致新在20世纪80年代到90年代的11年中，完成了中国人首次登顶世界七大洲所有最高峰的壮举，真的很厉害，难以想象。 3、冰雪奇缘2 2019年12月07日，冰雪奇缘是我非常喜欢的一部动画，不过这次一直等到快下映的时候才有时间去看。虽然看完后整体的映像不如第一部深刻，但也非常不错，看完感觉十分幸福那种，就喜欢这种大团圆的结局。很多隐藏的细节看的时候其实注意不到，后来通过《冰雪奇缘2》： 从成长到成熟这篇影评才发现，总体非常满意。 值得一提的是本篇里艾莎找到自己的力量时来了一次大变身，简直惊艳，语言无法言表，真的会令人惊呼的。实际上第二部里艾莎和安娜整体的服装风格都成熟不少，毕竟已经成为了合格的女王和公主。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:5:3","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"概念 1、阿拉善SEE基金会 2008年，阿拉善SEE生态协会发起成立阿拉善SEE基金会，致力于资助和扶持中国民间环保公益组织成长，一开始意味它是蚂蚁森林背后的基金组织，因为有一个项目叫做一亿颗梭梭，现在有点不确定，但官网当前公布的项目列表很丰富，涉及各个方面，比如地下水保护、三江源保护、卫蓝侠、任鸟飞等项目。 2、Google AIY Do-it-yourself artificial intelligence，意为动手创造你的人工智能。该项目由Google于2017年启动，目标是让每个创客都可以DIY自己的人工智能产品，是Google在人工智能领域投入的一部分。 Google当前有两个套件，Voice Kit和Vision Kit，前者可以用于创建虚拟语音助手，为自己的项目添加语音交互功能，后者是一套简单的计算机视觉系统，可运行3中基于TensorFlow的类神经网络模型应用。 3、水果证件照 美国农业部为全世界已知水果制作了7500幅水彩证件照，并提供了高清下载，下面是苹果的证件照。 github有一个项目，用python爬虫保存美国农业部网站上的水果证件照，专门用来下载保存这些图片。 4、wikihow 教导生活技能的网站。 5、临时邮箱申请 现在垃圾邮件越来越多，主要是我们用邮箱注册了很多账户，但实际上某些场景中我们只需要一次性的邮箱，不需要真实的邮箱地址，提供这种服务的包括moakt和自己用域名建立的临时邮箱 6、海姆立克急救法 抢救呼吸道异物堵塞的方法。 7、健体 不像健美肌肉分明，看起来有点可怕，健体展示较好的皮肤、匀称的肌肉，是普通人也能通过健康饮食和合理训练获得的，其身材也更符合人们的审美。 8、Echarts 一个纯Javascript的图表库，百度开源的一个数据可视化工具，提供大量直观，生动，可交互，克高度定制化的数据可视化图标，做出来的图表好看且炫酷，下面是一个截图，实际上可以交互。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:5:4","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"工具 1、githistory 以图形化的方式回顾github、gitlab或bitbucket的托管的项目历史 2、Github Marketplace 位于github网页顶端的Marketplace标签页，提供一些构建和提高工作流的工具，如持续集成和代码质量分析 3、codebeat 代码质量分析工具，需要时自动进行代码样式、质量、风格，测试覆盖率等检查 4、Travis CI 持续集成工具，在将代码推送到GitHub时自动构建和测试代码，防止错误部署到生产中 5、TLDR 类似于--help和man，用来查看linux的命令和参数用法，但显示效果很舒服 6、github gist github提供的分享代码片段的服务，可以把代码片段保存在这里，然后在博客放置链接，可以在博客页面直接看到代码内容，很有用。 7、The Things 一个开发可接入的全球LoraWAN网络 8、build-your-own-x 用各种编程语言实现一些有意思的东西的教程 9、ppio 一个分布式的的数据存储和交付平台，重视速度和隐私 10、code-surfer 以幻灯片形式展示编写的代码 11、Gooey 一个通用的前端，可以将任意命令行工具转换为图形界面 12、nodeppt 大致可以看作网页PPT，用来展示效果很好，这里有一个在线演示地址。同类产品有的也叫做HTML5 Presentation，代表性的是Reveal.js和Google Slides 13、刷题工具 编程面试的刷题工具，主要是leetcode，比较出名的书的话是《剑指offer》 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:5:5","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"图片 1、你所浪费的今日，是昨日死去之人奢望的明日。你所厌恶的现在，是未来的你回不去的曾经 2、20岁那年买得起10岁那年买不起的玩具，又有什么意义呢？认识就是这样，错过了就再也回不来了。有些事，现在不做，以后再也不会做了 3、遥不可及的并非十年之后，而是今日之前。 4、人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:5:6","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["日程及周刊"],"content":"文摘 1、一寸山河一寸血，十万青年十万军 2、只是希望，能有一个可以在身边。两个人的生活圈子，是有着重叠的地方的，一个人生病了的时候，另外一个人就可以立马过来照顾。不需要心急如焚的，等待着去购买车票。哪怕是夜深了，也能够一起约出来，在附近的街道上吃着宵夜。哪怕是下雨了，忘记带伞也能够让对方，很快的就是给你送来一把雨伞。哪怕是下雪了，你也能够拍摄照片，和对方一起分享下雪时候的快乐，一起约好了去打雪仗堆雪人，而不是只能在朋友圈里对着照片点赞留言。这终究，缺少了现实接触的温度。每一句话，每一个呼吸，每一次心跳，都是幸福的味道。 3、因为不知道下辈子还能不能遇到，所以这辈子拼命给你温暖给你拥抱 4、所谓的意义只是智慧生命为了体现自身价值而设定的一个概念，是生命活着的一种体现，既然没有外物赋予自身意义，那么为什么不可以给自己下一个有意义的定义呢？ 5、人有贫富，但无贵贱，达到这一点的时候已是平等的起源 6、人生最可怕的事在于：每个人都有他的理由 7、我们都知道，如果可以回到过去，改变任何一件小事情，都将极大地改变未来。然而，几乎没有人想到，今天只要小小改变，就会改变自己的未来。 8、我口袋里有一个小设备，可以访问几乎全部的人类知识。我却用它与不认识的人进行毫无意义的争论，并看猫的照片。 9、按时长大，平安喜乐。 10、年轻的时候就应该不去想那么多，想得越多，遗憾越多。 11、这世上，唯有感情在冲动的时候没有错。 ","date":"2020-01-03","objectID":"/2020/life-weekly-1/:5:7","tags":["书藏的生活周刊"],"title":"书藏的生活周刊第 1 期 (20200103)","uri":"/2020/life-weekly-1/"},{"categories":["平日里的白日梦"],"content":"总有些美好的事情发生 有些美好的人活着 哪怕我不曾遇见 哪怕不发生在我身上 这样的事啊 只想一想，就不孤独 ","date":"2020-01-01","objectID":"/2020/%E6%80%BB%E6%9C%89%E4%BA%9B%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%BA%8B%E6%83%85%E5%8F%91%E7%94%9F/:0:0","tags":["文摘"],"title":"总有些美好的事情发生","uri":"/2020/%E6%80%BB%E6%9C%89%E4%BA%9B%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%BA%8B%E6%83%85%E5%8F%91%E7%94%9F/"},{"categories":["日程及周刊"],"content":"1. 书籍 1、罗敷，这么慢，那么美，2019-01 2、大学全集，2019-02 3、知乎周刊，我，一个人生活，2019-02 4、琢磨先生，以幽默的方式过一生，2019-03 5、洛里·斯皮尔曼(美)，生命清单， 2019-04 6、加西亚·马尔克斯(哥伦比亚)，世上最美的溺水者，2019-05 7、东野圭吾(日)，解忧杂货店，2019-06 8、卡勒德·胡塞尼(美)，追风筝的人，2019-07 9、一禅小和尚，2019-08 10、蕾秋·乔伊斯(英)，一个人的朝圣，2019-08 11、舒乙，老舍幽默小说，2019-09 12、吴中杰，废名田园小说，2019-10 13、山本文旭(日)，然后，我就一个人了，2019-10 14、陈磊·半小时漫画团队，半小时漫画经济学:生活常识篇，2019-11 15、陈磊·半小时漫画团队，半小时漫画经济学:金融危机篇， 2019-11 ","date":"2020-01-01","objectID":"/2020/special-issue-2019-reading-film-viewing-and-travel-records/:1:0","tags":["书藏的生活周刊"],"title":"特刊：2019年阅读、观影和旅行记录","uri":"/2020/special-issue-2019-reading-film-viewing-and-travel-records/"},{"categories":["日程及周刊"],"content":"2. 电影 1、Ryan Reynolds / 死侍2 / 2019-01 2、吴京 / 流浪地球 / 2019-02 3、沈腾，韩寒(导演) / 飞驰人生 / 2019-02 4、Brie Larson / 惊奇队长 / 2019-03 5、小罗伯特·唐尼等 / 复仇者联盟4:终局之战 / 2019-04 6、Ryan Reynolds(配音) / 大侦探皮卡丘 / 2019-05 7、乔纳·豪尔·金 / 一条狗的回家路 / 2019-05 8、苏菲·特纳 / X战警:黑凤凰 / 2019-06 9、Chris Hemsworth，Tessa Thompson / 黑衣人:全球追缉 / 2019-06 10、宫崎骏 / 千与千寻 / 2019-06 11、Tom Holland / 蜘蛛侠:英雄远征 / 2019-06 12、饺子(导演) / 哪吒之魔童降世 / 2019-07 13、道恩·强森，杰森·斯坦森 / 速度与激情:特别行动 / 2019-08 14、亚历克斯·霍诺德 / 徒手攀岩 / 2019-08 15、吴京，李仁港(导演) / 攀登者 / 2019-09 16、基努·里维斯 / 疾速备战 / 2019-10 17、汤姆·哈迪 / 疯狂的麦克斯4:狂暴之路 / 2019-10 18、木头(导演) / 罗小黑战记 / 2019-10 19、阿诺·施瓦辛格，琳达·汉密尔顿 / 终结者:黑暗命运 / 2019-11 20、愤怒的小鸟2 / 2019-11 21、威尔·史密斯，李安(导演) / 双子杀手 / 2019-11 22、杰拉德·巴特勒，摩根·弗里曼 / 天使陷落 / 2019-11 23、吕克·贝松(导演) / 安娜 / 2019-11 24、迪士尼 / 冰雪奇缘2 / 2019-12 25、张涵予等 / 中国机长 / 2019-12 26、黄渤，陈凯歌(导演)等 / 我和我的祖国 / 2019-12 27、彭昱畅，王大陆，魏大勋 / 小小的愿望 / 2019-12 ","date":"2020-01-01","objectID":"/2020/special-issue-2019-reading-film-viewing-and-travel-records/:2:0","tags":["书藏的生活周刊"],"title":"特刊：2019年阅读、观影和旅行记录","uri":"/2020/special-issue-2019-reading-film-viewing-and-travel-records/"},{"categories":["日程及周刊"],"content":"3. 景点 1、秦皇求仙入海处 / 2019-03 2、孟姜女庙 / 2019-03 3、秦皇岛玻璃博物馆 / 2019-04 4、燕山大学 / 2019-06 5、北陵公园 / 2019-08 6、新乐遗址 / 2019-08 7、辽宁古生物博物馆 / 2019-08 8、沈飞航空博物馆 / 2019-08 9、白塔 / 2019-09 10、弥陀寺 / 2019-09 11、碧霞宫 / 2019-09 12、张氏帅府 / 2019-10 13、沈阳金融博物馆 / 2019-10 14、辽宁省博物馆“又见大唐”书画文物展 / 2019-11 15、辽宁大学崇山校区 / 2019-12 ","date":"2020-01-01","objectID":"/2020/special-issue-2019-reading-film-viewing-and-travel-records/:3:0","tags":["书藏的生活周刊"],"title":"特刊：2019年阅读、观影和旅行记录","uri":"/2020/special-issue-2019-reading-film-viewing-and-travel-records/"},{"categories":["Golang学习之路"],"content":"实际开发中对代码进行测试是不可缺少的工作，在go中可以通过testing包来进行代码的测试。testing包和go test命令相互配合，能够完成代码的自动化测试。 在实际开发中，对代码进行测试是不可缺少的工作，在go中可以通过testing包对代码进行单元测试和性能测试。 基本说明 testing包是与go test命令配合使用的，编写测试代码需要使用testing包，而执行测试需要使用go test命令。执行测试时，会自动读取源码目录下名为*_test.go的文件，生成并运行测试用的可执行文件，并最终在终端输出测试信息。输出的信息类似于 ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... testing包的说明位于：Package testing go test的说明可通过执行 go help test查看 单元测试 假设当前我们在源代码目录拥有名为hello.go的源码文件，其内容如下： package hello import \"fmt\" //Hello print \"hello! func Hello() { fmt.Println(\"hello!\") } 首先编写测试用例，即在hello.go文件同目录下创建hello_test.go文件，编辑其内容如下： package hello import \"testing\" func TestHello(t *testing.T) { Hello() } 注意，单元测试的函数头一般符合如下形式，其中Xxx是测试函数名。无论原函数名首字母是否大写，测试函数中函数名的首字母必须大写，原话为where Xxx does not start with a lowercase letter. func TestXxx(t *testing.T) 在这两个文件目录下执行go test命令 PS F:\\Go\u003e ls Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2019/9/19 19:31 154 hello.go -a---- 2019/9/19 19:45 222 hello_test.go PS F:\\Go\u003e go test hello! PASS ok _/F_/Go 0.248s 根据输出结果可知测试通过 性能测试 在hello.go中新增Add函数 package hello import \"fmt\" //Hello print \"hello! func Hello() { fmt.Println(\"hello!\") } //Add add para func Add(i int) int { return i } 在hello_test.go文件中添加Add的性能测试函数 package hello import ( \"fmt\" \"testing\" ) func TestHello(t *testing.T) { Hello() } func BenchmarkAdd(b *testing.B) { var sum int for i := 0; i \u003c b.N; i++ { sum += Add(1) } fmt.Println(sum) } 性能测试的函数头也符合与单元测试相似的形式 func BenchmarkXxx(b *testing.B) 执行带bench参数的go test命令 PS F:\\Go\u003e go test -bench . hello! 1 goos: windows goarch: amd64 BenchmarkHello-4 100 10000 1000000 100000000 2000000000 2000000000 0.32 ns/op PASS ok _/F_/Go 1.019s 以上命令只执行了性能测试函数，BenchmarkHello执行了2000000000次，每次的平均执行时间为0.32ns，总的执行时间为1.019s。测试通过。 go test命令的参数 以上是基本的单元测试和性能测试命令，go test命令还拥有大量的参数，可以对测试进行定制。 usage: go test [build/test flags] [packages] [build/test flags \u0026 test binary flags] 如上，go test命令接受用于本身的两个参数和用于生成的测试结果文件的两个参数。 用于test命令本身的参数列表如下 -bench regexp 只运行与正则表达式匹配的性能测试，默认不执行任何性能测试。 对于测试，正则表达式由斜杠（/）字符拆分为正则表达式序列 要运行所有的性能测试, 使用 '-bench .' 或 '-bench=.'. -benchtime t Run enough iterations of each benchmark to take t, specified as a time.Duration (for example, -benchtime 1h30s). The default is 1 second (1s). The special syntax Nx means to run the benchmark N times (for example, -benchtime 100x). -count n 运行每个测试和性能测试n次（默认1次） 如果设置了 -cpu 参数, 为每个 GOMAXPROCS 值运行 n 次 -cover 启用测试覆盖率分析。这里要注意，测试覆盖率分析是通过在编译前注释源码来实现的，因此，出现错误时报告的行 号可能不对应。 -covermode set,count,atomic 为正在测试的包设置测试覆盖率分析的模式。 默认为 \"set\" 启用了 -race 则为 \"atomic\". 各模式说明： set: bool: 这个声明运行了吗 count: int: 这个声明运行了多少次 atomic: int: count, but correct in multithreaded tests; significantly more expensive. 需要设置 -cover -coverpkg pattern1,pattern2,pattern3 在每个测试中对与模式匹配的包应用测试覆盖率分析。默认情况下，每个测试只分析正在测试的包。 运行 'go help packages' 可获得包模式的说明 需要设置 -cover -cpu 1,2,4 指定应为其执行测试或性能测试的GOMAXPROCS值的列表。默认值是GOMAXPROCS的当前值。 -failfast 第一次测试失败后不开启新的测试 -list regexp 列出与正则表达式匹配的测试、性能测试或示例测试。 但不会运行任何测试、性能测试或示例测试。 只列出顶级测试。不会显示子测试或子性能测试。 -parallel n 允许调用t.parallel的测试函数并行执行。 n是要同时运行的最大测试数；默认设置为GOMAXPROCS的值。 该参数只适用于单个测试二进制文件。 并行测试不同的package参加 'go help build' 命令的说明 -run regexp 仅运行与正则表达式匹配的那些测试和示例测试。 对于测试，正则表达式由斜杠（/）字符拆分为正则表达式序列 -short 测试长时间运行时声明需要缩短时间，默认关闭。 -timeout d 如果测试文件的运行时间长于 d, panic。 如果d为 0, 未超时。 默认为 10 分钟 (10m). -v 详细输出：记录所有运行的测试。即使测试成功，也打印日志。 -vet list 在“go test”期间配置“go vet”的调用，从而使用以逗号分隔的vet检查列表。 如果list为空，则“go test”运行“go vet”，其中列出了一系列被认为值得解决的检查。 如果list是“off”，则“go test”根本不会运行“go vet”。 用于生成的测试结果文件的参数列表如下 -benchmem 打印性能测试的内存分配统计信息 -blockprofile block.out Write a goroutine blocking profile to the specified file when all tests are complete. Writes test binary as -c would. -blockprofilerate n Control the detail provided in goroutine blocking profiles by calling runtime.SetBlockProfileRate with n. See 'go doc runtime.SetBlockProfileRate'. The profiler aims to sample, on average, one blocking event every n nanoseconds the program spends blocked. By default, if -test.blockprofile is set without this flag, all blocking events are recorded, equivalent to -test.","date":"2019-12-22","objectID":"/2019/golang-syntax-12-test/:0:0","tags":["Go语法"],"title":"Golang语法基础12-测试","uri":"/2019/golang-syntax-12-test/"},{"categories":["Golang学习之路"],"content":"Go中有两套错误处理的方式 普通错误： 在函数和方法中返回错误对象作为它们的唯一或最后一个返回值 ，如果返回nil，表示没有错误 异常：使用panic和recover 主调函数总是应该检查收到的错误，不要忽略，否则可能导致严重的后果。 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:0:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"1. 普通错误 Go有一个预定义的error接口类型 type error interface { Error() string } errors包中有一个errorString结构体实现了该接口，其实 errors 包实现很简单，如下 package errors // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:1:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"1.1 定义错误 当我们需要一个新的错误类型，可以使用errors包的errors.New函数接收合适的信息来创建，如下例 err := errors.New(\"math - square root of negative number\") 从上面的实现中可以看到调用 errors.New 其实就是将传入的字符串给了结构体 errorString，由于该结构体实现了 error 接口，因此 New 函数返回的时候将结构体赋给了一个 error 接口变量，所以以后我们在主调函数输出该返回值时，会输出结构体的值。 拿一个计算平方根的函数举例，可以这样使用 func Sqrt(f float64) (float64, error) { if f \u003c 0 { return 0, errors.New(\"math - square root of negative number\") } //implementation of Sqrt } 然后像下面这样调用Sqrt函数 if f, err := Sqrt(-1); err != nil { fmt.Printf(\"Error: %s\\n\", err) } 使用fmt.Printf将错误信息打印出来，定义的错误信息通过会有像Error:这样的前缀，所以错误信息的内容不要以大写字母开头，如上例中使用math而不是Math 大部分情况自定义错误类型都是很有用的方法，可以将底层错误信息之外的其它有用信息打印出来。如果有不同的错误条件，就可以用类型断言判断错误场景，并做一些补救和恢复 switch err := err.(type) { case ParseError: PrintParseError(err) case PathError: PrintPathError(err) ... default: fmt.Printf(\"Not a special error, just %s\\n\", err) } 包也可以用额外的方法定义特定的错误，如net.Error: package net type Error interface { Timeout() bool // Is the error a timeout? Temporary() bool // Is the error temporary? } 如前所述，所有的例子都遵循同一种命名规范： 错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:1:1","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"1.2 输出更多的错误信息 fmt.Errorf()是一个常用的fmt包的函数，用于输出更多的错误信息，而不是单单一个字符串。如前面平方根的例子 if f \u003c 0 { return 0, fmt.Errorf(\"math: squre root of negative number %g\", f) } 实际上，fmt.Errorf和errors.New一样都返回error类型的变量 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:1:2","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"2. 异常 或者称为运行时异常，指的是那些无法预测的错误。比如数组下标越界或类型断言失败，就会触发异常，并且伴随着程序终止返回一个runtime.Error接口类型的值，这个值和普通错误的区别在于有一个RuntimeError()方法 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:2:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"2.1 panic panic就是Go中用于生成异常的方法。当错误不可修复、程序无法继续运行时，使用panic函数来产生一个中止程序的运行时错误，panic接收任意类型的参数，通常是字符串，这个参数会在程序终止时被打印出来。中止程序和打印参数的过程由Go runtime负责。一个例子如下 package main import \"fmt\" func main() { fmt.Println(\"Starting the program\") panic(\"A severe error occurred: stopping the program!\") fmt.Println(\"Ending the program\") } 输出如下 Starting the program panic: A severe error occurred: stopping the program! goroutine 1 [running]: main.main() F:/Gotest/main.go:7 +0x9c exit status 2 一个检测到错误然后使用panic抛出异常的完整例子如下 if err != nil { panic(\"ERROR occurred:\" + err.Error()) } 但panic抛出异常并中止程序是最后的办法，如果有修复的可能就不应该使用 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:2:1","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"2.2 panicking 在多层嵌套的函数调用中使用panic，可以马上中止当前函数的执行，所有的defer语句都会保证执行并把控制权交还给接收到panic的函数调用者。这样向上冒泡直到最顶层，并执行（每层的）defer，在栈顶处程序崩溃，并在命令行中用传给panic的值报告错误情况：这个终止的过程就是panicking。 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:2:2","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"2.3 recover revocer函数用于让程序从panicking重新获得控制权，停止终止过程进而恢复正常执行，但recover只能在defer修饰的函数中使用。如果正常执行，调用recover会返回nil，没有其它效果。 简而言之，panicking有两个结果，一个是程序终止，一个是遇到defer修饰的recover()函数然后恢复。一个例子如下 func protect(g func()) { defer func() { log.Println(\"done\") // Println executes normally even if there is a panic if err := recover(); err != nil { log.Printf(\"run time panic: %v\", err) } }() log.Println(\"start\") g() // possible runtime-error } 将panic，defer和recover结合的完整例子如下 package main import ( \"fmt\" ) func badCall() { panic(\"bad end\") } func test() { defer func() { if e := recover(); e != nil { fmt.Printf(\"Panicing %s\\r\\n\", e) } }() badCall() fmt.Printf(\"After bad call\\r\\n\") // \u003c-- wordt niet bereikt } func main() { fmt.Printf(\"Calling test\\r\\n\") test() fmt.Printf(\"Test completed\\r\\n\") } 输出 Calling test Panicing bad end Test completed ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:2:3","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"3. 错误处理的一些原则 这是在编写自己的包时需要遵循的一些原则，有助于别人调用和程序正常运行 在包内部，总是在panic后使用recover，不要让panic返回的层次超出当前包的范围 向包的调用者返回错误值，而不是panic 在包内部的不可导出函数中有深层次调用时，将panic转换成error来通知调用者出错信息 根据此原则，一个parse包如下，作用是把输入的字符串解析为整数切片 package parse import ( \"fmt\" \"strings\" \"strconv\" ) // A ParseError indicates an error in converting a word into an integer. type ParseError struct { Index int // The index into the space-separated list of words. Word string // The word that generated the parse error. Err error // The raw error that precipitated this error, if any. } // String returns a human-readable error message. func (e *ParseError) String() string { return fmt.Sprintf(\"pkg parse: error parsing %q as int\", e.Word) } // Parse parses the space-separated words in in put as integers. func Parse(input string) (numbers []int, err error) { defer func() { if r := recover(); r != nil { var ok bool err, ok = r.(error) if !ok { err = fmt.Errorf(\"pkg: %v\", r) } } }() fields := strings.Fields(input) numbers = fields2numbers(fields) return } func fields2numbers(fields []string) (numbers []int) { if len(fields) == 0 { panic(\"no words to parse\") } for idx, field := range fields { num, err := strconv.Atoi(field) if err != nil { panic(\u0026ParseError{idx, field, err}) } numbers = append(numbers, num) } return } 该包定义了自己的ParseError，当没有东西需要转换或转换成整数失败时，产生panic，但可导出的Parse函数会从panic中recover并整合信息返回一个错误给调用者。 一个调用parse包的实例如下 package main import ( \"fmt\" \"./parse/parse\" ) func main() { var examples = []string{ \"1 2 3 4 5\", \"100 50 25 12.5 6.25\", \"2 + 2 = 4\", \"1st class\", \"\", } for _, ex := range examples { fmt.Printf(\"Parsing %q:\\n \", ex) nums, err := parse.Parse(ex) if err != nil { fmt.Println(err) // here String() method from ParseError is used continue } fmt.Println(nums) } } 输出 Parsing \"1 2 3 4 5\": [1 2 3 4 5] Parsing \"100 50 25 12.5 6.25\": pkg: pkg parse: error parsing \"12.5\" as int Parsing \"2 + 2 = 4\": pkg: pkg parse: error parsing \"+\" as int Parsing \"1st class\": pkg: pkg parse: error parsing \"1st\" as int Parsing \"\": pkg: no words to parse ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:3:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"4. 闭包处理错误 根据上面的原则，只要有函数返回，就应该检查是否有错误发生，但这会导致重复乏味的代码。结合 defer/panic/recover 机制和闭包可以得到一种更加优雅的写法。不过这种写法的限制是所有函数都需要是同一种签名。 假设所有函数签名都是下面这种形式 func f(a type1, b type2) 参数的数量和类型是不相关的，我们给这个类型一个名字： fType1 = func f(a type1, b type2) 使用两个辅助函数帮忙完成整个过程 check：用来检查是否有错误和panic发生的函数 func check(err error) { if err != nil { panic(err) } } errorhandler：接收一个 fType1 类型的函数 fn 并返回一个调用 fn 的函数, 其中包含有 defer/recover 机制 func errorHandler(fn fType1) fType1 { return func(a type1, b type2) { defer func() { if err, ok := recover().(error); ok { log.Printf(“run time panic: %v”, err) } }() fn(a, b) } } 当错误发生时会 recover 并打印在日志中，check() 函数会在所有的被调函数中调用，像这样： ```go func f1(a type1, b type2) { f, _, err := // call function/method check(err) t, err := // call function/method check(err) _, err2 := // call function/method check(err2) } 通过这种机制，所有的错误都会被 recover，并且调用函数后的错误检查代码也被简化为调用 check(err) 即可。在这种模式下，不同的错误处理必须对应不同的函数类型；它们（错误处理）可能被隐藏在错误处理包内部。可选的更加通用的方式是用一个空接口类型的切片作为参数和返回值。 最最重要的一点，Goroutine 中抛出的异常，只能在本协程中使用 recover 捕获，主协程是无法接收到的，同时，子协程发生的 panic 如果没有被捕获，会导致整个程序中断。 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:4:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["爱编程爱技术的孩子"],"content":"虚拟机长时间不开机，系统时间和当前时间不同步，导致很多操作被拒绝，这里记录如何主动同步系统的时间和网络时间 ","date":"2019-12-20","objectID":"/2019/linux%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/:0:0","tags":["linux"],"title":"linux系统时间同步","uri":"/2019/linux%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"},{"categories":["爱编程爱技术的孩子"],"content":"正文 设置系统时区 $ timedatectl set-timezone Asia/Shanghai 安装ntpdate工具 $ sudo apt-get install ntpdate 同步时间 $ sudo ntpdate cn.pool.ntp.org 将系统时间写入硬件时间 $ sudo hwclock --systohc ntpdate cn.pool.ntp.org是位于中国的公共NTP服务器 ","date":"2019-12-20","objectID":"/2019/linux%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/:1:0","tags":["linux"],"title":"linux系统时间同步","uri":"/2019/linux%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"},{"categories":["Golang学习之路"],"content":"首先来回顾在操作系统中学过的一些概念。进程(processes)是程序执行的基本单位，运行在一个独立的内存地址空间中；一个进程由多个线程(threads)组成，线程的存在是为了能够同时执行多个任务，最大化利用时间，防止产生等待，线程间是共享内存地址空间的。从windows资源管理器看这一点能看的很明白，如下，每个应用程序是一个进程，Typora程序下有两个线程在同时运行。 并发是建立在多线程之上的概念，将CPU的执行时间划分为许多很小的间隔，多个线程不断地切换执行，从上层看起来就像在同时执行一样，但本质上依然是线性的。并行则是程序在某个特定的事件同时运行在多个CPU上，多核处理器为并行提供了可能。因此，并发也可能是并行的。 操作系统课程中一个最主要的问题就是多线程对共享内存空间的访问，我们学到的解决方式是通过加互斥锁来实现，但在设计实现上是一个复杂的过程，非常容易出错，鉴于操作系统考试的惨痛经历，现在完全不想回忆。Go中的标准库sync中有一些工具可以用来实现互斥锁的相关操作，但它显然没有Go自身支持的Goroutines高效。 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:0:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"1. Goroutines Go原生支持并发，依靠的是协程(goroutine)和通道(channel)两个概念。goroutines的概念是为了和processes、threads、coroutines等概念区别。其中coroutines也叫做协程，而且这才是常规意义下的协程，goroutines只在Go中有效。 coroutines是比线程更轻的一个概念，只使用很少的内存和资源。它对栈进行分隔，从而动态地增加或缩减内存的使用，栈的管理也是自动的，在协程退出后自动释放空间。协程可以运行在多个线程间，也可以运行在线程内，它的创建廉价到可以在同一地址空间存在100000个。这一概念也存在于其它语言(C#, Java等)中，它与goroutines的区别在于： Go协程意味着并行(或者可以以并行的方式部署)，协程一般不是 Go协程通过通道来通信，协程则通过让出与恢复操作来通信 理论上，Go协程比协程更加强大。 以一个简单模型来描述goroutine：它是一个和其它协程在同一地址空间并发执行的函数。通过在函数或方法名前加上go关键字来创建和运行一个协程，运行结束后安静的退出(没有任何返回值)。 go list.Sort() //并行的运行list.Sort，不等待 Go程序中必须含有的main()函数可以看作一个协程，尽管它没有通过go关键字启动，在程序初始化的过程中(init()函数运行)，goroutine也可以运行。 单纯的结束协程的概念是不够具体的，协程需要和通道来配合 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:1:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2. Channel 并发编程的困难之处在于实现对共享变量的正确访问，互斥量的方式是复杂的，Go鼓励采用一种不同的方法，即在通道(channel)上传递共享值，如同Unix管道一般，通道用于发送类型化的数据，在任何给定的时间，只有一个协程可以对通道中的数据进行访问，从而完成协程间的通信，也避开了所有由共享内存导致的陷阱。这种通过通道进行通信的方式保证同步性的同时，数据的所有权也因此被传递。 这一设计理念最终简化为一句话：不要通过共享内存来通信，而通过通信来共享内存。 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.1 声明与初始化 声明通道的基本形式如下，未初始化的通道值为nil var identifier chan datatype 通道只能传输一种类型的数据，比如chan int或chan string，可以是任意类型，包括空接口interface{}和通道自己 和map相同，通道也是引用类型，因此使用make进行初始化，可以指定第二个参数用来指定缓冲区的大小，即通道可容纳的数据个数，这一个值默认是0，意思是无缓冲，无缓冲的通道将通信、值的交换、同步三者结合，保证两个协程的计算处于已知状态。 var ci chan string ci = make(chan string) // unbuffered channel of integers cj := make(chan int, 0) // unbuffered channel of integers cs := make(chan *os.File, 100) // buffered channel of pointers to Files ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:1","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.2 通信操作符\u003c- 这一操作符直观的表示数据的传输：信息按照箭头方向流动。 流向通道(发送)用ch \u003c- int1表示，意为利用通道ch发送变量int1 从通道流出(接收)用int2 = \u003c- ch表示，意为变量int2从通道ch接收数据，如果int2没有声明过，可以使用int2 := \u003c- ch \u003c- ch则用于表示丢弃当前值，获取通道的下一个值，可以用来验证，如 if \u003c- ch != 1000 { ... } 为了可读性通道的命名通常以 ch 开头或者包含 chan。通道的发送和接收都是原子操作，总是互不干扰的完成。下面的示例展示了通信操作符的使用。 package main import ( \"fmt\" \"time\" ) func main() { ch := make(chan string) go sendData(ch) go getData(ch) time.Sleep(1e9) } func sendData(ch chan string) { ch \u003c- \"Washington\" ch \u003c- \"Tripoli\" ch \u003c- \"London\" ch \u003c- \"Beijing\" ch \u003c- \"Tokyo\" } func getData(ch chan string) { var input string // time.Sleep(2e9) for { input = \u003c-ch fmt.Printf(\"%s \", input) } } //Output: Washington Tripoli London Beijing tokyo 如果2个协程需要通信，必须给它们同一个通道作为参数。上例中 main() 函数中启动了两个协程：sendData() 通过通道 ch 发送了 5 个字符串，getData() 按顺序接收它们并打印出来。 一些同步的细节如下： main() 等待了 1 秒让两个协程完成，如果不这样(注释掉time.Sleep(1e9))，sendData() 就没有机会输出。 getData() 使用了无限循环：它随着 sendData() 的发送完成和 ch 变空也结束了。 如果我们移除一个或所有 go 关键字，程序无法运行，Go 运行时会抛出 panic。这是因为运行时(runtime)会检查所有的协程是否在等待什么东西(从通道读取或写入某个通道)，这意味着陷入死锁，程序无法继续执行。 通道的发送和接收顺序是无法预知的，如果使用打印状态来输出，由于两者间的时间延迟，打印的顺序和真实发生的顺序是不同的。 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:2","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.3 通道阻塞 前面提到默认情况下通信是同步且无缓冲的，因此通道的发送/接收操作在对方准备好之前是阻塞的。 对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据 对于同一个通道，接收操作在发送者可用之前是阻塞的（协程或函数中的） 下例中的协程在无限循环中不断地给通道发送数据，但由于没有接收者，只输出了数字0 package main import \"fmt\" func main() { ch1 := make(chan int) go pump(ch1) // pump hangs fmt.Println(\u003c-ch1) // prints only 0 } func pump(ch chan int) { for i := 0; ; i++ { ch \u003c- i } } //Output:0 定义一个新的协程用来接收通道值可以持续输出 package main import \"fmt\" func main() { ch1 := make(chan int) go pump(ch1) go suck(ch1) time.Sleep(1e9) } func pump(ch chan int) { for i := 0; ; i++ { ch \u003c- i } } func suck(ch chan int) { for { fmt.Println(\u003c-ch) } } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:3","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.4 信号量模式 信号量模式的意思是利用通道阻塞特性，等待所有计算完成后才让程序退出，用于并行执行函数或for循环，加快程序执行速度，一个例子瑞小安 type Empty interface {} var empty Empty ... data := make([]float64, N) res := make([]float64, N) sem := make(chan Empty, N) ... for i, xi := range data { go func (i int, xi float64) { res[i] = doSomething(i, xi) sem \u003c- empty } (i, xi) } // wait for goroutines to finish for i := 0; i \u003c N; i++ { \u003c-sem } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:4","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.5 通道工厂 编程时常用一种通道工厂的模式，即不将通道作为参数传递给协程，而是用函数来生成一个通道并返回 package main import ( \"fmt\" \"time\" ) func main() { stream := pump() go suck(stream) time.Sleep(1e9) } func pump() chan int { ch := make(chan int) go func() { for i := 0; ; i++ { ch \u003c- i } }() return ch } func suck(ch chan int) { for { fmt.Println(\u003c-ch) } } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:5","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.6 给通道使用for循环 for 循环的 range 语句可以用在通道 ch 上，便可以从通道中获取值，像这样： for v := range ch { fmt.Printf(\"The value is %v\\n\", v) } 这样的使用依然必须和通道的写入和关闭相配合， 不能单独存在 package main import ( \"fmt\" \"time\" ) func main() { suck(pump()) time.Sleep(1e9) } func pump() chan int { ch := make(chan int) go func() { for i := 0; ; i++ { ch \u003c- i } }() return ch } func suck(ch chan int) { go func() { for v := range ch { fmt.Println(v) } }() } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:6","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.7 关闭通道 通道可以被显式的关闭，不过只有发送者才需要关闭通道，接收者永远不需要。 ch := make(chan float64) defer close(ch) 测试通道是否关闭则可以使用ok操作符 v, ok := \u003c-ch // ok is true if v received value 一个完整的例子如下 package main import \"fmt\" func main() { ch := make(chan string) go sendData(ch) getData(ch) } func sendData(ch chan string) { ch \u003c- \"Washington\" ch \u003c- \"Tripoli\" ch \u003c- \"London\" ch \u003c- \"Beijing\" ch \u003c- \"Tokio\" close(ch) } func getData(ch chan string) { for { input, open := \u003c-ch if !open { break } fmt.Printf(\"%s \", input) } } 但是使用for-range读取通道是更好的办法，因为这会自动检测通道是否关闭 for input := range ch { process(input) } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:7","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"3. Select 从不同的并发执行的协程中获取值可以通过关键字select来完成，它和switch控制语句非常相似，其行为像是“你准备好了吗”的轮询机制；select监听进入通道的数据，也可以是用通道发送值的时候。 select { case u:= \u003c- ch1: ... case v:= \u003c- ch2: ... ... default: // no value ready to be received ... } select 做的事情是：选择处理列出的多个通信情况中的一个。 如果都阻塞了，会等待直到其中一个可以处理 如果多个可以处理，随机选择一个 如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。 使用default可以保证发送不被阻塞，但没有default的监听模式也可能被使用，通过break语句退出循环。一个完整的例子如下 package main import ( \"fmt\" \"time\" ) func main() { ch1 := make(chan int) ch2 := make(chan int) go pump1(ch1) go pump2(ch2) go suck(ch1, ch2) time.Sleep(1e9) } func pump1(ch chan int) { for i := 0; ; i++ { ch \u003c- i * 2 } } func pump2(ch chan int) { for i := 0; ; i++ { ch \u003c- i + 5 } } func suck(ch1, ch2 chan int) { for { select { case v := \u003c-ch1: fmt.Printf(\"Received on channel 1: %d\\n\", v) case v := \u003c-ch2: fmt.Printf(\"Received on channel 2: %d\\n\", v) } } } 有 2 个通道 ch1 和 ch2，三个协程 pump1()、pump2() 和 suck()。在无限循环中，ch1 和 ch2 通过 pump1() 和 pump2() 填充整数；suck() 也在无限循环中轮询输入，通过 select 语句获取 ch1 和 ch2 的整数并输出。选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:3:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"4. 应用 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:4:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"4.1 惰性生成器 生成器是指当被调用时返回一个序列中下一个值的函数，例如： generateInteger() =\u003e 0 generateInteger() =\u003e 1 generateInteger() =\u003e 2 .... 生成器每次返回的是序列中下一个值而非整个序列；这种特性也称之为惰性求值：只在你需要时进行求值，同时保留相关变量资源（内存和cpu）：这是一项在需要时对表达式进行求值的技术。例如，生成一个无限数量的偶数序列：要产生这样一个序列并且在一个一个的使用可能会很困难，而且内存会溢出！但是一个含有通道和go协程的函数能轻易实现这个需求。 下例中实现了一个使用 int 型通道来实现的生成器。通道被命名为yield和resume，这些词经常在协程代码中使用。 package main import ( \"fmt\" ) var resume chan int func integers() chan int { yield := make(chan int) count := 0 go func() { for { yield \u003c- count count++ } }() return yield } func generateInteger() int { return \u003c-resume } func main() { resume = integers() fmt.Println(generateInteger()) //=\u003e 0 fmt.Println(generateInteger()) //=\u003e 1 fmt.Println(generateInteger()) //=\u003e 2 } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:4:1","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"4.2 Futures 模式 所谓Futures就是指：有时候在你使用某一个值之前需要先对其进行计算。这种情况下，你就可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕了。 Futures模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于Futures需要返回一个值。 一个例子： 假设我们有一个矩阵类型，我们需要计算两个矩阵A和B乘积的逆，首先我们通过函数Inverse(M)分别对其进行求逆运算，再将结果相乘。如下函数InverseProduct()实现了如上过程： func InverseProduct(a Matrix, b Matrix) { a_inv := Inverse(a) b_inv := Inverse(b) return Product(a_inv, b_inv) } 在这里例子中，a和b的求逆句子的过程可以同时进行，因此换用并行计算方式如下： func InverseProduct(a Matrix, b Matrix) { a_inv_future := InverseFuture(a) // start as a goroutine b_inv_future := InverseFuture(b) // start as a goroutine a_inv := \u003c-a_inv_future b_inv := \u003c-b_inv_future return Product(a_inv, b_inv) } InverseFuture函数以goroutine的形式起了一个闭包，该闭包会将矩阵求逆结果放入到future通道中： func InverseFuture(a Matrix) chan Matrix { future := make(chan Matrix) go func() { future \u003c- Inverse(a) }() return future } 对计算密集型的场景，使用Futures模式是很有意义的 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:4:2","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"4.3 C/S模式 客户端/服务器(C/S)模式是goroutines和channels最常见的应用。 客户端(Client)可以是运行在任意设备上的任意程序，它会按需发送请求(request)至服务器。服务器(Server)接收到这个请求后开始相应的工作，然后再将响应(response)返回给客户端。典型情况下一般是多个客户端（即多个请求）对应一个（或少量）服务器。例如我们日常使用的浏览器客户端，其功能就是向服务器请求网页。而Web服务器则会向浏览器响应网页数据。 使用Go的服务器通常会在协程中执行向客户端的响应，故而会对每一个客户端请求启动一个协程。一个常用的操作方法是客户端请求自身中包含一个通道，而服务器则向这个通道发送响应。 下面是请求Request的结构，响应暗含在请求的结构里面 type Request struct { a, b int replyc chan int // reply channel inside the Request } 服务器无限循环从chan *Request接收请求，为了避免某个请求长时间操作造成堵塞，为每个请求启动一个协程，然后启动run()函数处理该请求，处理后的值送到chan *Reply通道。 func server(op binOp, service chan *Request) { for { req := \u003c-service; // requests arrive here // start goroutine for request: go run(op, req); // don’t wait for op to complete } } type binOp func(a, b int) int func run(op binOp, req *Request) { req.replyc \u003c- op(req.a, req.b) } 但以上过程仅仅是对客户端的请求是并发处理的，实际上，server本身也是以协程方式启动的 func startServer(op binOp) chan *Request { reqChan := make(chan *Request); go server(op, reqChan); return reqChan; } startServer会在main函数中被调用，下面是main函数调用示例，一共发送了100个请求到服务器进行处理， 只有它们全部被送达后我们才会按相反的顺序检查响应： func main() { adder := startServer(func(a, b int) int { return a + b }) const N = 100 var reqs [N]Request for i := 0; i \u003c N; i++ { req := \u0026reqs[i] req.a = i req.b = i + N req.replyc = make(chan int) adder \u003c- req // adder is a channel of requests } // checks: for i := N - 1; i \u003e= 0; i-- { // doesn’t matter what order if \u003c-reqs[i].replyc != N+2*i { fmt.Println(“fail at”, i) } else { fmt.Println(“Request “, i, “is ok!”) } } fmt.Println(“done”) } //Output: Request 99 is ok! Request 98 is ok! ... Request 1 is ok! Request 0 is ok! done 完整的程序如下，因为server在main函数返回后是被强制结束的，下面还针对这一点做出改进，方法是提供一个退出通道给server package main import \"fmt\" type Request struct { a, b int replyc chan int // reply channel inside the Request } type binOp func(a, b int) int func run(op binOp, req *Request) { req.replyc \u003c- op(req.a, req.b) } func server(op binOp, service chan *Request, quit chan bool) { for { select { case req := \u003c-service: go run(op, req) case \u003c-quit: return } } } func startServer(op binOp) (service chan *Request, quit chan bool) { service = make(chan *Request) quit = make(chan bool) go server(op, service, quit) return service, quit } func main() { adder, quit := startServer(func(a, b int) int { return a + b }) const N = 100 var reqs [N]Request for i := 0; i \u003c N; i++ { req := \u0026reqs[i] req.a = i req.b = i + N req.replyc = make(chan int) adder \u003c- req } // checks: for i := N - 1; i \u003e= 0; i-- { // doesn't matter what order if \u003c-reqs[i].replyc != N+2*i { fmt.Println(\"fail at\", i) } else { fmt.Println(\"Request \", i, \" is ok!\") } } quit \u003c- true fmt.Println(\"done\") } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:4:3","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["我所热爱的生活啊"],"content":"正确的使用和保养可以延长衣物的使用时间，并使衣物看起来整洁干净，下面就对这些步骤做整理和介绍。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:0:0","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"1. 概述 整篇文章的思路是根据面料进行处理，但最终发现这样太过复杂，平时洗衣服前如果想这么多，还不如全部扔进洗衣机，因此简化一些流程。洗涤、熨烫、收纳的目的是使衣服保持干净整洁，现代人的服装更新换代很快，基本不需要考虑损坏的情况，因此，只考虑合理收纳而不考虑防损坏的保管。下面是完整的衣物处理流程 将内衣袜子单独分开，手洗； 将需要干洗的衣服比如羽绒服、呢绒大衣单独打理好送去干洗店； 将剩下的衣服分为浅色和深色； 温水加入洗衣液搅匀，放入衣物，浸泡1~2小时； 漂洗去除洗涤剂和脏水，对领口、袖口等部位揉搓重点去污，直到没有明显污渍和水不再变脏为止； 洗衣机洗涤，如果需要，加入柔顺剂； 洗衣机洗涤完毕后，检查衣物是否干净及是否有洗涤剂残留，如果有，继续漂洗去除多余的洗涤剂； 使用对应的衣架将衣服挂出晾干； 晾干的衣物中有褶皱的使用挂烫机熨平； 按季节整理保存，适当使用收纳箱。 其中有部分注意事项 如果衣服比较干硬，适当使用柔顺剂； 如果衣服发黄，适当使用漂白剂； 对全自动洗衣机来说，浸泡、洗涤、漂洗都自动完成，但结束后注意一下衣领等部位是否干净。 关于是否适合机洗、是否适合水洗、水温应该是多少、是否可熨烫、熨烫温度应该是多少，很多衣服在购买的时候都有一个小标签上面会有，多次洗涤后可能会看不清，所以最好购买的时候就把这些记下来，和购入时间、价格等信息一起计入自己的数字衣柜中就可以。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:1:0","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"2. 熨烫 衣物经水洗后，吸水膨胀或收缩，加上洗涤剂和洗衣机的机械外力的揉搓，外形通常会发生一定的变化。经过熨烫后，大多数衣物能恢复到原来的状态，甚至可以通过重新塑型弥补剪裁和缝纫时的不足，所以熨烫也是对服装再次加工的一个过程。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:2:0","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"2.1 熨烫作用 对衣物进行熨烫的主要作用是成型、熨平。 成型，通过设计、裁剪和缝纫将面料制作成衣物的过程就是一个塑造衣物形状的过程，称之为成型。但仅靠裁剪和缝纫显然是不够的，熨烫可以改变纤维的伸缩度和构成衣物的线的密度、方向等结构，使衣物各个部位变得挺拔或舒展，从而适应人体曲线和日常活动的要求，使穿着更加舒适。因此，熨烫也具有成型的作用。 衣物熨烫的整个过程可通过熨斗手工完成，目前最常用的还有挂烫机。 熨平，成型是使衣物获得一定的立体造型，熨平则相反，是通过熨烫，消除衣物穿着过程中的皱痕，使其平滑挺直的过程。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:2:1","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"2.2 基本原理 熨烫的基本原理是在加热条件下拆散服装纤维的分子间结构，冷却后使其在新的环境下建立平衡，从而将衣物形状固定。这样定型的服装持久程度是相对的，亲水性的面料持久性差，会在水洗后消失，如棉、毛、黏胶纤维等；疏水性面料持久性要好一点，可经过多次洗穿，比如涤纶等。这种方式叫做热定型，熨烫的热定型必须具备四个基本要素。 热能，需要加热拆散服装纤维的分子间结构，然后在外力作用下(熨斗)发生形变，并保持下来，这种性质称为热塑性。所有的纤维都有热塑性，但不同的纤维对热的敏感程度不同，天然纤维是非热敏性材料，熨烫温度过高只会变黄变焦，合成纤维及醋脂纤维则是热敏性材料，温度过高会严重收缩或熔化。 水分，水分能减小分子间、纤维间和纱线间摩擦力，增加衣物可塑性，因此熨烫时经常需要给面料加湿使其湿润软化，但这只对亲水性材料有效，比如天然纤维。合成纤维则是疏水性材料，熨烫时润湿没有帮助，主要利用纤维本身的热塑性。 压力，衣物在热能和水分作用下分子间结构被拆开，容易变形，此时施加压力就能将其在人们需要的位置和形状上固定下来，达到定型目的。 冷却，定型后的衣物只有经过冷却干燥，分子间结构才能稳定，不会再次轻易变形。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:2:2","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"2.3 如何熨烫 熨烫的基本工具是熨斗，现在很多人也使用挂烫机。熨烫的方法及一些技巧如下。 水的运用 较薄的面料如棉、麻、蚕丝、黏胶等，可以一边加湿一边熨烫，因为水分易挥发。 质地紧密、厚实且吸湿好的面料，如纯毛及毛与化纤混纺，可以垫湿布熨烫（湿布必须是棉制品，因为棉纤维能承受较高的熨烫温度）。因为加湿过多，水分不易挥发，即使烫平，过一段时间(1-2h)还是会恢复原来的状态。厚实的化纤织物也往往不耐高温，垫湿布熨烫可以将水分迅速化为蒸汽，均匀的分散在面料内部，提高受热面积，带来更好的熨烫效果。 温度的掌握 在熨烫过程中，适宜的温度至关重要。不同的面料需要的熨烫温度不同，见下表。若温度过低，水分不能转化为蒸汽，不能使纤维分子产生运动，达不到熨烫目的。相反，熨烫温度过高，会使纤维发黄，甚至炭化、分解。对于合成纤维会引起收缩、熔融。 面料名 直接熨烫温度 垫干布熨烫温度 垫湿布熨烫温度 纤维分解温度 棉织物 175-195 195-220 220-240 150-180 麻织物 185-205 200-220 220-250 150-180 羊毛织物 160-180 185-200 200-250 130-150 桑蚕丝织物 165-185 185-190 190-220 130-150 柞蚕丝织物 155-165 175-185 185-210 130-150 黏胶纤维织物 160-180 180-200 200-220 150-180 醋脂纤维织物 110-130 130-160 160-180 涤纶织物 150-170 180-190 200-220 锦纶织物 125-145 160-170 190-220 维纶 125-145 160-170 不可 腈纶 115-135 150-160 180-210 280-300 丙纶 85-100 140-150 160-190 氯纶 45-65 80-90 不可 氨纶 90-110 130 皮革 80-95 熨烫时一般需要先预热到一定的温度再开始烫，因为加湿熨烫时，水分变为蒸汽要带走热量，而且湿度越大，熨烫温度下降越快，预热可以保证温度的不断补充，从而提高熨烫的效果并缩短时间。另外，散热速度过快可能造成热力不足，这时需要放慢熨烫速度，整个过程熨斗应先轻后重，使水分蒸发扩散均匀、温度分布均匀。 压力与时间 压力越大，时间越长，熨烫效果越明显，但也应区别对待。有顽固褶皱的衣物加大压力并稍延长几秒就可熨平，毛织物、起绒类织物则不宜高压长时间熨烫。 冷却的方法 纤维在熨烫时定型是暂时的，只有通过急骤冷却，才能使纤维分子停止或大大减少运动，以达到“完全”定型的目的。冷却的方法有以下两种。 机械冷却法：使用空心熨烫板，铁或铝制，下面一台抽风机或真空机通过管道进行抽风。熨烫中或熨烫即将完毕，只要开动抽风机，将水分、余热全部抽掉，即可迅速冷却。 自然冷却法：这是普通家庭熨烫中常用的方法，即熨烫后衣物自然降温。要使自然降温速度加快，需要熨烫时将水分熨干，熨斗边熨烫边去掉湿布，并在刚熨烫过的部位吹凉气，也能达到加快冷却的目的。 当然，熨烫技术有一定的灵活性。例如，熨烫丝绸服装，白色和深色所用温度、水分和压力是不同的。白色丝绸温度高了易发黄，所以熨烫温度可低些，水分可少一些，但压力可以加大，增大压力弥补温度和水分的不足，从而达到熨烫的目的；而熨烫深色丝绸，温度可以稍高些，比烫其他衣物高10～15℃，水量也可稍大，但压力最好小些。浅色织物可以直接熨烫正面，深色织物则最好直接熨烫反面。对于缎纹组织织物，以烫反面为主。如果是起绒织物，先在正面垫湿布熨烫到八成干后，撤掉湿布，趁热及时用软毛刷刷顺绒毛（一定要沿同一方向刷），然后挂起晾干，熨烫时压力不宜大。熨烫针织羊毛衫，压力不能过大，要半提熨斗进行悬烫，主要是利用热力将湿布上的水分化为蒸汽散发到毛衣内部，达到熨平的目的，熨斗温度控制在180℃以下，但不能将湿布烫干。烫平后应立即提起衣服轻轻抖动，将热量和水气散发掉，晾干后方可折叠收藏。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:2:3","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"2.4 熨斗和挂烫机 如今挂烫机的使用已经很常见，具体的选择还是要看自己。掌握了正确的方法后，熨斗的效果要好很多，但是挂烫机更加方便，而且不会损坏衣物。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:2:4","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"3. 洗涤 常用的洗衣服的方法分干洗和湿洗两种，服装类型不同，面料种类不同，污渍不同，洗涤方法都不相同。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:3:0","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"3.1 湿洗 湿洗就是用水洗，加入洗涤剂，在适宜的温度下洗涤，适合水溶性的污渍，不过对油性污渍也可通过洗涤剂达到清洁目的。由于不同纤维吸水膨胀时的性质不同，因此湿洗引起的收缩、变形、绽开、褶皱、掉色等现象也不同，但总体来说，湿洗方便且不会造成严重后果，是最常用的洗涤方法。 棉类服装 棉类服装可手洗或机洗，温度根据颜色确定，深色服装温度不应太高，也不宜浸泡过久，避免褪色，而且应该和白色及浅色服装分开洗涤。同时还应当区别不同的棉类面料，如缎纹织物、提花织物及其他长浮线织物不宜用硬刷强力刷洗或在洗衣机中剧烈搅动，以免布面起毛；卡其、华达呢、哔叽等斜纹织物可以在平整的板面上顺织纹刷洗。 多数棉类服装机洗时，水的温度应该在30～50℃，开机搅洗10min。比较薄的衣服适合手洗，白色衣物可用碱性稍强的洗涤剂，有色衣物可用碱性稍小的洗涤剂，彩棉则用中性洗涤剂。除白色外，各种染色的棉类服装不应在阳光下暴晒，最好反面朝外在阴凉处阴干，以防止褪色。 麻类服装 麻类服装的洗涤与晾晒方法与棉服大致相同。但麻纤维较硬脆，不能剧烈揉搓，更不能用硬刷刷洗，也不要用力拧绞，以免麻纤维断裂、服装起毛，影响服装外观、缩短寿命。如果面料上含有硬挺剂、着色剂或黏合剂，洗涤温度应低于40℃。经过树脂整理的衣领（硬领），可用板刷或小毛刷蘸些肥皂或洗衣粉轻轻刷洗，切不可用力揉搓。 真丝服装 真丝服装比较娇嫩，对薄型高级服装和起绒服装最好干洗，一般的真丝服装手洗比机洗更好，因为后者易使真丝绸受损。手工洗涤时，需注意以下五点。 洗前浸泡时间不宜过长，3～5min或再长些，不能用力过猛，切忌拧绞。 宜手工大把地轻轻揉洗，对较脏的部位，把衣服平铺后，用软毛刷蘸洗涤液按绸面纹路轻轻刷洗，不宜用搓板和硬刷。 最好用中性、较高级的洗衣粉或洗涤剂，以保护真丝绸所特有的独特天然光泽，如用皂片，浓度可低些。 宜用微温或冷水洗涤，以防褪色。 如用肥皂或碱性洗衣粉洗涤，洗涤后，在清水中投洗3、4次后，要放入含有醋酸的冷水内浸泡2～3min，以中和衣服内残存的碱液。即使用中性洗衣粉，在最后清洗液中也可放少量醋酸，这样既对服装有保护作用，又能改善服装的光泽。 真丝绸服装洗后在阴凉处晾干，千万不要暴晒，也不要在露天过夜，以免褪色。 毛料服装 高级呢绒服装必须干洗，对一般呢绒服装来说，也是干洗优于水洗。 呢绒服装如沾污过多、过久，不但不易洗净，而且强力下降，因此，呢绒服装不宜穿得太脏再洗，以免损坏服装。 黏胶纤维服装 黏胶纤维湿强度差，因此，在洗液中浸泡时间要短，宜随浸随洗。白色或色牢度好的用70℃水洗，色牢度差的可用40℃或50℃水洗。洗涤时，最好手洗，不可剧烈揉搓，可大把轻轻揉洗，防止织物起毛。洗净后，把衣服叠起来，大把地挤掉水分或用毛巾包卷好，将水压出，切勿拧绞。黏胶纤维服装不耐晒，洗后宜阴干。 近年，许多再生纤维素纤维的服装洗涤方式与黏胶纤维服装相似，如竹浆黏胶纤维湿态强度较低，要防止湿态下被洗坏；莫代尔纤维服装洗涤时易发毛，故应避免用力摩擦。 涤纶服装 机织涤纶织物可机洗，但洗涤时间、甩干时间要短。洗涤温度不宜超过70℃，因为合纤的耐热性较差，在高温下会收缩、软化。无论机洗、手洗，不要剧烈揉搓，以防纤维磨毛而产生小球。 针织涤纶服装适合手工洗涤。浸泡片刻后，宜用碱性小的皂液或高级洗衣粉洗涤，揉搓要轻，清水漂洗后挤压掉水分，不要拧绞。在通风处挂晾，不要在阳光下暴晒，以防止变色或泛黄。洗涤后，无需熨烫。 锦纶服装 普通锦纶机织服装可机洗，但须以线脚不易滑出为前提。洗涤、出水、甩干时间要短，以防起皱。除白色服装可用70℃水洗外，一般洗涤温度为40～50℃。白色 服装经多次洗涤和穿着后，可能带灰色，可用过硼酸钠漂白。 锦纶轻薄服装和针织服装（如锦纶弹力衫），因机洗容易擦伤，宜手工洗。在低温洗涤液中轻揉，切忌重擦硬刷，洗涤和清洗时不可拎涮。出水后用干浴巾将服装包卷好，挤除水分后在通风处晾干。勿拧绞，以免留皱；勿带水晾挂，以防服装变形。 腈纶服装 腈纶的耐磨性和弹性都不如纯毛和毛/涤服装，洗涤时，宜先在冷水中浸泡10min，然后在低温（30℃）洗涤剂或中性洗液中轻轻揉洗，忌高温和用力搓擦。洗时不要随便拉抻和拎涮，以免变形；洗后，用干浴巾包卷好，挤除水分后在通风处晾干。 维纶服装 维纶服装的洗涤方法与棉制服装大致相同，但要避免用碱性强的肥皂，刷洗也不宜过重，以防起毛。可在30～50℃水温下机洗。手工洗涤时，不能用热水浸泡。洗后以阴干为好。 氯纶、丙纶服装 这两种服装洗涤时应在微温或冷水中进行。可采用中性洗衣粉大把地轻揉，切忌用力洗刷，以防服装起球。洗净出水后不加拧绞，压水或脱水后阴干。 羽绒服 如个别部位污迹较重，可先用软布蘸汽油轻擦后，将服装浸泡在温水冲调的洗衣粉（或皂片）溶液中。浸透后，用软毛刷刷去污迹，再用清水漂洗数次。然后，摊平在桌面上，垫上干毛巾挤压水分，再用衣架晾在阴凉处，晾干后在阳光下小晒。干后，用小棍轻轻拍打，使羽绒蓬松。 仿毛皮服装 仿毛皮服装的底布大多是棉纱，绒毛是腈纶、涤纶或锦纶等，有长绒和短绒两种。其洗涤方法是：先在冷水中浸泡10min，再在40℃中性洗液中大把揉洗，边浸边洗，洗涤时间不超过10min， 切忌用硬板刷。短绒服装用软毛刷顺序刷洗，洗净后晾干，再用干毛刷将倒伏的绒毛轻轻刷起。长绒服装晾至半干时，取下抖动几分钟，使绒毛松散后继续晾干。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:3:1","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"3.2 干洗 干洗又称化学清洗，是用各种化学溶剂，如三氯乙烯、四氯化碳、丙酮、汽油、松节油等，去除服装上的油腻、树脂或油漆等污渍。通常以三氯乙烯、四氯化碳应用最普遍。 用上述化学溶剂干洗服装时，不仅能溶解油脂、树脂或油漆等，同时，还会将与这些油脂结合在一起的污垢，随着溶剂的挥发从织物上除去。而且，干洗的服装不变形，快干，织物的牢度不受影响，不掉色，也不会产生缩水问题。 干洗的不足之处是洗净力较差。油脂性污垢可以溶洗除掉，而水溶性污垢却不易全部洗去；脱脂时并不脱色，因而白色服装难以获得纯白效果；溶剂有一定的毒性，价格较贵，易燃，需防火。 干洗方法 毛料西服的干洗：在干洗前，先通风晾晒，然后用毛刷轻轻拍打，使服装中的尘埃脱落，再用毛刷从上往下轻轻地刷。接着用毛刷或毛巾蘸少量汽油将呢面顺序擦洗一遍，沾污严重的部位多刷几下。也可以用三分汽油、七分清水搅匀，将毛巾浸湿后拧干。把西服一面铺在桌面上，上面铺毛巾，然后用熨斗均匀地推压。因为湿毛巾含有汽油，用熨斗一烫，西服上的污物就可蒸发消失。干洗一面后，再干洗另一面。最后，再将西服熨烫一次，把西服吸进的水分完全烫干，就可得到干净、平整的西服。 羽绒服的干洗：干洗前通风晾晒。然后，用软刷刷去表面尘埃。再把羽绒服平铺在干净的桌面上，将毛巾蘸上汽油并用力拧绞几下，再顺序均勻地将服装擦洗两遍。待汽油完全挥发再穿用或收藏。较脏的羽绒服还是以水洗为宜。 毛皮服装的干洗：洗前认真检查皮板，如有破损应用棉线缝好，再用刷子蘸一些酒精或汽油，将毛绒顺序均匀地刷洗，脏的地方可以刷重一些。然后把黄米面（黄米用水泡一昼夜，捞出碾碎，用少许水湿润使之发潮）、白面或滑石粉撒在毛面上，用双手均匀地把它揉到毛内。稍用力拨动毛被，直到毛干、面干。然后，抖动数次，使黄米面脱落，再晾在通风处（不要暴晒），待干燥后，抖净面粉。 皮革服装的干洗：先用一块干净的、不掉色的布蘸湿，擦去皮革表面上的污物，在油污处滴上几滴以1：1：1.5的配比，将氨水、酒精和水共混配制而成的去油污剂，再用湿布擦洗，切忌用汽油、苯类和酯类等有机溶剂，因为有机溶剂会吸去皮革表面的油脂而降低皮革柔韧性，使革面丧失滋润感，变得粗糙、硬化。如发现皮面有小裂纹， 可涂上少量鸡蛋清（不要蛋黄）即可弥合。如发现皮面脱色，可刷上服装或面料染色用的直接染料。以深棕色皮革服装为例，染料配比为：直接黑染料0.2份，直接深棕染料0.8份，水20份调匀。用毛笔蘸涂在脱色的皮面上，晾干后如发现遗留的脱色，可再用上法涂饰。 丝绒服装的干洗：先晾干，并用软毛刷刷去灰尘，再放入汽油内大把轻轻揉捏。脏处多重复几遍。洗净后，挤去汽油，用干净的浴巾包好挤压，打开后抖动几次，再晾干。 总之，湿洗和干洗两种洗涤方法的适用范围不同。油性污渍能溶解在干洗溶剂中，不能溶解在水中；而灰尘能溶解在水中，不能溶解在油性溶剂中。因此，对油性污渍最好选用干洗，而水溶性污渍则适合湿洗。从洗涤效果来说，干洗的效果不如湿洗。而干洗对服装的收缩变形及褪色影响小，又因采用特殊的有机溶剂成本较高，适于高档服装如毛料西服、真丝礼服的洗涤。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:3:2","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"3.3 特殊污渍 在日常生活中，人们穿着的服装难免会沾上各种污渍，有些污渍用一般洗涤剂难以洗净，需视污渍种类采用特殊的清洗方法。有时对某种服装面料行之有效的除渍方法，未必适用于另一些类型的服装面料，甚至可能使织物受损，处理不当，不仅会影响服装的色泽和美观，而且有可能使面料受损，降低使用寿命。除渍的原则如下： 服装一旦沾上污渍，要及时去除，时间一长，污渍会渗透到纤维内部，与纤维紧密结合，难以去除。 要先搞清污渍种类，才能考虑采用何种除渍方法，否则会使污渍更难除尽。 某些除渍剂对部分纤维或某些色泽有损，去污渍前还要弄清服装所用纤维成分。如果一时无法弄清，可以先在不显眼的褶缝处试一下，观察纤维和色泽是否受损。 用小刷刷洗时要巧刷，由污渍边缘往中心刷，避免留下色圈。切忌用力过猛使面料起毛。硬性污渍须软化后再刷。 在未了解污渍种类前不宜用热水浸泡，有些污渍受热会凝固在服装上，更难以洗除。 多数除渍剂对污渍有一定的作用时间，要多次少用，不要一次多用。在用两种除渍剂时，应把第一种洗净后再用第二种。 草酸有毒性，浓度高时还有损面料。因此，使用浓度不宜过高，在服装上擦洗后，要及时去除酸液。高锰酸钾是强氧化剂，会破坏某些色泽，使用前可先在衣服边角做试验，确定其不褪色时再用。 使用汽油、松节油、酒精等时切勿近火。 一般将沾渍面朝 下，放在软布或吸水纸的衬垫上，在织物反面加滴除渍剂，使污渍不致穿透衣服，必要时再用软布沾除渍剂轻揩，尽量不作搓擦，以免产生“极光”。 污渍去除后，务必清洗服装，勿使除渍剂残留在服装上。 常见污渍的去除方法用时到网上查。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:3:3","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"4. 保养 各种面料制成的服装，因原料性能不同，故对收藏有不同的要求。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:4:0","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"4.1 服装在保管中易发生的问题 棉、麻、毛、丝等天然纤维及其混纺品的服装，在使用保管过程中容易发生泛黄、脆化、发霉、虫蛀鼠咬等问题。 泛黄、脆化 泛黄指白色或浅色服装在储藏、流通或穿着过程中，因受日光、环境条件的影响或药品的作用而发生的带黄光的变化。造成服装泛黄的原因错综复杂，而且许多泛黄的原因会导致材料的脆化。如洗涤剂在服装上的残留，服装反复受日光、紫外线和干、湿热的影响，服装保管不当等，所有这些，都会引起服装泛黄脆化。易于泛黄的纤维依次为蚕丝、羊毛、锦纶、腈纶、氨纶以及棉和麻等纤维素纤维。另外，服装中因海绵、松紧带等附件泛黄而沾色或泛色的现象也时有发生。近年来，日本还发现，多数香水有促使服装泛黄的作用。 发霉 发霉是霉菌作用于含纤维素或蛋白质纤维的服装，使纤维遭受破坏的结果。霉菌的生长繁殖，需要适当的温度和湿度。服装保存时温、湿度过高，又没洗干净，就容易引起发霉。 虫蛀鼠咬 含天然纤维的服装，因含有纤维素、蛋白质营养物质，是某些虫类的良好食料，如保管时采用不完善的容器或保管方法不妥，容易遭到虫蛀、鼠咬。一般来说，合纤服装是不霉不蛀的，但在合纤的制造、染整、加工过程中，往往加有某种添加剂，如增塑剂、油剂、浆料、色素等，因而在一定的湿热环境下，也会引起轻度发霉。有时，蛀虫为了穿行通过或饥不择食，也会把合纤服装咬坏。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:4:1","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["我所热爱的生活啊"],"content":"4.2 服装的收藏 服装保管 外衣穿后应轻刷，除去浮土，并挂在通风处去除水分。针织品不宜挂藏，以防变形。 从洗衣店取回的服装，不要马上收藏起来，要在通风处晾干，使残留的干洗剂充分挥发，然后收藏。 存放服装的房间，湿度要低，温湿度变化要小，选择避免日光直射且通风良好的场所。 在保管洒过香水的服装时，必须将香水味散发去除。 切勿收藏未经清洗的脏衣。服装不宜靠近家庭中的暖气或炉子，并应尽量放在暗处。 各类服装存放方法 棉、麻服装：存放时，衣服须洗净、晒干、折平，衣柜、箱要保持清洁干净，防止霉变。白色服装与深色服装最好分开存放，防止沾色或泛黄。 真丝服装：收藏时，为防潮防尘，要在服装外盖一层棉布或把真丝服装包好。白色服装不能放在樟木箱内，也不能放樟脑丸，否则易泛黄。 呢绒服装：呢绒服装穿着一段时间后，要晾晒拍打，去除灰尘。不穿时放在干燥处。存放前，应刷洗或洗净、烫平、晒干，通风晾放一天。高档呢绒服装最好挂在衣柜内，勿叠压，以免变形影响外观。存放全毛或混纺服装时，用薄纸将樟脑丸包好，放在衣服口袋里或衣柜、箱子内。 化纤服装：有些化纤服装不宜长期吊挂在衣柜内，这样会使其悬垂伸长。在存放含天然纤维的混纺服装时，可放少量樟脑丸或去虫剂，但不要使其直接接触服装，因为这些药剂会使化纤溶胀而降低强度，甚至使服装遭到损坏。 毛皮服装：如果收藏不当，毛皮服装容易出现虫蛀、脱毛、绒毛并结或 皮板硬化等现象，保存时应注意： 收藏前挑一个好天气进行晾晒。高档名贵的紫貂、黄狼皮、水貂皮、狐狸皮等大衣，晒时外面要罩上一层白布，利用早上的阳光晒1h即可；兔皮、狗皮、猫皮等大衣晒的时间可适当长些（2～3h）。 晾晒后的毛皮服装，可用竹片或藤条轻轻拍打，除去毛上的尘埃；但对卷毛的毛皮如羔羊皮、滩羊皮等，只能用手拍打或用抖动的方法来松毛除尘。 晒后，要等毛皮服装的热量完全散尽后才能放进衣柜、箱内。存放时，最好用宽衣架挂起来，并在大衣袋内放入用纸包好的樟脑丸或樟脑精。如放在箱内，折叠时应将毛朝里平放，上面不要重压。特别是长毛绒服装，为防止绒毛倒伏，除吊挂外，宜放在箱子最上层。为防止感染污垢和虫菌，要与其他服装隔离单独存放。活里的毛皮服装要将面、里卸开，分别存放。 皮革服装：皮革由胶原纤维组成，经过穿用，难免会因吸湿受潮而发霉、生虫。皮革服装最好经常穿，并常用细绒布揩擦。如果遇到雨淋受潮或发生霉变，可用软干布擦去水渍或霉点。千万不要用水和汽油涂擦，因为水会使皮革变硬，汽油能使皮革的油分挥发而干裂。在穿着皮装时，要避免接触油污、酸性和碱性等物质。皮革服装不穿时，最好用衣架挂起来；当然也可以平放，但要放在其他衣物的上面，免得将其压瘪起皱，影响美观。收藏前要晾晒一下，时间宜在上午9～10时，下午3～4时，不能暴晒，中午阳光直射容易使皮革发热变色，还会使革中的油脂破坏，挂在阴凉干燥处通风即可。收藏时，为增加皮革的柔润度，可用布团在皮革表面薄薄地涂上一层皮革保护剂，然后储存。 ","date":"2019-12-08","objectID":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/:4:2","tags":["生活技能"],"title":"穿搭整理3-保养、收纳及旧衣处理","uri":"/2019/life-skills-9-maintenance-storage-and-disposal-of-used-clothes/"},{"categories":["研究生的区块链学习之路"],"content":"考虑到开题时老师给的意见和编写论文的需要，这里再分析一次场景，并选择一个合适的纳入实验。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:0:0","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"1. 场景 已有的该方向论文所使用的场景有：Smart home1 2、Healthcare3、Smart Factory4、Supply chain5 和 Smart lock6。如果根据场景来分类，各有各的不同，但如果根据信任关系来分类，Smart home、Smart Factory、Smart lock 都属于用户与生产厂商之间的冲突，Smart Factory 又可以和 Healthcare 一起归属传统的信任域，可能出现误操作或者人员间的信任问题，Supply chain 则涉及多方之间的信任。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:1:0","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 用户与生产厂商 Smart home、Smart factory 和 Smart lock 都涉及用户和生产厂商之间的信任问题，Smart device 产生的数据会回传给生产厂商的服务器，由厂商进行处理并提供具体的服务，用户对数据并没有完全的控制权，相关的协议仅靠用户协议规定，没有较强的约束力。 这三种中以 Smart home 最具代表性，2 中提到的架构图如下，其中涉及三种实体：IoT 设备、网关和服务器。设备有两种类型：智能手机、电视等可以通过 Wi-Fi 或 有线连接直接访问互联网，摄像头、温湿度传感器等只能通过蓝牙、Zigbee 等技术连接网关，由网关访问互联网。这两者是用户端的代表。服务器负责存储 IoT 设备产生的数据以及提供相应的服务，比如从传感器收集环境信息或发送操作命令给执行器。 Smart Factory 通常有自己的服务器，但不可避免地，会需要上传数据向设备厂商换取实时监控、维修等各种服务。而摄像头等设备，实际上并不局限于 Smart home，同样用于 Smart Factory、公共交通等各行各业，Smart Lock 除了用于酒店，当然也可以用在 Smart home，它们的界限并不那么清晰，但其共同点是：均属于 C/S 架构，有自己无法控制的数据。 Smart home 可扩展到 Smart building 场景，烟雾等火警传感器、电梯、电表、水表等，Smart building 涉及的设备和领域更多，也更具普适性。 这里举两个典型的实例。 第一个是摄像头。如今，很多家庭都选择在家里安装摄像头以提供防盗或其它功能，但是由于家用设备存储能力的不足，或者自身缺乏足够专业的能力进行远程访问，一般都是用设备厂商或第三方服务商提供的软件服务来存储摄录的内容及进行远程访问，监控的内容不可避免地需要上传到他们的服务器，近年来，第三方导致的监控内容泄露的情况频繁发生，用户缺乏对这些数据的控制能力的根本原因，另外，摄像头权限被非法获取也会造成隐私泄露及其它严重的安全问题。基于区块链对摄像头进行访问控制，可以令用户拥有对监控内容的完全控制能力，从而保证用户的隐私与安全。 第二个是智能门锁。这里指的是旅馆或公寓的短租房间的电子门锁（门锁作为一种 IoT 资源）。如果一个人想预定旅馆或公寓的房间几个晚上，可以从智能手机（客户端）向处理门锁授权请求的授权服务器（AS）发送请求，AS建立一个智能合约来接收预付款，一旦验证客户已支付，AS将向客户提供必要的凭据（数字钥匙或者称作访问令牌），在确定的时间内，客户可以通过利用手机通过蓝牙等通信手段发起请求，验证权限后可以打开门锁。尽管客户不具有智能门锁的所有权，但通过智能合约，仍然保证了自己的权益。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:1:1","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 传统信任域 如果说单个家庭属于绝对的信任域，那么工厂、医院、公司这种只能是相对的，即使不讨论跨国公司、位处多地的工厂和医院等情况，单个的工厂、医院、公司内也存在各种信任问题，不论有意还是无意，非法的操作是可能发生的。 以医院的资产管理3为例，考虑这样一件事：医院拥有大量的资产，比如外科手术器械，这些器械会在消毒部门、手术室、实验室等区域周期性的流动，器械位于错误的位置可能危及患者生命，缺乏详细的资产记录也可能造成资产损失。如下图，假设源房间（如灭菌室）将一些资产（如外科手术器械）运送到目的房间（如0号手术室、1号手术室）。由于 $Asset_1$ 已被分配到目的房间1（例如，1号手术室），假如由于人为错误试图访问目的房间0（例如，0号手术室），其访问将被拒绝。简而言之，这一系统的目的是建立医疗资产访问控制系统，防止由于人为错误或外部安全威胁导致资产进入错误区域（如房间）。 论文4 所提供的 Smart Factory 下的温度采集实例是一个相似的例子，下图中一个设备节点申请存储权限，温度计发出的数据存储请求由微型计算机代为处理，设备通过一个唯一ID标识，管理中心验证存储权限后，微型计算机将数据加入缓冲池，待数据量满足一定规模或者到达某个周期时间，加密后的温度数据就上传到数据库，数据哈希和相关交易记录存储到区块链中。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:1:2","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"1.3 供应链 论文5提出的木屋建造实例是一个供应链场景，主要由下图所示的几个关键流程组成 在收割阶段，传感器/执行器和其它低功耗设备将感知、收集和处理与原材料和收割过程相关的信息，这些信息将用于其它阶段。运输、制造和存储阶段的日志将会被其它阶段利用。分发阶段需要保证由正确的车辆通过正确的路线准时送达。整个过程涉及传感器/执行器、边缘设备/服务器、服务/网络提供者、其它第三方等多种角色，需要保证每个角色都只能访问需要访问的资源以及提供需要提供的必要信息。作者并没有给出一个具体的实验实例。 我们寻找了一个更加详细与具体的供应链实例说明7，是一个关于食品运输的例子，同时这里要说明的是，供应链是 IBM 区块链的一个主要场景，已投入使用，项目名为 IBM Food Trust 。如下图，假设一批香蕉从巴西里约热内卢附近的农场运往鹿特丹的超市配送中心。香蕉被打包放到托盘上，每个托盘都装有一个传感器节点。一大早，这些托盘就被卡车从农场运到港口的一个货运码头，在那里，托盘被装进集装箱，然后集装箱一路运到连锁超市的配送中心。在整个旅程中，香蕉的温度需要保持在10到15摄氏度之间，同时应该远离新鲜的咖啡豆等物品，因为这些东西产生的乙烯加速香蕉的成熟过程。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:1:3","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"2. 场景选择 我们选定 Smart home 中的摄像头用例、供应链中的易腐商品运输两个场景，来设计我们的实验。 摄像头场景设计如下，初始由厂商建立一个 4 节点的区块链网络（维持最小节点数），其中一个账户设定为管理账户，以该账户部署 MC 和 RC。购买了摄像头的用户注册一个账户为管理员账户，代表的设备可能是家用电脑或者智能手机，首先注册自身，节点类型为 Validator，然后为购买的每个摄像头建立普通节点账户，部署ACC 并注册到管理员账户下，每个家庭成员注册一个普通节点账户并关联自己的智能手机或个人电脑，注册到管理员账户下，ACC 合约地址为空。由家庭管理员为所有设备设定权限，涉及的访问操作包括 摄像头申请网络存储； 家庭成员申请查看录像（历史数据或实时数据）； 家庭成员申请开启或关闭摄像头； 厂商根据设备 MAC 和可用空间等决定是否授予写入数据权限，家庭成员则根据角色授予权限。 食品运输的场景设计如下，假设一批香蕉被采摘后打包装箱，贴好 RFID 标签/条形码，然后通过扫描枪和人工输入将采摘时间、采摘位置、所属农场、商品类型、重量、状态、采摘者、记录者等属性记录上链。这批香蕉已经被预定送往某个超市，且有一个大致的运输计划，包括这批货物在什么时间应当位于什么地点，被什么交通工具运输。早晨，这批香蕉被装运到货车上，装运时需要通过扫描枪扫描，然后通过货物ID查询相关信息与运输计划匹配，确保装运到了正确的货车上，同时采集并更新装运时间、装运地点、货物状态等信息。这批香蕉被送到港口的货运码头，卸货时在码头继续被扫描，更新卸货时间、地点、货物状态，确认到达了正确的码头，符合运输计划。紧接着，这批香蕉又被装入集装箱，相关的信息随之更新，当货物到达超市后，更新状态并确认目的地。 整个过程中发生的访问控制包括，一开始管理者根据运输计划设置访问控制策略，确保途中涉及的所有实体，包括运输的货车、港口、集装箱、超市等在规定的时间或位置有权访问这批香蕉的相关信息，在运输过程的每个阶段，这些实体扫描 RFID 标签/条形码时都会同步发起访问请求，只有符合要求的实体才能获得相关信息并更新当前环境属性。诸如购买订单、交付记录以及其它的法律文档或相关协定，不希望被第三方访问的，可以使用 Quorum 的私有交易功能，保证只被交易双方看到。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:2:0","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"关于访问操作的说明 谈到访问控制，指的是什么样的操作，我们通常所谈及的，是对传感器数据的访问和对执行器的控制。Dorri 的论文1是该基于区块链完成物联网访问控制领域起始的几篇论文之一，也是引用最多的论文之一，他的应用场景是 Smart home。在这篇论文中，他将对数据的操作分为了如下三类 首先是存储数据。每个设备都有数据存储的需求，以一个智能恒温器为例，假设 Alice 在云中有一个账户并设置了上传数据的权限，当恒温器有存储数据的请求时，需要首先将数据发送到本地矿工，矿工根据已定义的策略对恒温器的权限进行验证，验证通过后将数据、数据哈希一起发送到云存储，云存储检查是否有剩余空间并匹配数据哈希，在存储完成后，将数据 Hash 和区块号返回，相关的交易收集到区块链中。 然后是访问数据。服务提供者可能需要周期性的访问存储的数据或某个设备的全部数据，请求交易经过 Smart home 的矿工验证权限后，矿工从存储中获取数据，最后用请求者的公钥加密数据后将数据发给请求者。 最后是监控数据。某些时候，智能家庭的所有者可能需要实时地访问家里某些设备的信息，比如恒温器当前配置。矿工收到用户请求后，验证用户权限然后返回设备的实时数据。 我们应当证明我们所实现的系统能够完成这些操作，不过实际的测试需要添加存储系统比如 IPFS，然后编写一个存储合约与现有系统关联，由于涉及的东西比较多，可以作为下一步的工作。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:2:1","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"3. 供应链场景分析 这部分是 2020.09.09 写的，位于中期答辩以前，主要是以 IBM 的一个项目：IBM Food Trust 为参考，进一步分析供应链（更具体一点是食物供应链）场景，指出区块链的作用和我们工作的必要性。 需要说明的是，这部分场景可以用于论文中的实验说明及答辩的时候向老师们介绍，但实际上，设计系统的时候并没有严格和场景相关，理论上只要物联网和区块链可结合的场景都适用。所以，Introduction 从供应链的角度分析可以，从传统访问控制系统的问题这一角度分析也可以。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:3:0","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 供应链的问题 对消费者而言， 当前购买商品消费者的选择不断增多，导致品牌效应明显，消费者更倾向选择听过的品牌。另外，由于环保意识和可持续发展意识的形成，市场环境的恶化，当前消费者购买商品不仅想知道营养成分，还想知道如何种植、如何制作以及经历了哪些运输过程到达消费者手中的，对这一系列过程的透明化有助于消费者形成对品牌安全和质量的信心，培养用户忠诚度。 对于整个供应链整个上下游 ，包括生产商、加工方、运输公司、零售商等，参与者众多，各企业数字化程度不一致，协作与交接不密切，交接甚至有时候还在使用纸质文件，产生的问题包括 效率低下，整个过程发生产品损失、交付延期的概率增加，碳足迹也大幅增加，尤其是对于时间要求较高的食品而言，还会影响食品的新鲜程度，甚至造成食物浪费，其它商品类似； 发生食品安全问题时，在整个供应链中寻找发生问题的地方要花费大量的时间； 过程不透明，某些环节黑箱运作，是食品腐败和欺诈产生的重要原因之一。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:3:1","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 区块链的作用 依赖行业龙头企业或政府建立一个统一的平台是行不通的，供应链各参与者之间的信任难以达成，区块链的主要作用就是利用透明、不可篡改的特性提供信任，并通过智能合约尽量实现自动化，从而提高效率。具体的好处可以总结如下 所有参与者实时的知道货物来源、位置、状态，整个过程完全透明，消费者更放心，便于建立品牌信任； 知道所有的信息还便于保证产品质量，以及发现问题时快速确认责任方，以及消除欺诈风险； 便于供应链参与者根据货物情况建立更好的供需模型； 自动化的处理和即时的同步可以提升效率，减少运输成本和浪费，从而节省成本。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:3:2","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 访问控制系统 对于权限的控制是一个两级的机制。 首先，使用联盟链，企业想要加入需要得到监管委员会的认可。 其次，使用访问控制系统，保证每条供应链的隔离，确保数据只能被该条供应链的参与者看到。我们可以理解，一个访问控制系统是必不可少的，而且是核心功能。 另外，还使用隐私合约和隐私交易机制，进一步保证隐私，因为区块链本身是完全透明的。 为了应对物联网复杂的环境，我们决定实现一个基于属性的访问控制系统来完成细粒度的访问控制，要解决的问题包括 应该包含什么样的功能； 以什么样的架构来组织这些功能 对于问题1，核心的功能应该包括：用户及设备的管理、属性的管理、策略的管理及核心的访问控制逻辑。这里的管理包括增删查改四个基本功能。 对于问题2，我们参考了其它的论文，并做了一定的改动，具体查看前面的系列文章，有详细的思考和设计的过程。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:3:3","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"4. 未来工作 基于属性的访问控制引入了对海量属性和策略的维护问题，如何自动化的根据设备实时状态更新这些信息，可以是下一步研究的问题（比如预言机）； 物联网设备数量和通信活动的频繁，必然导致数据的快速增长，考虑区块链存储数据的昂贵，必须考虑如何解决这一点，可以考虑两种方案 使用分布式存储系统将数据存储在链下，虽然损失了区块链的安全性； 由于大量的数据具有时效性，可以考虑对这些数据进行压缩； 注意，这些工作是在恶意行为检测部分完成后可以继续进行的工作，我们书写本篇文章这部分内容时，恶意行为检测部分已经接近完成。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:4:0","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"5. 背景再分析 Blockchain, IoT, Access Control 是核心的三个关键词。该领域的研究中，大部分论文介绍背景从 IoT+Access Control 起步，介绍区块链能带来的好处，少部分从 Blockchain+IoT 起步，介绍访问控制对场景的必要性，事实上，我们研一开始的研究路径就是这样，先考虑 Blockchain 用于 IoT 有哪些好处，然后才选择了 Acccess Control 子方向。 前者可以参考之前写好的论文，或者该博客的另外一篇文章 区块链用于物联网访问控制；后者可以参考 IBM Food Trust 项目的介绍，或者查看本系列上一篇文章 实验场景的分析与选择 的第三部分。 无论从哪一个角度，亦或者从更直观的现象看（该方向论文超过 200 篇），都能得出一个结论：这三者的结合是必要的，至少是益处更多的。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:5:0","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"5.1 结合方式 我们之前遵循的分类是史锦山等在一篇综述8中提出的，该论文将这三种的结合分为两类： 区块链与已有的物联网访问控制模型结合，区块链充当可信实体； 新的完全基于区块链的物联网访问控制模型，该分类又包括两种 基于区块链交易或脚本机制实现的访问控制 基于智能合约实现的访问控制 然而我们在研究中逐渐意识到，第二种并不能作为一个单独的分类。基于区块链交易或脚本实现的访问控制本质是基于 token 在区块链中的实现，基于智能合约实现的访问控制，多数依然采用了传统 ACL、RBAC、ABAC、UCON、CapBAC 等的思想，仅仅是利用智能合约重新做了实现，是实现手段的变更，实现的手段从传统的 XACML、UMA 等变到了智能合约，只不过这种实现手段附带了区块链的优点。因此研究者们所做的工作，是探索传统访问控制思想与现有实现手段（区块链、智能合约）之间的高效结合方式，探索如何充分利用区块链的优点，以及尽可能消除区块链所引入的困难。 明白这一点对我们主要有如下帮助 区块链和传统访问控制模型的简单结合并不能看作一个创新型的工作，即不能在用智能合约实现了 UCON 模型就声称自己提出了一种新的方案，重点在于你的结合和其它结合的区别，如何更高效的利用了区块链的优点，或者如何更有力的消除了区块链的缺点； 如果之前没有人在区块链中实现传统访问控制模型，而你做了，可以算创新，因为要真正实现这一点需要做很多的工作（尤其是没有前人的经验借鉴是比较难的），但是这一点现在基本不太可能，因为传统模型只有几种，现在基本都有了区块链的实现； 大家所做的更多的是系统设计性的工作，而非算法改进，因为采用一种新的手段实现已有模型很少涉及算法，更多的是通过合约结构或合约功能的某种设计和实现，做了一定的优化； 应当充分吸收传统访问控制的优点。传统访问控制经历了多年的发展，在某些实现细节上有很多值得借鉴的设计，当换了一种新的实现手段，这些设计都可以移用过来。目前该方向的研究者大部分都是从区块链入手，考虑访问控制的实现，少有专业的访问控制方向的研究者转向区块链的实现，因此大部分的方案在功能完整性方面甚至都存在一定的不足，无法做全局的考虑。 下一小节我们描述区块链这种手段为物联网访问控制带来的优点和引入的困难，这将是我们进行方案优化和性能评估的凭借。 ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:5:1","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["研究生的区块链学习之路"],"content":"5.2 好处和困难 区块链的引入解决的核心问题是信任。链式结构和共识算法带来的不可篡改、透明、便于审计等特性，从而提高了系统的安全性，最终帮助我们搭建了协作实体之间的信任关系。基于这种信任关系，我们可以搭建一个统一的平台，从而又带来效率的提高。 安全性又包含两个方面，一个是系统运行过程中对各种攻击的抵御，这是现有物联网系统急缺的能力，这部分的研究主要就是区块链能抵御哪些攻击，添加某些设计又可以抵御哪些新的攻击，逐步完善它的能力；另一个是系统出问题后快速追查出问题的地方，这一点从供应链角度更好理解，建立了统一的平台后，各参与者直接的交接完全数字化和透明，减少了欺诈风险，同时由于数字记录不可篡改，出现问题时可以快速追查到出问题的环节。 区块链还引入了两个优点：自动化和分布式。自动化是智能合约带来的，基于智能合约图灵完备的能力提高各参与者之间的交接效率，推进数字化进程；分布式是区块链的实现方式带来的，解决了传统集中式方案的单点故障问题。尽管这两个优点是解决信任问题附带的产物，但如果充分利用这两个优点，同样可以是我们考虑的问题。 区块链带来的困难包括 实时性。某些场景下可能对实时性有一定的要求，但是，一个合法的交易在区块链中得到确认，需要经历被收集到区块、广播到区块链网络、经由大多数节点验证等过程，与传统方案相比，区块链方案显然有一定的差距； 吞吐量。同样的原因，区块链的吞吐量相比于传统方案有一定的差距，但影响吞吐量的决定性因素是区块链平台和共识算法的选择，架构设计产生的影响不大； IoT 设备的资源（能力）限制。运行共识算法需要一定的计算能力，不是所有的 IoT 设备都有这样的能力； IoT 环境的异构性。IoT 设备种类、软件平台、网络环境等千差万别，不是所有 IoT 设备都可以实用区块链客户端，并且可以实时地持续接入区块链网络； 区块链存储的昂贵性。在区块链中存储大量数据会导致区块链快速增长，对成员节点设备的存储性能是一个考验，因此应当尽量避免这一点； 成本问题。例如 Ethereum 中部署合约及与合约交互都需要以太币，更少的 Gas 消耗保证了更低的成本。 我们的解决思路 实时性和吞吐量：平台和共识选择； 设备资源限制和环境异构性：分层管理； 存储问题：调整合约架构 A. Dorri, S. S. Kanhere, and R. Jurdak, “Blockchain in internet of things: Challenges and Solutions,” arXiv:1608.05187 [cs], Aug. 2016. Available: http://arxiv.org/abs/1608.05187. ↩︎ P. Wang, Y. Yue, W. Sun, and J. Liu, “An Attribute-Based Distributed Access Control for Blockchain-enabled IoT,” in 2019 International Conference on WiMob, Barcelona, Spain, Oct. 2019, pp. 1–6, doi: 10.1109/WiMOB.2019.8923232. ↩︎ Figueroa, Añorga, and Arrizabalaga, An Attribute-Based Access Control Model in RFID Systems Based on Blockchain Decentralized Applications for Healthcare Environments, Computers, vol. 8, no. 3, p. 57, Jul. 2019, doi: 10.3390/computers8030057. ↩︎ J. Wan, J. Li, M. Imran, D. Li, and Fazal-e-Amin, “A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory,” IEEE Trans. Ind. Inf., vol. 15, no. 6, pp. 3652–3660, Jun. 2019, doi: 10.1109/TII.2019.2894573. ↩︎ T. Kumar, A. Braeken, V. Ramani, I. Ahmad, E. Harjula, and M. Ylianttila, “SEC-BlockEdge: Security Threats in Blockchain-Edge based Industrial IoT Networks,” presented at the 2019 11th International Workshop on RNDM, Nicosia, Cyprus, Oct. 2019, p. 7. ↩︎ V. A. Siris, D. Dimopoulos, N. Fotiou, S. Voulgaris, and G. C. Polyzos, “Trusted D2D-Based IoT Resource Access Using Smart Contracts,” in 2019 IEEE 20th International Symposium on WoWMoM, Washington, DC, USA, Jun. 2019, pp. 1–9, [Online]. Available: https://ieeexplore.ieee.org/document/8793041/. ↩︎ L. Evers and P. Havinga, “Supply Chain Management Automation using Wireless Sensor Networks,” in 2007 IEEE Internatonal Conference on Mobile Adhoc and Sensor Systems, Pisa, Italy, Oct. 2007, pp. 1–3, doi: 10.1109/MOBHOC.2007.4428689. ↩︎ 史锦山,李茹,等.物联网下的区块链访问控制综述J.软件学报,2019,Vol.30Issue(6):1632–1648. ↩︎ ","date":"2019-12-06","objectID":"/2019/analysis-and-selection-of-experimental-scenes/:5:2","tags":["科研记录"],"title":"研究记录10-实验场景的分析与选择","uri":"/2019/analysis-and-selection-of-experimental-scenes/"},{"categories":["我所热爱的生活啊"],"content":"穿搭的风格有很多种，我还是喜欢简约自然一点的，而且最重要的是，是我在穿衣服，不是衣服在挑我，为什么要被风格什么的限制住呢。最近看的一本书里有一句话我觉得很有道理，想象你穿着这件衣服去做什么事、去见什么人、说什么话、会不会大笑、行走坐卧，我觉得这才是购买和搭配的时候考虑的。这篇文章里只是记录一些搭配的基本原则和购买的一些技巧。 注：色彩搭配部分主要摘自公众号 女朋友教你穿衣服 和 公众号 思南的时尚笔记，购买的价格范围主要是询问父母。 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:0:0","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"1. 服装颜色搭配 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:1:0","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"1.1 色彩基础 服饰色彩的基础部分，从色相、明度、纯度开始。简单来说，每个颜色都是由不同的色相、纯度以及明度三部分构成的。 色相，决定是什么颜色 纯度，是指色彩的鲜艳程度，也称之为饱和度 明度，是指色彩的明暗，加入黑白可以改变色彩的明度 举个例子，红色掺入白色会变粉红色，纯度下降明度上升。加入黑色，纯度下降明度也下降，成为深红色。 这里要注意的是，明度和纯度比较高的颜色都比较吸引人，普通人很难驾驭，一不小心就是体育老师，所以色彩搭配的第一个原则是：尽量选择明度和纯度低的颜色。 除此之外，色彩还有冷暖的区别，冷暖强调的是给人的感觉，而且所有颜色都有冷暖之分，像白色，就有象牙白（暖色）和纯白（冷色）。 第二个原则：根据肤色挑选冷暖色。人的肤色也有冷暖之分，最常用的辨别方法是看血管颜色，观察手腕内侧静脉的颜色，如果静脉呈蓝色或紫色，那么肤色就是冷色调 如果静脉呈绿色，那么肤色就是暖色调 当然还有更直接的方法，那就是在自然光下把手放到下面的图片上做对比，手放在橙色上显得暗沉，就是冷色调皮肤，放在粉色上显得暗沉是暖色调皮肤，两边差距都不大难以识别的是中性色调皮肤。 大致判断的话，我自己的肤色属于黑暖色（秋季型），适合暖色饱和度高的色彩，比如驼色、牡蛎色、棕色等作为底色，要尽量选择明度和纯度较小的颜色，而且越温暖浓郁的颜色越能衬托秋季型人的成熟气质，推荐在相同色系或相邻色系中进行浓淡搭配。 确定了皮肤色调后，下面是适合不同色调皮肤的颜色 下面是两个例子，其中，鹿晗是冷色调，胡歌是暖色调 不过，根据皮肤色调选颜色并不绝对，只要让自己穿的看起来舒服就行了。 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:1:1","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"1.2 基础色搭配 黑白灰是基础颜色，也是一般人的常用颜色。 这里首先介绍第三个原则：下装要比上装的颜色深（上浅下深）。所以一般没有人会穿纯白的裤子，更多的都是黑裤子白上衣、黑裤子灰上衣或者灰裤子白上衣。 如果是同一种颜色，那么就掺一点其它颜色做调和，如下图，或者使用同一色系不同颜色，这就涉及到了之后要介绍的颜色的过渡与呼应。 基础色是不吃颜值的，比如郭德纲这种使用基础色搭配看起来也会很舒服 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:1:2","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"1.3 基础色加一种颜色 全身的颜色最好保持在2-3中，因此脱离黑白灰的简单搭配时，先只加一种颜色比较容易 当出现多种颜色时，尤其是秋冬季穿的衣服较多，出现了层次，一般遵循内浅外深的原则。 再比如蓝白黑的搭配 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:1:3","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"1.4 色彩的过渡和呼应 这里主要指的是四种搭配方式：同类色搭配，邻近色搭配，对比色搭配以及互补色搭配。 将色相以环的形式表示，如下面的十二色相环（可以按常规的红橙黄绿蓝紫），同类色是指同一色相环中相距30度以内的任两种颜色；邻近色是指同一色相环中相距60度以内的任两种颜色；对比色是指在色相环上相距120度到180度的两种颜色；互补色是每一个颜色对面，也就是相距180度的颜色。 色彩的过渡 色彩的过渡一般指的是同类色或邻近色，从上到下由浅到深的过渡，视觉上没有太大的变化，给人的感觉就会比较舒服。 同类色的过渡如下面的浅蓝到深蓝和浅灰到深灰 下面举一个反例，全身用了同一种颜色，看起来就很不舒服，不如下半身深蓝，上半身浅蓝，这样虽然是同一种颜色，但有了变化，有了过渡，就会好很多。 邻近色的过渡可以考虑下面这种，黄绿或绿蓝的过渡 当采用对比色或互补色时，可以在两种颜色之间有一小块中间的颜色用来过渡，也可以起到缓冲颜色的冲击力。比如下图，左边衬衫的灰色作为黑白的过渡，右边衬衫的白色作为黑灰的过渡。 色彩的呼应 色彩的呼应指的是不同部位的两种相同的颜色，视觉上起到一种相互呼应的作用，也可以给人舒服的感觉。比如下图中的 T恤和鞋子、帽子和短裤，处于身体的不同位置，不连成一块，但是由于用了同一种颜色，看起来就很舒服。 上衣和鞋呼应、帽子和裤子呼应是很常用的手法，其它一些的呼应手法还包括手表的表带和鞋、背包和裤子、围巾和裤子、上身和袜子、配饰和袜子等等。比如下图，就是用公文包和鞋子呼应 下面的图是一种综合应用，上半身和下半身是同一种颜色，但由于有了衬衣的白色过渡，没有了不适感，同时，外套和鞋子颜色呼应，且它们和包的棕色深浅过渡，都比较舒服。 更复杂一些，仍以上面的颜色过渡的图为例，左边卫衣和鞋子以白色呼应，右边露出的衬衣和鞋子呼应。 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:1:4","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"1.5 色彩的对比 指的是使用对比色时，由于对比色搭配有强烈的视觉冲击，要注意颜色搭配的层次，否则应选择低明度的颜色混搭，这种方法通常很难驾驭，而且最重要的是分清主次。 蓝色与红色（色相比较正时，其中一个作为配色） ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:1:5","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"2. 服装搭配的其它原则 选择服饰时，简单最重要，简单的含义包括基本款、清新自然、有清爽感和款式简洁，基本款的选择思路有 简洁的无图案款 易于搭配的纯色服饰 不带冗余装饰(如刺绣)的服装 版型比装饰重要，版型的含义简单理解就是看起来是否合适，最重要的一个评判标准是尺码，不同的衣服品牌可能略有区别，所以买衣服要多试，看手腕的包裹、袖子的长度、衣摆的长度、裤脚的长度、肩部是否合适等，一定要选择合适的尺码，如果有些地方不合适，可适当要求进行剪裁，一般卖衣服周围或服装店本身都提供裁剪服务。 衣摆长度通常应该在手腕部分，可以突出腰线，尤其是对于亚洲人这种典型的上下五五分的身材，明确腰线及尽量提高是很重要的。 丢比买重要，质胜于量，下面几种服饰可以处理掉 款式不够简洁的衣服 尺寸不合适的衣服 拉链不好用的衣服 已经穿旧的衣服 两三年没穿过的衣服 一定要持有客观性的立场，衣服不是只给自己穿的，也是给别人看的，要始终考虑希望自己给周围的人留下什么样的印象 选择店铺可以遵循下面的原则 有大量的基本款供选择 店员不会过于强势，能够轻松试穿 对店员所穿的服装抱有好感 服装的颜色尽量选黑、白、灰、藏青、浅驼、浅蓝、深棕，点缀色可以是紫色、湖蓝、橙色和浅粉色，要选没有横条和花纹的纯色服饰 买衣服的时候就要想，这件衣服能和衣柜里哪些衣服搭配，只有能和2-3件搭配才比较合适，不然就还要考虑以后再买能搭配新买的这件衣服的衣服 秋季最常见的一种搭配是内半袖外夹克； 深秋或初冬最常见的搭配是内卫衣外夹克； 冬季最常见的一种搭配就是衬衫+毛衣+外套，衬衫一般是白色，且露出领子，毛衣一般是浅色，比如浅灰或浅驼，外套颜色深一点，进入室内把外套脱下来，毛衣也要给人一种温暖成熟的感觉，因此要注意版型和颜色。 搭配的时候就是利用色彩搭配技巧，然后单品之间颜色、材质、元素相互**呼应、过渡、碰撞，**想要穿出彩，就应该好好折磨一下这些字眼。 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:2:0","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"3. 挑选和购买 包括每种衣服挑选时的注意事项、大致的价格范围、收藏的店铺等。 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:3:0","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"3.1 挑选原则 首先介绍两个基本概念： 克重(g)：不是指一件衣服的重量，指的是每平方米布料的克重，克重也可以理解为衣服的厚度，面料的克重越高，衣服越厚，反之克重越低越薄，太薄了会露点。 支数(s)：支数是纱线表示的一种公式，支数越高，纱线越细，织出来的面料也就越柔软轻薄。 很多文章介绍的时候会涉及这两个概念，但在买衣服的时候很少有商家会明确的给出数字，所以一般还需要自己大致地做判断。 T恤 主要摘自女朋友教你穿衣服：如何挑选T恤 T恤的问题是洗了易变形，白色T恤还容易发黄，所以对面料材质、克重支数和做工细节、版型都要特别注意。 首先，T恤面料一般选择纯棉，因为需要贴身，对舒适的要求高。不过为了避免纯棉的缺点，大多掺入一定量的化纤，以氨纶、莫代尔等居多，所以实际上是混纺，市面上一般超过 90% 棉就叫做纯棉了。在特殊场景下，比如运动T恤，由于出汗比较严重，可选择聚酯纤维。 关于夏季T恤的克重和支数并不是越高越好，因为克重高了T恤太厚穿起来易感闷热，支数太高过于柔软轻薄会露点也不耐洗。T恤比较合理的克重应该在160g~300g区间，更高的克重用于卫衣；常见的支数在18~50区间，更高的支数通常用于正装衬衫或羊毛类材质的西装面料。建议打底穿选择160~200g/支数30~40区间，外搭单穿的选择200~300g/支数20~36区间。 关于做工细节，主要是注意领口、袖口、肩条、下摆以及各个位置的缝线。领口选择小圆领即可，V领适合内搭，领口过大会显得没精神，总之其它领口看起来都很不舒服； 由于领口洗涤容易变形，应当选择多针加固的螺纹领，普通的螺纹领和布包边领都存在清洗几次就变形的问题； 此外，有肩条加固也可以防止领口变形，同时还有保持版型，使T恤挺阔的作用 同样的，袖口、侧缝、下摆都应当采用多针加固，还应当注意各个地方的缝线应该工整讲究，针眼对其，没有多余的线头，否则很容易穿几次就发现有线头脱落。 关于版型，首先应当选择修身、合身或略宽松的T恤，肩线应当在肩胛骨那里，不论缩到里面还是下落到手臂下面都很别扭 至于衬线，也就是肩膀上前后面料的缝合处，在中间位置适合体型正常的人，稍微靠后适合宽松的版型 关于腰部，略微收腰和直筒都可以，但紧身风格则很不合适 袖长不要超过手肘，但也不要太短，标准袖长和5分袖适合大多数人，下摆的长度则应当在手腕或盖过皮带1-2cm的位置。如果新买的衣服各处不合适，找个服装店裁剪一下。 T恤发黄的问题可以参考 女朋友教你怎么穿：白T出汗容易发黄怎么办。 关于搭配，首先，白T几乎是万能的，无论是外穿还是内搭，能配的衣服太多了，准备1-2件用。注意的是T恤是消耗品，基本上每年都需要换新的，所以发黄的、领口变形的、整体变大的，都可以直接扔掉。 夏天穿黑T太热，所以替换的T恤可以选择浅灰色或任意一种糖果色等其它色彩，注意是纯色的，如下图 如果想要一点图案，则应该选择比较小的，有设计感的，想要表达明确思想的，可以在左胸或T恤上半部正中的位置，当然，也可以在纯色T恤上用胸针。 具体选择哪种做替换，看每年的心情吧。 至于 Polo，是真的不喜欢，也许到了 30 多考虑年龄可能会穿，但现在不会。 衬衫 长袖衬衫夏天可以选择清爽一点的颜色，面料夏季可以选棉或棉麻的，牛津纺卷袖子易皱比较适合秋冬，长袖衬衫版型宽松一点，可以在偏凉的天气或者冷气太大的室内作外搭。有空也可以试试牛仔衬衫。 不过一般在夏季也不考虑了，可能会尝试，但现在没感觉，用白衬衫在秋冬作为内搭，其它颜色的衬衫看心情。如果是为了防冷，比如雨后、清晨等，可以选择卫衣或薄夹克。 毛衣 毛衣选择圆领的灰色或驼色，因为脸胖脖子短，就不选半高领和高领了， 卫衣 不要花里胡哨，简单的圆领无帽卫衣或连帽卫衣 开衫的卫衣就算了 夹克 牛仔夹克，经典永不过时，秋冬必备单品，牛仔蓝、深蓝色、原色 飞行员/棒球夹克都是很经典的秋冬外套 皮夹克暂时就算了，工装夹克比较硬朗，西装夹克暂时用不到 大衣 事实上有短款的大衣，不挑人 中长款可选驼色系、灰色系、藏青色和黑色，个子不高最好不要选长款 羽绒服和棉服 不少棉服的造型还是可以的 派克大衣也是棉服的一种，外观不错 米其林轮胎一样的羽绒服就比较丑了，尽量选下面这种类型的羽绒服 五分裤 不要太修身，不要太宽松，不要有太夸张的口袋，裤管不要太宽，裤长不要太短也不要太长，不超过但接近膝盖是最合适的，这也是七分裤为什么不适合穿的原因。 对于裤子的面料，黑色纯棉比较容易粘毛，喜欢纯棉可以考虑卡其色、灰色、灰绿等，粘毛看不出来，没有特别喜好可选择棉质斜纹面料、亚麻面料或泡泡纱。 泡泡纱成分是涤纶，外观经机器压泡后表面有凹凸不平的小泡泡，给人立体感比较强，穿着时不易贴身，抗皱性强，凉爽与挺阔感很好。我好像有一件，确实完全不发皱，只是裤管有点粗。 最后，5分库要有立体感，面料像T恤的那种看起来像睡裤一样，有点穿不出去 由于天气原因也不要黑色，选浅灰、卡其色或军绿，准备2件换洗，短裤是非消耗品，可以穿很多年。 长裤 拒绝紧身、太宽松，拒绝各种宽松奇特的裤子看起来应该松紧有度，腿型不好可以选择直筒，一定要保证腰围和裤管，裤长可以拿去改，合适的裤长是刚好到鞋面，牛仔裤也可以卷裤脚，可以在视觉上营造层次感，看起来更清爽。 牛仔裤选择经典款就可以了，不用花里胡哨多其他的东西，经典包括浅蓝、天蓝、湖蓝、深蓝、深灰、原色，如下图 冬天的话有下面这几种 休闲长裤选择宽松简单的，普通的黑灰、浅米白、浅卡其、灰绿、深蓝都不错 秋冬的裤子选棉、灯芯绒、羊毛等，颜色选灰色系、大地色等深色系，比如灰、深灰、藏青、黑色、深棕等 夏天可以选择浅色、薄一点的，秋冬深色、厚一点，尤其是冬天，裤管可以适当大一点，因为里面要穿保暖裤或棉裤，裤管小的话会被撑起来，比较难看，实际上工装裤裤管比较大，可以很好的包裹 鞋 夏天不要高帮，不要穿着袜子穿拖鞋。 夏季可以选择低帮的休闲板鞋，比如经典的德军训练鞋，德训鞋不同于小白鞋，鞋身的反绒面与生胶底看上去很有辨识度，能同时给人简约与复古感，整体质感也很不错。 帆布鞋回力、匡威、vans、P.F 等各品牌的经典款都可以，不容易出错（PS：没穿过，不过知道感觉怎么样） 还有基本款的小白鞋，最重要的是保持干净，如果不能保证干净，不如不穿 运动鞋的话各品牌的经典款都可以，常见的nike的max 95/97/98，NEW BALANCE 的608/990/991/993，adidas系列的等等，对我个人而言，穿跑鞋而不穿篮球鞋。 冬天尝试工装靴和较厚的运动鞋，马丁靴选6孔的，太高帮个子不高驾驭不了。 饰品 饰品的作用在于点缀，尤其是全身上下比较单调的时候。 由于脸比较圆，夏天戴一条项链可以在视觉上起到延伸作用，款式应当尽量简约，可以选择一些有趣的、有意义的，颜色建议金属色或银色，没有信仰最好不要戴十字架 项链的长度不要过长，在胸部位置最好 手链就算了，背包我喜欢帆布，选简约一些的款式，帽子的话其实圆脸大头不好选，就不戴了。 内衣 袜子春夏秋都可以选船袜，冬天短筒加绒，颜色最好和鞋子或其它部位呼应。 背心的话肩带不要太窄，一般秋冬用来打底，外面基本看不到，舒服就行 内裤四角，莫代尔或冰丝 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:3:1","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"3.2 价格范围 我们把全身分为上衣、裤子、内衣、鞋、配饰和其它， 衣服类型 所属类别 价格范围 背心 内衣 20左右 T恤/Polo衫 上衣 60-150 衬衫 上衣 100-200 卫衣 上衣 100-200 针织衫/毛衣 上衣 秋衣秋裤 套装 150左右 保暖上衣/裤子 上衣/裤子 150左右 短外套（夹克等） 上衣 长外套（大衣/羽绒服等） 上衣 短裤（5分） 裤子 100左右 长裤（牛仔/休闲等） 裤子 100左右 内裤 内衣 15以上 袜子 内衣 5-6块 鞋 鞋 200-500 床单 其它 40-50 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:3:2","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"3.3 店铺及品牌收藏 内裤推荐品牌为：浪莎、舒雅、优衣库、muji、Jockey 袜子推荐店铺（淘宝）： 口渴怎么办 素人工作室 叽呱袜子铺 Crazy Socks ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:3:3","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"4. 胶囊衣橱 夏季 T恤：1-2件白T，任意一种除黑色外的其它纯色 夹克：1件，牛仔夹克或飞行员夹克，薄款的，冷的时候套一下 短裤：2件，米白、灰、卡其或军绿 牛仔裤：2-3件，浅蓝/湖蓝/浅灰，经典款， 休闲裤：1件，黑/灰/米白/卡其色，简单款式 鞋：小白鞋或者德训，经典的帆布鞋，经典跑鞋 配饰：简约的项链，到胸部即可，打破圆脸的圆润感和纯色衣服的单调 春秋 卫衣：灰色或其他纯色，不要图案，可以选择白色T恤内搭 衬衫：白色必备，内搭注意合身，领口袖口易脏，注意清洗 夹克：稍厚的牛仔夹克、飞行员夹克，T恤作为内搭 长裤：同夏天，稍厚点即可 鞋：同夏天，但此时可加入经典款运动鞋 冬 毛衣：黑色圆领或高领，驼色圆领，使用白色衬衫内搭，冷的时候可以选择那种保暖的毛衣 衬衫：白色必备，内搭 秋衣秋裤：一般是套装，秋裤看不出来，秋衣穿着尽量往长袖T恤的样子靠拢，不要让人一看就是内衣，冷的时候适当选择保暖秋衣秋裤 大衣：灰/棕/深蓝色经典款纯色大衣 羽绒服/棉服：米其林轮胎一样的羽绒服尽量避免，棉服实际上最佳 长裤：同夏，稍后点 保暖裤：黑灰，薄和保暖兼顾最好，两三条换洗 鞋：运动鞋，低帮马丁靴（加绒） 其他 背心：只有深秋和冬季需要，内穿看不到，肩宽一点，不要两根吊带一样 内裤：夏冰丝，其他季节纯棉或莫代尔，半年一换 袜子：春夏秋船袜，注意配鞋子颜色，冬季短袜加绒 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:4:0","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"5. 各季搭配 以胶囊衣橱为基础，列举各个季节的搭配 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:5:0","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"5.1 夏季 夏季一般就是三大件：上衣、下衣和鞋子，然后就是可能的饰品：手表、项链、手链、背包、帽子等，如下图 下面是具体的搭配，首先是短袖+5分裤+鞋子，5分裤根据肤色自选颜色，以项链搭配， 白T克重小的可能露点，克重大的又比较热，所以可以适当选左胸口有兜的，或者有小图案的，比如这个 米白色的裤子很百搭 其次是T恤+长裤+鞋子 白T+衬衫+裤子+鞋 穿起来的时候记得把T恤下摆塞到裤子里，叠穿时里面应该比外面的衣摆短 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:5:1","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"5.2 秋季 打底+卫衣+长裤 打底+连帽卫衣+夹克+长裤 打底T恤+工装夹克+长裤 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:5:2","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"5.3 冬季 背心/长袖T恤打底+毛衣+长裤 背心/长袖T恤打底+毛衣+大衣+长裤 背心/长袖T恤打底+衬衫+毛衣+大衣+长裤 背心/长袖T恤打底+卫衣+大衣+长裤 其它的其实大致都一样，区别在于毛衣外面穿的是夹克、大衣、棉衣还是羽绒服。 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:5:3","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"6. 服饰之外 我希望给人的感觉是怎样的，是干净、简单、清爽、看着很舒服的那种，要做到这样，除了服饰搭配之外，还有一点其它的工作。 首先是头发，或长或短，找个适合自己的发型，然后勤洗头，勤打理，保证自己的头发看来不乱和不油腻。 其次是脸部，男生注意护肤也不是丢脸的事，多油的注意控油，干燥的注意保湿，阳光强烈的时候涂一点防晒或者打一把伞，洗脸的时候就顺便洗一下耳朵，修剪鼻毛、胡子都勤快点，每天两次刷牙，需要的时候洗一下牙，饭后漱口，可以时常嚼着点口香糖，避免一张口熏到别人。 掌握了穿搭也要勤洗衣服，保持干净，保养好衣服，褶皱、污渍都会对一个干净的形象有影响，穿着皱巴巴的衣服出门观感真的很不好。 当然，最重要的是规律作息，浑浊的眼睛和疲惫的状态无论如何不会给人好感的，多读书，多尝试新东西，热爱生活，一个人的经历和思想可以通过气质表达出来，和外在的穿搭构成整体。 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:6:0","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"7. 持续学习 找到自己喜欢的风格，看杂志、网站、街拍，凭直觉收集自己喜欢的造型和单品，在路上看的舒服的衣服也可以拍照记录下来，尽可能收集后，仔细观察其共通之处，包括单品设计、颜色、所表现出来的男性形象气场等。如果收集内容中某单品出现过多，则是自己心仪的 收集的搭配中，注意相似的整体搭配风格，找到自己喜欢的风格，逐渐尝试直到找到自己适合的风格 根据脸型、体型寻找相似明星、时尚达人、服装推荐博主或身边会穿衣服的人，参考他们的着装。 时刻保持清洁干净，锻炼身体 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:7:0","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"7.1 公众号和网站 公众号思南的时尚笔记 公众号女朋友教你穿衣服 yoka男士网 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:7:1","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"7.2 穿衣偶像 Nick Wooster，被誉为“世界上最会穿衣的型男”，曾做过著名公司的时尚总监，现在经营者自己的时尚造型公司，他的穿着总能给人眼前一亮的感觉，如何学习他的穿衣风格，可以参考How To Get Nick Wooster’s Style这篇文章。 Daniel(丹尼尔)，来自德国，出现在各类街拍中，INS超人气博主，健身顾问，属于健壮体型。丹尼尔的穿搭以简单为主，在夏天大多时候都是休闲裤或者牛仔裤，加简单的 LOGO T恤。正式一点，则会选择修身有型的衬衫。在秋冬季节，由于丹尼尔的身材并不高挑出众，则会选择比较短小简单而有型的外套来凸显身材，拉伸比例。而他本身的单品也并不奢侈，身上常见的牌子有 UNIQLO、H\u0026M、ZARA，再贵一点的就是 CK、Levis，而他的鞋子大多也是 adidas、Nike、Vans 等等。他在INS的ID为@ magic_fox Dennis Glanz是来自澳大利亚的时尚型男，极简的纳维亚休闲风格（北欧低调，至简随性的街头风格）是他的穿搭特色，但又不仅局限于此。同时他也是一位 sneakerhead，球鞋是他的标准装备。ID： @ asos_dennis Phil Cohen，极简穿搭，从不露脸，他分享的穿搭真的太爱了，可惜都是各种转载的，看不到INS原本博主的分享，微信链接 John Henry，T恤搭配，四季从来不缺，微信链接 ","date":"2019-12-05","objectID":"/2019/clothing-style-development-and-clothing-purchase/:7:2","tags":["生活技能"],"title":"穿搭整理2-服装搭配及购买","uri":"/2019/clothing-style-development-and-clothing-purchase/"},{"categories":["我所热爱的生活啊"],"content":"选择了国企以后，整个人一下子就放松了下来，感觉自己突然有很多时间去做自己想做的事情。最近这段时间就在看服装相关的知识，因为突然想到虽然我们从出生开始就与衣物打交道，但这方面的知识除了相关行业从业人员真的很少去了解，面料有哪些啊，衣服种类有哪些啊，怎么搭配衣服，买衣服要注意哪些事，怎么洗衣服更干净，怎么保养和收纳衣服，都不清楚，怪不得生活乱糟糟的，这一个系列主要就是学习和记录这些东西。另外，这一系列已同步发表在少数派。 本篇先了解关于面料的相关知识和服装的分类。从网上的文章1开始入门，查阅权威教材2，确保知识的权威性和正确性。因为自己本身也不是服装相关专业，也不打算学多细，就尽量从实用角度出发，只总结会用到的一些知识，其它的就一览而过不记录了。 注：文章中出现大量的图片，很多来自网络，侵权请联系，思维导图均为自己制作。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:0:0","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"1. 服用纤维 一件衣服的成型大致分成四个阶段：纤维、纱线、布匹、服装，我们平常所说的服装面料，大多是以纤维类型来称呼的。 用于制作衣服的纤维就叫服用纤维，服用纤维主要分为两大类，天然纤维和化学纤维，毛皮与皮革等虽然也用作织物，但不属于纤维类别，因此在后面单独讨论。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:1:0","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"1.1 天然纤维 天然纤维是指从自然界或人工养育的动植物上直接获取的纤维。主要分植物纤维（天然纤维素纤维）、动物纤维（天然蛋白质纤维）和矿物纤维三类，矿物纤维一般指石棉，因为生活里基本见不到这类衣服，这里不讨论。 植物纤维 植物纤维实际上是按植物部位来分的，我们主要接触的就是棉和麻。 棉 棉纤维是棉花的种子纤维，成品为棉布，是生活中的主要服装面料，一些常听说的材质都属于棉布，如斜纹布、卡其布、牛仔布、灯芯绒。 棉纤维的主要特性包括： 良好的染色性，易于染上各种颜色； 弹性差，不挺阔，服装穿着易起皱，且起皱后不易恢复； 手感柔软，穿着舒适，且吸湿性好，不刺激皮肤，不易产生静电； 耐磨性不够好； 耐湿热性能好，因此耐水洗，且洗时可用热水浸泡，高温烘干（或熨烫）； 缩水严重，因此加工时需要进行预缩处理； 不耐酸，图标粗长期穿着不及时清洗或清洗不当，人体汗液中的酸性物质就会使纤维发黄脆损； 耐碱，可用碱性洗涤剂清洗； 易受霉菌等微生物侵害，导致发霉色变； 棉质衣物的洗剂和保养方法有： 新买的颜色艳丽或深色的棉布可在清水中加入食盐浸泡，之后阴干，从而防止褪色（盐是很好的固色剂）； 使用碱性洗涤剂，并在穿着后及时清洗； 洗后垫湿布熨烫； 通风阴凉处晾晒，曝晒可能导致变黄； 棉布易发霉，因此存放时要注意通风，尤其是全棉布料。 麻 麻纤维多是由麻类植物茎秆上的韧皮加工制成，其中的亚麻是世界上最古老的纺织纤维。实际上一直以来用的最多只有亚麻和苎麻，其它的如大麻、罗布麻、黄麻等可纺性较差，现代工艺提高后才开始使用，而且多是和其它纤维混纺。下图中从左到右依次为亚麻、苎麻、黄麻和剑麻。 麻纤维的特性有： 光泽较好，有象牙色、棕黄色、灰色等，但纤维间存在色差，成型的织物颜色不均匀； 不易漂泊染色，因此常见麻织品颜色较灰暗； 麻织品较棉织品粗糙硬挺，因此服装多是支撑型的，纹理也多粗细不均，与人体接触可能有刺痒感； 弹性较差，易起皱，皱纹不易消失； 吸湿性好，导热性好，出汗后不易贴身，适用于夏季； 不易产生静电； 强度较高，因此结实耐用； 耐水洗，耐热，可以高温熨烫（湿熨）； 耐酸碱性比棉略强，但总体仍耐碱不耐酸； 麻纤维较硬，经常折叠的地方容易断裂，因此保存时不宜重压，织物褶皱也不应重复熨烫。 动物纤维 动物纤维只有两种：毛和丝，具体如下图 蚕丝 蚕丝是蚕的腺分泌物凝固成的线状长丝，成型的面料是丝绸，在中国具有重要地位。主要分为桑蚕丝（人工养殖）和柞蚕丝（野生）两种，前者占比最大。 蚕丝的主要特性有： 柔软有弹性，富有光泽，有特殊的闪光； 染色性好，染色鲜艳； 不耐盐水侵蚀，汗液中的盐分可以使蚕丝强度降低，所以夏天要勤洗勤换； 碱会损伤蚕丝，因此要避免使用碱性洗涤剂； 洗涤时采用柔和的方式，洗后不能绞干，应摊平晾干； 不能用含氯漂白剂处理，也不能用含漂白粉的洗衣粉洗涤； 耐光性差，过多的阳光照射会使纤维发黄变脆，洗后应阴干； 熨烫时要垫布，防止烫黄和水渍； 可能出现虫蛀和发霉。 动物毛 平常说的羊毛主要指绵羊毛。 羊毛的特性有： 毛纤维弹性好，不易起皱，通过湿热定型易于形成所需造型，但变湿后弹性、抗皱能力和保型能力都会明显下降，因此羊毛织物要避免水洗。 羊毛手感柔糯，触感舒适，隔热保暖性好，是理想的秋冬季衣料。 耐酸不耐碱，不能用碱性洗涤剂 对氧化剂敏感，尤其是含氯氧化剂，会使羊毛变黄、强度下降，因此不能用含氯漂白剂和洗衣粉 纯羊毛织物应干洗，和合成纤维混纺的羊毛织物可以水洗，但应使用中性洗涤剂，温（冷）水 易虫蛀，可生霉，保存前应洗净、熨平、晾干，放入樟脑丸防蛀 除绵羊毛外，其它的都是特种毛纤维，与绵羊毛功用相似，但具有一些各自的优良特性。下图第一行从左到右依次为山羊、安哥拉山羊、骆驼，第二行从左到右依次为牦牛、羊驼和骆马。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:1:1","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"1.2 化学纤维 化学纤维是以天然或人工合成的高聚物为原料，经一定的加工制造出来的纤维，分为再生纤维和合成纤维两大类。 再生纤维 再生纤维是以天然高聚物（如木材、甘蔗渣等植物短纤维、动物纤维、废弃动物毛皮等）为原料，经纺丝加工制成的纤维。 黏胶纤维是以木材、棉短绒、竹材、甘蔗渣、芦苇等为原料，经物理化学反应制成纺丝溶液，然后经喷丝孔喷射出来，凝固成纤维。因主要成分仍然是纤维素，特性与棉相似。 铜氨纤维是将棉浆、木浆中的纤维素原料溶解在铜氨溶液中，经加工而制得，织物比较耐磨。 金属纤维是以金属或其它合金制成得纤维，很早就已存在，但密度大、质硬、不吸汉、易生锈，实际上不适合做衣服。但出于防辐射、导电、耐高温、抗静电等特殊用途，有时候与其它纺织纤维混纺使用。 合成纤维 合成纤维以石油、煤、天然气及一些农副产品中所提取的小分子为原料，经人工合成得到高聚物，再经纺丝形成纤维。用于服装的主要有以下七大类： 合成纤维具有以下特性： 强度高、弹性好，结实耐用，制成得服装保型性好，不易起皱； 合成纤维中长丝易勾丝，短纤维织物易起毛起球； 吸湿性普遍低于天然纤维，易洗快干，不缩水； 易起静电，易吸灰； 对热敏感，熨烫时要注意温度和压力； 亲油，因此容易吸附油脂且不易去除； 不发霉防虫蛀。 其中涤纶最常用，锦纶耐磨性最好，腈纶性能与羊毛相似，但易起球。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:1:2","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"1.3 毛皮与皮革 除以上提到的各种面料外，毛皮和皮革也在服装中占有一定的比例。 直接从动物体上剥下来的毛皮称为生皮，湿润状态下很容易腐烂，干燥后则比较干硬，而且易生虫、易发霉发臭。生皮经过鞣制等处理后，才能形成具有柔软、坚韧、耐虫蛀、耐腐蚀等良好性能的毛皮和皮革。一般将鞣制后的动物毛皮称为裘皮，而把经过加工处理的光面或绒面皮板称为皮革。现代意义上的皮草是裘皮服装及服饰的统称。 毛皮由皮板和毛被组成。皮板密不透风，毛被的毛绒间可以存留空气，从而起到保存热量的作用，因此毛皮是防寒服装的理想材料。虽然毛皮与皮革是设计师和消费者所喜爱的珍贵服装面料，但为了保护野生动物，为了扩大原料皮的来源、降低皮革制品的成本，人造毛皮（仿裘皮）和人造皮革（仿皮革）产品越来越受到关注。它们在外观上与真皮相仿，服用性能优良，缝制方便，从而大量进入服装工业，并以其物美价廉而独具优势。 毛皮 我国地域辽阔，毛皮资源丰富，全国各地分布着400多种家畜和野生动物，毛皮动物占80多种。比较常见的毛皮动物有绵羊、山羊、兔、狗、猫等；比较珍贵的毛皮动物有水獭、紫貂、狐、豹、虎等，其中水獭皮质量最佳，毛密绒厚，富有光泽，有很好的防水性，较其他毛皮耐穿耐用。 由于野生动物受到保护，故高档时装用毛皮主要来自人工伺养的貂皮和狐皮。用狐皮或貂皮做的大衣，具有保暖、富贵、华丽、舒适、轻盈等特点。 皮革 皮革根据来源及加工方法不同分为天然皮革、人造皮革和再生皮革。 天然皮革是动物的皮板（原料皮）经一系列化学处理和机械加工制成的，与原料皮性质相比，耐腐蚀性（不会变臭）、耐热性（原料皮65℃变形）、耐虫蛀性及弹性均有提高，且手感柔软、丰满，保型性好，因此应用广泛。目前，服装用革主要有羊皮、牛皮、猪皮，此外，还有少量的蛇皮、麂皮、鸵鸟皮等，其中的鸵鸟皮、蛇皮和鳄鱼皮等都属于特种动物皮。 为了提高原料皮的利用率，往往将较厚的皮板片成多张皮革，故有头层皮、二层皮、三层皮等之分， 如牛皮较厚（约4mm），可分割成3～6层，得到非常轻、薄、软的皮革材料。一般，头层皮（带粒面）质量最好，强度高，但价格较贵；二层（分裂一层）以上的皮质量较差，强度稍低。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:1:3","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"2. 面料 面料的种类非常非常多，命名方式也各异，全部列举是不可能的，下面只介绍几种生活中最常见的。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:2:0","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"2.1 纯棉 纯棉在我们购买衣服时是最常见的，纯棉织物是以棉花为原料，通过织机，由经纬纱纵横沉浮相互交织而成的纺织品。纯棉面料比较舒适亲肤，吸湿、散热、透气性很好，但是易皱和吸附毛尘，耐酸性不好； 纯棉面料里也有分为精梳棉和普通纯棉，精梳棉在纺织的时候多了一道精致梳理的程序去除比较短的纤维以及杂质，这样单纱长也更有韧性织成衣服后品质更好，穿着不容易易起毛球、拉长变形且更有光泽、质感好： ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:2:1","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"2.2 化纤 化纤就是上面提到的化学纤维，用天然的或人工合成的高分子物质为原料制成的纤维。 化纤中常见的是涤纶和氨纶。涤纶是聚酯纤维，手感顺滑，结实耐用、弹性好、不易变形、耐腐蚀、易洗快干，但是面料顺滑贴身易反光，肉眼看上去质感差；氨纶则不易起皱、褪色，伸阔性大、保型性好，且耐酸、耐碱耐磨，常见少量的用于与棉混纺，这样的面料手感清凉、更顺滑，不易变形； ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:2:2","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"2.3 混纺 混纺即混纺化纤织物，是化学纤维与其它棉毛、丝、麻等到天然纤维混合纺纱织成的纺织产品，既有涤纶的风格又有棉织物的长处，如涤棉布、涤毛华达呢等。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:2:3","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"2.4 呢绒 又叫毛料，它是对用各类羊毛、羊绒织成的织物的泛称。适用以制作礼服、西装、大衣等正规、高档的服装。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:2:4","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"2.5 麻布 麻布制成的产品具有透气清爽，柔软舒适耐洗、耐晒，防腐、抑菌的的特点。一般用来制作休闲装、工作装，也可用来制作环保包装，时尚手袋，工艺礼品等。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:2:5","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"3. 面料鉴别 面料的鉴别在买衣服的时候是很有用的一个技能，网上买衣服的时候，在商品的参数部分查看 线下购买多采用「一看二摸三抓四拆」的方法，看颜色和光泽，摸光滑度和软硬度，抓一下看起皱程度，拆一些纱线做判断。纱线的判断最简单的可以使用燃烧法，通过纤维燃烧的气味、灰烬的颜色和形状可以判断是植物纤维、动物纤维还是合成纤维。但燃烧法较难判断更细节的成分和混纺面料。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:3:0","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"4. 服装分类 服装的分类也比较多，但大致可以分上衣、裤子、内衣、鞋、配饰3 4五类。 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:4:0","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"4.1 上衣 T恤：分短T和长袖T恤 Polo 衫 卫衣：分无帽卫衣、连帽卫衣和开衫卫衣 衬衫：分短袖衬衫和长袖衬衫 毛衣/针织衫：圆领、V领和高领，开衫的针织衫 夹克：翻领、对襟，其实就是各种短外套，以材质分可以有牛仔夹克、飞行员夹克、冲锋衣夹克、皮衣、羊羔绒夹克等等，西装上衣也可以叫夹克 风衣：防风的轻薄型大衣，一般和毛呢大衣统称大衣 棉服、羽绒服：有填充物做夹层的衣服叫棉衣，以棉花填充的叫棉服，以羽绒填充的叫羽绒服 西装 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:4:1","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"4.2 裤子 短裤（五分），七分/九分裤 牛仔裤 工装裤 运动裤 西裤 休闲裤：除上述外的各种长裤，会有正常款式、直筒、束脚等不同样式 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:4:2","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"4.3 内衣 背心，内裤 袜子：分船袜、短筒、中筒和长筒袜，可以加厚加绒，羊毛袜 秋衣秋裤 保暖裤，棉裤 保暖内衣（类似秋衣秋裤，但是加绒保暖） 保暖毛衣 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:4:3","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"4.4 鞋 凉鞋拖鞋 帆布鞋 板鞋 便鞋/懒人鞋 皮鞋 工装鞋靴 运动鞋：最常见的是跑鞋和篮球鞋 其他各种款的休闲鞋 ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:4:4","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["我所热爱的生活啊"],"content":"4.5 配饰 手表，皮带、首饰、围巾、帽子、眼镜、背包 知乎-衣服面料全知识 ↩︎ 周璐英, 王越平. 现代服装材料学 (第 2 版)[M]. 中国纺织出版社, 2011. ↩︎ 衣服分类方法 ↩︎ 男士衣物分类 ↩︎ ","date":"2019-11-30","objectID":"/2019/fabric-and-clothing-classification/:4:5","tags":["生活技能"],"title":"穿搭整理1-面料及服装分类","uri":"/2019/fabric-and-clothing-classification/"},{"categories":["研究生的区块链学习之路"],"content":"这篇文章是关于区块链用于物联网访问控制的总结，有两个目的，一是梳理脑子里的思路，指导接下来的研究方向，二是作为之后要完成的小论文的参考。 在开始正文前，我们首先需要来定一个基调：区块链和智能合约只是一种实现访问控制的手段，我们可以用它来实现 ACL，也可以用它来实现 RBAC、ABAC、CapBAC 等其它任何访问控制模型。研究过程中遇到的很多问题，比如属性和策略的定义方法、属性发现机制、策略挖掘机制、策略冲突解决机制等，说到底，都是传统领域中研究这些模型已经出现过的问题，通常已有成熟的解决方案，直接拿来用就好，但不应当作为一个创新点来讨论；另外，这些模型间自身的区别，比如 RBAC 比 ACL 好在哪里、ABAC 又解决了什么问题、CapBAC 解决了什么特殊领域的问题，依然是传统方向已经深入讨论的问题，甚至是这些模型的开创者就在论文中详细阐述过的，我们没有必要继续阐述，当然也不能作为自己的创新或优势，不能说我将 ABAC 与区块链结合，就比你的 RBAC 和区块链结合好，它们都有各自的适用场景。我们真正应该关心的，是区块链用于实现物联网访问控制有哪些好处，我们设计的方案如何充分发挥了这种结合的优势，又如何解决了它们结合所产生的问题，这才是创新点应当所在之处。 还有一个需要明确的问题，是我在研究过程中逐渐意识到的一点：再小的一个方案，涉及到的方向都很多，有些是我们必须解决的，有些不是，对于那些必须解决的问题，如果不是我们关注的重点，可以直接使用别人的设计或方法，这是不可避免的，人的精力也是有限的， 不可能在每个方向都有突破，但是，我们需要重点突出自己所做的改进，解决了什么问题，相比别人的方案有什么优点，这就是创新点，这种点，有2-3个就够了。举个例子，物联网和区块链结合，在吞吐量、存储、结合方式等太多方面有可做的事了，有些比如 PoW 对资源的需求和物联网设备的有限能力的冲突，是所有人都要面对的，但如果不是我们当前方案重点解决的问题，那么直接用别人设计好的方法就行，把精力放在自己重点关注的问题上。 ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:0:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1. 背景 毫无疑问，物联网已经走进了我们工作和生活的方方面面，智能工厂、医院、车联网、智慧城市、智能电网、家里的智能家居，甚至我们身上的可穿戴设备，然而，物联网的快速增长带来了巨大的安全隐患。 物联网设备会生成、处理和交换大量安全相关的数据和隐私敏感的信息，而且一些设备本身承担的功能十分重要，受到攻击后造成的危害也更大，比如一辆行驶中的汽车的控制权被夺取，可能威胁到驾驶员的生命； 现有物联网设备朝着能耗低、重量轻的方向发展，其能量和计算资源主要用于执行核心程序，只有很少的一部分能配给处理安全和隐私问题，尤其是，对于传感器、执行器、RFID 标签等，自身完全没有能力处理相关逻辑； 传统的解决安全与隐私问题的结构是集中式的，无法应对分布式的大规模物联网设备以及巨大的流量，还面临单点瓶颈和故障问题，并且往往代价较高，不适用于物联网 针对传统物联网访问控制的局限性，区块链具有如下优点，这些优点多是基于分布式、不可篡改、可追溯等特性。 保证访问权限归属于用户。这点其实主要是针对手机App来说的[1]，但对工业场景如车联网也是适用的，汽车制造商会为车主提供各种服务，因此涉及到权限和隐私问题。总的来讲，凡是涉及服务提供方的场景，都可得益，这种归属权具体指代的是：1）服务商只能获取用户授予的权限，系统不是黑盒，用户的授权过程确实有效；2）用户可随时撤销权限，不受服务商阻挠。其缺点在于，链上的信息对所有区块链的参与者是完全公开的，但这种公开可以为我们带来对非法操作的追溯与惩罚，具有两面性。其局限性在于，服务商可以做出不授予权限就不提供服务的设计，即使这种权限是不必要的，区块链对这种情况无能无力。 解决集中式的单点故障问题和可扩展性问题。由于分布式的特性，这种优点是显而易见的，虽然传统IoT访问控制中也有如CapBAC等分布式方案，但这些方案中轻量级设备无法保证自身安全性，无法应用在不可信环境下，区块链依然具有显著的优点。虽然区块链当前也面临可扩展性问题，但随着研究人员的不断努力，这一问题已取得较大进展，分片方案已经得到大量使用，并在持续不断的改进。 保证访问控制权限不受篡改。基于不同的实现方案，可能指权限，也可能指实体属性、访问控制策略等，这一点有以下几方面的含义：1）无论服务提供商还是用户，防止一方以欺诈方式拒绝执行区块链的判决结果，实际上指的是依据链上内容的不可篡改性，对历史数据进行审计的过程；2）防止恶意第三方(黑客或其它)非法获取权限以谋取利益，这种抵御能力有时不仅限于对不可信环境(各方合作)有益，对信任域(电网系统、公司、工厂内部)也有意义，因为这种信任域在当前依然有着艰难的处境，攻击事件屡发不止。论文[3]有一部分描述是相关的。 跨组织、跨域访问控制问题。这是区块链最能发挥自身优势的地方，涉及明显的信任问题，[2]描述了跨组织角色认证的问题，使用的是RBAC模型。 以及一些对区块链完成物联网访问控制的理解： 访问控制的实质是将区块链看作了分布式权限数据库，因此而言，物联网数据量庞大的问题并不会在该领域造成困扰，因为数据本身并不会存入区块链。而如前所述，区块链不仅具有常规分布式数据库的优点，还具有自身的特性，抗攻击能力较高、容灾而且审计方便。 正如普通互联网应用中涉及的访问控制，区块链的访问控制也理应是区块链应用(Dapp)的基础 如果物联网和区块链是天然可结合的，是必然的发展方向，那么未来就不会继续使用原有的访问控制系统，遵循简单原则，使用同一套区块链系统完成访问控制是最好的选择 访问控制的针对目标必然包含数据，但不仅限于此，对物联网而言，设备的执行权限也是访问控制的一部分。因此，访问控制的研究是和数据共享的研究有一部分重合的，但不等同，不过可以借鉴数据共享领域的前沿研究。 传统访问控制的优点是吞吐量和存储。区块链在访问控制的速度上由于交易确认时间的存在，有着先天的缺陷，只能逐渐通过其它手段优化，而存储的高额代价，尤其是区块链中的存储只能增加不能减少，相比传统存储方案也是一个劣势。 最后谈论应用场景问题。最为相关的一篇论文是[14]，基于属性的访问控制设计作为Dapp的一部分，用于医疗机构中对手术器械RFID标签的访问，并且最终设计目标是供应链，显然，这一案例涉及到了与我们相关的所有概念，是一个绝佳的参考。[7]中提到的场景是多个智能家庭之间彼此的访问控制，[7]的作者Dorri的另一篇区块链与车联网的论文则涉及保证权限归属用户这一优点。综上，我们将应用场景分为两类： 同一信任域内。显而易见的私链情况，现在依然存在大量关于私链是否有意义的讨论，这种情况私链单纯的作为一个分布式数据库存在，相比于传统分布式数据库的优点是抵御攻击的能力和智能合约，智能合约意味着可以在这个分布式数据库上编写和运行各种应用，这是最大的优势。 不同组织间的协作。最典型的是供应链场景，但不止于此，同一集团位于各地的分公司和代理机构、公司与服务提供商、充电桩涉及的电动汽车网络、[10]中提到的产品个性化定制等，都是潜在的应用场景。我们在此对两个场景做具体描述，选择一个进行实验设计 以工厂为核心，设备供应商（维修商）、原材料供应商、监管机构、其它合作商等一同组成的联盟，涉及对彼此间设备信息的访问。（参考Dennis Miller和Barco You） 供应链。区块链记载货物的位置和时间信息，作为货物的装运证明和交付证明。这样可以最大限度地减少装运延迟，更准确地预测货物地交付时间，更好地实时检测库存水平。位置数据由IoT传感器捕获，IoT传感器将数据转发到IoT平台。供应链的参与者包括原始设备制造商（OEM），供应商，第三方物流提供商，托运人和仓库。每个参与者都可以根据参与者的角色查看区块链中的相关货运数据。制造商使用物流管理系统来查询区块链的装运数据，并向区块链提供额外的装运信息。这一描述来自论文[25]，这里显著的会涉及访问控制。 对于实际应用场景的考虑，区块链本质解决的是信任问题，一些详细的内容可以参考[9]和[10]两篇论文的描述。实验的设计与考虑查看第6节。 ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:1:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2. 引入智能合约 [1, 3-6]都是利用比特币解锁与锁定脚本完成访问控制的论文，Ouaddah A在[4]中提出的FairAccess是一个典型的解决方案，已被大量的研究者认可和引用，这是一个基于区块链技术用于物联网场景的访问控制模型。然后，Ouaddah A在论文[5]中对涉及的流程进一步做了详细的解释，因此我们基于论文[5]说明这一类访问控制的基本方法和存在的问题。 比特币脚本存在的意义是自动化地验证交易的合法性，分为锁定脚本和解锁脚本两种。举个例子，假设Alice要向 bob支付0.015比特币, Alice会用到一个UTXO(假设是单输入，单输出)，这个UTXO带有一个锁定脚本，为交易设置“障碍”。 bob如果要接收这笔比特币，就要给出一个解锁脚本，然后解锁脚本和锁定脚本组合后执行的结果为真才能确认交易有效，换个说法就是Bob证明了对这笔比特币的所有权。 比特币的脚本是简单的堆栈语言，是非图灵完备的，当把这种脚本语言推广到图灵完备的逻辑时，就是智能合约。因此智能合约可视作比特币脚本语言的超集，它可完成脚本语言本身的职能，同时还能做到其它的事情，但我们使用智能合约并不仅仅因为这一点。 来看看利用脚本语言完成访问控制的过程，假设设备A向设备B请求一个资源的访问权，它需要首先获取一个访问令牌。这一操作通过如下过程完成： 设备A向设备B的所有者发送请求，声明要访问的资源和在资源上执行的操作 设备B将访问控制策略以锁定脚本的形式封装到授权交易的输出中，以设备A的地址为接收者，发送授权交易。该交易的实质是比特币的转账，访问令牌的实质是签名后的UTXO，也就是比特币。 授权交易被整个区块链确认后，设备A就获得了资源的访问权。 以上是策略定义的整个过程，当需要实际发起访问时，设备A发起访问交易，过程如下 访问交易的输入是设备A未花费的输出（UTXO的基本原理），之前授权交易将访问令牌发送给了设备A，因此，此时访问令牌在这一笔交易的输入中。 设备B利用解锁脚本确认设备A拥有访问权限 访问交易经整个区块链确认，访问控制完成。 FairAccess中利用比特币完成的访问控制基本流程如上所示，Zyskind G在[1]中使用区块链账户公私钥利用密码学知识构建的复合身份体系，完成访问控制的过程与FairAccess是相似的，其它几篇类似。这种方案存在很明显的问题： 每一次访问都要先获取访问令牌（即定义策略），其后的访问控制会消耗掉该访问令牌。这是一种极为原始的体系，甚至连ACL（访问控制列表）都不如，设备（资源所有者）每次都要对特定请求者进行判断然后定义策略，物联网难以承受这种非自动化的访问控制方式 定义策略与访问控制交易成对出现意味着交易的数量翻倍，最终会导致区块链体积的快速增长 一次访问控制需要两次交易确认过程，确认时间的翻倍为提升访问控制的速度、尽可能实现实时性带来了更大的困难。 除此之外，还有一些其它的设计，比如Dorri A在[7]中的方案，访问控制的策略定义在区块中，该论文在普通区块结构中区块头的基础上，新添了策略头结构，用来存储访问控制策略，并在Cluster Header（分层管理结构中的管理者）中维护可访问者的公私钥列表作为辅助，实现访问控制。但这种方式的本质依然是ACL（访问控制列表），严重依赖于人的参与，只能应对设备数量不多的情况。 基于智能合约实现的访问控制，智能合约本质只是一个载体，其图灵完备的特性，允许我们实现已有的成熟访问控制模型如ACL、RBAC、ABAC、UCON等，在区块链分布式、不可篡改的特性上结合传统模型的优点。因此我认为并不存在完全新的访问控制模型，仅仅是利用区块链和智能合约替换了原先的XACML、OAuth和UMA等实现方式。 ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:2:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3. ABAC模型 如上节所述，基于智能合约实现的访问控制，实质上区块链和传统模型的结合，因此，选择合适的模型利用智能合约实现是考虑的核心。依然是Ouaddah A，在[8]中，详细的分析了各传统模型在物联网环境下的适用性，结论中包括： RBAC 将角色和一组权限关联在一起,用户根据系统所赋予的角色获取相应的权限 。 但是 RBAC 作为一种静态的访问控制方法,无法提前预设{用户,角色}、{角色,权限}的对应关系,因此无法解决物联网节点动态接入的问题 ABAC 是一种动态的访问控制模型，使用属性作为访问控制的关键要素，而属性是主体和客体内在固有的,通过实体属性发现机制 可以挖掘出独立、完备的主体、客体等的属性集合,因此不需要管理者手工输入,然后通过自动化的属性-权限 关联关系发现机制可以快速挖掘出{属性,权限}.因此,ABAC 不仅可以解决物联网中节点的动态接入问题,而且 对于节点移动和访问数据变化带来的动态性也可以完美解决. UCON 不仅解决了节点动态接入问题,而且还在访问控制过程中考虑 了连续性和可变性两个重要属性.连续性体现在访问控制会对请求者访问资源的整体过程进行实时监控,可以随时撤销其资源使用权限;可变性是指属性在访问控制过程中是可变的 CapBAC 在物联网环 境中已经实现了轻量级的分布式的访问控制,而且支持动态性和可扩展性.虽然 CapBAC 分布式的设计避免了使用集中式服务器所带来的单点故障问题,但是 CapBAC 在物联网中轻量级的设备上实现 分布式的访问控制决策时,轻量级设备并不能保证自己的安全性,有可能会被攻击者通过安全性薄弱的物联网 设备作为突破口威胁到访问控制的安全,因此,分布式 CapBAC 无法解决在不可信环境下的物联网访问控制. 因为区块链的分布式特性同CapBAC是重合的，甚至可以解决CapBAC无法解决的不可信环境访问控制，不予考虑。最终考虑ABAC和UCON，理论上采用智能合约实现UCON是最佳选择，但考虑到UCON是ABAC的扩展，因此先实现一个ABAC模型作为测试 在具体的实现之前，先来看看当前使用智能合约实现的访问控制都是如何做的。[2]中利用智能合约实现了一个典型的RBAC模型，用来解决跨组织的用户角色认证问题，而且权限的判定过程是在链下进行的，智能合约只起到确认角色身份的作用。[11]中的智能合约则提供了设备的注册和策略添加、权限判定的完整功能，但其访问控制策略的定义是一对一的，本质上是一张访问控制列表，[12]声称实现了动态的访问控制，但仅仅是在[11]的基础上添加了一个在发起访问控制前查询是否存在相关的访问控制策略的过程，如果不存在相关策略，则请求设备管理者添加此策略，这种动态在设备数量较多时是效率低下的。[9]清晰的划分了设备注册、访问控制、行为判决等基本功能，通过良好的设计实现了对物联网设备的访问控制，但其策略的定义依然是一张访问控制列表，所有的权限需要事先定义，缺乏动态性，难以应对大量的访问控制请求。这些论文利用智能合约实现的访问控制无一例外都依然面临着传统模型在物联网环境下面临的问题，仅仅利用区块链提供了分布式的信任。 既然如此，接下来考虑一些同样实现基于属性的访问控制的论文，有6篇[3, 13-17]。[14]针对的是特殊场景：医院设备，访问控制涉及的属性和策略也完全基于RFID标签来定义与执行，这一实现提供了一个良好的范例，但其策略执行的过程是在链下进行的，虽然在医院这个特殊场景中适用，但其它的常规物联网场景恐怕不很合适。[3]使用比特币脚本完成基于属性的访问控制，[13]所描述的方案更类似于一个新的密码学协议，需要经过双方的多次交互，[15]则倾向于利于基于属性的加密来完成数据共享. 这部分工作还没有完成，论文[16]仍未完全理解，而且可预见的短时间内无法理解，[17]处于刚刚发现的状态，但鉴于发表自2017年，并不抱希望，已简略总结的几篇基于属性的访问控制也还需要进一步的阅读和对比。因为涉及的论文比较多，本周在其它部分的论文回顾和总结上花费了大量精力，到这里已经时间不够了。留待下周做 本部分未完待续… ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:3:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4. 面临的问题 上述模型的考虑仅仅是为了完成访问控制这一基本功能，以及应对设备数量多，访问控制请求频繁这一特点。而物联网环境下的访问控制难题不止于此，总结为三个： 物联网设备计算和存储能力较弱。 物联网中的终端设备如智能摄像头、传感器、可穿戴设备、智能家居、智能汽车等都有大小不一的计算和存储能力,但这些计算和存储能力主要是为物联网设备自身的功能服务的,无法为访问控制提供足够的计算和存储能力。 物联网节点数量多、种类多、数据类型多，产生的数据量庞大 物联网动态性问题，即部分节点具有移动性，及节点的动态接入问题 传统方案中 访问控制涉及的计算与存储由集中式的服务器完成，解决节点能力不足问题； RBAC将角色与权限分离，通过管理角色，减少ACL的存储数，适应了少量特定物联网场景，ABAC基于属性完成访问控制，完全适用物联网节点数量多、种类多、数据类型多的特点，CapBAC等其它模型也可以应对某些特定的物联网场景； 一些改进的RBAC添加了上下文感知和上下文约束，实现了角色和权限的实时动态管理；ABAC作为动态访问控制模型天然支持节点动态接入；UCON在节点动态接入的基础上，加入连续性和可变性两个因素，可以实时监控整个访问控制过程，动态调整属性和资源使用权限[18, 19] 目前区块链解决这一问题的方案总结如下： 由此可见，使用区块链替代集中式的中央权威的同时，结合分层管理的方式，已经一定程度解决了节点能力弱的问题，唯一在细节上的区别是区块链仅用于提供存储能力还是同时提供存储与计算能力，这里存储指代的内容大致包括设备收集或产生的数据、访问控制记录、ACL、(属性-权限)关联关系和属性集等内容，计算指在区块链中完成权限的比较与授予。之前提到的论文中，一部分仅将权限存储在区块链内，权限的比较（即策略的执行过程）是在链下进行的，这称作仅利用了存储功能，将权限、策略执行过程全部放在区块链中执行，称为同时利用了区块链的存储与计算功能。后一种方式充分发挥了智能合约的能力，在智能合约中执行访问控制策略，有助于防止设备恶意拒绝已授予的访问权限。 分层管理在解决节点能力弱的问题的同时，也解决了节点数量多，管理不便的问题。但区块链存储的高额代价、较慢的交易确认速度，都与物联网快速增长的数据量冲突，这一问题属于在实现基本的访问控制功能上的优化，可通过链下存储数据、链上存储数据哈希，压缩存储，设计更好的共识来完成。然而当前主流的共识 动态接入的问题主要指的是在物联网系统中，设备的加入和退出比较频繁的场景，但区块链本身的特性就足以应对这种情况。ABAC模型应对的动态性主要指的是实现了访问控制的合约自动应对访问请求而尽量减少管理者后续的参与的情况，管理者只需要针对性的更新属性和策略，不必对每个请求都专门定义策略。两者相互补充。 除了上一部分提到的问题外，区块链还引入一些新的问题 模型设计及实现。一个好的访问控制模型设计或实现仍然能带来很多好处，这里主要指智能合约实现访问控制模型的方式，比如[9]就进行了良好的功能划分。同时，由于主要的功能都基于智能合约实现，合约的安全性急剧上升，虽然区块链提供不可篡改特性，但合约代码本身的安全漏洞仍然存在，而且导致了漏洞发现后无法及时的更新，因此合约部署前的安全性检查至关重要。 区块链存储的访问控制策略或交易数据本身的隐私。利用了区块链提供的信任，取代了传统的中央权威，将权限和策略存在了区块链中，但区块链的数据是对整个区块链网络的用户公开可见的，这种情况可能在某些场景中不适用，为了满足需求，需要可选的实现对交易以及合约的隐私保护。Quorum的隐私交易管理器是能找到的最好方案，我们也不必去做重复造轮子的工作。 跨链访问。区块链可以轻松实现跨域访问控制，但仅仅是小范围的，用于一个商业联盟。一条链提供全世界的访问控制显然不可能，跨链访问控制是后续一个必须进行的工作。 ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:4:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"5. 可参考的方案设计 Ali Dorri. Blockchain in Internet of Things:Challenges and Solutions Ali Dorri设计的架构由smart home, overlay network, cloud storage三部分组成 Oscar Novo. Blockchain Meets IoT:An Architecture for Scalable Access Management in IoT 这篇论文中IoT设备不属于区块链网络，通过Management Hub与区块链交互。这种方法使IoT设备不再收到有限能力的限制，并且减小了延迟。另外，该论文中的方案针对可扩展性进行了优化，可支持大批量设备的加入退出和地理上位于不同位置的传感器网络的统一管理。 IoT设备在Manager的控制下注册，一个IoT设备可以属于多个Manager。注册完成后Manager通知Management Hub，同时将Management Hub的地址传递给设备。Management Hub需要能找到最近的区块链节点，从而获取策略信息。 合约中设备和管理者注册结构是mapping，策略定义是一个设备对另一个设备的资源是否有访问权，设备由公钥标识，资源由资源名标识，权限则包括查看、修改、执行。 该方案中为了可扩展性和实时性做了妥协，但这种结构下管理中心的存在是最大的危险，在可扩展性、吞吐量和延迟等方面存在分片、雷电网络等解决方案。无独立能力的物联网设备在Manager控制下注册的思路值得借鉴。智能合约中注册和策略的定义实现方式也值得学习。 我们对上述两个方案做了一点比较，首先是架构方面，具体表格如下 Ali自己设计了区块链，Oscar使用以太坊 Ali的方案中一共涉及三种区块链，其中Shared BC是一个人管理多个智能家庭的特殊情况，以下比较不考虑（BC是Blockchain的简称） Ali方案中的Local BC实际上只是用了区块链的结构，但本身是集中式的，只有一个或少数几个高资源设备维持链 两人的方案中，普通的有资源限制的物联网设备都不参与BC 比较的方面 Oscar Ali:Local BC Ali:Overlay BC 区块链可见性 论文中的验证实现是Private，但方案的最终目标是Public Private Public BC参与者 Manager，以及其它的以太坊BC节点 一个或少数几个高资源设备 智能家庭miner，智能家庭的其它高资源设备，用户的智能手机或个人电脑 共识机制 PoW 无 无 涉及的交易类型 设备注册，访问控制策略定义与修改 store, access, monitor, remove, genesis access, store, genesis 存储方式 未提及，猜测是传统的集中式 集中式（Local storage） 集中式（cloud storage） BC是否保存IoT设备产生的数据 否 是，但非实时 是，但非实时 访问控制实现方式 智能合约 策略头 请求者，被请求者和转发三个公钥列表 权限查询和执行 management hub从最近的区块链节点查询并执行 miner从策略头查询并执行 CH进行公钥匹配，并执行 IoT设备识别 公钥 设备ID 公钥 对BC的控制权 没有人 智能家庭所有者 没有人 对miner/CH/manager的信任 信任级别相同 信任级别相同 信用有等级 如何选择miner/CH/manager 自选 屋主选择 簇中节点选举 激励机制 有 无 其次是实现方式上 Ali Dorri的方案中，访问控制机制的核心是Local BC中的策略头（policy header），权限由智能家庭的主人直接定义在策略头中，交易发生之前先由miner在策略头中查询是否拥有权限，再执行。Overlay BC中因为有cluster和cluster header，维持着三个公钥列表，执行着一部分的权限控制。 Oscar Novo的方案中，权限定义在智能合约里，由manager与智能合约交互完成权限的定义与修改，由management hub与BC任意节点交互完成权限的查询和执行 再次是安全方面 首先分析对安全和隐私的需求是否得到实现以及如何实现。关于信息安全框架，国外主要从机密性、完整性和可用性三方面分析，国内从内容安全、数据安全、运行安全和实体安全四层分析。Ali的论文中是前者。 需求 Ali如何保证 Oscar如何保证 机密性 通过对称加密实现 采用CoAP的C语言实现LibCoAP，通过利用tinydtls框架实现安全通信 完整性 通过哈希实现 未采用相关机制保证 可用性 通过限制设备和miner可接受的交易实现 通过CH维持的三个公钥列表过滤交易 用户控制 通过在本地BC中记录交易实现 通过manager与智能合约交互定义和修改权限实现 身份鉴别 通过使用策略头和共享密钥实现 manager和manager管理下的IoT设备都需要再区块链中注册 然后分析两方案对各种常见的攻击是否能有效应对。 Ali Oscar Sybil 一个智能家庭内的设备有自己的设备ID manager和IoT设备都要注册，且IoT设备由公钥唯一识别 spoofing 访问权限是由屋主直接定义的，如果家里的设备被屋主信任，那么不会出现欺骗，如果不被信任，不会授予权限，唯一的问题是屋主要手动定义权限 manager和IoT设备都会进行注册，但智能合约的地址以及management hub要寻找最近的区块链节点的地址，这两种地址可能不可靠，带来的后果也很严重。 tampering 覆盖网络中的交易是签名的， 访问权限是不可篡改的，由区块链保证，但IoT设备提供的数据难说 DDoS 首先，攻击者不可能直接在智能家居设备上安装恶意软件，因为所有的交易都由miner检查，所有的设备都无法直接访问。其次，假设设备被感染，称为恶意节点，由于所有传入传出的请求都由miner通过检查策略头授权，构成DDoS攻击流量的请求是不会被授权的CH会匹配公钥，从而阻止这种攻击，但使用不同的公钥，这种攻击有可能达成 可能 repudiation 会达成，但会被发现，从而簇中节点重新选举CH 可能，management hub是否执行策略，区块链无法检查 然后是隐私 Ali为了防止Linking攻击，允许用户将任意交易发到覆盖网络，并且每个交易的ID和公钥都可变。 Oscar的方案区块链和物联网是分离的，没谈论隐私的问题 最后是性能 Ali Dorri的方案中，区块链不存储传感器数据。作者通过使用Cooja仿真器仿真智能家居场景，和没有使用加密，哈希和区块链的场景做对比，结果如下，虽然引入了额外的开销，但作者认为相比于该方案带来的安全性和隐私性，额外引入的这些开销是可以接受的。 Packet 开销：多一个策略头，比原本的大 时间开销：由于额外的加密和哈希操作，需要更多的时间，但引入的额外时间最多不超过20ms，可以接受。 能量开销：能耗几乎增加了一倍。 Oscar Novo的方案中，区块链也不存储数据，而是只存储访问策略，所以处理实时数据和非实时数据没有区别，因为权限都能实时查询到，基本没有延迟。在实验仿真中，考虑不同数量的并发客户端（management hub或IoT 设备）每秒请求数及消息数的变化，该方案能支持大量的并发请求，满足物联网的需要。 A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory 该文结合区块链技术提供轻量级和可扩展；利用白名单和非对称加密提高安全和隐私；引入安全和隐私模型帮助分析架构。文中提到的数据库是存放数据的地方，指的确实是云，但是是由多个管理中心的存储设备结合形成的分布式的云。区块链由管理中心维护，因此，管理中心的存储中同样存放着区块数据。 问题：传感层的微型计算机和网关的区别。文中描述为管理中心是智能边缘网关和云的结合。是网关？那这些微型计算机呢 架构解释：传感器收集数据，交给微型计算机，微型计算机在管理中心为设备注册唯一的身份，并预处理设备数据。然后，微型计算机向管理中心申请存储权限，吧数据放入缓冲池，数据量累积到一定程度后，管理中心完成工作量证明，将数据加密存入数据库。所有的权限许可都会生成区块记录并存在区块链中。动态验证是指权限是有时间限制的，一段时间后需要重新申请。数据库正是云，云基于这些数据提供如可视化等多种服务，用户节点需要访问时，要先经过白名单和动态认证，然后才能获得访问权限，同样，用户节点也需要周期性的重新申请权限。 访问控制的实现：主体、对象、访问矩阵、访问属性，权限级别 Smart Contract-Based Access Control for the Internet of Things 访问控制由三个合约：访问控制合约ACC，判决合约JC，注册合约RC实现。相比其它方案的优点时加入了处罚机制。 抽象结构为访问控制矩阵。实际实现是访问控制列表，列表中每条包括subject，object的资源，subject执行的操作，以及对操作的许可（allow或deny）。 每个ACC实现一对节点的访问控制，JC进行恶意行为判决，RC存储JC和ACCs信息并提供管理合约的功能。如下图所示。 给我们的借鉴是恶意行为记录，判决，处罚，以及如何在时间上做限定。 Decentralizing Privacy：Using Blockchain to Protect Personal","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:5:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"6. 可参考的实验设计 对众多论文仿真实验的方式做总结，从而为自己的仿真实验的实现提供参考。 BAD: a Blockchain Anomaly Detection solution 该实验的目的是检测对等节点上由日蚀攻击引起的分叉，然后分享给信息给其它节点从而构建一个参考模型，从而检测未来可能出现的同样的攻击。 实验设计 为了简单和清晰起见，我们在这里描述了一个已经在我们的真实系统上部署和运行的模拟环境。该环境由两个分离的私有IP网络A和B组成，两个网络通过一个路由器连接。在A（B也一样）中部署两个全节点和一个轻客户端。一方面，两个全节点A1和A3（B中为B1和B3）运行在一个拥有4GB RAM和Ubuntu 16.04系统的虚拟机上，并且都运行在regtest实验模式下（该模式中创建的本地测试环境可以按需即时的生成区块和无实际价值的数字资产），A3（B中为B3）由恶意用户控制。另一方面，我们使用比特币Java版钱包BitcoinJ作为轻客户端，运行在具有4GB RAM和win8系统的机器上。该钱包即A2（B中为B2)在日蚀攻击中扮演受害者。A1和A3彼此连接，这意味着它们可以交换区块信息并达成最长链共识。A和B中的节点维护同一条区块链。 攻击检测和防御 我们对A2做日蚀攻击，强迫其只与恶意节点A3通信，A3不与A1交换区块信息从而避免被网络A中其它节点检测到（通过将A1的IP地址从连接节点列表中删掉）。然后A发送给A2三个包含虚假或恶意交易的区块，区块被A2接受并连接到A2认为的最长链上。因为这3各区块包含A3创建的恶意交易，所以A2此时实际上已被攻击。攻击结束后所有连接重新建立，A2接收到了其它节点的正确的区块链信息，但不丢弃三个恶意区块，并且，这些恶意区块的信息会广播给其它节点，本实验中指B2。接下来，一旦在网络B中执行相同的攻击，因为B2有能检测到B3发送的区块信息中包含A2发送过来的恶意区块相似或相同的交易，就可以拒绝接受这些区块，从而避免受攻击。然后，B2同样会把接受到的恶意区块信息在对等网络中共享。 问题 实验中描述的情况，第一，两次攻击包含的恶意交易是相同的，所以才能在第二次检测到，局限性应该很大。第二，网络中不仅要广播正常的区块，还要广播恶意区块，网络负载很大。第三，每个节点最后都会维护一个恶意信息库，并且在接受到区块的时候查询库做比对，不管是存储的开销还是比对的时间开销都很大。 Work-in-Progress: Integrating Low-Power IoT devices to a Blockchain-Based Infrastructure 该实验是要模拟低资源的物联网设备如何接入基于区块链的物联网基础设施，部署的区块链是以太坊私有区块链，目的是将LoRa网关和区块链通过基于事件的通信机制集成起来。 实验设计 本实验中，一个低功耗的物联网设备发送位置信息到LoRa网关，然后，LoRa网关通过基于以太坊客户端geth将位置信息发送到智能合约，从而存储在私有的以太坊区块链中。使用连接到Dragino LoRa / GPS Hat的Raspberry Pi 2构建发送位置信息的物联网终端设备，使用IMST的名为iC880A的LoRa集成开发板连接到Raspberry Pi 3构建LoRa网关。 为了实现这样的双向LoRaWAN-Ethereum代理，网关应当同时运行LoRa协议软件和终端设备通信，运行以太坊客户端上传数据到区块链网络。另外，建立一个私有的以太坊网络，设置较低的挖矿难度换取更快的响应时间。 为了使网关和区块链交互，在区块链里部署一个智能合约。最后，还开发一个智能代理，一遍从LoRa的包转发器捕获所有数据，并通过JSON-RPC接口提供给geth并调用智能合约。 智能合约“Bridge\"有两个事件（Process和Notify），两个函数（request()和activate()）以及相应的构造和销毁方法。无论何时网关收到数据，区块链客户端都会调用querry()方法，将收到的数据作为参数，该调用合约的交易会被挖矿并收集到区块，变成区块链的一部分。节点们监听Notify事件从区块链客户端获取callback，从而采取相应的动作。相似的，其它节点也可以调用activate()发送消息给网关远程激活物联网终端设备。网关将一直监听Process事件，只有被寻址的网关对收到的消息采取行动。 合约执行流程 When mobile blockchain meets edge computing 针对边缘物联网节点算力不足的情况，提出从边缘服务器借算里的思想 实验设计 在移动区块链网络中，节点（如移动设备和物联网设备）需要在边缘服务器上执行挖矿。实验使用了一台Intel Xeon CPU E5-1630工作站作为边缘服务器提供算力，多台安卓设备作为移动节点，节点安装了移动区块链客户端应用，扮演矿工的角色。客户端会使用内部传感器（GPS或加速度传感器等）记录数据，发起交易并在网络中传输数据。有两台屏幕显示以太坊数据，移动节点使用客户端通过网关连到边缘服务器。基本的挖矿步骤如下：矿工从边缘服务器请求算力来挖矿，挖到的区块可以通过以太坊的功能来访问和分发。 实验模型 ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:6:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"7. 我们的方案 考虑到了上述提到的所有问题，我们的设计与实现的要点包括 通过智能合约实现ABAC，同时利用区块链提供的存储与计算能力，存储实体属性和访问控制策略，并且在合约中进行权限判定而非链下。 合约的实现基于[9]的工作，对功能进行良好的划分 采用分层管理 采用共识速度高的PBFT 采用Quorum提供合约隐私和交易隐私 后续可能加入压缩存储的工作，用来应对区块链数据的快速增长。 虽然上面的五点已经是特殊的工作，但还是要和原型论文[9]以及其它使用智能合约实现的基于属性的访问控制做对比，方案的特殊性如下 完全基于智能合约实现整个访问控制过程，属性集和策略全部定义在链上，而非其它方案设计复杂的密码协议或将策略定义在链下 同原型[9]的区别是每个设备关联有个访问控制合约，基于属性完成访问控制两点，目的是减小运行压力和实现动态性 使用联盟链Quorum进行实验，IBFT共识提高交易速度，隐私交易管理器实现交易和合约隐私 上面提到的东西都是抽象性的，我们需要把这些东西放到一个实际的应用场景下，待选的应用场景在第1节已经做了描述，这里讨论一下实验设计。 工业供应链场景，涉及的角色包括：工厂、设备维修商、监管机构、产品运输和分销过程涉及的接触者。访问控制权限应分两方面：访问数据、请求某IoT设备执行。工厂内，所有设备的运行数据通过传感器(震动传感器)收集，维修商有权查看它们并做出评估[25]；生产过程可能涉及不同设备间的互访问，或者请求某些设备执行操作(看过的某篇论文有提到车间之间的关系)；产品运输过程，温湿度、GPS、时间等属性信息，决定了不同参与者的访问权限。 Arduino连接震动传感器收集数据，维修商角色有权访问，工厂有权撤销访问权限； Arduino连接小电机，请求对小电机的执行权限 Arduino或树莓派连接温湿度传感器、GPS Hat，根据角色、时间决定权限授予情况 为了完善场景描述和实验设计需要重新回顾的文章 Figueroa S, Anorga J, Arrizabalaga S, et al. An Attribute-Based Access Control Model in RFID Systems Based on Blockchain Decentralized Applications for Healthcare Environments[J]. The first computers, 2019, 8(3). Miller D. Blockchain and the Internet of Things in the Industrial Sector[J]. IT Professional, 2018, 20(3): 15-18. 那篇工厂车间之间产品传送场景的描述(先把论文找出来) 如何充分利用IoT设备的属性，充分利用区块链的优势，证明使用区块链的好处，使用基于属性的访问控制的必要性，继续考虑 ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:7:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"下一步的研究方向 1、补全当前方案 细化工作，因为当前返回的结果仅仅是对访问控制请求同意还是拒绝，可以分两种情况分别细化 对数据，存储到链下，访问控制通过时直接返回哈希(类似于data share方向) 对控制命令，直接执行并在执行完毕后返回结果 架构调整，比如Judge合约其实可以删除，其功能合并到ACC 用docker实现 \u0026 区块链实时状态查看 主要是当前的quorum区块链浏览器都是基于docker的 新加入的节点如何获取ether用于gas消耗的问题 基于属性的访问控制进一步自动化必须的属性和策略规则的自动发现机制 合适的前端页面 2、异常检测 继续先前异常检测的工作，主要是协作异常检测，利用智能合约和当前的访问控制结构，每个设备的ACC(访问控制合约)本地运行检测模型，然后有一个单独的合约进行合并统计 3、区块链压缩 基于区块链不断增长的容量，修改共识源码，过滤不相干数据，并在每轮共识前先进行一次压缩 4、性能测试工具 编写区块链的性能测试工具 ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:8:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"中期总结 中期答辩的时候在纸上做了一些总结，现在把这些内容记录到这里。 首先，要讲清楚的几件事是 做了一个什么样的工作； 为什么做这个工作； 创新性在哪里； 需要哪些方面的数值结果、如何分析这些结果 所作工作的关键词是：blockchain, IoT, smart contract, ABAC, misbehavior detect, reputation 1、海量设备管理问题（Done） IoT 设备性能不足以作为区块链节点；节点越多达成共识时间越长；对联盟链来说，投票权很重要，设备数量更多的企业会拥有更多投票权 解决方法：分层结构 2、访问控制实现（Done） 原始论文使用了访问控制矩阵，为每一个 subject-object 对都定义了一个合约，这样会导致区块链体积快速增长，而且当遇到没有预定义的访问控制权限时，需要即时的定义 解决方法：使用 ABAC，为每个设备定义合约，从而减少合约数量，未设定访问控制策略标记为 Not applied 总结：一个功能上的完善，一个存储性能上的优化 3、恶意行为检测 基于信誉阻止短时间大量访问和其它几种恶意行为，利用 require 阻止非法增删改（Done） 应当测试奖励、惩罚、容忍、报警四个功能（Doing） 应当有数值结果进行衡量，比如公平性（基尼系数）和网络拥塞程度（Doing） 根据 subject 历史行为、操作严重性做决策，优化决策算法（Todo） 4、数值结果 和其它基于属性的、用智能合约实现的访问控制方案相比，比较如下方面的内容 存储：各种方案对区块链造成的存储压力的不同； Gas 消耗，如果都是基于以太坊的，大家的 Gas 消耗的不同； 时间 各种增删查改、访问控制操作需要的时间，这之前要确定这些时间是受合约设计的影响更大，还是受区块链同步速度的影响大； 属性的数目、策略条目的数目对访问时间的影响。 ","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:9:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"参考文献 [1] Zyskind G, Nathan O, Pentland A, et al. Decentralizing Privacy: Using Blockchain to Protect Personal Data[C]. ieee symposium on security and privacy, 2015: 180-184. [2] Cruz J P, Kaji Y, Yanai N, et al. RBAC-SC: Role-Based Access Control Using Smart Contract[J]. IEEE Access, 2018: 12240-12251. 链接 [3] Maesa D D, Mori P, Ricci L, et al. Blockchain Based Access Control[C]. distributed applications and interoperable systems, 2017: 206-220. [4] Ouaddah A, Elkalam A A, Ouahman A A, et al. FairAccess: a new Blockchain-based access control framework for the Internet of Things[J]. Security and Communication Networks, 2016, 9(18): 5943-5964. [5] Ouaddah A, Elkalam A A, Ouahman A A, et al. Towards a Novel Privacy-Preserving Access Control Model Based on Blockchain Technology in IoT[J]. Advances in intelligent systems and computing, 2017: 523-533. 链接 [6] Jemel M, Serhrouchni A. Decentralized Access Control Mechanism with Temporal Dimension Based on Blockchain[C]. international conference on e-business engineering, 2017: 177-182. 链接 [7] Dorri A, Kanhere S S, Jurdak R, et al. Blockchain for IoT security and privacy: The case study of a smart home[C]. pervasive computing and communications, 2017: 618-623. [8] Ouaddah A, Mousannif H, Elkalam A A, et al. Access control in the Internet of Things[J]. Computer Networks, 2017: 237-262. [9] Zhang Y, Kasahara S, Shen Y, et al. Smart Contract-Based Access Control for the Internet of Things[J]. arXiv: Cryptography and Security, 2018. [10] Angrish A, Craver B, Hasan M, et al. A Case Study for Blockchain in Manufacturing: “FabRec”: A Prototype for Peer-to-Peer Network of Manufacturing Nodes[J]. arXiv: Computers and Society, 2018. [11] Novo O. Blockchain Meets IoT: An Architecture for Scalable Access Management in IoT[J]. IEEE Internet of Things Journal, 2018, 5(2): 1184-1195. [12] Hwang D, Choi J, Kim K, et al. Dynamic Access Control Scheme for IoT Devices using Blockchain[C]. international conference on information and communication technology convergence, 2018: 713-715. [13] Ding S, Cao J, Li C, et al. A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT[J]. IEEE Access, 2019: 38431-38441. [14] Figueroa S, Anorga J, Arrizabalaga S, et al. An Attribute-Based Access Control Model in RFID Systems Based on Blockchain Decentralized Applications for Healthcare Environments[J]. The first computers, 2019, 8(3). [15] Zhang Y, He D, Choo K R, et al. BaDS: Blockchain-Based Architecture for Data Sharing with ABS and CP-ABE in IoT[J]. Wireless Communications and Mobile Computing, 2018: 1-9. [16] Lin C, He D, Huang X, et al. BSeIn : A blockchain-based secure mutual authentication with fine-grained access control system for industry 4.0[J]. Journal of Network and Computer Applications, 2018: 42-52. [17] Pinno O J, Gregio A, Bona L C, et al. ControlChain: Blockchain as a Central Enabler for Access Control Authorizations in the IoT[C]. global communications conference, 2017: 1-6. [18] Park J, Sandhu R. The UCON ABC usage control model[J]. ACM Transactions on Information and System Security, 2004, 7(1): 128-174. 链接 [19] Zhang G, Gong W. The Research of Access Control Based on UCON in the Internet of Things[J]. Journal of Software, 2011, 6(4): 724-731. 链接 [20] Alansari S, Paci F, Sassone V, et al. A Distributed Access Control System for Cloud Federations[C]. international conference on distributed computing systems, 2017: 2131-2136. 链接 [21] Hashemi S H, Faghri F, Campbell R H, et al. Decentralized User-Centric Access Control using PubSub over Blockchain.[J]. arXiv: Cryptography and Security, 2017. 链接 [22] Rifi N, Rachkidi E, Agoulmine N, et al. Towards using blockchain technology for IoT data access protection[C]. ieee international conference on ubiquitous wireless broadband, 2017: 1-5. 链接 [23] Outchakoucht A, Essamaali H, Leroy J P, et al. Dynamic Access Control Policy based on Blockchain and Machine Learning for the Internet of Things[J]. International Journal of Advanced Computer Science a","date":"2019-11-29","objectID":"/2019/blockchain-based-access-control-for-iot/:10:0","tags":["科研记录"],"title":"研究记录9-区块链用于物联网访问控制梳理","uri":"/2019/blockchain-based-access-control-for-iot/"},{"categories":["Golang学习之路"],"content":"结构体是一种非常重要的结构，用到的地方非常多，在 Go 中，结构体还是实现面向对象编程的基础。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:0:0","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1. 结构体 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:0","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1.1 定义与初始化 结构体定义方式如下： type identifier struct { field1 type1 field2 type2 ... } 大括号中的每一行称为一个字段，每个字段都有一个类型和一个名字，在一个结构体中，字段名必须是唯一的。结构体名和字段名的命名遵循可见性规则，即使用首字母的大小写来表示可导出和不可导出。但是需要注意，一个可导出的结构体类型中可以存在不可导出的字段。 结构体的字段可以是任意类型，甚至可以是结构体本身、函数或者接口。一个简单的结构体定义示例如下 type T struct { a,b int } 结构体是自定义数据类型，因此我们可以向基本数据类型一样声明/定义一个结构体类型的变量，声明时会分配内存并默认使用每个字段类型的零值来初始化。我们也可以手动初始化一个结构体，使用点号符给字段赋值，示例如下。另外，访问结构体内字段的值时同样使用点号符，这种使用点号符赋值和获取字段值的方式叫做选择器(selector)， var s T s.a = 5 s.b = 8 由于结构体也是值类型，使用new函数创建。注意，使用 new 得到的 t 是指向结构体的指针。 var t *T = new(T) t := new(T) // 简单方便地写法，最常用 至此我们注意到，使用结构体时我们可能遇到两种类型：结构体类型和结构体指针类型，这两种类型都可以通过选择器的方式来使用，如下，v.i 和 p.i 都可以得到正确的值，在理解的时候可以想象底层对结构体指针 p 自动做了解引用，如 (*p).i。 type myStruct struct { i int } var v myStruct // v是结构体类型变量 var p *myStruct // p是指向一个结构体类型变量的指针 v.i p.i (*p).i 除使用选择器初始化结构体字段外，一种更简短更常用的结构体初始化方法如下 ms := struct1{10, 15.5, \"Chris\"} //结构体类型 ms := \u0026struct1{10, 15.5, \"Chris\"} //结构体指针类型 ms := \u0026struct1{f1:15.5，i1:10} //括号内声明字段名，这样可以不按定义的字段顺序，甚至省略部分字段 其中第二行称为混合字面量语法，但底层仍然会调用new()，因此与使用 new() 初始化是等同的。以type Point struct {x,y int}为例，这几种初始化方式的内存布局如下 从上图可以看出，结构体和它包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套其它的结构体，同样如此。 type Rect1 struct {Min, Max Point } type Rect2 struct {Min, Max *Point } 一个使用结构体的完整例子如下 package main import \"fmt\" type struct1 struct { i1 int f1 float32 str string } func main() { ms := new(struct1) ms.i1 = 10 ms.f1 = 15.5 ms.str= \"Chris\" fmt.Printf(\"The int is: %d\\n\", ms.i1) fmt.Printf(\"The float is: %f\\n\", ms.f1) fmt.Printf(\"The string is: %s\\n\", ms.str) fmt.Println(ms) } //Output: The int is: 10 The float is: 15.500000 The string is: Chris \u0026{10 15.5 Chris} ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:1","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1.2 结构体标签 实际上，一个完整的结构体定义，在字段名和类型外，还有一个标签(tag)部分。标签是一个字符串，用来对字段进行一定的说明，对程序功能没有太大的作用，因此前面才没有介绍。正如我们说的，它的主要作用就是对字段进行说明，标签只有包 reflect 能获取。 package main import ( \"fmt\" \"reflect\" ) type TagType struct { // tags field1 bool \"An important answer\" field2 string \"The name of the thing\" field3 int \"How much there are\" } func main() { tt := TagType{true, \"Barak Obama\", 1} for i := 0; i \u003c 3; i++ { refTag(tt, i) } } func refTag(tt TagType, ix int) { ttType := reflect.TypeOf(tt) ixField := ttType.Field(ix) fmt.Printf(\"%v\\n\", ixField.Tag) } //Output: An important answer The name of the thing How much there are ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:2","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1.3 匿名字段与内嵌结构体 结构体的字段名其实和变量很相似，不需要时也可以用空白符 _ 代替，但实际上，也可以直接省略，即整个字段只有类型，此时类型就是字段名，这种字段叫做匿名字段。如下例，通过类型 t.float32 来获取存储在匿名字段中的数据，也因为这种调用方式，一个结构体中对每一种数据类型只能有一个匿名字段。 package main import \"fmt\" type T struct { a int float32 // anonymous field } func main() { t := T{6, 7.5} fmt.Println(t.float32) } //Output: {6 7.5} 由于结构体本身也是一种数据类型，因此也可以作为匿名字段使用，称为内嵌结构体。通过内嵌结构体可以实现 OO 编程种的继承。 package main import \"fmt\" type A struct { ax, ay int } type B struct { A bx, by float32 } func main() { b := B{A{1, 2}, 3.0, 4.0} fmt.Println(b.ax, b.ay, b.bx, b.by) fmt.Println(b.A) } //Output: 1 2 3 4 {1 2} 使用内嵌结构体的时候，很可能会出现命名冲突（继承来的字段名和当前结构体的某个字段名相同），这种情况下外层的名字会覆盖内层的名字，但两者的内存空间都会保留，下例中d.b的调用不会出错，指的是float32，而不是B.b，进行内层调用可以使用d.B.b type B struct {a, b int} type D struct {B; b float32} var d D 但下面这种情况，c.a的调用会导致编译器错误,只能由程序员手动修改 type A struct {a int} type B struct {a, b int} type C struct {A; B} var c C ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:3","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1.4 结构体工厂 可以为结构体定义一个工厂来创建结构体实例，工厂的名字通常以new或New开头，这是一种很常用的方法。假设定义了如下File结构体类型 type File struct { fd int //文件描述符 name string //文件名 } 下面是为File结构体创建的工厂，返回一个指向结构体的指针 func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } return \u0026File{fd, name} } 然后这样调用它 f := NewFile(10, \"./test.txt\") 这种方式可以模拟OO编程中使用new的实例化，如果要完全等同，还需要利用可见性规则禁止使用Go内置的new()函数 type matrix struct { ... } func NewMatrix(params) *matrix { m := new(matrix) // 初始化 m return m } 然后在其它包里就只能使用工厂创建结构体实例 package main import \"matrix\" ... wrong := new(matrix.matrix) // 编译失败（matrix 是私有的） right := matrix.NewMatrix(...) // 实例化 matrix 的唯一方式 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:4","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2. 方法 Go中的方法是作用在接收者上的一个函数，接收者是某种类型的变量。定义方法的一般格式如下 func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... } 在func关键字之后，方法名之前的括号中声明接收者和接收者类型。同样还可以看到，方法的本质仍然是函数，只不过是针对特定变量的函数，除了括号中的接收者声明，其它部分和普通函数没有不同。 接收者几乎可以是任何类型的变量，包括基本数据类型、数组的别名类型、结构体、函数等，但不可以是接口，因为方法是需要实现的，而接口只是抽象定义。 如果接收者变量recv已经在其它地方进行了初始化，Method1是它的方法名，那么方法的调用格式为recv.Method1()，同结构体相似，如果recv是指针，调用时自动解引用。 如果方法不需要使用recv的值，可以用空白符_替换它 func (_ receiver_type) methodName(parameter_list) (return_value_list) { ... } 类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集（method set）。 一个接收者变量加上它的方法等价于面向对象中的一个类，区别只在于Go中方法的代码与变量定义是分离的，只要在同一个包中即可。 因为方法是函数，所以方法同样不允许重载，但不同的接收者变量可以有相同名字的方法，即使它们在同一个包中，一个例子如下 func (a *denseMatrix) Add(b Matrix) Matrix func (a *sparseMatrix) Add(b Matrix) Matrix 一个结构体方法的例子如下 package main import \"fmt\" type TwoInts struct { a int b int } func main() { two1 := new(TwoInts) two1.a = 12 two1.b = 10 fmt.Printf(\"The sum is: %d\\n\", two1.AddThem()) fmt.Printf(\"Add them to the param: %d\\n\", two1.AddToParam(20)) two2 := TwoInts{3, 4} fmt.Printf(\"The sum is: %d\\n\", two2.AddThem()) } func (tn *TwoInts) AddThem() int { return tn.a + tn.b } func (tn *TwoInts) AddToParam(param int) int { return tn.a + tn.b + param } //Output: The sum is: 22 Add them to the param: 42 The sum is: 7 一个非结构体类型(数组别名)方法的例子如下 package main import \"fmt\" type IntVector []int func (v IntVector) Sum() (s int) { for _, x := range v { s += x } return } func main() { fmt.Println(IntVector{1, 2, 3}.Sum()) // 输出是6 } 变量和定义在它上面的方法必须在同一个包里定义，如下例是错误的，这也是为什么不能定义int这样的基本类型的方法，但可以定义基本类型的别名的方法 package main import \"container/list\" func (p *list.List) Iter() { // ... } func main() { lst := new(list.List) for _= range lst.Iter() { } } ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:0","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.1 函数和方法的区别 函数将变量作为参数：Function1(recv) 方法在变量上被调用：recv.Method1() 在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。 不要忘记 Method1 后边的括号 ()，否则会引发编译器错误：method recv.Method1 is not an expression, must be called 接收者必须有一个显式的名字，这个名字必须在方法中被使用。 receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。 在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。 方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:1","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.2 指针或值作为接收者 如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。一个例子如下 package main import ( \"fmt\" ) type B struct { thing int } func (b *B) change() { b.thing = 1 } func (b B) write() string { return fmt.Sprint(b) } func main() { var b1 B // b1是值 b1.change() fmt.Println(b1.write()) b2 := new(B) // b2是指针 b2.change() fmt.Println(b2.write()) } /* 输出： {1} {1} */ 指针方法和值方法都可以在指针或非指针上被调用，如上例，b1是值类型，而change()方法作用在指针类型上，b1.change()会被自动转换为(\u0026b1).change()；b2是指针类型，但write()方法是值类型，b2.write()会被自动转换成(*b2).write() ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:2","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.3 利用方法读取结构体中的未导出字段 本文开始对结构体的介绍中，提到结构体对外部可见，而结构体中的字段对外部不可见是可能发生的，对于这种情况，读取或修改结构体中的字段值可以通过作用在结构体上的方法完成，一个例子如下 package person type Person struct { firstName string lastName string } func (p *Person) FirstName() string { return p.firstName } func (p *Person) SetFirstName(newName string) { p.firstName = newName } 对其中定义的结构体字段进行调用 package main import ( \"./person\" \"fmt\" ) func main() { p := new(person.Person) // p.firstName undefined // (cannot refer to unexported field or method firstName) // p.firstName = \"Eric\" p.SetFirstName(\"Eric\") fmt.Println(p.FirstName()) // Output: Eric } ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:3","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.4 内嵌类型的方法与继承 当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法 ， 这个机制提供了一种简单的方式来模拟面向对象语言中的子类和继承相关的效果。一个示例如下 package main import ( \"fmt\" \"math\" ) type Point struct { x, y float64 } func (p *Point) Abs() float64 { return math.Sqrt(p.x*p.x + p.y*p.y) } type NamedPoint struct { Point name string } func main() { n := \u0026NamedPoint{Point{3, 4}, \"Pythagoras\"} fmt.Println(n.Abs()) // 打印5 } 使用同名方法可以覆盖父类型中的方法，比如在上例中添加如下代码，会打印100 func (n *NamedPoint) Abs() float64 { return n.Point.Abs() * 100. } 因为一个结构体可以嵌入多个匿名类型，所以实际上可以实现简单的多重继承，如下例所示 package main import ( \"fmt\" ) type Camera struct{} func (c *Camera) TakeAPicture() string { return \"Click\" } type Phone struct{} func (p *Phone) Call() string { return \"Ring Ring\" } type CameraPhone struct { Camera Phone } func main() { cp := new(CameraPhone) fmt.Println(\"Our new CameraPhone exhibits multiple behaviors...\") fmt.Println(\"It exhibits behavior of a Camera: \", cp.TakeAPicture()) fmt.Println(\"It works like a Phone too: \", cp.Call()) } //Output: Our new CameraPhone exhibits multiple behaviors... It exhibits behavior of a Camera: Click It works like a Phone too: Ring Ring ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:4","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.5 在类型中嵌入功能 主要有两种方法来实现在类型中嵌入功能： A：聚合（或组合）：包含一个所需功能类型的具名字段。 B：内嵌：内嵌（匿名地）所需功能类型，像前一节 10.6.5 所演示的那样。 假设有一个 Customer 类型，我们想让它通过 Log 类型来包含日志功能，Log 类型只是简单地包含一个累积的消息（当然它可以是复杂的）。如果想让特定类型都具备日志功能，你可以实现一个这样的 Log 类型，然后将它作为特定类型的一个字段，并提供 Log()，它返回这个日志的引用。 使用聚合方式实现如下 package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string log *Log } func main() { c := new(Customer) c.Name = \"Barak Obama\" c.log = new(Log) c.log.msg = \"1 - Yes we can!\" // shorter c = \u0026Customer{\"Barak Obama\", \u0026Log{\"1 - Yes we can!\"}} // fmt.Println(c) \u0026{Barak Obama 1 - Yes we can!} c.Log().Add(\"2 - After me the world will be a better place!\") //fmt.Println(c.log) fmt.Println(c.Log()) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) Log() *Log { return c.log } //Output: 1 - Yes we can! 2 - After me the world will be a better place! 使用内嵌方式实现如下 package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string Log } func main() { c := \u0026Customer{\"Barak Obama\", Log{\"1 - Yes we can!\"}} c.Add(\"2 - After me the world will be a better place!\") fmt.Println(c) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) String() string { return c.Name + \"\\nLog:\" + fmt.Sprintln(c.Log) } //Output: Barak Obama Log:{1 - Yes we can! 2 - After me the world will be a better place!} 内嵌的类型不需要指针，Customer 也不需要 Add 方法，它使用 Log 的 Add 方法，Customer 有自己的 String 方法，并且在它里面调用了 Log 的 String 方法。 如果内嵌类型嵌入了其他类型，也是可以的，那些类型的方法可以直接在外层类型中使用。 因此一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:5","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"本篇介绍 Golang 中的接口与反射。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:0:0","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1. 接口 类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集，我们可以使用接口来定义方法集，但是这种定义是抽象的，不包含方法的代码实现，接口中也不能包含变量。 接口定义的基本格式如下 type Namer interface { Method1(param_list) return_type Method2(param_list) return_type ... } ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:0","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.1 接口理解 接口可以是空的，也就是不包含任何方法，空接口的底层实现是一个名为 eface 的结构体 type eface struct { _type *_type data unsafe.Pointer } type _type struct { size uintptr // type size ptrdata uintptr // size of memory prefix holding all pointers hash uint32 // hash of type; avoids computation in hash tables tflag tflag // extra type information flags align uint8 // alignment of variable with this type fieldalign uint8 // alignment of struct field with this type kind uint8 // enumeration for C alg *typeAlg // algorithm table gcdata *byte // garbage collection data str nameOff // string form ptrToThis typeOff // type for pointer to this type, may be zero } 非空接口的底层实现与空接口不同，是一个名为 iface 的结构体，非空接口中定义的方法的具体实现都放在 itab.fun 变量中 type iface struct { tab *itab data unsafe.Pointer } // layout of Itab known to compilers // allocated in non-garbage-collected memory // Needs to be in sync with // ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs. type itab struct { inter *interfacetype _type *_type link *itab bad int32 inhash int32 // has this itab been added to hash? fun [1]uintptr // variable sized } type interfacetype struct { typ _type pkgpath name mhdr []imethod } type imethod struct { //这里的 method 只是一种函数声明的抽象，比如 func Print() error name nameOff ityp typeOff } itab 可以简单理解为 接口类型+具体类型，interfacetype 是接口类型，包含包路径、方法等信息。_type 则是具体类型，空接口也包含这个字段。 关于接口值的理解是一件很重要的事，但是比较复杂。我们通过了解接口的内存布局来理解接口的本质，从而理解接口值。先看一个例子 type Stringer interface { String() string } type Binary uint64 func (i Binary) String() string { return strconv.Uitob64(i.Get(), 2) } func (i Binary) Get() uint64 { return uint64(i) } func main() { b := Binary{} s := Stringer(b) fmt.Print(s.String()) } 对比非空接口的底层实现，发现接口在内存中实际上由两个成员组成，如下图，tab 指向虚表，data 指向实际引用的数据 虚表描绘了实际的类型信息及接口的方法集，具体有哪些部分我们以及从 itab 结构体中看到了。注意在这里是 Stringer 接口的函数指针列表，而不是实际类型 Binary 的函数指针列表，只有在运行时遇到 s := Stringer(b) 这样的语句，才会生成接口对应的 Binary 类型的虚表。这样，当判定一种类型是否满足某个接口时，只需要判断类型的方法集是否完全包含接口的方法集即可。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:1","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.2 接口值 我们可以将一个变量声明为接口类型，var ai Namer，未初始化时，接口值为 nil。 type Shape interface { Area() float32 } func main() { var s Shape fmt.Println(\"value of s is\", s) fmt.Printf(\"type of s is %T\\n\", s) } //Output: value of s is \u003cnil\u003e type of s is \u003cnil\u003e 我们可以理解接口变量的值为 nil，那么为什么类型也是 nil 呢？上一小节我们理解接口的时候知道，接口其实就是定义在结构体中的两个指针，未初始化时这两个指针都是 nil，因此接口值是 nil，接口类型也是nil。 当我们初始化接口变量后，两个指针都有了具体指向的值，此时接口的值就是接口指向的类型的值，接口的类型就是实现了接口的变量类型。如下例，变量 i 本身是接口类型 Namer，先后指向实现了接口类型的 St1 和 St2 两个空结构体，其值和类型就发生了变化。 type Namer interface { Name() } type St1 struct { a int } func (st1 St1) Name() { fmt.Println(st1.a) } type St2 struct{} func (St2) Name() {} func main() { var i Namer = St1{2} fmt.Printf(\"type is %T\\n\", i) fmt.Printf(\"value is %v\\n\", i) i = St2{} fmt.Printf(\"type is %T\\n\", i) fmt.Printf(\"value is %v\\n\", i) } //Output: type is main.St1 value is {2} type is main.St2 value is {} ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:2","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.3 接口的实现 接口的实现是一种隐式的实现，只要某个类型的方法集完全包含接口的方法集，就属于实现了该接口，实现了接口的变量可以赋值给接口值。 package main import \"fmt\" type Shaper interface { Area() float32 } type Square struct { side float32 } func (sq *Square) Area() float32 { return sq.side * sq.side } func main() { sq1 := new(Square) sq1.side = 5 var areaIntf Shaper areaIntf = sq1 // shorter,without separate declaration: // areaIntf := Shaper(sq1) // or even: // areaIntf := sq1 fmt.Printf(\"The square has area: %f\\n\", areaIntf.Area()) } //Output: The square has area: 25.000000 空接口可以声明为 interface{}，同时因为空接口不包含任何方法，所以任何类型都默认实现了空接口。举个例子，fmt 包中的 Println() 函数，可以接收多种类型的值，比如：int、string、array等。这是因为它的形参就是接口类型，可以接收任意类型的值。 func Println(a ...interface{}) (n int, err error) {} 多个类型可以实现同一个接口，如下例，一个类型也可以实现多个接口。 package main import \"fmt\" type Shaper interface { Area() float32 } type Square struct { side float32 } func (sq *Square) Area() float32 { return sq.side * sq.side } type Rectangle struct { length, width float32 } func (r Rectangle) Area() float32 { return r.length * r.width } func main() { r := Rectangle{5, 3} // Area() of Rectangle needs a value q := \u0026Square{5} // Area() of Square needs a pointer // shapes := []Shaper{Shaper(r), Shaper(q)} // or shorter shapes := []Shaper{r, q} fmt.Println(\"Looping through shapes for area ...\") for n, _ := range shapes { fmt.Println(\"Shape details: \", shapes[n]) fmt.Println(\"Area of this shape is: \", shapes[n].Area()) } } //Output: Looping through shapes for area ... Shape details: {5 3} Area of this shape is: 15 Shape details: \u0026{5} Area of this shape is: 25 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:3","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.4 接口嵌套 Go 中的接口可以包含一个或多个其它接口，这相当于直接将这些内嵌接口的方法列举在外层接口中。下例中File接口包含了ReadWrite和Lock接口的所有方法 type ReadWrite interface { Read(b Buffer) bool Write(b Buffer) bool } type Lock interface { Lock() Unlock() } type File interface { ReadWrite Lock Close() } ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:4","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.5 类型断言 如果一个变量是接口变量，实际上其值的类型是不确定的，我们使用类型断言来检测值的具体类型 v := varI.(T) varI是一个接口变量，T是待检测类型，这一语句的作用是检测 varI 的动态类型是否和 T 一致，实质是将 varI 转换为 T 类型的值 package main import ( \"fmt\" \"math\" ) type Square struct { side float32 } type Circle struct { radius float32 } type Shaper interface { Area() float32 } func main() { var areaIntf Shaper sq1 := new(Square) sq1.side = 5 areaIntf = sq1 // Is Square the type of areaIntf? if t, ok := areaIntf.(*Square); ok { fmt.Printf(\"The type of areaIntf is: %T\\n\", t) } if u, ok := areaIntf.(*Circle); ok { fmt.Printf(\"The type of areaIntf is: %T\\n\", u) } else { fmt.Println(\"areaIntf does not contain a variable of type Circle\") } } func (sq *Square) Area() float32 { return sq.side * sq.side } func (ci *Circle) Area() float32 { return ci.radius * ci.radius * math.Pi } //Output: The type of areaIntf is: *main.Square areaIntf does not contain a variable of type Circle 类型断言可能失败，为了更安全的使用类型断言，使用如下的方式 if v, ok := varI.(T); ok { // checked type assertion Process(v) return } // varI is not of type T 由于断言是一个比较的过程，因此需要多次尝试，使用 switch 语句最为简便，不过要求所有 case 语句中列举的类型(nil除外)都必须实现对应的接口。 switch t := areaIntf.(type) { case *Square: fmt.Printf(\"Type Square %T with value %v\\n\", t, t) case *Circle: fmt.Printf(\"Type Circle %T with value %v\\n\", t, t) case nil: fmt.Printf(\"nil value: nothing to check?\\n\") default: fmt.Printf(\"Unexpected type %T\\n\", t) } //Output: Type Square *main.Square with value \u0026{5} 类型断言还有一种反向用法，就是测试它是否实现了某个接口，如下 type Stringer interface { String() string } if sv, ok := v.(Stringer); ok { fmt.Printf(\"v implements String(): %s\\n\", sv.String()) // note: sv, not v } 所以我们可以意识到，断言格式 varI.(T) 中的 varI 可以是任意变量，T 是任意类型，断言的实质就是将变量转换为 T 类型的值，然后进行比较。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:5","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.6 使用指针接收者和值接收者实现接口 虽然作用于变量的方法不区分变量是指针还是值，但是遇到接口时，会变得稍微复杂一点。 package main import ( \"fmt\" ) type List []int func (l List) Len() int { return len(l) } func (l *List) Append(val int) { *l = append(*l, val) } type Appender interface { Append(int) } func CountInto(a Appender, start, end int) { for i := start; i \u003c= end; i++ { a.Append(i) } } type Lener interface { Len() int } func LongEnough(l Lener) bool { return l.Len()*10 \u003e 42 } func main() { // A bare value var lst List // compiler error: // cannot use lst (type List) as type Appender in argument to CountInto: // List does not implement Appender (Append method has pointer receiver) // CountInto(lst, 1, 10) if LongEnough(lst) { // VALID:Identical receiver type fmt.Printf(\"- lst is long enough\\n\") } // A pointer value plst := new(List) CountInto(plst, 1, 10) //VALID:Identical receiver type if LongEnough(plst) { // VALID: a *List can be dereferenced for the receiver fmt.Printf(\"- plst is long enough\\n\") } } 在 lst 上调用 CountInto 时会导致一个编译器错误，因为 CountInto 需要一个 Appender，而它的方法 Append 只定义在指针上。 在 lst 上调用 LongEnough 是可以的，因为 Len 定义在值上。 在 plst 上调用 CountInto 是可以的，因为 CountInto 需要一个 Appender，并且它的方法 Append 定义在指针上。 在 plst 上调用 LongEnough 也是可以的，因为指针会被自动解引用。 Go语言规范中接口方法集的调用规则为： 类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集 类型 T 的可调用方法集包含接受者为 T 的所有方法 类型 T 的可调用方法集不包含接受者为 *T 的方法 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:6","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"2. 反射 反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分，在运行程序时，程序无法获取自身的信息。 支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。 Go 语言的反射系统无法获取到一个可执行文件空间或者一个包中的所有类型信息，仅仅是在运行时通过 reflect 包来访问指定的类型信息。 https://mp.weixin.qq.com/s/qJVfEWngSDg3It3UytPuxA ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:2:0","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"2.1 方法和类型的反射 Go 的反射包中比较重要和常用的有三个类型：Kind，Type，Value，其中 Type用来表示一个Go类型，Value为Go值提供了反射接口。 reflect.TypeOf 和 reflect.ValueOf 分别是定义在这两者之上的方法，函数原型如下 func TypeOf(i interface{}) Type func ValueOf(i interface{}) Value 其本质是检查接口的动态类型和动态值，一般用来返回被检查对象的类型和值。例如，x被定义为var x float64 = 3.4，那么reflect.TypeOf(x)返回type: float64，reflect.ValueOf(x)返回value: 3.4 因此，使用ValueOf转换获得的值，依然拥有自己的类型和值，反射包的Value有不少方法都可以作用于它，比如kind方法返回一个常量来表示类型，Type方法也返回值的类型，Int和Float等方法可以获取存储在内部的值，Interface方法可以还原接口值。示例如下 package main import ( \"fmt\" \"reflect\" ) func main() { var x float64 = 3.4 fmt.Println(\"type:\", reflect.TypeOf(x)) v := reflect.ValueOf(x) fmt.Println(\"value:\", v) fmt.Println(\"type:\", v.Type()) fmt.Println(\"kind:\", v.Kind()) fmt.Println(\"value:\", v.Float()) fmt.Println(v.Interface()) fmt.Printf(\"value is %5.2e\\n\", v.Interface()) y := v.Interface().(float64) fmt.Println(y) } //Output: type: float64 value: 3.4 type: float64 kind: float64 value: 3.4 3.4 value is 3.40e+00 3.4 由于x是一个float64类型的值，因此使用v.Float()获取它的实际值，其它类型的值可以使用Int(), Bool(), Complex, String() Kind方法总是返回底层类型，如 type MyInt int var m MyInt = 5 v := reflect.ValueOf(m) v.Kind()将返回reflect.Int ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:2:1","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"2.2 通过反射修改值 无论如何，利用反射修改值总是应该极为谨慎的，而且，不是所有的反射值都可以修改，是否可修改可通过CanSet()方法检测。v := reflect.ValueOf(x)函数传递了一个x的拷贝，对拷贝的修改无法影响原值，因此，若想修改原值，应传递指针，v = reflect.ValueOf(\u0026x)。此时v的类型是*float64，但依然不可修改，还需要最后一步，使用Elem()方法，至此才能使用SetFloat()修改原值，一个完整的例子如下 package main import ( \"fmt\" \"reflect\" ) func main() { var x float64 = 3.4 v := reflect.ValueOf(x) // setting a value: // v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value fmt.Println(\"settability of v:\", v.CanSet()) v = reflect.ValueOf(\u0026x) // Note: take the address of x. fmt.Println(\"type of v:\", v.Type()) fmt.Println(\"settability of v:\", v.CanSet()) v = v.Elem() fmt.Println(\"The Elem of v is: \", v) fmt.Println(\"settability of v:\", v.CanSet()) v.SetFloat(3.1415) // this works! fmt.Println(v.Interface()) fmt.Println(v) } //Output: settability of v: false type of v: *float64 settability of v: false The Elem of v is: \u003cfloat64 Value\u003e settability of v: true 3.1415 \u003cfloat64 Value\u003e ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:2:2","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"2.3 结构体的反射 对结构体进行反射，需要使用NumField()方法返回结构内的字段数量，然后通过for循环用索引获得每个字段的值Field(i)，最后可以使用索引调用签名在结构体上的方法：Method(i).Call(nil) package main import ( \"fmt\" \"reflect\" ) type NotknownType struct { s1, s2, s3 string } func (n NotknownType) String() string { return n.s1 + \" - \" + n.s2 + \" - \" + n.s3 } // variable to investigate: var secret interface{} = NotknownType{\"Ada\", \"Go\", \"Oberon\"} func main() { value := reflect.ValueOf(secret) // \u003cmain.NotknownType Value\u003e typ := reflect.TypeOf(secret) // main.NotknownType // alternative: //typ := value.Type() // main.NotknownType fmt.Println(typ) knd := value.Kind() // struct fmt.Println(knd) // iterate through the fields of the struct: for i := 0; i \u003c value.NumField(); i++ { fmt.Printf(\"Field %d: %v\\n\", i, value.Field(i)) // error: panic: reflect.Value.SetString using value obtained using unexported field //value.Field(i).SetString(\"C#\") } // call the first method, which is String(): results := value.Method(0).Call(nil) fmt.Println(results) // [Ada - Go - Oberon] } //Output: main.NotknownType struct Field 0: Ada Field 1: Go Field 2: Oberon [Ada - Go - Oberon] 但是尝试修改会得到错误，结构体中只有被导出字段才是可设置的。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:2:3","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"3. 总结：面向对象 面向对象最重要的三个方面：封装、继承和多态，在Go中都可以寻找到替代的实现方式 封装(数据隐藏)：即Go中的可见性规则，不同于别的OO语言中的4种访问性，Go只有两种 继承： 用组合或内嵌实现，结构体一篇中谈到过这个。 多态：用接口实现。某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:3:0","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"3.1 组合实现继承 组合的含义是包含所需功能的具名字段 package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string log *Log } func main() { c := new(Customer) c.Name = \"Barak Obama\" c.log = new(Log) c.log.msg = \"1 - Yes we can!\" // shorter c = \u0026Customer{\"Barak Obama\", \u0026Log{\"1 - Yes we can!\"}} // fmt.Println(c) \u0026{Barak Obama 1 - Yes we can!} c.Log().Add(\"2 - After me the world will be a better place!\") //fmt.Println(c.log) fmt.Println(c.Log()) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) Log() *Log { return c.log } //Output: 1 - Yes we can! 2 - After me the world will be a better place! ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:3:1","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"3.2 内嵌实现继承 内嵌的含义是匿名的实现所需功能 package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string Log } func main() { c := \u0026Customer{\"Barak Obama\", Log{\"1 - Yes we can!\"}} c.Add(\"2 - After me the world will be a better place!\") fmt.Println(c) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) String() string { return c.Name + \"\\nLog:\" + fmt.Sprintln(c.Log) } //Output: Barak Obama Log:{1 - Yes we can! 2 - After me the world will be a better place!} 内嵌看起来更简单一点，因此最合适的办法就是利用内嵌创建一些小的、可复用的类型作为工具箱，来被其它类型调用。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:3:2","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"3.3 多重继承 package main import ( \"fmt\" ) type Camera struct{} func (c *Camera) TakeAPicture() string { return \"Click\" } type Phone struct{} func (p *Phone) Call() string { return \"Ring Ring\" } type CameraPhone struct { Camera Phone } func main() { cp := new(CameraPhone) fmt.Println(\"Our new CameraPhone exhibits multiple behaviors...\") fmt.Println(\"It exhibits behavior of a Camera: \", cp.TakeAPicture()) fmt.Println(\"It works like a Phone too: \", cp.Call()) } //Output: Our new CameraPhone exhibits multiple behaviors... It exhibits behavior of a Camera: Click It works like a Phone too: Ring Ring ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:3:3","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["研究生的区块链学习之路"],"content":"很多区块链领域极有启发性的文章或者介绍极为详细的文章都很值得保存，以前直接将文章完整的转载过来，但最近发现这种方法占用空间而且毫无意义，因此专门开一篇博客用来收集和介绍这些文章，只记录它们的链接并作简单介绍。逆序排列，最新收集的文章在最前，同样，越往前序号越大。 ","date":"2019-11-26","objectID":"/2019/articles-about-blockchain/:0:0","tags":["区块链"],"title":"区块链方向有参考价值的文章收集","uri":"/2019/articles-about-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"共识协议 时间：2020.01.06 文章链接：Consensus Protocols That Meet Different Business Demands 一共两篇，详细介绍了常见的各种共识协议。 ","date":"2019-11-26","objectID":"/2019/articles-about-blockchain/:1:0","tags":["区块链"],"title":"区块链方向有参考价值的文章收集","uri":"/2019/articles-about-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"区块链交易打包过程 时间：2019.04.03 文章链接(唐霜的个人博客)：区块链中，交易被如何打包进区块 通过这篇文章要弄清楚的问题是：矿工优先打包交易费高的交易，会不会遗漏某些区块？ 大部分材料都详细分析了挖矿过程，介绍了区块是如何产生的。然而，区块的产生并不是区块链的最终目的，保存交易信息才是区块链的最终目的。所以，更重要的一点是要理解，交易信息是如何被打包进区块链的。 ","date":"2019-11-26","objectID":"/2019/articles-about-blockchain/:2:0","tags":["区块链"],"title":"区块链方向有参考价值的文章收集","uri":"/2019/articles-about-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"Hyperledger搭建 时间：2018.12.25 文章转自IBM，地址为：英文版 ,中文版 Introduction: 整个教程分三部分， 第1部分学习如何在 Hyperledger Composer Playground 的本地版本中建模并测试一个简单的业务网络，第 2 部分学习如何改进和部署区块链网络，第 3 部分学习如何在计算机上安装 Hyperledger Fabric，将业务网络部署到本地实例以及与示例网络区块链应用交互。 ","date":"2019-11-26","objectID":"/2019/articles-about-blockchain/:3:0","tags":["区块链"],"title":"区块链方向有参考价值的文章收集","uri":"/2019/articles-about-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"比特币脚本 时间：2019.11.27 文章链接(来自CSDN)：谈谈自己对比特币脚本的理解 Introduction： 比特币脚本存在的意义是自动化的验证交易的合法性，分为锁定脚本和解锁脚本两种。假设Alice要向 bob支付0.015比特币, Alice会用到一个UTXO(假设是单输入，单输出)，这个UTXO带有一个锁定脚本，为交易设置“障碍”。 bob如果要接收这笔比特币(另一种说法是bob可以引用该笔输出)，就要给出一个解锁脚本,然后解锁脚本和锁定脚本组合后执行的结果为真才能确认交易有效。 脚本是简单的堆栈语言，是非图灵完备的，这篇文章详细解释了锁定脚本与解锁脚本的运行机理。 ","date":"2019-11-26","objectID":"/2019/articles-about-blockchain/:4:0","tags":["区块链"],"title":"区块链方向有参考价值的文章收集","uri":"/2019/articles-about-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"日蚀攻击 时间：2019.04.08 文章链接(来自知乎)：比特币点对点网络中的日蚀攻击 Introduction： 这篇文章是对同名论文Eclipse Attacks on Bitcoin’s Peer-to-Peer Network原理和思想的解释，实际上针对的还不是原论文，是论文作者的讲解视频。 ","date":"2019-11-26","objectID":"/2019/articles-about-blockchain/:5:0","tags":["区块链"],"title":"区块链方向有参考价值的文章收集","uri":"/2019/articles-about-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"IoT数据 时间：2019.04.10 文章链接(来自IBM)：了解IoT数据 Introduction： 随着越来越多的事物连接到物联网，与 IoT 设备相关联的数据量及其生成的数据量（包括设备状态、元数据和传感器读数）呈指数级增长。如果 IoT 解决方案要实现价值，那么管理和了解这些数据至关重要。这篇文章介绍一些处理 IoT 数据的方法，包括存储数据、处理和分析数据以及应用规则。讲解的相当深入。 ","date":"2019-11-26","objectID":"/2019/articles-about-blockchain/:6:0","tags":["区块链"],"title":"区块链方向有参考价值的文章收集","uri":"/2019/articles-about-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"区块链改善学术界 时间：2019.02.26 英文原文(来自medium)：Ideas on how to improve scientific research 中译文(来自知乎)：Coinbase CEO：区块链或可改善学术届，科研将变得像编程一样开放 Introduction： 科学论文之于人类持续进化的重要性不言而喻，每年，全世界范围有数百万篇论文会被发表，它们代表着人类智慧的最新成果，但其中只有一小部分真正带来了新的产品和服务，人们可真正从中获益。 然而，传统的学术环境在为人类带来创新的同时，也存在着大量的落后特性，我们不禁思考，能否改善学术界的环境，使得人类发展能够变得更快、更开放？ 来自区块链独角兽公司Coinbase的首席执行官Brian Armstrong，为我们提供了一些非常棒的想法，我们或许可结合区块链token和市场上已存在的技术，使得学术研究变得像Github那样开放，人人都可参与学术研究和讨论，倘若实现这一想法，学术研究者们将变得不再苦逼，人类文明因此而将更好地发展…… ","date":"2019-11-26","objectID":"/2019/articles-about-blockchain/:7:0","tags":["区块链"],"title":"区块链方向有参考价值的文章收集","uri":"/2019/articles-about-blockchain/"},{"categories":["Golang学习之路"],"content":"1. 函数声明与定义 Go中有三种类型的函数： 普通的带有名字的函数 匿名函数 方法（Methods，在结构体部分介绍） 普通函数声明的基本格式为 func functionName(param1 type1, param2 type2,...) (ret1 type1, ret2 type2,...) 定义就需要添加大括号和函数体 func functionName(param1 type1, param2 type2,...) (ret1 type1, ret2 type2,...) { ... } 两个括号中分别为参数列表和返回值列表，参数个数和返回值个数允许为0。左大括号必须与声明语句在同一行，流程控制部分已经见过这个规定，这是编译器强制规定。 当函数执行到代码块最后一行，也就是最后一个}之前，或者执行到return语句的时候就会退出。 main函数是每个程序必须包含的，一般来说是启动后第一个执行的函数，但如果有init()函数会先执行该函数。 main函数既没有参数，也没有返回值，如果添加了两者中任一者，都会引发构建错误。main函数一旦返回就表示程序已成功执行并立即退出。同样，init()函数也没有返回值 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:1:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"2. 函数调用 同一个包内，可以直接使用函数名调用该函数，不同包内，需要添加包名，如下所示 pack1.functionName(arg1, arg2, ..., argn) pack1是包名，functionName是该包中的一个函数，括号里是传入的实参。一个简单的调用其它函数的例子如下 package main func main() { println(\"In main before calling greeting\") greeting() println(\"In main after calling greeting\") } func greeting() { println(\"In greeting: Hi!!!!!\") } //Output: In main before calling greeting In greeting: Hi!!!!! In main after calling greeting Go中不允许函数重载 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:2:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3. 函数参数与返回值 除了mian()和init()函数外，其它函数都可以拥有参数和返回值。而且任意一个有返回值的函数都必须以return或panic语句结尾，return可以返回多个值，多值返回是Go的一大特性。 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.1 参数传递类型 Go中的参数传递类型有两种：按值传递和按引用传递。 Go默认使用按值传递来传递参数，也就是传递参数的副本，因此参数在函数中被更改后不会影响原值。如果希望函数运行的同时改变原变量的值，应该添加取地址符\u0026，传递变量的指针，也就是按引用传递，按引用传递时，传入的是指针的副本，但指向的值依然是原变量。 函数调用时，切片、映射、接口、通道这些引用类型默认使用按引用传递 几乎在任何情况下，按引用传递的消耗都比按值传递小 按引用传递可以直接修改外部变量的值，因此被修改的变量不再需要使用return返回 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:1","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.2 命名参数 函数定义时，形参一般都有名字，不过也可以定义没有形参名的函数，只有形参类型，比如func f(int, int, float64)，返回值同样如此。只有类型的返回值称为非命名返回值，有名字的返回值称为命名返回值。一个例子如下 package main import \"fmt\" var num int = 10 var numx2, numx3 int func main() { numx2, numx3 = getX2AndX3(num) PrintValues() numx2, numx3 = getX2AndX3_2(num) PrintValues() } func PrintValues() { fmt.Printf(\"num = %d, 2x num = %d, 3x num = %d\\n\", num, numx2, numx3) } func getX2AndX3(input int) (int, int) { return 2 * input, 3 * input } func getX2AndX3_2(input int) (x2 int, x3 int) { x2 = 2 * input x3 = 3 * input // return x2, x3 return } //Output: num = 10, 2x num = 20, 3x num = 30 num = 10, 2x num = 20, 3x num = 30 命名返回值会被初始化为相应类型的零值，返回时只需要一条简单的不带参数的return语句（带参数也不会出错）。 当需要返回多个非命名返回值时，需要使用括号包围，如(int, int)，但对命名返回值，即使只有一个返回值，也要用括号包围。 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:2","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.3 空白符 空白符_用来匹配不需要的返回值，然后丢弃掉，之前已经介绍过。 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:3","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.4 变长参数 如果函数最后一个参数是...type的形式，那么函数就可以处理一个变长的参数，这个长度可以是0，这样的函数称为变参函数 func myFunc(a, b, arg ...int) {} 变长参数的本质是一个切片，如下例 func Greeting(prefix string, who ...string) Greeting(\"hello:\", \"Joe\", \"Anna\", \"Eileen\") 变量who的值为 []string{\"Joe\", \"Anna\", \"Eileen\"} 如果参数本身就存在一个切片类型中，比如切片slice1，则可以通过slice1...的形式传递参数，之前的切片部分使用append函数时已经这样使用过 package main import \"fmt\" func main() { x := min(1, 3, 2, 0) fmt.Printf(\"The minimum is: %d\\n\", x) slice := []int{7,9,3,5,1} x = min(slice...) fmt.Printf(\"The minimum in the slice is: %d\", x) } func min(s ...int) int { if len(s)==0 { return 0 } min := s[0] for _, v := range s { if v \u003c min { min = v } } return min } //Output: The minimum is: 0 The minimum in the slice is: 1 一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递 func F1(s ...string) { F2(s...) F3(s) } func F2(s ...string) { } func F3(s []string) { } ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:4","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.5 函数作为参数 函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，只要函数返回值个数、返回值类型和返回值顺序同调用函数的形参列表定义相同，称之为回调。下面是一个将函数作为参数的简单例子 package main import ( \"fmt\" ) func main() { callback(1, Add) } func Add(a, b int) { fmt.Printf(\"The sum of %d and %d is: %d\\n\", a, b, a+b) } func callback(y int, f func(int, int)) { f(y, 2) // this becomes Add(1, 2) } //Output: The sum of 1 and 2 is: 3 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:5","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"4. 内置函数 Go语言拥有一些不需要导入就可以使用的内置函数，之前已经接触过一些，比如len, cap, append，以下是内置函数列表 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数，在部署环境中建议使用 fmt 包 complex、real imag 用于创建和操作复数 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:4:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"5. 匿名函数与闭包 匿名函数是类似 func(x, y int) int { return x + y } 这样没有名字的函数。 匿名函数可以被直接调用，下面是一个计算从 1 到 1 百万整数的总和的匿名函数。表示参数列表的第一对括号必须紧挨着关键字 func，因为匿名函数没有名称。花括号 {} 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。 func() { sum := 0 for i := 1; i \u003c= 1e6; i++ { sum += i } }() 另外，匿名函数可以像其它函数一样接受参数，下例展示了如何传递参数到匿名函数中 func (u string) { fmt.Println(u) … }(v) 还应该知道的，匿名函数可以被赋值给某个变量，如fplus := func(x, y int) int { return x + y }，这样函数的地址就保存到了变量中，之后可以通过变量名对函数进行调用：fplus(3, 4) 所谓闭包就是函数及其引用环境的组合，这么说比较难理解，举个例子 func f(i int) func() int { return func() int { i++ return i } } 在这里例子里，返回值是一个函数，这个函数本身没有定义变量，而是引用了它所在环境的变量 i，这就形成了一个闭包。从这里可以看出，闭包与匿名函数息息相关，因为匿名函数被用作函数返回值非常合适。下面是一个完整的例子 package main import \"fmt\" func main() { var f = Adder() fmt.Print(f(1), \" - \") fmt.Print(f(20), \" - \") fmt.Print(f(300)) } func Adder() func(int) int { var x int return func(delta int) int { x += delta return x } } //Output: 1 - 21 - 321 从这里例子中我们注意到 x 的值是不断累加的，这也就意味着闭包函数其实会保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 这里可以理解为函数被赋值给 f 之后，其实将整个闭包包括环境都赋值给了 f，变量 f 的生存周期内，其值是不变的，所以结果才会累积。 这种返回值为另一个函数的函数的形式也被称之为工厂函数，在需要创建一系列相似的函数的时候非常有用。下面的函数演示了如何动态返回追加后缀的函数： func MakeAddSuffix(suffix string) func(string) string { return func(name string) string { if !strings.HasSuffix(name, suffix) { return name + suffix } return name } } 现在可以生成如下函数 addBmp := MakeAddSuffix(\".bmp\") addJpeg := MakeAddSuffix(\".jpeg\") 然后调用它们 addBmp(\"file\") // returns: file.bmp addJpeg(\"file\") // returns: file.jpeg ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:5:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"6. defer和追踪 关键字 defer 是 Go 中一个非常有用的特性，作用是将某个语句或函数推迟到函数返回之前执行。准确的说，defer 的执行时机有三种： 包含 defer 语句的函数返回前 包含 defer 语句的函数执行到末尾 所在的 goroutine 发生 panic 时 一个例子如下 func main() { defer fmt.Println(\"Fourth\") fmt.Println(\"First\") fmt.Println(\"Third\") } //Output: First Third Fourth defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，如下例 i := 1 defer fmt.Println(\"Deferred print:\", i) i++ fmt.Println(\"Normal print:\", i) // Output: Normal print: 2 Deferred print: 1 但与匿名函数结合起来后，变量的值在函数运行时才会确定 func f1() (r int) { r = 1 defer func() { r++ fmt.Println(r) }() r = 2 return } func main() { f1() } // Output: 3 上例中出现了 return 语句，defer 与 return 的执行顺序比较复杂，这里要先理解两件事 defer 函数执行时机是外层函数设置返回值之后，即将返回之前 return xxx 操作并不是原子的 下面的例子中， return 0 实际上可以拆分为 r = 0; return 两条语句，因此输出是1不是0 func f1() (r int) { defer func() { r++ }() return 0 } func main() { fmt.Println(f1()) } 来一个更复杂的例子 func double(x int) int { return x + x } func triple(x int) (r int) { defer func() { r += x }() return double(x) } func main() { fmt.Println(triple(3)) } // Output: 9 上面的例子实际上等价于 func triple(x int) (r int) { r = double(x) func() { r += x }() return } 多个 defer 同时使用时，以逆序执行，即后进先出 func f() { for i := 0; i \u003c 5; i++ { defer fmt.Printf(\"%d \", i) } } //Output: 4 3 2 1 0 defer 关键字一般用于释放某些已分配的资源或在函数执行完进行一些收尾工作，比如 关闭文件流 //open a file defer file.Close() 解锁一个加锁的资源 mu.Lock() defer mu.Unlock() 打印最终报告 printHeader() defer printFooter() 关闭数据库链接 //open a database connection defer disconnectFromDB() ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:6:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"7. 编写规范 Go是编译型的语言，因此函数的编写顺序无关紧要，但鉴于可读性的需求，最好遵循一定的编程规范，我这里采用的是Uber开源在github的编码规范，有两条主要规则 函数应按粗略的调用顺序排序 同一文件中的函数应按接收者排序，意即可被外部访问的函数（参考可见性规则）应放在前面，普通工具函数放在后面。另外，在类型定义（结构体、接口等）后，可被外部访问的函数前，可能会出现类似于newXYZ()这样的新建某个类型的函数。一个简单的例子如下 type something struct{ ... } func newSomething() *something { return \u0026something{} } func (s *something) Cost() { return calcCost(s.weights) } func calcCost(n []int) int {...} 最后，main函数放在所有函数的最后。 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:7:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["我所热爱的生活啊"],"content":"本篇继续了解医保相关知识，以及医院等级、分类和就医流程。本文基本内容来自国家医疗保障局官网和网络。 ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:0:0","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["我所热爱的生活啊"],"content":"1. 医保 全称「社会医疗保险」，是国家建立的一种社会保险制度，目的是在公民患病时提供一定的补助，缓解看病的经济压力。 ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:1:0","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["我所热爱的生活啊"],"content":"1.1 发展历史 1998年，国家发布「国务院关于建立城镇职工基本医疗保险制度的决定1」，建立城镇职工医保，之后又启动了新型农村合作医疗制度试点，建立了城乡医疗救助制度，2007年，开启城镇居民基本医疗保险试点，将最后的城镇非从业居民包括进来，从而建立了基本覆盖城乡全体居民的医疗保障体系。 2010年10月28日，全国人大通过了「中华人民共和国社会保险法2」，为社会保险体系建立了法律依据，确立了包括基本养老保险、基本医疗保险、工伤保险、失业保险、生育保险等在内的社会保险制度，保障公民在年老、疾病、工伤、失业、生育等情况下依法从国家和社会获得物质帮助的权利。其中关于医保的相关说明如下： 参保人员及参保类型 职工应当参加职工基本医疗保险，由用人单位和职工按照国家规定共同缴纳基本医疗保险费。无雇工的个体工商户、未在用人单位参加职工基本医疗保险的非全日制从业人员以及其他灵活就业人员可以参加职工基本医疗保险，由个人按照国家规定缴纳基本医疗保险费。 国家建立和完善新型农村合作医疗制度，管理办法由国务院制定 国家建立和完善城镇居民基本医疗保险制度。城镇居民基本医疗保险实行个人缴费和政府补贴相结合。享受最低生活保障的人、丧失劳动能力的残疾人、低收入家庭六十周岁以上的老年人和未成年人等所需个人缴费部分，由政府给予补贴。 缴费年限 参加职工基本医疗保险的个人，达到法定退休年龄时累计缴费达到国家规定年限的，退休后不再缴纳基本医疗保险费，按照国家规定享受基本医疗保险待遇；未达到国家规定年限的，可以缴费至国家规定年限。 个人跨统筹地区就业的，其基本医疗保险关系随本人转移，缴费年限累计计算。 医保使用 符合基本医疗保险药品目录、诊疗项目、医疗服务设施标准以及急诊、抢救的医疗费用，按照国家规定从基本医疗保险基金中支付 参保人员医疗费用中应当由基本医疗保险基金支付的部分，由社会保险经办机构与医疗机构、药品经营单位直接结算。 社会保险行政部门和卫生行政部门应当建立异地就医医疗费用结算制度，方便参保人员享受基本医疗保险待遇。 2016年，国家开始整合城镇居民基本医疗保险和新型农村合作医疗，建立统一的城乡居民基本医疗保险制度，覆盖除职工基本医疗保险应参保人员以外的其他所有城乡居民。同年国务院印发《“健康中国2030”规划纲要》3，其中关于医保体系的说明为 健全以基本医疗保障为主体、其他多种形式补充保险和商业健康保险为补充的多层次医疗保障体系。整合城乡居民基本医保制度和经办管理。健全基本医疗保险稳定可持续筹资和待遇水平调整机制，实现基金中长期精算平衡。完善医保缴费参保政策，均衡单位和个人缴费负担，合理确定政府与个人分担比例。改进职工医保个人账户，开展门诊统筹。进一步健全重特大疾病医疗保障机制，加强基本医保、城乡居民大病保险、商业健康保险与医疗救助等的有效衔接。到2030年，全民医保体系成熟定型。 2019年3月，国务院发布「关于全面推进生育保险和职工基本医疗保险合并实施的意见4」，将医保和生育保险开始合并，主要的一些内容如下 统一参保登记。参加职工基本医疗保险的在职职工同步参加生育保险。 统一缴费和管理。生育保险基金并入职工医保基金，统一征缴。按用人单位原先参见生育保险和职工医保的缴费比例之和确定新的缴费比例，个人不缴纳生育保险费用。职工医保基金不再单列生育保险基金的收入，仅在支出中设置生育待遇支出项目 ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:1:1","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["我所热爱的生活啊"],"content":"1.2 缴费说明 从第一部分来看，我国医保目前分为职工医保和居民医保两部分，辅以商业健康保险和其它形式的补充保险，构成多层次的医疗保障体系。学生医保本质上是居民医保。 纳入医保的所有人，每个人都有一张医保卡，同时可在微信、支付宝等多个平台申领电子医保凭证。 医保缴纳有统筹区的概念，这也是大家常说的“医保交在了哪里”。根据国发[1998]44号文件1规定，基本医疗保险原则上以地级以上行政区（包括地、市、州、盟）为统筹单位，也可以县（市）为统筹单位，北京、天津、上海　3个直辖市原则上在全市范围内实行统筹（以下简称统筹地区）。铁路、电力、远洋运输等跨地区、生产流动性较大的企业及其职工，可以相对集中的方式异地参加统筹地区的基本医疗保险。2020年，国务院发布「中共中央 国务院关于深化医疗保障制度改革的意见5」,其中提到要巩固提高统筹层次，即按照制度政策统一、基金统收统支、管理服务一体的标准，全面做实基本医疗保险市地级统筹。探索推进市地级以下医疗保障部门垂直管理。鼓励有条件的省（自治区、直辖市）按照分级管理、责任共担、统筹调剂、预算考核的思路，推进省级统筹。 居民医保目前覆盖范围为除职工基本医疗保险应参保人员以外的其他所有城乡居民，实行个人缴费与政府补助相结合为主的筹资方式，至2021年6，个人缴费每年320元，政府补助每人每年不低于580元，一年一缴，全部计入城乡居民医保基金。居民医保每年都需要缴纳，不能停止，不缴费不能享受待遇，报销比例在45%~~65%左右。 职工医保缴纳的费用根据工资决定，按照平均工资，设定一个下限和一个上限，平均工资在该范围内的，缴纳固定的比例，低于下限的，按下限计算缴纳费用，高于上限的，按上限计算缴纳费用。 职工医保基金由统筹基金和个人帐户构成。职工个人缴纳的基本医疗保险费(约工资的2%)，全部计入个人帐户。用人单位缴纳的基本医疗保险费(约工资的8%)分为两部分，一部分用于建立统筹基金，一部分划入个人帐户。划入个人帐户的比例一般为用人单位缴费的30％左右，具体比例由统筹地区根据个人帐户的支付范围和职工年龄等因素确定。 职工医保交满25年（男）、20年（女），退休后就可以享受终身免费医保报销 ，这里只是指山西，各地政策可能不同。另外注意，退休前缴满年限的，也不可以断缴。 ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:1:2","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["我所热爱的生活啊"],"content":"1.4 医保查询 目前，对于我自己，单位缴纳医保比例为6.9%，个人缴纳比例为2%，此外，单位每个月还缴纳大额医疗费用补助15元，而每个月划入医保个人账户的资金比例不清楚。 截止 2022 年初，山西省医保已纳入全国统一医保信息平台，个人医保信息、缴费和使用信息可在网上直接查询，PC端可登录山西医保公共服务 (shanxi.gov.cn)查询，手机端可下载「国家医保服务平台」登录查询。 ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:1:3","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["我所热爱的生活啊"],"content":"1.3 医保报销 平时去医院看病、到定点药房买药，直接刷医保卡，用的是个人账户的钱，移民、退休、死亡或者去其它城市工作，可以将没用完的钱取出来。而走统筹基金的门诊和手术住院，拥有起付线、报销限额和报销范围。 起付线就是看病花费没到一定数目，不给报销，报销限额就是一个人一年最多只给报那么多，超过的不给报。报销范围指只有医保规定的药品和治疗项目才可以报销。药品目录7包括西药、中成药、协议期内谈判药品成分和中药饮片，治疗项目可以到网上查询。 报销金额=（治疗总费用—起付线—报销范围之外的费用）×报销比例 以王大爷为例，假设王大爷住院花了40万，起付线是1300元，其中6万元在报销范围外，报销限额是25万，报销比例为80%。 王大爷的报销金额=（40万—1300元—6万）×80%=270960元。 因为超过了报销限额，最后王大爷只能报销25万，剩余的15万需要自费。 在很多城市，只有去指定的医院才能报销，如果去了其它医院，要么不能报销，要么报销比例很低。所以最好选择一个距离自己住的地方或公司比较近的医院，平时看病到该医院而不是随便乱跑。 医保报销的一个普遍规则是，医院等级越高，报销比例越低，所以要根据症状选择医院，小病小灾不需要到大医院，不划算。 职工医保每月缴纳，尽量不要断缴，断缴第二个月起看病就无法报销了，医保断缴超过3个月，不仅要重新缴纳6个月之后才能生效，还会影响连续缴费年限，导致报销限额变低。 关于异地医保报销，分为三种情况 在户籍地交社保，本人却长期在外地生活的； 因老家医疗条件不好，去大城市求医看病的； 出差、旅游的时候，在其他城市突然生病的。 第一种情况，长期在外定居，需要在当地社保管理中心填写**《长期异地就医登记备案》**，生病的时候去**医保跨省异地联网结算系统**里登记的医院，拿着医保卡就可以直接报销，当然，现在也可以网上备案。医院目录可以从国家社会保险公共服务平台7查看，在该网站可以查到哪些医院是异地定点医疗机构、自己的异地就医备案情况、异地就医费用等各种实用的信息。如果去的医院不在该系统中，就只能自己先垫付医疗费用，然后拿着药物清单、收费单据、诊疗证明等，回到参保地，去异地医保窗口申请报销。 第二种情况，老家医疗条件不好，去大城市治疗。需要由老家的医院开具《跨省转诊转院就医备案表》，等当地的社保部门审批之后，转诊到外地就医。如果去的医院已经纳入医保跨省异地联网结算系统**，**看完病直接刷医保卡报销，否则就是自己先垫付，回老家再报销。 第三种情况，出差旅游忽然生病。拿起手机拨打参保地的社保服务电话，告诉工作人员你要查询“异地就医电话”。只要在出院之前拨打异地就医电话，完成电话备案，就可以正常报销，否则，你这次看病的报销起付线将提高5%，报销比例将下降5%。 更多的信息可以查看知乎问答「医保如何报销8」 从 2022 年 3 月 1 日开始，山西省参保职工在参保地以外的其他统筹区异地定点医药机构普通门诊和药店就医购药，无需进行异地就医备案，即可使用个人账户基金进行直接结算。参保职工在异地定点医疗机构住院、门诊购买特药，以及慢特病患者门诊就医购药等发生的费用应由个人负担的部分，可由个人账户基金直接结算支付。各级医保经办机构要做好参保职工参保缴费信息管理，确保单位欠费或个人暂停缴费状态下个人账户基金均能正常使用。 ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:1:4","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["我所热爱的生活啊"],"content":"2. 医院分级 医院等级划分标准，是我国依据医院功能、设施、技术力量等对医院资质评定指标。全国统一，不分医院背景、所有制性质等。按照《医院分级管理标准》，医院经过评审，确定为三级，每级再划分为甲、乙、丙三等，其中三级医院增设特等，因此医院共分三级十等。 一级医院是直接为社区提供医疗、预防、康复、保健综合服务的基层医院，是初级卫生保健机构。其主要功能是直接对人群提供一级预防，在社区管理多发病常见病现症病人并对疑难重症做好正确转诊，协助高层次医院搞好中间或院后服务，合理分流病人。（病床数在100张以内，包括100张。）是直接向一定人口的社区提供预防，医疗、保健、康复服务的基层医院、卫生院。 二级医院是跨几个社区提供医疗卫生服务的地区性医院，是地区性医疗预防的技术中心。其主要功能是参与指导对高危人群的监测，接受一级转诊，对一级医院进行业务技术指导，并能进行一定程度的教学和科研。（病床数在101张–500张之间）是向多个社区提供综合医疗卫生服务和承担一定教学、科研任务的地区性医院。 三级医院是跨地区、省、市以及向全国范围提供医疗卫生服务的医院，是具有全面医疗、教学、科研能力的医疗预防技术中心。其主要功能是提供专科（包括特殊专科）的医疗服务，解决危重疑难病症，接受二级转诊，对下级医院进行业务技术指导和培训人才；完成培养各种高级医疗专业人才的教学和承担省以上科研项目的任务；参与和指导一、二级预防工作。（病床数在501`张以上）是向几个地区提供高水平专科性医疗卫生服务和执行高等教育、科研任务的区域性以上的医院。 企事业单位及集体、个体举办的医院的级别，可比照划定。 2011年卫生部印发的《医院评审暂行办法》明确了分为甲等、乙等和不合格，不合格要在规定期限内整改。 具体而言，一二三级是规模，甲等乙等是能力评价。因此，现在等级高低为： 三特 \u003e 三甲 \u003e 三乙 \u003e 二甲 \u003e 二乙 \u003e 一甲 \u003e 一乙 下面列举关注的医院等级和类型 所在省 医院名称 医院等级 医院类别 山西 沁县人民医院 二级甲等 综合医院 山西 山西省长治市人民医院 三级甲等 综合医院 山西 山西省长治市第二人民医院 三级乙等 综合医院 山西 长治医学院附属和济医院 三级甲等 综合医院 山西 长治医学院附属和平医院 三级甲等 综合医院 山西 太原市中心医院 三级甲等 综合医院 山西 太原市第四人民医院 三级甲等 专科医院 山西 山西医科大学第一医院 三级甲等 综合医院 山西 山西医科大学第二医院 三级甲等 综合医院 山西 山西省儿童医院 三级甲等 专科医院 山西 晋中市第一人民医院 三级甲等 综合医院 山西 晋中市第二人民医院 三级乙等 综合医院 山西 晋中市妇幼保健院 三级乙等 专科医院 山西 山西中医学院晋中中医院 三级乙等 专科医院 ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:2:0","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["我所热爱的生活啊"],"content":"3. 就医流程 到公立大医院看病： 排队挂号。告诉挂号员你哪里不舒服，她们会帮你选择科室，然后根据挂号单上的位置，找到科室，有些需要在科室门口找到分诊台分诊进行电子登记排队。专家号不用。然后在诊室门口等待医生电子叫号。 排队看病。 排队缴费。进去看完病后，医生也许会开药，开检查单或化验单。然后你去挂号处缴费，或自助缴费机缴费。 到相关科室排队做检查或化验。有些地方需到先到分诊台登记排队。 检查结果出来后，找医生复诊看病。一般不需再排队。医生会下诊断，写病历，开药或开治疗单，或开住院单。 缴费。在挂号处排队缴费，办住院。或在自助缴费机缴费。 回到诊室，排队接受治疗。或到药房取药回家。 如果有医保或合作医疗的，应带医保卡和合作医疗证，并用医保卡挂号，这样才能启动医保，报销医药费。 ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:3:0","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["我所热爱的生活啊"],"content":"4. 拨打120 判断是否需要拨打120 是否有威胁患者生命的情况？ 在送往医院途中，病情是否会加重？或者威胁到患者的生命？ 病人是否需要急救人员的专业技能或者专业设备？ 救护车的协助是否能更快到达医院？ 是否有怀疑脊柱损伤的情况？ 打通之后描述以下情况 所在地址 事故类型或者病人的主要症状，如车祸、外伤、胸痛、昏迷、抽搐、呼吸困难等，而不要告知您怀疑的疾病诊断，如果遇到车祸、事故或者群殴等情况，最好说清楚是什么事故，是什么车撞什么车，多少人受伤等等，并记得同时拨打110。。 如果突发情况时，大脑一片空白而不知道该说些什么，只需听清楚并回答调度员的问题即可，不用抢着说话，或者重复说着同样的话。 除非调度员提示，千万不要抢在调度员前面挂断电话。 派人到显眼位置接车 http://www.nhsa.gov.cn/art/1998/12/14/art_37_1189.html ↩︎ http://www.nhsa.gov.cn/art/2010/10/28/art_37_1183.html ↩︎ http://www.nhsa.gov.cn/art/2016/10/25/art_37_1167.html ↩︎ http://www.nhsa.gov.cn/art/2019/3/25/art_37_1032.html ↩︎ 中共中央 国务院关于深化医疗保障制度改革的意见 (nhsa.gov.cn) ↩︎ 关于做好2021年城乡居民基本医疗保障工作的通知 (nhsa.gov.cn) ↩︎ http://www.nhsa.gov.cn/art/2019/8/20/art_37_1666.html ↩︎ https://www.zhihu.com/question/41409040 ↩︎ ","date":"2019-11-23","objectID":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/:4:0","tags":["生活技能"],"title":"医药健康3-医保及就医","uri":"/2019/medicine-and-health-5-medical-insurance-and-medical-treatment/"},{"categories":["Golang学习之路"],"content":"只有基本的数据类型无法适应所有的情况，当需要存储和处理大量数据时，通常会使用数组、映射、链表等数据结构，称之为容器(container)。在Go语言中，由于数组不够灵活，增加了切片(slice)类型，切片也是一种容器。 C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。 本篇只介绍数组和切片，映射类型放在下篇介绍，链表类型在数据结构中介绍。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:0:0","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"1. 数组 数组是有限个相同类型的数据的集合，Go语言中数组声明的格式为 var identifier [len]type 数组元素可以是任意基本类型，数组本身，结构体甚至接口（空），当元素类型是数组本身时，即为二维或多维数组。 应注意，数组长度也是数组类型的一部分，[5]int和[10]int是两个不同类型。 数组元素通过索引来读取或修改，不同于字符串，数组是可变的。索引的范围从0到len(arr)-1，内置函数len()可用来获取数组长度，数组长度最大为2Gb。 声明数组时所有的元素都会被自动初始化为元素类型的零值，初始化的过程是按照数组元素的顺序进行的。 当数组元素较少时，可以在声明时直接进行初始化，一些表达方式如下 var arr1 = [3]int{1, 2, 3} var arr2 = [10]int{1, 2, 3} //剩下的元素会自动补全，其值为0 var arr3 = [3]string{2:\"test\"} //只有索引2被赋予了实际的值，其它元素都初始化为空字符串 数组长度的位置也可以使用省略号，此时数组长度会根据提供的值的个数自动推断 arr := [...]int{1, 2, 3} fmt.Println(len(arr)) //3 数组元素较多时使用for循环初始化 var arr [100]int //使用for循环初始化 for i:=0; i \u003c len(arr); i++ { arr[i] = i * 2 } Go语言中数组是一种值类型，而不像C语言是指向首元素的指针，因此可以使用内置函数new()来创建数组（new()用来创建值类型，返回所创建类型的指针） var arr1 = new([5]int) 这种方式和var arr2 [5]int的区别是，arr1的类型是*[5]int，而arr2的类型是[5]int，一个简单的式子可以帮助理解 arr2 := *arr1 当像上式这样进行赋值时，我们把arr1的值做了一次拷贝，因此修改arr2不会对arr1产生影响。同理，函数中数组作为参数传入时，传入值类型的数组不会改变原值，但是直接传入数组作为参数，当数组很大时会消耗很多内存，可以传入数组的指针或使用切片来解决。以下是传入指针的例子。 package main import \"fmt\" func f(a [3]int) { fmt.Println(a) } func fp(a *[3]int) { fmt.Println(a) } func main() { var ar = [3]int{1, 2, 3} f(ar) // passes a copy of ar fp(\u0026ar) // passes a pointer to ar } 数组可以组装成多维数组，一个二维数组可以理解为一个数组类型的数组，以下演示一个二维数组的声明 // 声明一个二维整型数组，两个维度的长度分别是 4 和 2 var array [4][2]int // 声明并初始化数组中索引为 1 和 3 的元素 array = [4][2]int{1: {20, 21}, 3: {40, 41}} // 声明并初始化数组中指定的元素 array = [4][2]int{1: {0: 20}, 3: {1: 41}} ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:1:0","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"2. 切片 切片（slice）就是动态数组，可以理解为对数组一个连续片段的引用，是一个引用类型。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:2:0","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"2.1 声明与使用 切片声明的格式如下，基本就是去掉了数组声明中的长度 var identifier []type 未初始化的切片默认为nil，长度为0。切片的初始化格式为 var slice []type = arr[start:end] 表示slice是数组arr从start索引到end-1索引之间的元素构成的子集，切片的大小可以和数组相等，但应注意到终止索引的项并不包含在切片内。一些切片的方式如下 var arr = [5]int{1,2,3,4,5} s := arr[:] s := arr[0:5] //这两个切片都等于整个数组 s := arr[:3] s := arr[0:3] //这两式输出都是[1,2,3] s := arr[2:] s := arr[2:5] //这两式输出都是[3,4,5] 切片是可索引的，但切片的索引与原数组的索引不一定相同，如上例最后一行，s[0] = arr[2]。 切片的长度在运行时可修改，最小为0最大为相关数组的长度，具体的长度值可通过len()函数获得。 cap()函数可以计算切片的容量，也就是切片最长可以达到多少。举个例子，如果 s 是一个切片，cap(s) 就是从 s[0] 到数组末尾的数组长度。切片的长度永远不会超过它的容量。容量之所以从s[0]开始计数，是因为切片只能向后移动，任何试图获取切片第一个元素之前的数组元素的做法都会导致编译错误。 arr := [5]int{1, 2, 3, 4, 5} s := arr[2:4] //len(s)为2，cap(s)为3 两个直接创建切片的例子如下 s := [3]int{1,2,3}[:] x := []int{2,3,4,5,6} 但本质上这两者都是先创建的数组，然后取了与数组等长的切片。 注：切片本身已是引用，它没有指针，因此不要对它使用取地址符。 在上面的数组部分我们谈到当数组很大时，直接将数组作为参数传给函数会占用大量内存，因此我们介绍了如何传入数组的指针，这里我们再介绍如何传入切片：我们应当在函数中声明参数为切片类型，调用函数时，把数组分片，创建一个切片引用传递给该函数，示例如下 func sum(a []int) int { s := 0 for i := 0; i \u003c len(a); i++ { s += a[i] } return s } func main() { var arr = [5]int{0, 1, 2, 3, 4} sum(arr[:]) } 数组作为值类型使用new()来创建，而切片作为引用类型，需要使用make()。 var slice []type = make([]type, len) slice := make([]type, len) //简写形式 其中第二个参数len是数组的长度，也是slice的初始长度，例如定义s1 := make([]int, 10)，那么cap(s1) == len(s1) == 10 也可以在声明时利用第三个参数指定切片容量 slice := make([]type, len, cap) 因此，下面两种方法可生成相同切片 make([]int, 50, 100) new([100]int)[0:50] 字符串可以看作是一个不可变的字节数组，因此也可以切分为切片使用。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:2:1","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"2.2 常用操作 由于切片的灵活性，会经常使用切片进行一些操作，这里简单介绍几种。 重组 使用make创建切片的时候可以指定容量，因此必要时可以改变切片长度直到达到容量上限，改变切片长度的过程称为切片重组（reslice），如将切片扩展1位 s = s[0:len(s)+1] //len(s)+1 \u003c= cap(s) 复制 增加切片的容量必须创建一个新的更大的切片并把原分片的内容都拷贝过来。切片拷贝使用copy()函数，函数原型如下 copy(destSlice, srcSlice []T) int 作用是将 srcSlice 复制到 destSlice，两者类型必须一致，返回值为实际复制的元素个数。源地址和目标地址可能会有重叠。复制的元素个数是 srcSlice 和 dstSlice 的长度最小值。示例如下 sl_from := []int{1, 2, 3} sl_to1 := make([]int, 5) sl_to2 := make([]int, 2) n1 := copy(sl_to1, sl_from) // n1 = 3, s1_to1 = [1,2,3,0,0] n2 := copy(sl_to2, sl_from) // n2 = 2, s1_to2 = [1,2] 追加 追加也是一种切片扩容的方式，主要使用append()函数，函数原型是 func append(s []T, x ...T) []T 作用是将0个或多个具有相同类型T的元素追加到切片s后面病并回新的切片，追加的元素类型需要和原切片的元素同类型。如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。 sl3 := []int{1, 2, 3} sl3 = append(sl3, 4, 5, 6) // sl2 = [1,2,3,4,5,6] 删除 删除切片元素没有专用语法，需要使用切片本身的特性。分为三种情况：从开始位置删除，从中间位置删除，从末尾删除 从开始位置删除 直接移动数据指针 a = []int{1, 2, 3} a = a[1:] // 删除开头1个元素 a = a[N:] // 删除开头N个元素 不移动数据指针，而是将后面的数据向开头移动 a = []int{1, 2, 3} a = append(a[:0], a[1:]...) // 删除开头1个元素 a = append(a[:0], a[N:]...) // 删除开头N个元素 使用copy()函数 a = []int{1, 2, 3} a = a[:copy(a, a[1:])] // 删除开头1个元素 a = a[:copy(a, a[N:])] // 删除开头N个元素 从中间位置删除 对剩余的元素做一次整体移动，可以使用copy()或append() a = []int{1, 2, 3, ...} a = append(a[:i], a[i+1:]...) // 删除中间1个元素 a = append(a[:i], a[i+N:]...) // 删除中间N个元素 a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素 a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素 从末尾删除 a = []int{1, 2, 3} a = a[:len(a)-1] // 删除尾部1个元素 a = a[:len(a)-N] // 删除尾部N个元素 删除开头和末尾都是删除中间的特殊情况 插入 插入的一般方式是使用两次append()函数 a = append(a[:i], append([]T{x}, a[i:]...)...) //在索引i的位置插入元素x a = append(a[:i], append(make([]T, j), a[i:]...)...) //在索引i的位置插入长度为j的新切片 a = append(a[:i], append(b, a[i:]...)...) //在索引i的位置插入切片b的所有元素 映射(map)其实就是数据结构里的哈希表，但不少语言都已经把它作为了内置的数据类型。映射是元素对的无序集合，由键(key)和值(value)两部分构成，可以通过键快速查找值（比线性查找快，但实际上比通过数组或切片索引直接读取要慢）。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:2:2","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3. 映射 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:0","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3.1 声明与初始化 Golang 中的 map 是引用类型，声明方法如下 //语法格式 var mapname map[keytype]valuetype //示例 var map1 map[string]int 凡是可以用 == 或 != 操作符比较的类型都可以作为键的类型，比如string、int、float、只包含基本类型的结构体、指针和接口，而数组、切片以及含有数组切片的结构体无法作为键类型。值的类型是任意的，当值类型是一些复杂结构时，往往有比较特殊的用途，比如 函数。值类型为函数时可以视作分支结构，key用来选择要执行的函数。 空接口。我们可以用空接口作为值类型存储任意类型的值，只是在使用前需要做一次类型断言。 切片。通过将值类型定义为切片类型，应对一个Key对应多个值的情况，示例如下 mp1 := make(map[int][]int) map 可以动态增长，声明时不关心长度，使用时其长度使用内置函数len()获取。 未初始化的 map 值为 nil，如果此时试图给map添加元素会导致运行时错误，因此添加元素必须首先初始化。map初始化的方法有两种 直接使用大括号，在数组与切片的初始化中已经见过这种方法，示例如下 var mapLit map[string]int mapLit = map[string]int{\"one\":1, \"two\":2} 使用make，map是引用类型，因此使用make初始化。以make方式初始化其实相当于mapLit := map[string]int{} mapLit := make(map[string]int) 虽然map可以动态增长，没有长度限制，但是也可以在一开始标明其初始容量 mapLit := make(map[string]int, 100) 当map增长到容量上限后，继续增加新的键值对，map的大小会自动加1，因此容量对map并没有多大影响。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:1","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3.2 访问与删除map中的元素 如果 key1 是 map1 的 key，那么 map1[key1] 就是对应 key1 的值，map中就通过这种类似数组索引的方式访问元素 val1 := map1[key1] 上式将 key1 对应的值赋给了 val1，但反过来，也可以通过这种形式设置对应key1的值，如下 map1[key1] = val1 访问 map 中不存在的 key 会获得它所对应的值类型的空值，因此我们还需要有一种办法来判断键值对是否存在，这样才能区分到底是键值对本身不存在，还是值是空值。实际上通过键来访问值会返回两个结果，如下 val1, ok := map1[key1] 当键值对存在时，ok 的值为 true，而当键值对不存在时，ok 的值为 false。如果只想判断某个键值对是否存在，可以将返回的真正的值设置为匿名变量 _, ok := map1[key1] map中元素的删除使用内置函数delete()，格式如下 delete(mapname, keyname) 如果键值对不存在，删除操作也不会产生错误 mapLit := map[string]int{\"one\": 1, \"two\": 2} delete(mapLit, \"one\") 但 Golang 并没有提供清空 map 中所有元素的方法，清空 map 的唯一办法就是重新 make 一个新的 map mapLit := map[string]int{\"one\": 1, \"two\": 2} mapLit = make(map[string]int) ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:2","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3.3 遍历map for-range可用于遍历map for key, value := range map1 { ... } 其中第一个返回值 key 是 map 中的 key 值，第二个返回值 value 则是 key 对应的 value 值。如果只关心值，可以省略键 for _, value := range map1 { ... } 而如果只关心键，则可以省略值 for key := range map1 { fmt.Printf(\"key is: %d\\n\", key) } 还需要知道的一点是，for-range 结构虽然能遍历整个 map，但我们并不知道 map 中键值对排列的顺序，并不是按 key 的顺序排列的，也不是按 value 的顺序排列。 如果想要为 map 排序，那么就需要先通过遍历将 map 的所有数据复制到切片中，再对切片排序，最后打印出来 // the telephone alphabet: package main import ( \"fmt\" \"sort\" ) var barVal = map[string]int{\"alpha\": 34, \"bravo\": 56, \"charlie\": 23} func main() { fmt.Println(\"unsorted:\") for k, v := range barVal { fmt.Printf(\"Key: %v, Value: %v ; \", k, v) } keys := make([]string, len(barVal)) i := 0 for k := range barVal { keys[i] = k i++ } sort.Strings(keys) fmt.Println() fmt.Println(\"sorted:\") for _, k := range keys { fmt.Printf(\"Key: %v, Value: %v ; \", k, barVal[k]) } } //Output: unsorted: Key: alpha, Value: 34 ; Key: bravo, Value: 56 ; Key: charlie, Value: 23 ; sorted: Key: alpha, Value: 34 ; Key: bravo, Value: 56 ; Key: charlie, Value: 23 ; 上例按key进行了排序并输出，如果想要更好的显示，可以使用结构体切片 type name struct { key string value int } ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:3","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3.4 map类型的切片 map类型的切片是一个很有意思的结构，构造它需要使用两次make()函数，第一次分配切片，第二次分配切片中的每个map元素 package main import \"fmt\" func main() { // Version A: items := make([]map[int]int, 5) for i:= range items { items[i] = make(map[int]int, 1) items[i][1] = 2 } fmt.Printf(\"Version A: Value of items: %v\\n\", items) // Version B: NOT GOOD! items2 := make([]map[int]int, 5) for _, item := range items2 { item = make(map[int]int, 1) // item is only a copy of the slice element. item[1] = 2 // This 'item' will be lost on the next iteration. } fmt.Printf(\"Version B: Value of items: %v\\n\", items2) } //Output: Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]] Version B: Value of items: [map[] map[] map[] map[] map[]] 应该意识到，for-range 结构中，value 只是值的拷贝，对它做操作不会影响原值，因此上例中第二种写法是错误的，真正的 map 元素并没有得到初始化。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:4","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["爱编程爱技术的孩子"],"content":"本文用来收集喜欢的主题和有参考价值的博客(使用Hexo或Hugo的)。 ","date":"2019-11-17","objectID":"/2019/hugo-blog-themes-collection/:0:0","tags":["Hugo"],"title":"hugo搭建个人博客5-博客收集","uri":"/2019/hugo-blog-themes-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"主题 LeaveIt KeepIt LoveIt AllinOne hexo-theme-pure hexo-theme-Chic ","date":"2019-11-17","objectID":"/2019/hugo-blog-themes-collection/:1:0","tags":["Hugo"],"title":"hugo搭建个人博客5-博客收集","uri":"/2019/hugo-blog-themes-collection/"},{"categories":["爱编程爱技术的孩子"],"content":"博客 Yearito’s Blog 深入浅出区块链 Sirice’s Blog Mogeko’s Blog Wyane’s Blog Dillon’s Blog Orianna的博客 MARKSZ的Blog：PicGo的开发者 始终的博客：Hexo-Next主题优秀博客 ","date":"2019-11-17","objectID":"/2019/hugo-blog-themes-collection/:2:0","tags":["Hugo"],"title":"hugo搭建个人博客5-博客收集","uri":"/2019/hugo-blog-themes-collection/"},{"categories":["研究生的区块链学习之路"],"content":"Figueroa, Añorga, and Arrizabalaga, “An Attribute-Based Access Control Model in RFID Systems Based on Blockchain Decentralized Applications for Healthcare Environments,” Computers, vol. 8, no. 3, p. 57, Jul. 2019, doi: 10.3390/computers8030057. Keywords: blockchain, smart contract, RFID, ABAC, access control, IoT, healthcare ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:0:0","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引言 在医疗领域使用 RFID，可以追踪患者和医疗设备，更好的管理医疗资产，优化审计过程。如图1所示，一个 RFID 系统通常由四部分组成： RFID 标签：包含识别数据 RFID 阅读器：与标签直接交互并进行信息交换 RFID 中间件：管理设备，管理数据（过滤、收集、整合、构建） 信息管理层（业务层）：包含一些应用，如后端数据库，企业资源规划系统（ERP，enterprise resource planning），客户关系管理（CRM，customer relationship management），仓库管理解决方案（WMS，warehouse management solutions），电子产品代码追踪应用（tracking and tracing and electronic product code applications）。 GS1（一个全球标准组织）的标准分三类：[识别]^(identify)， [捕获]^(capture)和 [共享]^(share)。RFID 标签启用电子产品代码（EPC，electronic product code）后，标签和阅读器可以执行捕获过程；识别号被编码为 GTIN（Global Trade Item Number）或被解码为 RFID 标签的 EPC 时，中间件执行识别过程；共享过程则由信息管理层完成。 GTIN 描述了一种数据结构，它使用 14 位数字并以某些组合方式进行编码，目前在条形码和 RFID 领域都有使用。一个 GTIN 号码的结构如下所示： $$ urn:epc:id:sgtin:CompanyPrefix.ItemReference.SerialNumber $$ GS1 标准系统用于实现可追溯性解决方案，尤其是在供应链中，如新鲜食品、健康、技术产业、运输和物流，其中 RFID 系统用于数据捕获和共享。本文以医疗行业的供应链为例，介绍一个追踪医疗资产流动的场景：医院使用大量的资产，如外科医疗器械（SMI），这些资产可以在消毒部门、手术室、实验室等区域间进行周期性的流动，器械位于错误的位置可能会危及患者的生命，缺乏详细的资产记录则可能造成资产损失。 RFID 是执行数据捕获和共享的关键技术，对任何 RFID 系统来说，安全性都至关重要，但 RFID 系统的安全威胁不同于传统的无线安全威胁，如论文1所述，这些威胁可以分为： RFID的物理组件遇到的威胁（如克隆标签、反向工程、标签修改）， 通信通道威胁（如窃听、浏览、重放攻击） 全局系统威胁（如欺骗，DoS， 「tracing and tracking」 ）。 访问控制（AC）是解决安全问题的核心，这里首先介绍本文方案使用的器械标识方法：在 GS1 的基础上，用 GTIN 标记 SMI（使用无源 RFID 标签）。编码方案如下，包括一个公司前缀（例如，医院 A:000389）、一个产品类型用以对资产进行分类（例如，剪刀：000162）以及一个序列号用以识别特定资产（例如，序列号：000169740）。 $$ 01.000389.000162.000169740 \\\\ Header|compPrefix|Product type|Srial Number $$ 图2用于详细说明医疗系统的工作流程。源房间（如灭菌室）将一些资产（如SMI）运送到目的房间（如0号手术室、1号手术室）。由于 $Asset_1$ 已被分配到目的房间1（例如，1号手术室），假如由于人为错误试图访问目的房间0（例如，0号手术室），其访问将被拒绝。简而言之，论文所提出的系统的目的是建立医疗资产（如SMI）访问控制系统，防止由于人为错误或外部安全威胁导致不需要的资产进入错误区域（如房间）。 访问控制机制通常部署在图1所示 RFID 系统的中间件部分，传统的实现通常是基于 RBAC 的中心化结构，而本文提出的方案中，利用 DApp 执行访问控制策略，智能合约用作 Dapp 和区块链间的接口，从而实现了分布式的访问控制，使允许或阻止某个资产进入某个确定的区域（如手术室）成为可能。该论文提出的方案还将将资产（如 SMI）和 GTIN 代码相关联，用于追踪资产。 作者在相关工作部分做了两个比较 ABAC vs. RBAC Decentralized Model vs. Centralized Model 鉴于所作的比较，作者认为使用 ABAC 可以提供良好的灵活性和可扩展性，以及使用以太坊区块链提供分布式信任，实验首先在一个本地以太坊环境中实施，然后部署到 Ropsten 测试网中，最后扩展到以太坊主网络。但在扩展到主网前，需要首先数字化医疗资产。 ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:1:0","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"2. 方案 如前所述，整个方案是一个融合多种不同技术的整体，下面首先对基本架构进行描述，从而使读者对该系统如何执行 ABAC 有一个了解。 ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:2:0","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 分布式系统架构 基于以太坊实施的 ABAC 模型如下图所示，物理节点由 RFID Reader Control（RFID-RC），DApp和智能合约组成。当一个带有 RFID 标签的医疗器械尝试访问一个房间时，RFID-RC 发送访问请求到 DApp，DApp 查询智能合约返回与资产相关的属性（例如公司前缀，产品类型，序列号等），同时，DApp 还会从 RFID-RC 获取其它的属性如时间戳。然后，DApp 基于获取的这些属性来执行安全策略，从而决定来自标签的访问是允许还是拒绝。同时，物理节点可以通过与区块链建立新连接的方式进行复制，不影响现有节点，这体现了该系统可扩展性的优点。 ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:2:1","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 访问控制机制 [主体]^(subject)处理某个 [对象]^(object)的访问请求（例如，允许或拒绝访问），主要基于 ABAC 模型，大致检查四个方面：主体属性，访问控制策略，对象属性和环境信息。 尽管预期主体通常是人类，但诸如[自主服务]^(autonomous service)或应用程序等非人实体也可以作为主体这一角色。本文示例中，Reader 通过 DApp 发起对某个资产（RFID标签）的请求。为了将资产从源房间（如灭菌室）转移到目的房间（如手术室），需要建立一些边界条件。首先，如图4所示，已授权员工通过 DApp发起交易授权资产转移；其次，资产标签使用的 EPC（电子产品代码）如下表示式所示 $$ 01.000389.000162.000169740 \\\\ Header|compPrefix|Product type|Srial Number $$ DApp 收到访问请求后执行的过程如下所述 基于 reader name（如，rdr_nm : “roomA”）和 location（如，loc：“41.40338，2.17403”) 两个属性验证主体(reader) 验证其它属性，包括公司前缀（如， cmp_prf : 000389）、产品类型（如, item_ref: 000162）、指定资产的序列号（如, ser_nmb: 000169740），以及资产状态（如, st: “STERILIZED”） 根据资产被送到医疗室，医疗室的阅读器收到来自资产的访问请求所经过的时间来验证环境属性。如果间隔小于10分钟（600秒），则环境条件验证通过。若在两个位置间移动资产，则发起交易设置该时间，变量 time-In（例如 time_-In:156209335）是交易完成后的时间记录，变量 time-out（例如 time-out:156209455）是 阅读器请求访问此 RFID 标签时给定的时间。 基于论文2的符号表示，我们建立了访问控制策略 C 的表达式如下 $$ if:(rdr_nm = “roomA” \\cap loc = “41.40338,2.17403” \\cap cmp_pfr = 000389 \\cap \\\\ iem_ref = 000162 \\cap ser_nmb = 000169740 \\cap st = “STERILIZED” \\cap \\\\ time_out - time_in \\lt 600), C = True \\\\ otherwise: C = False $$ 访问控制策略在 DApp 上执行而不是作为智能合约的一部分，主要有两个原因：一是公链存在速度限制，如果策略作为合约的一部分，会导致一定的延迟；二是公链中合约是公开的，访问控制策略将被所有人看到。 ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:2:2","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 技术实施细节 图4表明整个系统分为三个子系统：ABAC configuration，ABAC execution 和 ETH blockchain monitoring。下表总结了每个子系统中使用的相关技术 ABAC配置子系统 ABAC 配置子系统包括一个基于 React 构建的图形界面（GUI），通过浏览器交互。GUI 有两个视图，第一个视图允许授权员工向系统中添加新资产，员工将公司前缀、产品类型、资产ID（序列号）等参数输入系统，并随之生成交易存储在 ETH 区块链中。第二个视图用于转移资产，授权用户首先需要通过查询智能合约验证资产ID（序列号），这一操作通过点击 「Verify iD」按钮完成，然后就可以在两个房间转移资产，之前的资产属性如资产状态、时间戳都会更新，资产转移操作通过点击「Transfer asset」按钮完成。 ABAC执行子系统 ABAC 执行子系统是图4中的物理节点，可以允许或拒绝对资产的访问请求，该子系统布置在每个医疗室内。执行子系统包括 RFID reader，LLRP服务器，属性解析器（AP），ABAC安全策略（ABAC-SP）和区块链接口（BI）。后三者构成 DApp，RFID Reader 和 LLRP 服务器构成 RFID-RC（RFID Reader Control） RFID reader 附加标签的资产以及 LLRP 服务器直接交互。其中 LLRP 是 EPC Global 认可的一种协议，它是构成 reader 与其软件或控制硬件之间的接口，该协议在客户端（reader）和服务器（LLRP server）之间发送 XML 消息，论文使用开源工具 Rifidi 基于 SGTIN96 标准创建虚拟的阅读器和标签来进行概念验证。 属性解析器 AP 从LLRP服务器收到 RFID 标签的电子产品代码，然后使用一个基于Node.js库的GTIN 转换系统，将 RFID标签 的电子产品代码转换成 EPC 标签 URL。如下表达式所示，属性解析器解析得到公司前缀、产品类型和序列号等属性，同时也控制其它的属性如时间戳、reader name和位置。 $$ RFID \\ Tag \\ EPC: 3074257bf7194e4000001a85 \\\\ EPC \\ Tag \\ URI: urn:epc:tag:sgtin-96:3.0614141.812345.6789, $$ 区块链接口构建基于Truffle框架，使用 Drizzle 库与 web3.js 服务器交互。Drizzle 是一个编写DApp 前端的前端库集合。DApp 和 RFID 部分通过执行 GET 和 POST 方法通信，例如，ABAC-SP 决定是否允许或拒绝对资产的访问，它设置一个变量，该变量通过 POST 方法发送到 LLRP 服务器。因此，LLRP 服务器发送一个 XML 消息 「keepalive」来保持与 RFID 标签的交互，或者只是断开连接。 区块链监控子系统 使用了 ETH Network Stats 项目监控区块链系统的运行，如下图所示。这里有一个这篇论文实验的视频演示 ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:2:3","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"3. 实验 为了证明方案的可行性，作者在两个环境中进行了实验：本地区块链和 ETH 测试链 Ropsten。 本地区块链环境下，使用如下命令部署了一个 ETH 节点，但设置为 nodiscover，因此无法连接到主网络。 geth –datadir data –unlock 0x8a6d63ea98e05a550b01f8aa4a19021e43bd43f0 –networkid 123456 —-ws -wsaddr 192.168.127.95 –wsport 8546 –wsorigins \"*\" -rpc -rpcaddr 192.168.127.95 –rpcport 8545 –rpccorsdomain \"*\" –nodiscover console 2\u003e\u003e ETH.log, 测试链选择 Ropsten 而不是其它几种的原因如下： 使用 PoW 共识，因此能更好的反映主网情况； 可以同时使用 geth 和 parity 客户端 允许添加自己的节点到测试网络，并可以从一些网址获取测试用的 ether 为了访问网络需要创建一个 Infura 项目，该项目会生成一个系统配置文件（truffle-config.js）会用到的 endpoint URL，如下所示。 ropsten.infura.io/v3/fa42299dbea54014801bc4145d7a1a1e, ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:3:0","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 工具 主要是 ETH Network Stats，Etherscan，Truffle Test 和 Infura Dashboard，这些工具全部被部署到本地环境及测试网络中，其中的例外是 Infura，这只是一个与测试网络有关的工具，下面是对这些工具的描述。 ETH Network Stats是一个追踪以太坊网络状态的可视化工具，使用WebSockets来接收运行节点的数据并通过界面显示，可以在本地单独运行，主要由前端的 Ethereum Network Stats 和后端的 Ethereum Network Intelligence API组成。至于 ETH Network Status 是一个类似的工具，用于 Ropsten 测试网。 Etherscan是一个监控区块链和其上交易状态的工具，作为服务器安装，但可以部署在本地。 Infura Dashboard 是为了更好地理解如何改进 DAPP 而对开发人员需求的响应，使我们能够获得有关调用 web3.js 方法的相关信息，这些方法允许与Ropsten 测试网进行某种类型的交互。 Truffle 是一个自动化测试框架，可以利用 JS 或 Solidity 编写简单易管理的测试。 Tool ETH Network Stats Ethersacn Truffle Test Infura Dashboard 作用 网络监控 区块链监控 智能合约监控 带宽监控 本地环境 本地节点网络监控 本地 ETH 区块链监控（如合约地址，交易和区块等） 测试合约与本地区块链的交互 Ropsten测试网 测试网的网络监控 Ropsten测试网监控（如合约地址，交易和区块等） 测试合约与Ropsten的交互 允许查看每个 web3.js 方法使用的带宽行为 ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:3:1","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 测量 论文对实现的每个部分都进行测试，从网络监控，节点数量和网络哈希速率等功能，到智能合约应用的延迟和每个web3.js方法的带宽消耗。下面分别介绍通过上一小节列出的工具可以监视的主要参数。考虑到与每个工具相关的主要特性，下图是这些工具使用的逻辑顺序 ETH Network Stats 允许监控一些与 ETH 网络状态相关的参数：成功挖掘的区块数、叔块的出现、最后一个区块的挖掘时间、平均挖掘时间、平均网络哈希速率、难度、活动节点、gas price、gas limit、页面延迟、正常运行时间、节点名称、节点类型、节点延迟等。图7是一个使用示例，利用浏览器从一个本地 IP 的3000端口访问。 Ethersacn 获取与区块链相关的信息，如账户余额、账户信息、交易哈希、区块号、token类型（如Erc20）、average gas used、交易花费和交易费用等。 Infura Dashboard 允许获得的参数包括：调用的方法总数、每个方法占用的带宽、占用的总带宽。其测量的主要特征是带宽。 Truffle Test 测量的主要参数是：数据查询时间，数据插入的时间和花费，完整测试的时间，合约部署的 gas 和时间花费等。 ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:3:2","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 结果 ETH Network State 监控网络状态，在这篇论文分析时，Ropsten 已经挖掘了5931224个区块，有14个活跃节点，平均出块时间为 14.04s，平均网络哈希速率为 120.1 MH/s，难度为 2.16 GH。这些参数可以与图7所示的本地区块链进行对比，本地区块链共挖掘了6967个区块，只有一个活动节点，平均出块时间为 27.45s，平均网络哈希速率为 142 KH/s，难度为 1.43 MH。可以看到，本地网络可用计算资源明显小于公网，这是可以预见的。 Etherscan 允许我们查看从我们的区块链测试地址发出的所有交易，可以验证的其他属性包括每个交易的状态、交易所在区块、使用的 gas 百分比（例如，平均 gas 使用量为限值的66.67%）、交易成本和费用以及 PoW 中使用的 nonce。本地网络中获得了类似的结果。 下图来自 Infura Dashboard，详细说明了为了通过智能合约与区块链交互， wpingeb3.js库 调用的主要方法以及它们所花费的带宽。该仪表盘还包括一些其它信息，如每小时带宽使用量的峰值（183.33 MB）和平均值（9.11 MB）。 使用 Truffle Test 进行的测试流程如下图所示 得到的数据如下表，比较了数据插入、数据查询和完整测试的时间和 gas 消耗。百分比的计算公式如下，因为时间的不确定性，分别记录的最好和最坏时间。 $$ (Local_network_time/Ropsten_network_time) × 100 $$ 合约迁移的延迟在本地网络中和测试网中具有很大的不同，但该参数对系统的评价不起决定性作用，因为该过程在系统部署前执行。资产属性的插入是一个主要的方法，尽管延迟是显而易见的，但不会导致访问控制策略的执行延迟。合约部署和数据插入的 gas 消耗不会因网络不同而改变。决定性的指标是数据的查询时间，由于本地网络的节点更少，数据查询的延迟也相对更小。 4. 总结与收获 作者利用区块链实现ABAC的思路没有值得称道的地方，但给出了针对医疗资产转移场景的一个完整方案设计，包括具体的属性管理、使用的工具、测量的参数以及详细的实验过程，这对于我们自己进行一个完整的实验是有很大借鉴意义的。 鉴于本文提到的内容，我们在实现一个基于IoT的访问控制系统时，首先要明确具体的场景并给出示例，基于智能合约实施核心功能后，要实现一个前端界面，以及使用本文提到的诸多工具测量所有相关的参数。对于我们现有的工作，欠缺的是一个前端实现和参数测量。 Figueroa Lorenzo, S.; Añorga Benito, J.; García Cardarelli, P.; Alberdi Garaia, J.; Arrizabalaga Juaristi, S. A comprehensive review of RFID and bluetooth security: Practical analysis. Technologies 2019, 7, 15. ↩︎ Samarati, P.; de Vimercati, S.C. Access Control Policies, Models, and Mechanisms. In International School on Foundations of Security Analysis and Design; Springer: Berlin/Heidelberg, Germany, 2011. ↩︎ ","date":"2019-11-11","objectID":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/:3:3","tags":["论文笔记"],"title":"An ABAC  Model in RFID Systems Based on DApp for Healthcare Environments","uri":"/2019/an-abac-model-in-rfid-systems-based-on-dapp-for-healthcare-environments/"},{"categories":["Golang学习之路"],"content":"本篇介绍字符串的相关操作，涉及string和strconv两个标准库，以及介绍输入输出的基本方法，涉及fmt和bufio两个标准库。 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:0:0","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1. 字符串操作 对字符串的操作无论在什么语言里都是很重要的，因此在基本数据类型中介绍过字符串之后，这里仍然专门拿出一篇来介绍关于字符串的处理。 如我们之前所述，内置的字符串操作是字符串的拼接，通过拼接符+来完成。 s := \"hel\" + \"lo,\" s += \"world!\" fmt.Println(s) //Output: //hello, world! 但使用拼接符+并不是最高效的做法，同时，由于字符串是一种内容不可变的值类型，无法直接通过索引操作其内的任意字符。Go语言内置了strings包来提供对字符串的种种操作，方便我们使用，当然，很多时候也会使用strconv包，这个包的使用我们在类型转换部分提到过。 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:0","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.1 判断包含关系 HasPrefix 判断字符串 s 是否以 prefix 开头： strings.HasPrefix(s, prefix string) bool HasSuffix 判断字符串 s 是否以 suffix 结尾： strings.HasSuffix(s, suffix string) bool 示例如下 package main import ( \"fmt\" \"strings\" ) func main() { var str string = \"This is an example of a string\" fmt.Printf(\"T/F? Does the string \\\"%s\\\" have prefix %s? \", str, \"Th\") fmt.Printf(\"%t\\n\", strings.HasPrefix(str, \"Th\")) } //Output: //T/F? Does the string \"This is an example of a string\" have prefix Th? true 更一般化的，Contains 判断字符串 s 是否包含 substr： strings.Contains(s, substr string) bool ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:1","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.2 获取子字符串的位置 Index 返回字符串 str 在字符串 s 中的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str： strings.Index(s, str string) int LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str： strings.LastIndex(s, str string) int 如果需要查询非 ASCII 编码的字符在父字符串中的位置，使用以下函数来对字符进行定位： strings.IndexRune(s string, r rune) int 示例如下 package main import ( \"fmt\" \"strings\" ) func main() { var str string = \"Hi, I'm Marc, Hi.\" fmt.Printf(\"The position of \\\"Marc\\\" is: \") fmt.Printf(\"%d\\n\", strings.Index(str, \"Marc\")) fmt.Printf(\"The position of the first instance of \\\"Hi\\\" is: \") fmt.Printf(\"%d\\n\", strings.Index(str, \"Hi\")) fmt.Printf(\"The position of the last instance of \\\"Hi\\\" is: \") fmt.Printf(\"%d\\n\", strings.LastIndex(str, \"Hi\")) fmt.Printf(\"The position of \\\"Burger\\\" is: \") fmt.Printf(\"%d\\n\", strings.Index(str, \"Burger\")) } /*Output: The position of \"Marc\" is: 8 The position of the first instance of \"Hi\" is: 0 The position of the last instance of \"Hi\" is: 14 The position of \"Burger\" is: -1 */ ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:2","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.3 统计出现次数 Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数： strings.Count(s, str string) int 示例 package main import ( \"fmt\" \"strings\" ) func main() { var str string = \"Hello, how is it going, Hugo?\" var manyG = \"gggggggggg\" fmt.Printf(\"Number of H's in %s is: \", str) fmt.Printf(\"%d\\n\", strings.Count(str, \"H\")) fmt.Printf(\"Number of double g's in %s is: \", manyG) fmt.Printf(\"%d\\n\", strings.Count(manyG, \"gg\")) } /*Output: Number of H's in Hello, how is it going, Hugo? is: 2 Number of double g’s in gggggggggg is: 5 */ ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:3","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.4 替换与重复 Replace 用于将字符串 str 中的前 n 个字符串 old 替换为字符串 new，并返回一个新的字符串，如果 n = -1 则替换所有字符串 old 为字符串 new： strings.Replace(str, old, new, n) string Repeat 用于重复 count 次字符串 s 并返回一个新的字符串： strings.Repeat(s, count int) string 示例 package main import ( \"fmt\" \"strings\" ) func main() { var origS string = \"Hi there! \" var newS string newS = strings.Repeat(origS, 3) fmt.Printf(\"The new repeated string is: %s\\n\", newS) } //Output: //The new repeated string is: Hi there! Hi there! Hi there! ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:4","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.5 大小写转换 ToLower 将字符串中的 Unicode 字符全部转换为相应的小写字符： strings.ToLower(s) string ToUpper 将字符串中的 Unicode 字符全部转换为相应的大写字符： strings.ToUpper(s) string 示例 package main import ( \"fmt\" \"strings\" ) func main() { var orig string = \"Hey, how are you George?\" var lower string var upper string fmt.Printf(\"The original string is: %s\\n\", orig) lower = strings.ToLower(orig) fmt.Printf(\"The lowercase string is: %s\\n\", lower) upper = strings.ToUpper(orig) fmt.Printf(\"The uppercase string is: %s\\n\", upper) } /*Output: The original string is: Hey, how are you George? The lowercase string is: hey, how are you george? The uppercase string is: HEY, HOW ARE YOU GEORGE? */ ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:5","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.6 修剪与分割 可以使用 strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号； 可以使用 strings.Trim(s, \"cut\") 来将开头和结尾的指定字符串（cut）去除掉。 如果只想剔除开头或者结尾的字符串，则可以使用 TrimLeft 或者 TrimRight 来实现。 strings.Fields(s) 将会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice。 strings.Split(s, sep) 用于自定义分割符号来对指定字符串进行分割，同样返回 slice。 因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:6","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.7 拼接 Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串： strings.Join(sl []string, sep string) string 示例 package main import ( \"fmt\" \"strings\" ) func main() { str := \"The quick brown fox jumps over the lazy dog\" sl := strings.Fields(str) fmt.Printf(\"Splitted in slice: %v\\n\", sl) for _, val := range sl { fmt.Printf(\"%s - \", val) } fmt.Println() str2 := \"GO1|The ABC of Go|25\" sl2 := strings.Split(str2, \"|\") fmt.Printf(\"Splitted in slice: %v\\n\", sl2) for _, val := range sl2 { fmt.Printf(\"%s - \", val) } fmt.Println() str3 := strings.Join(sl2,\";\") fmt.Printf(\"sl2 joined by ;: %s\\n\", str3) } /*Output: Splitted in slice: [The quick brown fox jumps over the lazy dog] The - quick - brown - fox - jumps - over - the - lazy - dog - Splitted in slice: [GO1 The ABC of Go 25] GO1 - The ABC of Go - 25 - sl2 joined by ;: GO1;The ABC of Go;25 */ ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:7","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2. 输入输出 编写程序进行数据的读写必不可少，一般会用到fmt, os和bufio三个包，下面对一些读写方式进行总结。 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:0","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2.1 读取用户输入 用户输入来自三种：标准输入，字符串，io.Reader类型 来自标准输入 读取用户输入一般指的是读取用户的键盘（控制台）输入，定义为标准输入os.Stdin，最常用的方法是使用fmt包提供的Scan开头的函数。 func Scan(a ...interface{}) (n int, err error) func Scanf(format string, a ...interface{}) (n int, err error) func Scanln(a ...interface{}) (n int, err error) Scan从标准输入扫描文本，将成功读取的空白分隔的值传递给函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。 Scanf从标准输入扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值传递给函数的参数。返回成功扫描的条目个数和遇到的任何错误。 Scanln类似Scan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。 一个示例程序如下： package main import \"fmt\" var firstName, lastName string func main() { fmt.Println(\"Please enter your full name: \") fmt.Scanln(\u0026firstName, \u0026lastName) // fmt.Scanf(\"%s %s\", \u0026firstName, \u0026lastName) } 来自字符串 读取来自字符串的输入一般使用fmt包中SScan开头的函数 func Sscan(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) SScan开头的函数基本和Scan相似，唯一的不同是多了第一个参数str，代表从字符串str扫描文本。一个示例程序如下： package main import \"fmt\" func main() { var name string var age int n, err := fmt.Sscanf(\"Kim is 22 years old\", \"%s is %d years old\", \u0026name, \u0026age) if err != nil { panic(err) } fmt.Printf(\"%d: %s, %d\\n\", n, name, age) } //Output 2: Kim, 22 来自io.Reader类型 主要是使用Fscan开头的函数 func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) 同样，与Scan的不同是第一个参数r是io.Reader类型，示例程序如下： package main import ( \"fmt\" \"os\" \"strings\" ) func main() { var ( i int b bool s string ) r := strings.NewReader(\"5 true gophers\") //返回一个io.Reader类型 n, err := fmt.Fscanf(r, \"%d %t %s\", \u0026i, \u0026b, \u0026s) if err != nil { fmt.Fprintf(os.Stderr, \"Fscanf: %v\\n\", err) } fmt.Println(i, b, s) fmt.Println(n) } 5 true gophers 3 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:1","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2.2 输出指定内容 输出和读取输入基本是是相反的，各函数原型如下： func Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) func Sprint(a ...interface{}) string func Sprintf(format string, a ...interface{}) string func Sprintln(a ...interface{}) string func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) 示例程序如下： package main import ( \"fmt\" \"io\" \"os\" ) func main() { const name, age = \"Kim\", 22 fmt.Printf(\"%s is %d years old.\\n\", name, age) s := fmt.Sprintf(\"%s is %d years old.\\n\", name, age) io.WriteString(os.Stdout, s) // Ignoring error for simplicity. n, err := fmt.Fprintf(os.Stdout, \"%s is %d years old.\\n\", name, age) if err != nil { fmt.Fprintf(os.Stderr, \"Fprintf: %v\\n\", err) } fmt.Printf(\"%d bytes written.\\n\", n) } //Output Kim is 22 years old. Kim is 22 years old. Kim is 22 years old. 21 bytes written. ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:2","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2.3 使用bufio包 使用fmt进行读写，读写次数比较多时，时间耗费极大。go提供了一个bufio包，使用该包可以大幅提高文件读写效率。 bufio包原理 介绍来自茹姐-GO语言基础进阶教程：bufio包。io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。 读入 package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { inputReader := bufio.NewReader(os.Stdin) fmt.Println(\"Please enter some input: \") input, err := inputReader.ReadString('\\n') if err == nil { fmt.Printf(\"The input was: %s\\n\", input) } } bufio.NewReader() 构造函数的签名为：func NewReader(rd io.Reader) *Reader inputReader 是一个指向 bufio.Reader 的指针。inputReader := bufio.NewReader(os.Stdin) 这行代码，将会创建一个读取器，并将其与标准输入绑定。返回的读取器对象提供一个方法 ReadString(delim byte)，该方法从输入中读取内容，直到碰到 delim 指定的字符，然后将读取到的内容连同 delim 字符一起放到缓冲区。在上面的例子中，我们会读取键盘输入，直到回车键（\\n）被按下。 写出 package main import ( \"os\" \"fmt\" \"bufio\" ) func main() { w1 := bufio.NewWriter(os.Stdout) for i:=1;i\u003c=1000;i++{ w1.WriteString(fmt.Sprintf(\"%d:hello\",i)) } w1.Flush() } ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:3","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2.4 文件读写 主要是使用os.Open函数打开文件，以及defer关键字和close方法在程序结束时关闭文件。 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) func main() { inputFile, inputError := os.Open(\"input.dat\") if inputError != nil { fmt.Printf(\"An error occurred on opening the inputfile\\n\" + \"Does the file exist?\\n\" + \"Have you got acces to it?\\n\") return // exit the function on error } defer inputFile.Close() inputReader := bufio.NewReader(inputFile) for { inputString, readerError := inputReader.ReadString('\\n') fmt.Printf(\"The input was: %s\", inputString) if readerError == io.EOF { return } } } 未完待续… ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:4","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["我所热爱的生活啊"],"content":"经济是每个人都躲不开的东西，作为普通人，搞懂一些生活中的经济常识，能帮助我们活得更明白一点，这些知识包括缴税、理财、买房、养老、生育、贷款等等，都是与每个人息息相关的。本篇学习五险一金。 五险一金指的是养老、医疗、失业、工伤、生育五种保险和住房公积金，其中的五种保险统称社保。五险一金由国家强制规定，由个人和公司共同承担，公司不给缴是违法的。 ","date":"2019-11-09","objectID":"/2019/insurances-and-public-housing-fund/:0:0","tags":["生活技能"],"title":"经济学常识-五险一金","uri":"/2019/insurances-and-public-housing-fund/"},{"categories":["我所热爱的生活啊"],"content":"1. 怎么缴 全国各省市五险一金的缴费比例不同，具体可在当地社保机构查询。以北京为例，其缴费比例如下表所示，注意，工伤和生育保险完全由公司来缴，个人不需要缴纳。 项目 个人承担 企业承担 备注 养老保险 8% 20% 单位20%（其中17%划入统筹基金，3%划入个人账户），个人8%（全部划入个人账户） 医疗保险 2%+3元 10% 失业保险 0.5% 1.5% 工伤保险 无 0.3% 工伤保险根据单位被划分的行业范围来确定工伤费率 生育保险 无 0.8% 须为北京市户口或有北京工作居住证 住房公积金 12% 12% 根据企业实际情况，选择祝福公积金缴费比例，原则上最高缴费额不得超过北京市职工平均工资300%的12% 注意，这里的缴费比例都是相对于缴费基数来讲的，将缴费基数与缴费比例相乘，才是应缴的钱。缴费基数和工资有关，但一般还会设定一个缴费的上限与下限，超过上限缴费基数就按上限算，低于下限按下限算，只有在中间才按工资本身算。个人缴费的比例示意图如下 五险一金的缴纳是按原始工资算的，而我们领到的工资是先扣除五险一金，再扣除个人所得税的金额。此外，人们常有一些认识上的误区，总结如下 工资的计算应以直接支付给职工的全部劳动报酬为根据，包括奖金、津贴、补贴、加班费等收入，只按基本工资算是不合法的。 从试用期开始，单位就应该与员工签订书面劳动合同，并足额缴纳社会保险费。 社保的缴纳不仅是单位的义务，也是个人的义务，因此个人出具的自愿放弃社保等协议书是无效的。 ","date":"2019-11-09","objectID":"/2019/insurances-and-public-housing-fund/:1:0","tags":["生活技能"],"title":"经济学常识-五险一金","uri":"/2019/insurances-and-public-housing-fund/"},{"categories":["我所热爱的生活啊"],"content":"2. 怎么用 我们缴的五险一金最后会到两个地方：统筹基金和个人账户。具体对每种保险要分开看，重点关注养老和医疗保险。 更具体的，要分别来看 养老保险 现行的养老保险其实是一种现收现付制，也就是国家用现在工作的人交的养老金发给现在的老年人。当然，领取养老金也要满足一定的条件，即在退休前养老保险缴满15年，如果不够15年，自己缴的那部分会退还，但公司帮忙缴的那部分就没有了。 假设一个人税前工资2万，那么他每个月养老保险要缴8%，也就是1600元，公司缴的大概占20%，大概4000元。一共5600元会统一存放到社保基金中，由国家保管并发放给老年人，等到我们多年后退休，我们也是从社保基金中领取养老金。 具体最后能领多少，基本上取决于两个因素：自己工作多年的平均工资和缴费年限。这两个数字越高，退休后能领的养老金就越多。同时，养老金的计算以当时的社会平均工资为基础，因此不用担心钱贬值的问题，但这个数字就不是自己能决定的了。举个例子，一个人月薪2万，另一个人月薪3500，工龄都是30年，他们退休后的社会平均工资为5000，那么他们可以领到的退休金分别为每月7100元和每月2000元。 但这种制度存在一些问题，第一个是养老金的领取和社会平均工资挂钩，但和物价水平无关；第二个就是随着老龄化社会加剧，上班的人变少，老年人变多，就会导致社保基金入不敷出… 解决的办法有一些，一种办法是在社保基金有盈余的时候拿这部分钱去投资，比如换取国有企业的股份，每年领取固定红利来发放养老金，还有就是推迟退休年龄和开放生育2胎等，至于效果怎么样，就只能慢慢看了 目前的养老制度是多层次的，即在国家基本养老制度的基础上，还可以参加职业养老保险和商业养老保险。职业养老保险是大公司给员工缴的，比例和国家养老保险差不多，都是个人和公司各缴一部分，这笔钱统一交给基金公司去投资，本金和收益都归属自己，但退休后才能用，当然，现在的人很少在一个公司干一辈子，这个很难说。商业养老保险就是各保险公司推销的那种，虽然买的好很有用，但种类繁多，千差万别，买的时候一定要注意。 医疗保险 医保的全名叫社会医疗保险，分两部分，自己缴的医疗保险大概2%，会到自己的医保卡账户，公司缴的医疗保险大概8%，一小部分进入医保账户，大部分进入统筹基金。 平常买药门诊用的都是自己的医保卡，其实就相当于一张银行卡，但不是所有药都可以刷医保卡。而遇到重病住院，就需要调用统筹基金里的保险金，报销一部分花费。 医保的报销比较乱，有的是医院直接报销，有的得去社管局，而且能报的部分并不多，首先要减去起付线，然后超过封顶线的也不给报，最后不同医院不同药物报销比例也不一样，比如去社区医院看病可以报销90%，三甲医院就只有80%，医保划分的三类药品中，甲类（价格低的常见药）就都可以报，比甲类贵一点的乙类就只能报一部分，最后的丙类就完全不给报。 最后的最后，进口药、特殊医疗设备、特殊医疗服务等等，以及非治疗类或第三方造成的伤害，比如整容、保健、车祸、打架也不给报。 在医保之外，也可以自己参加商业医疗保险，多一层保障，但也要注意擦亮眼睛。 失业、工伤、生育保险 失业保险要缴满一年才能用，而且办理手续麻烦，钱也很少。 工伤保险全部由公司缴，工作时受伤可以报销，上下班路上出事以及一些职业病也算。 生育保险大概包括带薪产假、生育津贴、医疗费报销等。 住房公积金 专门解决房子问题，没房子也可以用于租房、自己盖房和自建房翻修，如果住房公积金一直没用过，退休后会全部发放。 多张社保卡可以转移合并 ","date":"2019-11-09","objectID":"/2019/insurances-and-public-housing-fund/:2:0","tags":["生活技能"],"title":"经济学常识-五险一金","uri":"/2019/insurances-and-public-housing-fund/"},{"categories":["我所热爱的生活啊"],"content":"参考 [1] 陈磊等. 半小时漫画经济学[M]. 海南出版社. 2019.10 ","date":"2019-11-09","objectID":"/2019/insurances-and-public-housing-fund/:3:0","tags":["生活技能"],"title":"经济学常识-五险一金","uri":"/2019/insurances-and-public-housing-fund/"},{"categories":["我所热爱的生活啊"],"content":"日常生活中会遇到不少突发事件，如运动受伤、烧伤、溺水、中毒等，掌握一些常见的急救知识，并且在意外发生时沉着冷静，及时进行处理，可以减轻自己或他人的痛苦，避免进一步损伤，甚至可以拯救生命。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:0:0","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"1. 心肺复苏（CPR） CPR适用于电击、溺水、药物中毒等各种原因造成的呼吸和心跳停止，当心跳停止， 循环中断，如果未给予任何处理，脑部在4-6分钟后开始受损，超过10分钟没有急救将会造成无法恢复的脑损害。心肺复苏的原理是采用胸外按压和人工呼吸形成暂时的人工循环，使血液可推进到脑部，以维持生命。如果在心脏停跳4分钟内实施初步CPR，可大幅减小死亡率。CPR发明于1960年，从未发生过因口对口人工呼吸而传染艾滋病的案例。 心肺复苏的步骤可参见红十字会-CPR Step，但具体的执行最好经过专门训练，否则容易引起其它伤害。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:1:0","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"2. 海姆利克急救法 初次知晓这个概念是在看一段视频的时候，视频中吃饭的男子突然站起，手掐喉咙，好似在努力吐东西，有弹幕提示说应该是食物进入了气管，这时这家饭店里有人冲出来（疑似店主），站到男子身后，双手勒住其下腹部，不断上提，最后该男子平安无事。弹幕中有人提示这是海姆利克急救法，大家都应该学一下，于是大感兴趣，将此概念记录了下来，但直到此刻才想起具体了解和整理。 海姆利克急救法，Heimlich Maneuver，主要用于抢救异物卡喉窒息，它是海姆利克教授于1974年发明的。其原理是窒息时，患者的肺内仍有残留气体，给膈以下软组织以突然向上的压力，使胸腔压力骤然升高，从而压迫双肺，驱使肺内残存的气流进入气管，便可排出卡在气管口的食物或其他异物。 海姆利克急救法的步骤：抢救者应站于患者身后，两臂绕至患者腰前抱紧。一手握拳，以拇指侧顶住患者腹部，略高于脐上，在肋缘之下。另一手与握拳之手紧握，并以突然的快速向上冲力，向患者腹部加压。必要时可反复数次，直至异物从喉喷出。 更具体的操作可以参见wikiHow-如何实施海姆利克急救法 维基百科中建议使用该方法前先使用拍背和胸部冲击，知乎-海姆利克急救法的正确打开方式给出了5次拍背法和5次压胸法的说明 很多文章声称该法可推广用于拯救溺水者，但红十字会和海姆利克研究所已停止提倡，因为可能会使溺水者因呕吐而窒息。 海姆利克急救法可能造成伤害，如腹部瘀伤，严重可能出现肋骨骨折 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:2:0","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"3. 外伤性出血 外伤性出血可分为外出血和内出血两种。血液从伤口流向体外者称为外出血，常见于刀割伤、刺伤、枪弹伤和碾压伤等。若皮肤没有伤口，血液由破裂的血管流到组织、脏器或体腔内，称为内出血，内出血一般出血量比较大，并且大多伴有重要脏器损伤，因此必须紧急抢救，呼叫救援。 出血量为全身血容量10%-15%时，会出现头昏、畏寒等症状；达到20%以上时，出现皮肤苍白、厥冷、头晕、乏力、出汗、脉快、心悸等症状；达到30%以上，则有脉搏细弱、呼吸加快、血压下降及休克等症状。止血是救治的主要目的。 根据出血部位的不同，止血方式也不同。毛细血管、静脉出血、骨髓出血可使用压迫和填塞止血，动脉出血一般使用间接指压法止血。 压迫与填塞止血法 毛细血管出血：血液从创面或创口四周渗出，出血量少、色红，找不到明显的出血点，危险性小。这种出血常能自动停止。通常用碘酊和酒精消毒伤口周围皮肤后，在伤口盖上消毒纱布或干净的手帕、布片，扎紧就可止血。 静脉出血：暗红色的血液，缓慢不断地从伤口流出，其后由于局部血管收缩，血流逐渐减慢，危险性也较小。止血的方法和毛细血管出血基本相同。抬高患肢可以减少出血，如在出血部位放上几层消毒纱布或干净手帕等，加压包扎即可达到止血的目的。比如流鼻血，可以参考知乎-流鼻血最合理的止血方式 骨髓出血：血液颜色暗红，可伴有骨折碎片，血中浮有脂肪油滴，用敷料或干净多层手帕等填塞止血。 动脉出血：血液随心脏搏动而喷射涌出，来势较猛，颜色鲜红，出血量多，速度快，危险性大。动脉出血急救，一般用间接指压法止血。即在出血动脉的近端，用拇指和其余手指压在骨面上，予以止血。在动脉的走向中，最易压住的部位叫压迫点，止血时要熟悉主要动脉的压迫点。这种方法简单易行，但因手指容易疲劳，不能持久，所以只能是一种临时急救止血手段，而必须尽快换用其它方法。 加垫屈肢止血法 四肢膝、肘以下部位出血时，如没有骨折和关节损伤，可将一个厚棉垫、泡沫塑料垫或绷带卷塞在腋窝或肘窝部，屈曲腿和臂，再用三角巾、宽布条、手帕或绷带等紧紧缚住。 止血带止血法 止血带分橡皮止血带、布制止血带（叠成条状）和临时止血带等。方法是，将止血带放置于出血部位的上方，将伤肢扎紧，把血管压瘪而达到止血的目的,此种止血法只适用于四肢部位血管的出血。日常可以在家里常备一些止血带以备不时之需。止血带止血法虽较牢固，但有一些注意事项，如 止血带应放在伤口近心端。上臂和大腿都应绷在上1/3部位，上臂中1/3禁止上止血带，以免压迫神经引起上肢麻痹 上止血带前先用毛巾或其它布片、棉絮垫一下，止血带不要直接扎在皮肤上，没有条件时可将裤脚或袖口卷起，止血带扎在上面 要扎得松紧合适，过紧损伤神经，过松达不到止血目的 结扎时间过久可能引起肢体缺血坏死，因此要每隔1小时左右放松2-3分钟；放松期间使用指压法暂时止血，寒冷季节每隔30分钟放松一次；结扎部位超过2小时，应更换比原来较高得位置结扎 记录上止血带得时间和部位，及时送往医院，防止肢体缺血导致坏死 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:3:0","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"4. 中暑 中暑是指在高温和热辐射的长时间作用下，机体体温调节障碍，水、电解质代谢紊乱及神经系统功能损坏症状的总称。当气温超过皮肤温度（一般为32℃-35℃），或环境中有热辐射源（电炉、明火等），或空气中湿度过高又通风不良，体内热量难以散发，贮存累计就会引起中暑。 中暑可分为先兆中暑、轻度中暑和重度中暑。 先兆中暑的症状为头痛、头晕、口渴、恶心、多汗、四肢无力发酸、注意力不集中和动作不协调等，体温正常或略有升高；轻度中暑除了先兆中暑的表现外，还有面色潮红或苍白、呕吐、气短、大汗、脉搏细弱、心率增快等症状，体温可能超过38℃。这两种情况出现时，应立即离开高温环境，选择阴凉通风处休息，喝一些带盐分的饮料；涂抹清凉油、风油精，或服用藿香正气水等。如果没有缓解，前往卫生所或医院治疗。 中毒中暑一般出现昏迷、高热等情况，需要及时转移至阴凉通风处，使其平躺，抬高下肢，松开衣领，用冷水或酒精擦拭，严重者送往医院。 为防止中暑，高温天气出门应穿戴太阳镜、遮阳伞等装备，穿透气性好的衣服，长时间在户外要准备防暑药品如藿香正气水，出汗过多及时补充带相关电解质的饮料。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:4:0","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"5. 运动性损伤 运动性损伤是指体育运动中由于个人或环境因素造成的损伤，按轻重程度分为轻度损伤和重度损伤。重度损伤如骨折、关节脱位（脱臼）、脑震荡和内脏破裂应及时拨打120前往医院救治，这里只介绍轻度损伤。 擦伤是由摩擦产生的表皮脱落、翻卷等为主要表现的损伤。擦伤表面常沾有脏物，应首先清洗创面，可使用淡盐水（没有可用自来水）边冲洗边用干净棉签擦洗，将泥灰等脏物洗去。如有砂子、煤渣等嵌入皮肤，应及时用软毛刷刷洗去除，不能有渣屑留在皮肤内，否则伤口愈合后，脏物可能留在皮肤里难以去除。用碘酒、75%酒精等消毒伤口周围，伤口本身使用双氧水消毒，小伤口不用包扎，大伤口可用消毒纱布包扎，但要注意创面清洁干燥。创面结痂前尽可能不要沾水，并要及时换药。擦伤的伤口不适合用创可贴，因为创可贴吸水性和透气性一般不好，不利于创面分泌物和脓液引流，反而有助于细菌滋长，容易引起伤口发炎，不利于伤口愈合。 撕裂伤是指身体受到钝性暴力打击引起的皮肤、皮下组织撕裂，多为对抗类运动中头部被碰撞引起的撕裂。如伤口较浅小干净，用碘酊或其它外用消毒剂消毒，然后用创可贴或消毒纱布包扎即可，若伤口较深或较脏，现场处理包扎后及时送往医院进行清创、止血、缝合，并注射破伤风疫苗。 刺伤和切伤是指锐细物刺穿皮肤及皮下组织器官的损伤，如田径运动中鞋钉与标枪的刺伤，刺伤伤口细小，但较深，可能伤及深部组织或器官或将异物带入伤口深处，容易引起感染；切伤是指锐器切入皮肤及皮下组织所致的损伤。这两者的处理同撕裂伤，但要注意有无神经、血管、肌腱等深部重要组织的损伤。 挫伤是指由钝性物体或墩力作用于人体软组织面发生的非开放性损伤，在运动中常因相互冲撞、踢打、挤压、拌跌等发生。轻度挫伤仅在损伤部位有疼痛、肿胀、皮下出血、皮肤青紫等症状；重度挫伤则可引起血肿甚至休克。部位不同的挫伤可引起不同的功能障碍，如关节挫伤可在运动时出现明显疼痛。 拉伤是指肌肉、韧带在外力的作用下过度收缩或牵拉所引起的损伤。轻度拉伤一般只有肌肉或韧带极少部分的撕裂，仅出现局部疼痛、肿胀、压痛、肌肉紧张或痉挛，功能障碍，重度拉伤则为肌肉或韧带的大部分撕裂或完全撕裂，症状重，并可在撕裂处摸到凹陷或一端隆起。皮下组织可见到明显的淤血。 扭伤是指在外力作用下、关节发生超常范围的活动，造成关节内外侧副韧带损伤。轻者因韧带只是部分纤维断裂，可只表现为关节出现疼痛、肿胀、皮下淤血、关节功能障碍可不明显，重者因韧带纤维完全断裂，可引起关节脱位或半脱位，同时合并关节内滑膜和软骨损伤。 三种损伤(挫伤、拉伤、扭伤)都属于闭合性软组织损伤，这种损伤在运动中较为常见，如处理不当，往往会变成慢性或留下不同程度的功能障碍。其轻度损伤急性期处理原则基本一致：制动、止血、止痛、防肿和减轻炎症反应。受伤后的48小时内冷敷非常重要，可控制出血和渗出，减轻肿胀、疼痛等症状，若伤后疼痛较剧烈可服用止痛剂，若肿胀较明显，则可用弹性绷带固定压迫同时将下肢抬高增加静脉血回流。在出血停止以后可使用热敷，以加速消散伤处周围的瘀血。一般而言，受伤24到48小时后始用热敷。重度闭合性软组织损伤需在加压包扎后急送医院进行救治。 肌肉痉挛俗称抽筋，是指肌肉突然、不自主的强直性收缩。它是运动中较为常见的一种症状，常因寒冷刺激、疲劳、电解质失调、肌肉收缩失调或损伤引起肌肉强直性收缩。运动中最易发生痉挛的肌肉是小腿腓肠肌，其次为足底的屈跖肌和屈趾肌。痉挛的肌肉僵硬或隆起，疼痛难忍，痉挛肌肉所涉及关节的伸屈功能有一定障碍；痉挛缓解后，局部仍有酸痛不适感。肌肉痉挛的急救为牵拉屈曲的指(趾)，使过伸，以使痉挛的肌肉被牵伸而解痉，如腓肠肌痉挛，可伸直膝关节，同时用力将踝关节背伸；如屈跖肌和屈趾肌痉挛，可用力背伸踝关节和足趾。牵引时用力宜均匀、缓慢，切忌暴力，然后局部按摩，热敷。肌肉痉挛的预防一般是在运动前充分做好准备活动(特别在寒冷环境中锻炼时，尤需注意这)，冬季注意保暖，夏天出汗多，注意喝些盐开水，补充丧失的电解质，疲劳或饥饿时不宜参加体育运动等。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:5:0","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"6. 意外伤害 主要包括烧伤、电击、毒蛇咬伤和溺水等。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:6:0","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"烧伤 烧伤是指热力、化学物质、电能、放射线等引起的皮肤、粘膜，甚至深部组织的损害，其中皮肤热力烧伤（如火焰、开水）最为常见。根据损伤到皮肤不同的深度，将烧伤分为四度，即Ⅰ度、浅Ⅱ度、深Ⅱ度、Ⅲ度和Ⅳ度烧伤。 Ⅰ度烧伤损伤最轻，烧伤皮肤发红、疼痛、明显触痛、有渗出或水肿，轻压受伤部位时局部变白，但没有水疱，无须特殊治疗即可在3-5天痊愈，愈后不留疤痕，可有暂时性色素沉着。 浅Ⅱ度烧伤局部红肿，渗液较多而形成大小不等的水疱，创面湿润，创底鲜红、水肿、剧痛，若无感染可于2周内痊愈，无疤痕形成，可有暂时性色素沉着。 深Ⅱ度烧伤局部肿胀，白色或棕黄色，水疱较小，感觉迟钝，皮温稍低，疼痛较轻，如无感染可与3-4周愈合，愈后有疤痕，但皮肤功能基本保存。 Ⅲ度烧伤累及皮肤的全层甚至皮下脂肪，创面苍白或焦黄炭化，无疼痛，无水疱，感觉消失，质韧似皮革，3~4周焦痂脱落后遗留肉芽组织面，愈后遗留癜痕，皮肤功能分丧失，造成畸形。 Ⅳ度烧伤可累及肌肉、内脏器官等。 I度烧伤无须特殊治疗就能自愈；浅Ⅱ度烧伤若仅为单个水疱，可由医生在无菌条件下抽出水疱液后包扎治疗，多处或面积较大可以包扎或暴露，辅以烧伤外用药治疗；深Ⅱ度烧伤可采取包扎、暴露治疗，或磨痂、削痂手术治疗；Ⅲ度烧伤一般采取切削痂、各种植皮手术治疗；Ⅳ度烧伤若毁损严重需截肢(或截指、趾)治疗，若有挽救可能，采取皮瓣修复。除Ⅰ度和未发生感染的浅Ⅱ度烧伤外，其他深度烧伤均遗留瘢痕，中、重度烧伤的治疗不仅复杂，并且花费巨大，但是如果现场急救和自救稳妥得当，则会给后续治疗带来很好的效果，现场的急救和自救措施包括 迅速设法除去引发烧伤的原因，如热源、开水、化学腐蚀性物质等。 除去引发烧伤的原因后，立即用清水(水温一般为15℃~20℃)冲洗创面15~30分钟，如无法冲洗，则可采取冷敷。 在冲洗过程中，小心剪开衣物。 继续在冷水中浸泡15~30分钟。 在暴露的烧烫伤创面上用干净的布、巾覆盖。 腐蚀性化学物灼伤眼睛或皮肤时，要将伤侧朝下，慢慢用清水冲洗15分钟，再包扎送医院处理，在冲洗眼睛时应从眼睛内角向外角冲洗，并避免揉搓眼睛，不能用酸性物质中和碱性物质，反之亦然。生石灰烧伤，不能立即用水冲洗，因为生石灰遇水会产生大量热，加重创面的损伤程度。所以首先必须将创面上的生石灰完全清除干净，然后用大量清水冲洗创面。在急救和自救过程中，应注意不要弄破烧烫伤处的水疱，以防感染；不要在创面处吹气或涂抹牙膏、芦荟、消炎粉等，以防伤情恶化。在上述措施进行后，应将患者送往医院进行治疗。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:6:1","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"电击 电击伤是当一定电流能量(静电)通过人体引起损伤、功能障碍甚至死亡，俗称触电。高电压还可引起电热灼伤，雷击也是一种电击伤，而且是高电压损伤。 引起电击伤的原因包括：不懂安全用电常识、自行安装电器、在电线上晒湿衣服、雷雨时在大树下避雨或撑铁柄伞，身体进入高压电弧内，救其他触电者直接用手拉等，因大风雪、火灾、地震、房屋倒塌扽使高压线断裂落地；闪电击伤等因素也会引起电击伤。 当人体接触电流时，轻者立刻出现惊慌、呆滞、面色苍白，接触部位肌肉收缩，且有头晕、心动过速和全身乏力。重者出现昏迷、持续抽搐、心室纤维颤动、心跳和呼吸停止。电流引起的灼伤在人口处程度比出口处重。灼伤皮肤呈灰黄色焦皮，中心部位低陷，周围无肿、痛等炎症反应。当人被闪电击中，心跳和呼吸常立即停止，并伴有心肌损害。皮肤血管收缩呈网状图案，认为是闪电损伤的特征。 触电急救基本的办法是断开电源，使用绝缘体拉开触电者等，触电症状无论轻重，都应立即送到医院急救。 一些预防措施是被从小教育的，如不要用湿手触摸带电物品，雷雨天避免在野外行走和大树下避雨等，人离落地的电线距离应在10米以上，室内最少4米以上，如果处在危险区域，应单脚跳跃或双脚小碎步离开。 一般来说，我们遇到的电击多数是220伏民用电或380伏工业用电，当无人救援时，务须镇静自救，在触电后的最初几秒内，人的意识并未完全丧先，触电者可用另一只手抓住电线绝缘处，把电线拉出，摆脱触电状态；如果触电时电线或电器固定在墙上，可用脚猛蹬墙壁，同时身体往后倒，借助身体重量甩开电源。而在野外遇到雷击时，如感到头发竖起、皮肤刺痛，应立即卧倒，迅速滚向别处，以减轻身体损伤。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:6:2","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"毒蛇咬伤 我国蛇类有160余种，其中毒蛇50余种，常与夏秋两季出现在森林、山区、草地，当人在草地行走、采野果、拔菜、散步、军训时易被咬伤。 在野外被蛇咬伤，首先要判断是否是毒蛇：毒蛇头多呈三角形，颈部较细，尾部短粗，色斑较鲜艳，咬人时嘴张的很大，牙齿较长；无毒蛇头多呈椭圆形，身上色彩单调，尾部细长。无法判断时，一律按毒蛇咬伤处理。 毒蛇咬伤后，伤口局部常留有一对或3~4毒牙痕迹。且伤口周围明显肿胀及疼痛或麻木感，局部有淤斑、水疱或血疱，全身症状也较明显。局部有两排深粗牙痕，有出血、疼痛、红肿，并向躯体近心端蔓延，附近淋巴结肿大，有压痛，起水疱。全身症状有发热、寒战、头晕、头痛、乏力、恶心、呕吐、嗜睡、腹痛、腹泻、视物不清、鼻出血，严重者惊厥、昏迷、心律失常、呼吸困难、麻痹、心肾衰竭。 咬伤后的急救处理步骤为： 及时绑扎伤口：被咬伤后应保持镇静，立即坐下，自行或叫人帮忙，用迅速可以找到的鞋带、裤带之类的绳子绑扎伤口的近心端。绑扎的目的仅在于阻断毒液经静脉和淋巴回流人心，而不妨碍动脉血的供应，与止血的目的不同。故绑扎无须过紧，它的松紧度掌握在能够使被绑扎的下部肢体动脉搏动稍微减弱为宜。绑扎时间可持续8~10小时，每隔15~30分钟放松1~2分钟，一般在伤口排毒和服药后1~3小时解除绑扎。咬伤超过12小时后不宜绑扎。 迅速排除毒液：立即用凉开水、泉水、肥皂水或1：5000高锰酸钾溶液冲洗伤口及周围皮肤，以洗掉伤口外表毒液。如果伤口内有毒牙残余，应迅速用小刀或碎玻璃片等其它锐物挑出，使用前应常规消毒。以牙痕为中心作十字切开，深至皮下，然后用手从肢体的近心端向伤口方向及伤口周围反复挤压，促使毒液从切开的伤口排出体外，边挤压边用清水冲洗伤口，冲洗挤压排毒须持续20~30分钟。 如果随身带有茶杯可对伤口作拔火罐处理，先在茶杯内点燃一小团纸，然后迅速将杯口扣在伤口上，使杯口紧贴伤口周围皮肤，利用杯内产生的负压吸出毒液。如无茶杯，也可用嘴吮吸伤口排毒，但吮吸者的口腔、嘴唇必须无破损、无龋齿，否则有中毒的危险。吸出的毒液随即吐掉，吸后要用清水漱口。 在野外被毒蛇咬伤后，可立即用火柴头3-5个，放在伤口中点燃，烧灼1-2次，以破坏蛇毒，这是一种简便有效的野外急救方法。 排毒后的应急处置：排毒完成后，伤口要湿敷以利毒液进行流出，若身边备有蛇药可立即口服以解内毒。病人出现口渴，可给足量清水饮用，切不可给酒精类饮料，以防毒素扩散加快，经过切开排毒处理的伤员要尽快用担架、车辆送往医院作进一步的治疗，以免出现在野外无法处理的严重情况，转运送中要消除病人紧张心理，保持安静。 可采取一些预防措施，当野外旅行、工作时，尤其在夜间最好穿长裤、蹬长靴或用厚帆布绑腿；打草惊蛇，持木棍或手杖在前方左右拨草将蛇赶走；夜间行走时要携带照明工具，防止踩踏到蛇体招致咬伤；选择宿营地时，要避开草丛、石缝、树丛、竹林等阴暗潮湿的地方；还应常备解蛇毒药品以防不测。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:6:3","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["我所热爱的生活啊"],"content":"溺水 溺水是指大量水液被吸人肺内，引起人体缺氧窒息的危急病症。多发生在夏季，游泳场所、海边、江河、湖泊、池塘等处。人落水后，水、泥沙阻塞呼吸道，或因呼吸道痉挛而引起缺氧、窒息、死亡。落水被淹后一般4-6分钟即可致死。 溺水的急救需要专业知识，尤其是不会水的人，能做的只有拨打119和120。但同时这里有一些自救措施： 首先应保持镇静，千万不要手脚乱蹬拼命挣扎，可减少水草缠绕，节省体力。只要不胡乱挣扎，不要将手臂上举乱扑动，人体在水中就不会失去平衡，这样身体就不会下沉得很快，不要慌张，发现周围有人时立即呼救；呼气要浅，吸气要深，这样可勉强浮起，等人来救，腿抽筋应尽快呼救，并仰泳浮上水面，好转后，应速上岸。 落水后应立即屏住呼吸，踢掉双鞋，然后放松全身，让身体漂浮在水面上，将头部浮出水面并保持后仰，使鼻部可露出水面呼吸，呼吸时尽量用嘴吸气、用鼻呼气，以防呛水，呼气要浅，吸气要深，千万不要试图将整个头部伸出水面，用脚踢水，防止体力丧失，等待救援；身体下沉时，可将手掌向下压。 当救助者出现时，落水者只要理智还存在，绝不可惊慌失措去抓抱救助者的手、腿、腰等部位，一定要听从救助者的指挥，让他带着你游上岸，否则不仅自己不能获救，反而连累救助者的性命。 会游泳者，如果在水中突然抽筋，又无法靠岸时，立即求救。如周围无人，可深吸一口气潜人水中，伸直抽筋的那条腿，用手将脚趾向上扳，以解除抽筋。 ","date":"2019-11-07","objectID":"/2019/medicine-and-health-3-first-aid-knowledge/:6:4","tags":["生活技能"],"title":"医药健康4-急救知识","uri":"/2019/medicine-and-health-3-first-aid-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"Truffle和Ganache的安装使用 ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:0","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"1. 安装Truffle 在Ubuntu18.04 下安装运行，要求Node.js版本高于v8.9.4 $ sudo apt-get install npm $ sudo npm install npm@latest -g $ sudo npm install n -g $ sudo n lts 安装Truffle $ sudo npm install -g truffle ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:1","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"2. 创建项目 以Truffle Boxes中的MetaCoin项目为例 首先为 Truffle 项目创建新目录 $ mkdir MetaCoin \u0026\u0026 cd MetaCoin 下载MetaCoin box $ truffle unbox metacoin ✔ Preparing to download ✔ Downloading ✔ Cleaning up temporary files ✔ Setting up box Unbox successful. Sweet! Commands: Compile contracts: truffle compile Migrate contracts: truffle migrate Test contracts: truffle test 下载完成后的项目目录如下 $ tree . ├── contracts │ ├── ConvertLib.sol │ ├── MetaCoin.sol │ └── Migrations.sol ├── LICENSE ├── migrations │ ├── 1_initial_migration.js │ └── 2_deploy_contracts.js ├── test │ ├── metacoin.js │ └── TestMetaCoin.sol └── truffle-config.js 3 directories, 9 files contracts是solidity编写的合约存放的文件夹 MetaCoin.sol创建了一种简单的代币，它引用了ConvertLib.sol合约 Migrations.sol是一个单独的合约文件，用来管理所部署合约的状态，每个Truffle项目中都有该文件，而且通常不需要更改 migrations是部署脚本存放的文件夹 1_initial_migration.js是Migrations.sol合约的迁移和部署脚本 2_deploy_contracts.js是MetaCoin.sol合约的迁移和部署脚本 所有的脚本按文件名开头的序号按顺序执行 test是测试应用和合约的测试文件存放的目录 TestMetaCoin.sol是合约形式的测试文件 metacoin.js是JS脚本形式的测试文件 两者的功能是一样的，只是使用了不同方式做测试 truffle.js是Truffle的配置文件，用于配置网络信息和其它项目相关的信息 ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:2","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"3. 编译 编译合约 $ truffle compile Compiling your contracts... =========================== \u003e Compiling ./contracts/ConvertLib.sol \u003e Compiling ./contracts/MetaCoin.sol \u003e Compiling ./contracts/Migrations.sol \u003e Artifacts written to /home/shuzang/MetaCoin/build/contracts \u003e Compiled successfully using: - solc: 0.5.8+commit.23d335f2.Emscripten.clang ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:3","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"4. 测试 在终端中运行合约形式的测试文件 $ truffle test ./test/TestMetaCoin.sol Compiling your contracts... =========================== \u003e Compiling ./contracts/ConvertLib.sol \u003e Compiling ./contracts/MetaCoin.sol \u003e Compiling ./contracts/Migrations.sol \u003e Compiling ./test/TestMetaCoin.sol TestMetaCoin ✓ testInitialBalanceUsingDeployedContract (83ms) ✓ testInitialBalanceWithNewMetaCoin (76ms) 2 passing (6s) 在终端中运行JS脚本形式的测试文件 $ truffle test ./test/metacoin.js Compiling your contracts... =========================== \u003e Compiling ./contracts/ConvertLib.sol \u003e Compiling ./contracts/MetaCoin.sol \u003e Compiling ./contracts/Migrations.sol Contract: MetaCoin ✓ should put 10000 MetaCoin in the first account ✓ should call a function that depends on a linked library (60ms) ✓ should send coin correctly (154ms) 3 passing (271ms) ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:4","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"5. 与Ganache关联使用 为了部署合约我们需要连到区块链，Truffle提供这方面的功能，但是目前我们使用Ganache来模拟区块链做部署测试 首先在Download页面下载对应操作系统的Ganache软件包，Linux系统下该软件包点击即可启动，无需安装 然后编辑truffle-config.js文件，替换为如下内容，这些配置参数将允许Ganache以默认参数连接 module.exports = { networks: { development: { host: \"127.0.0.1\", port: 7545, network_id: \"*\" } } }; 保存并关闭文件，打开Ganache 执行迁移命令，将合约部署到Ganache创建的区块链 $ truffle migrate Compiling your contracts... =========================== \u003e Everything is up to date, there is nothing to compile. Starting migrations... ====================== \u003e Network name: 'development' \u003e Network id: 5777 \u003e Block gas limit: 0x6691b7 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- \u003e transaction hash: 0x58a9f65031802c841183fc99a46d647870a99de5a717e27791f7ea13e9ccd47c \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0x03A587F157700FBdDff5195F22Eeab32c030424e \u003e block number: 1 \u003e block timestamp: 1573040253 \u003e account: 0x6c9d11d64bDC226d3d143b228d1019cB187c962d \u003e balance: 99.99477214 \u003e gas used: 261393 \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00522786 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0.00522786 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- \u003e transaction hash: 0x1685578d778d127196ce3b7d915b44e6433049f2a250e4384f836161cba8b75c \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0x741be30b7E4F5160026A0882f15763E623Fbcd66 \u003e block number: 3 \u003e block timestamp: 1573040254 \u003e account: 0x6c9d11d64bDC226d3d143b228d1019cB187c962d \u003e balance: 99.99185922 \u003e gas used: 103623 \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00207246 ETH Linking ------- * Contract: MetaCoin \u003c--\u003e Library: ConvertLib (at address: 0x741be30b7E4F5160026A0882f15763E623Fbcd66) Deploying 'MetaCoin' -------------------- \u003e transaction hash: 0x8800cc6fecf73a8d247fad63d5e739cccbd5e9f8dd350bbb709eb258396b96e4 \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0xBfc5d417c17fc15E837aCA46063F6b5403ad469e \u003e block number: 4 \u003e block timestamp: 1573040254 \u003e account: 0x6c9d11d64bDC226d3d143b228d1019cB187c962d \u003e balance: 99.98509224 \u003e gas used: 338349 \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00676698 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0.00883944 ETH Summary ======= \u003e Total deployments: 3 \u003e Final cost: 0.0140673 ETH 输出记录中显示了交易ID，部署的合约地址，总花费，实时状态等诸多信息。 在Ganache中点击Transactions按钮可以看到执行的交易的详细信息。 之后，使用Truffle控制台还可以和合约交互 $ truffle console truffle(development)\u003e ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:5","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"6. 与合约交互 truffle v5以后，控制台支持使用async或await函数，以下是一些合约交互的示例 首先部署合约并获取账户地址 truffle(development)\u003e let instance = await MetaCoin.deployed() truffle(development)\u003e let accounts = await web3.eth.getAccounts() 检查部署合约的账户余额 truffle(development)\u003e let balance = await instance.getBalance(accounts[0]) truffle(development)\u003e balance.toNumber() 10000 检查余额值多少ether，合约定义1单位余额值2ether truffle(development)\u003e let ether = await instance.getBalanceInEth(accounts[0]) truffle(development)\u003e ether.toNumber() 20000 向另一个账户发送货币 truffle(development)\u003e instance.sendCoin(accounts[1], 500) { tx: '0xf392891ee029f6bc6f970b9e5ae91cfd2e92baa4e141f0a94f6c6fbf5942c8a8', receipt: { transactionHash: '0xf392891ee029f6bc6f970b9e5ae91cfd2e92baa4e141f0a94f6c6fbf5942c8a8', transactionIndex: 0, blockHash: '0x14d49b375d485ae98860383d3483174995f019f349e9fdf5fd1d669be35a4791', blockNumber: 6, from: '0x6c9d11d64bdc226d3d143b228d1019cb187c962d', to: '0xbfc5d417c17fc15e837aca46063f6b5403ad469e', gasUsed: 51072, cumulativeGasUsed: 51072, contractAddress: null, logs: [ [Object] ], status: true, logsBloom: '0x00008000000000000000000000000000000000000000000400000000000000000400000010000000000000000000000000000000000002000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000010000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000800000000000', v: '0x1b', r: '0x6ad89e5e88194468c9d8f82891c7839b9c4d92ee01bd689ce080e35e99e74d1d', s: '0x77f2bc1452799a94cfaec2a9400f85393794ff96b285447a3407371b2d991978', rawLogs: [ [Object] ] }, logs: [ { logIndex: 0, transactionIndex: 0, transactionHash: '0xf392891ee029f6bc6f970b9e5ae91cfd2e92baa4e141f0a94f6c6fbf5942c8a8', blockHash: '0x14d49b375d485ae98860383d3483174995f019f349e9fdf5fd1d669be35a4791', blockNumber: 6, address: '0xBfc5d417c17fc15E837aCA46063F6b5403ad469e', type: 'mined', id: 'log_c14235e4', event: 'Transfer', args: [Result] } ] } 检查接收账户的余额 truffle(development)\u003e let received = await instance.getBalance(accounts[1]) truffle(development)\u003e received.toNumber() 500 检查发送账户的余额 truffle(development)\u003e let newBalance = await instance.getBalance(accounts[0]) truffle(development)\u003e newBalance.toNumber() 9500 ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:6","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"7. 使用truffle develop 之前部署合约使用了Ganache，也可以使用truffle develop。这一工具是Truffle内置的测试用私链，运行在本地。 运行truffle develop $ truffle develop Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0xfc166345efd307d6c22bde2cc8f4e4e345c49495 (1) 0x7b06844a7accc66d34294557d98224c39c496c81 (2) 0x49bb2bd5e7506708b1c458d0b6331916180c091b (3) 0x6ee54be55b95845c3c00cf1fb34cff053b619f44 (4) 0xeb259672501d8a16c954d09a8fdf84291d67cad2 (5) 0xb924f911ae293488043f6cc1d534654213db498f (6) 0x02ce17094c74a5062ac6a2cd432a4948b7adba26 (7) 0x2e8e85efcefb3e96f09f2ca4d3d4342ef88a0b2c (8) 0xd773abd9401ac8973cfcf5d8957bde6121347a92 (9) 0x0fcbde05930c09ecac70f9eeddb92d8b7ddec845 Private Keys: (0) 328523fee9c143c97a93d27c2ef67a37e57143591e584bcbbdc6de71a0f92d8e (1) 640e66ab0c0b9e775b32d5dfc00d71decc6c96006d71d6729abe336f88ef3c57 (2) c819551e120e1de0785f4476f7221d9d656a3b7c0e0fbce1de4eef986b2384bc (3) 648892c4e7896ab4c1d26242ecda4de7f39a46cd2822451557c2910ce7b4be7f (4) 8902380d9dd0dd8d6d97e59c694944a95829776db1dcb61406baec815649cb03 (5) f7d2341f7fbcde003d92e1a8ff3d3972fae00aff6a7568595e7bef03490efde9 (6) e4d11c8069bfaa777f666817d2d5f6b30a33dd75fb960b6e95abfd368286ef37 (7) 7af6c87f895b9c2a661748138a3bee82aff36439bcb43346f0285aa9dfb5aa04 (8) c810feb901d3bbeb57c9fadeba4e9da6bb61d61f1512fdabf5b0363264dd6336 (9) eb21927033d555614606e545e176c9584d8d673db404b70cc8fa4124cbee5438 Mnemonic: merry wrong fruit carry rifle phrase catalog describe mail traffic rate act ⚠️ Important ⚠️ : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)\u003e 以上显示了生成的十个账户和它们的私钥，可用于之后与区块链的交互。 在出现的truffle(develop)\u003e提示符下，可以省略truffle前缀而执行truffle的相关命令，依次执行编译和迁移命令 truffle(develop)\u003e compile Compiling your contracts... =========================== \u003e Everything is up to date, there is nothing to compile. truffle(develop)\u003e migrate Compiling your contracts... =========================== \u003e Everything is up to date, there is nothing to compile. Starting migrations... ====================== \u003e Network name: 'develop' \u003e Network id: 5777 \u003e Block gas limit: 0x6691b7 1_initial_migration.js ====================== Replacing 'Migrations' ---------------------- \u003e transaction hash: 0x5cf8f2d9154c8c579535788af12bf153cba4dfe5f2e980b774f7a41cfe795089 \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0x199Fb2370bb84f3eE5CacfF079D8478b67Cfba08 \u003e block number: 1 \u003e block timestamp: 1573044347 \u003e account: 0xFc166345EFd307D6c22bdE2cC8f4e4E345c49495 \u003e balance: 99.99477214 \u003e gas used: 261393 \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00522786 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0.00522786 ETH 2_deploy_contracts.js ===================== Replacing 'ConvertLib' ---------------------- \u003e transaction hash: 0x8bb95067ae3d85e519a37fa49feb0bca0b39ecd471f6626399b75c66592d5cb7 \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0x3f2dF366aC8C3356516C53B14610DE53309F7CCA \u003e block number: 3 \u003e block timestamp: 1573044347 \u003e account: 0xFc166345EFd307D6c22bdE2cC8f4e4E345c49495 \u003e balance: 99.99185922 \u003e gas used: 103623 \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00207246 ETH Linking ------- * Contract: MetaCoin \u003c--\u003e Library: ConvertLib (at address: 0x3f2dF366aC8C3356516C53B14610DE53309F7CCA) Replacing 'MetaCoin' -------------------- \u003e transaction hash: 0x88213b424d793c5e8d04cce4f34789a38b5c318a3782da511eee51c73fc97da6 \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0xBADc6F515922344a53675A348ccBEeec6A96a37a \u003e block number: 4 \u003e block timestamp: 1573044347 \u003e account: 0xFc166345EFd307D6c22bdE2cC8f4e4E345c49495 \u003e balance: 99.98509224 \u003e gas used: 338349 \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00676698 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0.00883944 ETH Summary ======= \u003e Total deployments: 3 \u003e Final cost: 0.0140673 ETH 接下来同样可以在提示符下直接进行合约交互，而不必退出使用truffle console ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:7","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"8. Truffle develop和Truffle console 两者都可以用于测试合约交互和手动执行交易，但Truffle develop同时还可以用来发起一个区块链 两者的使用场景为 Truffle Console 已经有正在使用的客户端，如Ganache或geth 想要部署到测试网络或以太坊主网络 想要使用具体的助记符或账户列表 Truffle develop 正在测试项目，该项目不会马上部署 不需要使用指定的账户，使用默认提供的账户足够 不想安装或管理额外的区块链客户端 ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:8","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"参考 [1] Truffle Quickstart, https://www.trufflesuite.com/docs/truffle/quickstart [2] Using Truffle Develop and The Console, https://www.trufflesuite.com/docs/truffle/getting-started/using-truffle-develop-and-the-console#truffle-develop ","date":"2019-11-06","objectID":"/2019/use-truffle-develop-ethereum-project/:0:9","tags":["区块链"],"title":"以太坊开发8-Truffle框架安装使用","uri":"/2019/use-truffle-develop-ethereum-project/"},{"categories":["研究生的区块链学习之路"],"content":"本文介绍在论文复现过程中发现的一些问题和自己产生的一些想法。与原论文1设计架构的对比可以查看本文最后的对比表，点这里 直接跳转。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:0:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"1. 应用场景思考 考虑一个高层次的抽象结构，IBFT 共识最初是应对银行场景提出的，具有更高的可管理性和吞吐量，更低的延迟和最终一致性，但没有考虑验证者的可扩展性，而且 Quorum 是基于以太坊开发的并支持智能合约，这些特性是适合于工业场景的。 IBFT共识 维持的核心是验证者，能容忍1/3以下的验证者节点故障（或恶意节点），因此验证者的数量不可少于4个，没有设置上限，但一般不会太多。区块链支持普通节点加入，数量不做限制，但普通节点对区块链的维持不起作用，不影响新区块的生成和区块链的延长。 基于以上的描述，考虑可能场景如下 同一企业旗下位于不同地理位置的工厂间（参考 Ali Dorri 在多个智慧家庭间设置区块链）。每个独立的工厂拥有一个验证者节点维持共识，工厂内的网关作为普通节点存在，IoT 设备受网关管理。 工厂、设备供应商（维修方）、材料供应商、其它合作商、监管机构等构成小型联盟（参考 Dennis Miller 和 Barco You）。每一方拥有一个验证者节点维持共识，各自都可以添加网关作为普通节点。 以上场景描述中以每一个参与方拥有一个验证者节点为例，但具体每一方分配多少验证者节点数量可以更好的保证安全性，可以做进一步分析。另外需要注意的是，超过2/3的节点串通就可以控制整个共识过程，少于2/3但大于1/3的节点串通可以导致共识永远无法达成。因此，多数人攻击可能是一个潜在的安全问题，Roberto Saltini 最近（8月份）分析了IBFT的安全性并给出了改进建议。 注1：IBFT共识中没有矿工，也没有激励机制。交易、部署和调用智能合约虽然都需要 Gas，但 Gasprice 是0，不会真的消耗掉。因此，在我们的架构中，网关作为普通节点加入时，需要被分配一定的代币用于之后的操作，这一机制可通过智能合约完成，向每个新注册的设备账户转移一定数量的代币（做不到，因为调用智能合约首先需要用于余额，但是就是因为没有余额才想要调用智能合约获取余额，这是一个死循环，只能通过其他方式获取余额）。 注2：Quorum是联盟链，因此本身带有准入控制，不是所有人都可以加入。另外，Quorum还支持隐私交易。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:1:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"2. 基本架构设计 这里对改进的架构做一次完整描述。整个架构自上而下可分为三层：共识层，网关层，设备层。前两层的所有节点构成区块链。以下对每层做解释 共识层。联盟中的每个成员运行一个验证者节点，这些验证者节点共同维持区块链的存在，所使用的共识是IBFT。除此之外，访问控制三个合约中的注册合约和判决合约都由验证者节点部署。 网关层。工厂或其它成员的网关设备，作为普通节点加入区块链，它们不参与共识过程，但拥有发起交易，部署和访问智能合约的能力（本质就是一个轻节点）。网关的核心作用是管理下一层的 IoT 设备，所有与网关连接的 IoT 设备都会由网关代理建立一个区块链账户，并调用注册合约进行注册，记录设备的基本信息、访问控制的优先级和归属权。IoT 设备的所有行为都与该区块链账户相关联，当设备发起访问控制请求，设备关联的区块链账户是发送者，当设备收到访问控制请求，接收者也是该账户。但这些操作都由网关代理完成。网关本身也需要进行注册，节点的第一个账户代表网关本身，其它账户分别与每个管理的 IoT 设备相关联。 共识层的验证者节点和网关层的普通节点一同构成区块链。 设备层。所有最下层的 IoT 设备，包括各种传感器/执行器甚至连到网关的智能手机等终端设备共同构成设备层。IoT 设备本身不作为区块链普通节点存在，所有行为由归属的网关代为管理。一个网关一般管理多个 IoT设备，但一个 IoT 设备只从属于一个网关，不能在区块链中重复注册。 采用这种分层管理的原因主要是常规的传感器/执行器的能力不足以作为区块链节点存在，即使能力足够，有限的能力也往往要用在本身的工作上。另一方面，这种分层管理方式还可以保证 IoT 设备不会直接暴露在网络中，减小了攻击可能性。虽然这同时带来了另一个问题，即作为核心的网关设备被攻破，其管理的所有设备都将失联。但可以注意到的一点是，IoT 设备的注册信息在区块链中始终存在，因此当判断网关失联或变成恶意节点后，可以将它所管理的设备的归属权移交其它网关。 智能合约中的归属权移交容易实现，但实际的移交却困难重重，这里分两种情况 传感器/执行器与网关有线连接，这种情况下，即使合约中的归属权移交，也没有任何意义； 传感器/执行器通过 Lora, ZigBee, Wifi，NB-IoT 等无线通信技术连接到网关，这种情况下，一方面不一定存在新的可连接网关，一方面如何控制 IoT 设备断开原网关重连到指定新网关上较难实现； 设备即使移交成功，管理需要的密钥也较难转移。 普通情况下，基本的管理单位是设备，当设备退出网络可以删除其注册信息，当检测到设备恶意行为可以对其关联的账户进行处罚。但从另一方面讲，网关的沦陷可能意味着其所管理的设备全部沦陷，因此可以直接设置对网关账户的处罚，而对网关账户的处罚将级联作用于归属该网关的所有设备。因为网关沦陷后，如果设备不物理重连到其它网关，即使在区块链中移交了归属权，也无法继续进行操作，或者说控制设备完成访问控制。 理论上边缘设备的使用是不冲突的，边缘服务器本身可以作为普通节点加入，与一般的网关同属网关层，边缘服务器对资源进行分配时一般是容器虚拟化的方式，普通 IoT 设备对边缘服务器资源的访问控制请求将由边缘服务器关联到分配了资源的容器上。所以从这个角度看，验证者、网关节点等直接运行区块链节点似乎不是最好的选择，可以以容器方式运行。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:2:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"3. 访问控制方案 当前架构中实现的访问控制的主体是智能合约，所有的操作通过智能合约完成。共有四种智能合约，注册合约、访问控制合约，判决合约和存储合约。 注册合约。注册合约的作用是注册访问控制合约、判决合约、网关和网关管理的 IoT 设备，并提供对注册信息的管理（增删查改）。访问控制合约和判决合约在部署后应当立即调用注册合约进行注册，IoT 设备加入网络后应当由网关代理调用注册合约进行注册，声明设备基本信息、设备优先级，设备关联的区块链账户和所归属的网关。注册合约由验证者节点部署。 访问控制合约。每个设备注册时都需要同时部署一个与之关联的访问控制合约，其中定义相关的访问控制策略，也定义恶意行为判定的策略，检测到的恶意行为会记录到判决合约并从中获取判决结果。访问控制合约中只能预定义少量的针对固定设备的访问控制策略，大量的访问控制请求处理通过设备优先级比较完成。执行操作的访问控制请求在链下进行，被请求的网关收到请求后，查询合约确认操作权限，确认拥有权限后被请求网关控制设备执行操作，获取执行结果并返回给请求者。读取数据的查询请求则由请求者直接发起，从调用访问控制合约验证读取权限后，从注册合约获取设备存储合约的地址，然后调用设备存储合约，获得数据哈希，根据数据哈希从存储平台中获得数据。写操作一般是向存储中写入设备数据，这一权限应当只属于设备本身和设备归属的网关。 判决合约。判决合约的作用是记录恶意行为和做出判决，向访问控制合约返回判决结果。由于可能用到记录的这些恶意行为，由验证者节点部署一个判决合约最合适。但如果不需要，可以像访问控制合约一样一个设备关联一个判决合约， 存储合约。以上流程中会涉及数据的写操作，传感器收集的数据源源不断地传输给网关，网关应当在本地进行处理并将数据存储到存储平台（Swarm 或 IPFS），获取返回的所存数据的数据哈希，在调用访问控制合约验证写操作权限后，将数据哈希存储到存储合约中。 访问控制的流程值得仔细考虑，比如网关如何将执行结果返回给请求者，初步的想法是链下进行，或者在合约中设置一个状态量，执行成功后将状态量置为真，然后智能合约主动将结果告知请求者。 访问控制可能发生在同一工厂的设备间，用于获取某些需要的资源或请求执行一些操作，也可能发生在设备维修商对工厂的设备，目的是检测设备情况，同时，监管机构也可能不时调用相关数据进行验证。同一企业位于不同地方的工厂间也可能相互访问。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:3:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 关于属性集的思考 ABAC 中有四种实体可以拥有属性，分别是主体(subject)、客体(object)、动作(action)和环境(environment)。在我们的方案中，所有的区块链账户背后都是一个设备（可能是IoT设备、网关或服务器等），每个设备都可能是发起访问控制的主体(subject)。设备拥有资源，比如数据、计算能力、存储能力等，每个资源是接收访问控制的客体(object)。动作(action)是可执行的操作，比如读、写、执行等。环境(environment)是一些独立于资源的需要满足的环境条件，比如两次访问控制请求的间隔，请求的频率等。这四者都需要定义与存储其属性集。我们来考虑几种属性集分别应该定义在哪种合约中，又分别应该按什么样的格式来定义和管理。大致的想法有以下三种： 属性集全部定义在 RC 中。由于 RC 的作用本来就是合约管理，似乎再添加属性集管理的功能也无可厚非，但这样带来的问题一是 ACC 进行访问控制时所有读取属性的操作都要跨合约进行，二是管理权问题，需要严格划分谁来定义和管理属性，三是类似于环境和操作属性等严格与设备相关，每个设备的这些属性都有可能不同，统一定义到 RC 中不好区分。 属性集全部定义在 ACC 中，这样带来的问题是策略判决时访问主体(subject)的属性要先调用 RC 获取 subject的合约地址，再访问 subject 关联的 ACC 获取它的属性，流程繁琐 主体(subject，也即设备)的属性集定义在 RC 中，其它属性集定义在 ACC 中，独立维护主体的属性集的好处是调用属性不再需要两道流程，同时资源、操作、环境这些属性集由各自的管理者定义和管理，有助于根据具体的情况进行调整。 一个可参考的实现是 wang 的论文2。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:3:1","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"4. 仿真实验 实验总体会涉及两部分，耦合程度并不高，第一部分是区块链平台搭建和智能合约实现。区块链平台选择了Quorum，这是一个基于以太坊开发的联盟链平台，提供了更高的可管理性、吞吐量，降低了延迟，提供了隐私交易的功能。由于 Quorum 保留了以太坊的智能合约，访问控制的基本功能都通过智能合约实现，合约的编写，编译和安全检查使用在线编辑器 Remix 完成，合约的部署和测试则使用 Truffle 框架完成。网关与合约的交互主要通过 web3.js 库来完成，区块链的节点使用 geth 客户端，由于官方没有提供 arm 架构下的客户端，我们自行进行了编译。 第二部分是网关和 IoT 设备。在IIoT场景下，机械臂是最常见的终端 IoT 设备，但受限于实验条件，我们无法将其用于实验。其它容易获得且能代表一个典型场景的设备暂时也无法找到，因此目前考虑能完成通用操作的设备，比如任意的传感器和执行器。终端 IoT 设备从普遍意义上可以分为传感器和执行器两种，传感器收集并传输数据，执行器执行操作。由于当前的架构设计中采用分层管理的方式，网关作为区块链节点，终端 IoT 设备由网关控制，我们需要一套包括网关、传感器、执行器在内的设备做实验模拟，可考虑的有三种 树莓派+arduino+传感器/执行器 树莓派+Lora通信+arduino+传感器/执行器 Beaglebone+CC1350+Sub1GHz通信+CC1350+传感器/执行器 目前已有的传感器有音量传感器、灰尘传感器，执行器有全彩LED。另外 CC1350 LunchPad 内置了温度传感器和LED。传感器数据的处理或执行命令的传递使用 Python 编写程序完成。 一些两部分之间的交互流程，如从合约调用的结果中获取访问控制命令传输给 IoT 设备，或者预处理 IoT 设备传输的数据交给网关，都通过 node.js 调用 web3.js 库来完成。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:4:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"5. 安全分析 将区块链中的异常分两种，一种是意外发生的异常，无法确定异常类型；另一种是主动发起的攻击。 按架构中的三个层次分别总结各层中可能出现的异常（安全隐患） ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:5:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"5.1 共识层 共识层的主体是验证者，它们有可能破坏整个区块链的正常运行，可能的恶意行为（来自#650-Faulty node）有 NotBroadcast：验证者不广播共识过程中的消息 SendWrongMsg：验证者发送错误的消息 ModifySig：验证者修改消息签名 AlwaysPropose：验证者不断地打包新区块并广播 AlwaysRoundChange：验证者收到消息时总是发送Round change消息 BadBlock：验证者打包的区块内容具有非法交易 以上是在共识运行过程中验证者可能做出的破坏。同时，承载验证者节点的设备可能在运行过程中宕机从而导致节点失联。 另外，联盟的部分成员可能串通作恶，为自己谋取利益，当串通的节点数超过总节点数的1/3，区块链将不再安全。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:5:1","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"5.2 网关层 网关层的普通节点可能的恶意行为包括 持续发起访问控制请求 拒绝执行已验证的访问控制请求 返回虚假的设备执行结果 部署错误的访问控制合约 注册不存在的IoT设备 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:5:2","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"5.3 设备层 设备层与区块链无关，其通讯链路的安全只能依靠传统方案保证。 除以上所述的具体恶意行为，传统的攻击方式，包括 DDoS、女巫、中间人、日蚀等各种各样的攻击手段应分别讨论。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:5:3","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"6. 合约中存在的问题 以下是我们在论文复现中发现的合约实施过程中出现的问题，或者想到的一些需要实施的合约改进。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:6:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"6.1 设备注册 之前已经讨论过设备注册功能，这一功能应当在合约实施中添加。 设备注册这一功能将依旧由注册合约（RC）完成，注册的设备信息由结构体 devices 统一描述，包括设备ID、设备类型，设备说明、设备优先级、设备关联的区块链账户，设备归属的网关账户、设备关联的访问控制合约地址（如果采用单独的存储合约，还会包括设备关联的存储合约地址）等字段，其中，设备关联的区块链账户地址与设备唯一关联，可以使用 mapping 结构作为键来使用。 如之前所述，设备的注册将由网关代理完成，每个设备对应一个唯一的区块链账户，应进行静态检查避免重复注册。未注册的设备无法完成任何操作，而区块链中发起对设备的请求时，应当同时包括请求者(subject)、设备(object)、设备代理网关(manager)三个角色的账户地址。 访问控制的双方不做限制，可能是机构双方，可能是机构对设备，也可能是设备对设备。 判决合约的主键应更改为 IoT 设备关联的区块链账户。区块链账户的恶意行为应该折算计入网关设备的恶意行为。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:6:1","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"6.2 合约warning 合约编译的过程中产生了不少的warning，这些warning虽然不影响合约的部署和使用，但总令人担心具有某些安全隐患，尤其是我们实现的合约本身就与安全息息相关。我们之前从中发现了关于过量 Gas 消耗和内联汇编(inline assembly)的问题，并致力于对其进行改进，同时，对合约中的某些设计我们也持怀疑态度，但很多问题在逐渐深入的了解过程中都被发现其实并没有太大的影响。即使如此，我们依然在此对各个warning做一下分析。 这部分所作的改进可以精简一下，作为自己的一部分工作。 内联汇编 在注册合约(RC)和访问控制合约(ACC)中，使用了 methodName 和 resource 两个字段作为索引值，用来查询方法、策略和恶意行为的相关信息。由于这两个字段长度的不确定性，将其定义成了string类型，但mapping的键无法使用动态长度(dynamically-sized)的string作为类型，因此将其定义成了固定长度(fixed-sized)的byte32类型。 struct Method{ string scName; //contract name address subject; address object; address creator; //the peer(account) who created and deployed this contract address scAddress; //the address of the contract } mapping(bytes32=\u003eMethod) public lookupTable; 为了实现完整的功能，需要在每个函数中都事先将string转换为bytes32类型，这一功能通过stringToBytes32函数实现，而该函数完成类型转换使用了内联汇编(inline assembly)，并由此引发了waring. browser/RC.sol:23:9:CAUTION: The Contract uses inline assembly, this is only advised in rare cases. Additionally static analysis modules do not parse inline Assembly, this can lead to wrong analysis results. 我们当前所担心的，是内联汇编会不会引起Gas的大量消耗，以及会不会带来安全隐患两个问题。Solidity文档中对内联汇编的解释一定程度能解答我们的问题。 solidity的内联汇编是为了实现更细粒度的控制，通过汇编风格的代码直接从底层访问以太坊虚拟机。内联汇编程序使用assembly{...}来标记，在大括号中书写汇编代码。我们的类型转换代码如下 function stringToBytes32(string memory _str) public pure returns (bytes32 result) { bytes memory tempBytes = bytes(_str); if(0==tempBytes.length){ return 0x0; } assembly{ result := mload(add(_str,32)) } } 可见，函数中的汇编代码只是单纯的使用了add和mload操作码，而智能合约的所有代码最终都会转化为这种底层的操作码，可见不会引起Gas的额外消耗。文档中称「内联汇编是一种在底层访问以太坊虚拟机的语言。这抛弃了很多 Solidity 提供的重要安全特性」。这说明了使用内联汇编可能会带来一些安全上的问题，但我们暂时并不清楚是什么。至于编译时弹出的警告，注意是由于编译器无法对汇编语句进行相关的检查，所以对我们进行提示。 但这一警告同时也提示我们要明确自己在做什么，因为除非必须，否则最好不要使用内联汇编。从这一点看，我们回到使用内联汇编的出发点，string类型转换为bytes32类型，但我们发现这种转换其实是没有必要的，因为转换过程中超出bytes32大小的部分依然会被截断，那么为什么一开始就定义为bytes32类型，因为同样的条件下bytes32比string使用更少的gas。唯一的理由是基于可读性的考虑，在合约调用传入参数时可以直接将双引号或单引号包围的字符串类型参数传入，我们认为，基于这样的理由在合约中完成类型转换是不必要的，类型转换的工作应该在调用合约的脚本中实现。因此关于内联汇编的warning得出结论 删除合约中的类型转换函数，将类型转换操作迁移到调用合约的脚本中完成，同时将合约中相关的string类型调整为bytes32类型 关于如何在脚本中进行类型转换，有两个参考： stackoverflow—Pass parameter as bytes32 to Solidity Smart Contract csdn—web3j中字符串如何转换Bytes32 Gas需求无限 这一warning是我们判断合约Gas消耗过量的主要依据。 Gas requirement of function \u003cfunction_name\u003e() high: infinite. If the gas requirement of a function is higher than the block gas limit, it cannot be executed. Please avoid loops in your functions or actions that modify large areas of storage(this includes clearing or copying arrays in storage) 这一warning占到总warning的1/3到一半，可以说是最大的问题了。但网上找到的回答中发现这个warning其实并不重要，因为很多情况都会引起 infinite 的警告，但这并不意味着代码中存在无限循环或者说代码不正确。在我们的程序中，导致该 warning 的三个个核心问题是内联汇编的存在，string 类型的定义以及调用其它的合约，Remix无法预测gas消耗时会提示 infinite，string 作为动态类型无法预测，内联汇编的语句无法在编译时进行检查，合约无法获得另一个合约的代码，因此这三种情况都会做出这样的提示。 在上一节中我们已经决定撤销在合约中进行类型转换，因此内联汇编将随之消失，而合约的调用是必需的操作，我们只要知道不会造成影响就好。 关于如何消除这一警告的一个解释是 stackExchange—How to get the cost (in gas) of the non-constant function call? 至于string类型的使用，让我们继续考虑上一小结，考虑一个相关的问题：Use string type or bytes32。答案很清楚，对长度超过32字节的任意字符串数据，使用string类型，否则就使用合适固定长度的bytes，无论是bytes32还是其它。 考虑我们的合约，注册合约(RC)中定义了string类型的scName，意为合约名。根据我们已掌握的知识，普通的ASCII码如英文字母和数字等都只占据1个字节，汉字一般占据3个字节(当然，我们传参一般不用汉字)。原作者给出的示例合约名为ACC和Judge，以我们编写的代码中定义的合约名来看，Judge和AccessControlMethod两个合约名都不超过32个字节，因此，合约名字段可以不适用string类型。同时基于合约名字段的有效性考虑，我们打算将其更改为合约类型字段，共分JC和ACC两种合约类型，更具有实际意义。因此最后的决定为 注册合约中的合约名字段更改为合约类型，同时字段类型由string调整为bytes32 判决合约(JC)中定义操作、恶意行为为 string 类型，恶意行为的长度确实是不固定的，可能超过32字节，但操作一般情况只包括read，write和execute三种，即使存在其它操作描述，一般不超过32字节，故将其定义为byte32类型。最后的决定为 判决合约中操作字段类型由string调整为bytes32 访问控制合约(ACC)中除与JC相同的两个字段外，错误信息描述同样使用string定义，但它同样是有意义的。而权限字段只有 allow 和 deny 两种选择，故将其定义为bytes32类型。最后的决定为 访问控制合约中操作字段和权限字段由string调整为bytes32 以上之所以统一更改为bytes32类型而非根据长度调整是为了转换方便。 删除不彻底 RC和ACC中都会涉及delete操作，用来删除映射表中无效的方法或策略。但也因此引发了如下warning browser/RC.sol:52:9:Using delete on an array leaves a gap. The length of the array remains the same. If you want to remove the empty position you need to shift items manually and update the length property. 这是因为delete操作的本质是对变量赋初值，并不清理内存，因为隐射与数组比较大时，删除操作之后调整长度和内存将会非常消耗gas，没有意义。所以这里就不管这个警告了。 变量名相似 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:6:2","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"6.3 自主决策 访问控制的权限校验严重依赖于预定义的策略，当设备数量过多时，人工预定义策略是一个极为庞大的工作。而在无法检测到相关策略的情况下权限申请会被直接驳回，由此可能引发错误。这一机制对可扩展性的支持也不是很友好。 当前思路是在设备注册时即对设备资源优先级进行预定义，当接收到访问控制请求时，如果未查询到定义的访问控制策略，则根据设备的优先级进行判定，最后做出决策。这种判定表的设计在强访问控制（MAC）中有参考。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:6:3","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"6.4 授权时间 目前的架构设计没有权限授予时间的概念，所有的授权都是一次性的，下次访问要重新发起访问控制，在很多情况下并不合适。 思路是添加权限授予时间字段，默认一次性授权，根据情况可以自定义授权时间，在授权时间范围内不必重新发起请求。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:6:4","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"6.5 隐私 基于场景中可能的隐私需求，利用 Quorum 的隐私交易管理器实现。 更新：实际上有大量的论文自己设计某种算法来保证隐私，也许我们不应当自我限制必须用隐私管理器解决。 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:6:5","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"7. 实验中存在的问题 实验中 ACC 对 JC 合约的调用不成功，应修复合约间调用出错的问题 使用虚拟机为实验带来了高延迟 合约功能测试可以通过测试合约完成，或利用Remix完成，或者在测试链中测试 使用 truffle 框架简化合约部署、脚本执行等相关操作(truffle 框架具有自己的限制) 网关设备调整为普通节点，在区块链启动之后加入，并预先分配一定的代币 通过构建前端页面形成完整访问控制 Dapp，将一些涉及多个操作的合约交互流程自动化(但估计很难有精力完成)——确实没有精力，也没有能力。 网关与 IoT 设备的连接，来自 IoT 设备的数据如何返回到区块链，来自区块链的控制命令如何交给 IoT 设备，这两种交互的实施（属于对访问控制系统的应用，没有实现） 利用相关工具对合约代码进行安全性检查（好用的工具都收费了） 利用 Ethscan 等工具监测区块链获取相关数据（找了一个区块链浏览器） 当前工作的关键词 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:7:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"8. 总结 总结一下所作的调整和改进 使用联盟链 Quorum 和联盟链共识 IBFT，增强了可管理器、吞吐量，减小了延迟，可以进行隐私交易 分层管理的结构具体化，设备由网关代理并在区块链中注册，读数据、写数据、执行请求等流程和场景具体化 基本的管理单位由资源调整为设备，核心的访问控制结构变成 RC+ACC+JC+SC，分别指注册合约、访问控制合约、判决合约和存储合约。 网关故障时的归属权移交机制（不可行） 使用强访问控制对原先的访问控制列表进行补充（未实现） 授权时间调整为动态（未实现） 其它的一些想法 访问控制的论文再总结一次，归纳发展情况和不足，提出我们当前方案的改进 设备可以阻止别人的未授权访问，当若设备本身已被控制，我们的方案无法解决，所以假设设备、网关是安全的，不考虑内部攻击，只考虑通过访问控制阻止未授权访问。访问控制的策略由资源所有者定义 原方案存在的问题：过于分散。每个 subject-resource 对都要定义一个 ACC，但不是所有的 subject 都会对每个资源进行访问，全部定义会有冗余，这是访问控制列表方法的缺点。何时布置 ACC 合约，如何授予权限都需要管理员管理，工作量极大。 权限转移，不只是权限所有者，也可能是被授予权限的人 Blockchain Based Access Control 当前的行为检测是绝对的，但很多情况下根本无法判断某个行为是好的还是坏的，只能打分来进行量化，基于分数来判断行为是否出格 ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:8:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["研究生的区块链学习之路"],"content":"9. 相关资料 [1] 李晓峰, 冯登国, 陈朝武, et al. 基于属性的访问控制模型[J]. 通信学报, 2008(04):95-103. 链接 [2] 基于属性的访问控制关键技术研究综述[J]. 计算机学报, 2017(7). 链接 [3] Vincent C. Attribute-Based Access Control [4] NIST Guide to ABAC Definition and Considerations：链接 [5] SCI 数据库查询页面 [6] 访问控制模型简单介绍：https://blog.csdn.net/LngZd/article/details/100781310 [7] Golang实现的各种访问控制模型的库，官网，Github Zhang Y, Kasahara S, Shen Y, et al. Smart contract-based access control for the internet of things[J]. IEEE Internet of Things Journal, 2018. ↩︎ P. Wang, Y. Yue, W. Sun, and J. Liu, “An Attribute-Based Distributed Access Control for Blockchain-enabled IoT,” in 2019 International Conference on WiMob, Barcelona, Spain, Oct. 2019, pp. 1–6, doi: 10.1109/WiMOB.2019.8923232. ↩︎ ","date":"2019-10-31","objectID":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/:9:0","tags":["科研记录"],"title":"研究记录8-原始论文问题总结及优化考虑","uri":"/2019/summary-of-problems-and-optimization-considerations-about-prototype-system/"},{"categories":["Golang学习之路"],"content":"本文介绍 Golang 中的运算符和流程控制 ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:0:0","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"1. 运算符 Go语言的运算符有6种，如下表所示 运算符类型 运算符 算术运算符 +，-，*，/，%，++，– 关系运算符 ==，!=，\u003e，\u003c，\u003e=，\u003c= 逻辑运算符 \u0026\u0026，||，! 位运算符 \u0026，|，^，«，»，\u0026^ 赋值运算符 =，+=，-=，*=，/=，%=，«=，»=，\u0026=，^=，!= 其它运算符 \u0026，* 基本的运算规则都与C语言相同，一些注意事项列举如下 算术运算符中自增自减运算符只能作为语句使用，不能用于表达式 a++ // 允许 a-- // 允许 a = a++ //不允许，编译错误 a[i] = b[i++] //不允许，编译错误 整数除以0会导致编译错误，如果编译时未检出会导致程序崩溃。浮点数除以0.0会返回无穷大，用+Inf表示 逻辑运算符具有短路效果 位运算符是对整数在内存中的二进制位进行操作的，假定A = 60，B = 13，则 A = 0011 1100 B = 0000 1101 A\u0026B = 0000 1100 // 结果为12 A|B = 0011 1101 // 结果为61 A^B = 0011 0001 // 结果为49 A\u003c\u003c2 = 1111 0000 // 结果为240 A\u003e\u003e2 = 0000 1111 // 结果为15 其它运算符中的\u0026是取地址符，*是指针变量 运算符的优先级是不同的，下表从上往下代表优先级从高到低 优先级 运算符 7 ^ ，! 6 * ，/ ，% ，« ，»， \u0026， \u0026^ 5 +， -， | ，^ 4 ==， !=， \u003c ，\u003c= ，\u003e=， \u003e 3 \u003c- 2 \u0026\u0026 1 || 二元运算符的运算方向均是从左到右，必要时可以使用括号提升优先级或更清楚地表达。 ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:1:0","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2. 控制结构 除去顺序结构外，Go语言提供的基本流程控制结构包括 条件结构 if-else 结构 switch 结构 select 结构，用于channel的选择（协程与通道部分） 循环结构 for for-range 同时，Go还提供了关键字break、continue和goto用来辅助进行流程控制，以及return语句提前结束执行。 注1：在这些结构中，Go都省略了条件语句两侧的小括号，使视觉上更加简洁。 注2：除case关键字后的语句，即使代码块只有一行，大括号也不可省略 注3：左大括号必须和关键字在同一行，对多分支结构中的else关键字，右大括号也要和它在一行。这两条规则是编译器的强制规定。 ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:0","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2.1 if-else 结构 if-else 结构的基本形态与C语言相同。可以省略else关键字变成单分支结构，也可以添加else if变成多分支，但为了代码简洁，过多的分支最好换用switch结构实现。 if condition1 { // do something } else { // do something else } 当双分支结构在代码块的末尾时，通常会将else中原本的代码块迁移出来放在最后，如 if condition { return true } return false Go中 if 还可以在条件语句前添加一个初始化语句，以分号分隔 if initialization; condition { // do something } 例如 if val := 10; val \u003e max { // do something } 但需要注意的时，使用简短方式 := 声明和初始化的变量作用域只限于 if 结构的代码块内，属于局部变量。 由于Go语言并行赋值的特性，if 语句经常用于测试多返回值函数的错误。返回某个值以及true表示成功，返回零值（或nil）以及false表示失败 if value, ok := readData(); ok { … } 当不使用true或false时，也可以使用一个error类型的变量来代替作为第二个返回值，成功执行，error的值为nil，失败返回的值会包含相应的错误信息。 var err error if err := file.Chmod(0664); err != nil { fmt.Println(err) return err } ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:1","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2.2 switch 结构 switch结构的基本形态依然同C语言相同 switch var1 { case val1: ... case val2: ... default: ... } 不同的是，Go中switch语句接受任意形式的表达式，如上例中var1可以是任何类型，而val1和val2可以是同类型的任意值，不局限于数值。 可以同时测试多个可能符合条件的值，使用逗号分隔，例如case val1, val2, val3 每个case分支都是唯一的，从上到下逐一测试，一旦成功匹配到某个分支，执行完对应的代码块后会自动退出整个 switch 结构，而不需要使用break结束。因此，程序不会自动的去执行剩下的case分支的代码，如果想继续执行，需要使用fallthrough关键字 switch i { case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用 } case语句后不需要用大括号包围代码块，default分支可以出现在任何顺序，但最好放在最后 package main import \"fmt\" func main() { var num1 int = 100 switch num1 { case 98, 99: fmt.Println(\"It's equal to 98\") case 100: fmt.Println(\"It's equal to 100\") default: fmt.Println(\"It's not equal to 98 or 100\") } } //Output: //It's equal to 100 switch可以不提供条件语句，然后在每个case分支测试不同条件，可以替换分支比较多的if-else结构，简化代码 switch { case i \u003c 0: f1() case i == 0: f2() case i \u003e 0: f3() default: ... } switch的条件语句还可以是初始化语句 switch a, b := x[i], y[j] { case a \u003c b: t = -1 case a == b: t = 0 case a \u003e b: t = 1 } ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:2","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2.3 for 结构 Go中只有for用于循环结构，没有C中的while或do while，基本形态如下 for 初始化语句; 条件语句; 修饰语句 { ... } 同样，for 关键字后的三个语句不需要小括号，左大括号需和关键字在同一行 可以只保留条件语句，这种情况下可以去掉所有分号，大致等同于其它语言的while循环 package main import \"fmt\" func main() { var i int = 5 for i \u003e= 0 { i = i - 1 fmt.Printf(\"The variable i is now: %d\\n\", i) } } 或者省略条件语句，但必须在循环体中存在条件判断以确保在某个时候退出循环，退出可以使用break或return for i := 0; ; i++ { ... } 或者三条语句全部省略，但同样需要在循环体中添加退出条件 for { ... } ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:3","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2.4 for-range 结构 这是 Go 中特有的迭代结构，可以迭代数组、切片、map、字符串等任意一个集合，一般形式为 for k, v := range set { ... } k 为索引，每次递增，v 为索引对应的值的拷贝。值得注意的是，由于 v 只是值的拷贝，任何对它的修改都不会影响集合中原来的值，除非索引是指针。 如果不需要索引，可以使用匿名变量_忽略它 for _, v := range set{ ... } 但如果只需要索引而不需要值，可以直接省略不写 for k := range set { ... } // Output: 0 1 2 ... 字符串通过for-range结构获取的元素是rune类型 ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:4","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"3. 辅助关键字 break用来跳出循环，在for循环中跳出一层循环，在switch或select语句中，跳过整段代码块 for i:=0; i\u003c3; i++ { for j:=0; j\u003c10; j++ { if j\u003e5 { break } print(j) } print(\" \") } //Output: //012345 012345 012345 continue用来忽略剩余的循环体直接进入下一次循环，只存在于for循环中 for i := 0; i \u003c 10; i++ { if i == 5 { continue } print(i) print(\" \") } //Output: //0 1 2 3 4 6 7 8 9 for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词，下例中continue语句指向LABEL1，当执行到该语句时，就会跳转到LABEL1标签的位置起继续执行，不过此时注意循环体内的变量并不会被释放，当j==4循环跳出后，i会自动变成下一个循环的值，不会陷入无限循环。 package main import \"fmt\" func main() { LABEL1: for i := 0; i \u003c= 5; i++ { for j := 0; j \u003c= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(\"i is: %d, and j is: %d\\n\", i, j) } } } 标签的名称和一般的标识符相同，都是大小写敏感的，但为了可读性，一般全部使用大写字母。同变量相同，标签定义未使用也会导致编译错误。 goto关键字是配合标签使用的，但这种用法并不被推荐，因为很可能导致糟糕的代码结构，一如当年的PASCAL 逆序的标签虽然可能导致错误，但正序的标签(标签位于goto语句之后)则可以正常使用，但标签和goto之间不能有新定义变量的语句，否则会导致编译失败 // compile error goto2.go:8: goto TARGET jumps over declaration of b at goto2.go:8 package main import \"fmt\" func main() { a := 1 goto TARGET // compile error b := 9 TARGET: b += a fmt.Printf(\"a is %v *** b is %v\", a, b) } ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:3:0","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["研究生的区块链学习之路"],"content":"AMIS公司提出的 Istanbul Byzantine Fault Tolerance Consensus（简称IBFT或Istanbul BFT），是一个基于PBFT的交易一致性的共识。因为要考虑可能发生的异常，对共识的原始文档作一次通读，仔细理解一下。原始文档位于github ethereum/EIPs#650，以下一边翻译一边阅读。 注：EIP，即Ethereum Improvement Proposal，以太坊改进建议 这一工作深受Clique POA的启发，并在协议层中尽可能设计相同的机制，比如验证者投票。我们遵循EIP风格，将背景和原理放在所提出的共识协议的后面供开发者阅读。这一工作也受到Hyperledger’s SBFT，Tendermint，HydraChain和NCCU BFT的启发。 ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:0:0","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"术语 Validator：区块验证者 Proposer：一轮共识中被选举出打包新区块的验证者。 Round：共识轮数。一轮共识起始于Proposer打包一个新区块，结束于新区块提交或轮数改变（轮数改变可能由于验证不通过或区块更新）。 Proposal：共识正在处理的新打包的区块。 Sequence：新区块的序号（从创世区块起排列的一个顺序），这一数字应大于所有之前区块的序号。目前，每个区块的高度都是它的序号。 Backlog：将来的共识信息记录在这里面。 Round state：指定轮数和序号的共识信息，包括预准备信息、准备信息和提交信息。 Consensus proof：提交的区块签名，每个验证者验证后都会对区块签名，可以证明区块经历了整个共识过程。 Snapshot：验证者投票状态。 ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:1:0","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"共识 Istanbul BFT基于 PBFT 算法，然而，原始的PBFT需要做一些调整来适应区块链。首先，没有具体的发送请求和等待结果的client的概念，所有的 validator 都可以视作clients。其次，为了保证区块链的运行，需要在每一轮共识中持续不断的选举出 proposer 来打包新的区块，同样，每轮共识的结果是一个可验证的区块而不是文件系统的一组读写操作。 Istanbul BFT 继承了 PBFT 共识的三阶段：pre-prepare，prepare 和 commit，我们称之为预准备阶段、准备阶段和提交阶段。系统可以容忍 N 个 validator 节点的网络中F个节点错误，其中 N = 3F + 1。每一轮之前，validators会首先投票选出一个proposer，默认的选举方式是轮询。选出的proposer将会打包一个新的区块并附随 pre-prepare 消息广播出去，当接收到 pre-prepare 消息，validators 会进入 pre-prepared 状态，然后广播 prepare 消息。这一步是为了确认所有的 validators 在同一个 sequence 和同一个 round上工作。当接收到 2F + 1个 prepare 消息，validator 就会进入 prepared 状态并广播 commit 消息。这一步是为了通知其它节点它验证了新区块并且将会把新区块添加到了区块链中。最后，验证者们等待 2F + 1 个 commit 消息并进入 committed 状态，最后把区块添加到区块链末尾。 Istanbul BFT共识中的区块符合最终一致性，这也就是说所有的区块都必须位于主链中，区块链没有分叉。为了防止恶意节点生成一条和主链完全不同的链，每个验证者都要在将区块添加到区块链末尾之前附加 2F + 1 个收到的 commit 签名到区块头的 extraData 字段。因此，所有区块都是自验证的并且支持轻节点。然而，动态的 extraData字段可能造成区块哈希计算的相关问题，因为不同的验证者在同一轮共识中收到的一组 commit 消息可能不同，从而导致 extraData 字段不同，最终整个区块的哈希值不一致，为了应对这种情况，在计算区块哈希时会排除 commit 签名部分。因此，依然可以保持区块/区块哈希的一致性，并把一致性证明放在区块头。 ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:2:0","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"1. 共识状态 Istanbul BFT是一个状态机复制算法，每个验证者为了达成区块一致都维持一个状态机副本。 状态(States)： new round：proposer打包新区块，验证者等待 pre-prepare 消息 pre-prepared：验证者接收 pre-prepare 消息，广播 prepare 消息，然后等待 2F + 1 个 prepare 或 commit 消息 prepared：验证者收到了 2F + 1 个 prepare 消息并广播 commit 消息，然后等待 2F + 1 个commit消息 commited：验证者收到了 2F + 1 个 commit 消息，可以将新区块插入区块链末尾了 final commited：新区块成功插入区块链末尾，验证者准备下一轮 round change：验证者等待同一轮上的 2F + 1 个round change消息 ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:2:1","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"2. 状态转换 New round —\u003e Pre-prepared proposer从交易池收集交易 proposer打包新区块并广播，然后进入 pre-prepared 状态 每个验证者收到pre-prepare消息后，若符合如下条件，进入pre-prepared状态 新区块来自有效的proposer 区块头有效 新区块的序号和轮数符合验证者状态 验证者向其它验证者广播prepare消息 Pre-prepared —\u003e Prepared 验证者收到 2F+1 个有效prepare消息后进入prepared状态，prepare消息有效是指符合如下条件 序号和轮数匹配 区块哈希匹配 消息来自已知验证者 验证者进入prepared状态后广播commit消息 Prepared —\u003e Committed 验证者收到 2F+1 个有效commit消息后进入committed状态，commit消息有效是指符合如下条件 序号和轮数匹配 区块哈希匹配 消息来自已知验证者 Commited —\u003e Final committed 验证者附加2F+1个提交签名到extraData字段，将区块插入区块链末尾 区块插入成功后验证者进入Final committed状态 Final Commited —\u003e New round 验证者选举新的proposer并启动新一轮共识计时器 ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:2:2","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"3. Round change工作流 以下三种情况将会触发 Round change Round change 计时器超时 无效 prepared 消息 区块插入失败 当一个验证者发现符合以上三种情况任一种时，就会将新的轮数附加到 round change消息上广播出去，然后等待来自其它验证者的 round change消息。附加的新的轮数根据以下条件确定 如果验证者收到来自其它节点的 round change 消息，它会从数量超过F+1个的轮数消息中选择最大的那个轮数 否则，将 当前轮数+1 作为新的轮数 无论何时，验证者一旦收到同一个轮数上的F+1个 round change 消息，它就会比较收到的轮数和自己的轮数，如果收到的更大，验证者会以收到的轮数再次广播 round change 消息 一旦收到了同一个轮数上的 2F+1 个round change消息，验证者就会退出round change循环，选举新的proposer，然后进入new round状态 另一个验证者跳出轮数改变循环的情况是它通过节点同步收到了已验证的区块 ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:2:3","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"4. Proposer选择 当前支持两种策略：round robin和sticky proposer round robin：每一次区块和轮数更改都会换一个proposer sticky proposer：只有轮数改变时才会更改proposer ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:2:4","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"5. 验证者列表投票 IBFT使用一个和Clique相似的验证者投票机制，每个epoch交易都会重置验证者投票，这意味着当授权或取消授权投票过程正在进行，投票过程将中止。 对所有交易区块而言 proposer可以投一票提议更改验证者列表 未完待续 ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:2:5","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"问题 Istanbul BFT’s design cannot successfully tolerate fail-stop failures #305 Correctness Analysis of Istanbul Byzantine Fault Tolerance 没有激励机制 ","date":"2019-10-29","objectID":"/2019/ibft-consensus/:3:0","tags":["区块链"],"title":"区块链学习6-IBFT共识","uri":"/2019/ibft-consensus/"},{"categories":["研究生的区块链学习之路"],"content":"Kumar, Tanesh \u0026 Braeken, An \u0026 Ramani, Vidhya \u0026 Ahmad, Ijaz \u0026 Harjula, Erkki \u0026 Ylianttila, Mika. (2019). SEC-BlockEdge: Security Threats in Blockchain-Edge based Industrial IoT Networks. 以一个木屋建造场景作为IIoT用例，简要介绍了一个区块链-边缘计算框架。然后以此为基础讨论了关键的安全需求，每个层次中可能出现的安全威胁和解决方案。 ","date":"2019-10-24","objectID":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/:0:0","tags":["论文笔记"],"title":"SEC-BlockEdge Security Threats in Blockchain-Edge based IIoT Network","uri":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/"},{"categories":["研究生的区块链学习之路"],"content":"木屋建造场景 作者使用的木屋用例包含了一些关键的工业流程。以下是该用例的6个主要阶段。 ","date":"2019-10-24","objectID":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/:1:0","tags":["论文笔记"],"title":"SEC-BlockEdge Security Threats in Blockchain-Edge based IIoT Network","uri":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/"},{"categories":["研究生的区块链学习之路"],"content":"区块链-边缘计算框架 结合区块链和边缘计算为 IIoT 提供便利，提出了一个框架，由 Local, Edge, Global, Ledger 四层组成 本地层负责收集原始数据，上传到边缘和云。 边缘层提供部分计算资源和能力，处理原始数据并追踪原材料的收集和交付过程。 全局层提供更多的资源和能力，访问频繁的资源会放在边缘，但访问频率较低的资源会放在云。 区块链层为其它三层提供一些具体的服务，本地层主要是认证和监控是否符合条件，边缘层主要是促进来自不同地方的数据的处理、存储和共享，全局层则是总体的监督。 ","date":"2019-10-24","objectID":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/:2:0","tags":["论文笔记"],"title":"SEC-BlockEdge Security Threats in Blockchain-Edge based IIoT Network","uri":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/"},{"categories":["研究生的区块链学习之路"],"content":"安全需求 以下是一些系统必须遵守的安全需求 需求 说明 Authentication 场景涉及不同的角色，包括传感器/执行器，边缘设备/服务器，服务/网络提供者和第三方。这种情况下，保证只有合法实体才能访问和提供资源非常重要。智能合约可以实现。 Integrity 木屋场景中的数据处理和共享涉及多个利益相关者，某些如边缘设备可能通过边缘服务器/数据中心共享和复制数据，导致数据完整性受威胁。 Privacy 当身份公开，如果交易存储在公链上，任何人都可以跟踪并访问，可能泄露公司与竞争对手相关的重要商业信息。 Trustworthy Computation 一些计算/处理工作可能放到不信任的节点上运行，需使用可信计算保证可信度 Availability 确保需要的数据在每一个层次上持续可用 Network Security 木屋场景中的边缘层是攻击者的主要攻击目标，区块链的一些关键特性可以增强安全性 ","date":"2019-10-24","objectID":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/:3:0","tags":["论文笔记"],"title":"SEC-BlockEdge Security Threats in Blockchain-Edge based IIoT Network","uri":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/"},{"categories":["研究生的区块链学习之路"],"content":"安全威胁和解决方案 以下对作者列出的安全威胁和解决方案做总结和分析。 Layer Security Threats challenges solutions Local Docker/Container 容器可以提供各种本地进程执行所需的轻量级虚拟化微服务。容器虚拟化主要依赖于内核所提供的特性，因此需要特别关注幽灵和熔断这种攻击。此外，随着最近容器的频繁使用，出现了一些与镜像相关的威胁、基于主机和操作系统的漏洞以及基于硬件的攻击。 通过定期扫描镜像和应用来对抗镜像漏洞。通过加密签名验证已注册镜像， 确保使用可信镜像。对于与内核和操作系统相关的威胁，部署能够验证操作系统和内核安全的管理工具。 Local Local Nodes/Devices 本地层中的低功耗节点由于节点资源有限，容易受到节点篡改、恶意代码注入、旁道攻击、虚假节点和物理破坏等攻击，可能会被篡改或窃取相关信息，影响网络乃至整个物联网系统的性能和安全。因此，需要轻量级安全机制，特别是密钥管理机制，通过身份认证，来防止所有可能的威胁，并保证消息完整性和机密性。 预安装密钥是初始化安全机制最简单的方式，目前为止提出的基于对称密钥或公钥的机制已满足了大部分的安全需求(如防篡改、匿名性等)，然而预安装的密钥依赖于可信第三方(TTP)的存在，掌握密钥分发的TTP是整个体系的弱点。一种隐式证书(implicit based)方案允许在没有TTP的情况下生成私钥对，是可能的解决方案。 Local Local Communication 本地层的短距离通信协议/技术包括：低功耗蓝牙，ZigBee，NFC，Wi-Fi。每一种通信技术都面临多种威胁，被攻击者捕获的设备可能用来假冒正常节点。 主要的解决方案是使用安全密钥协商协议生成共享密钥用于之后的安全通信。如果需要添加新的安全需求，还需要使用专用协议。而对于防止设备被捕获，可使用如物理不可克隆之类的原语。 Edge Virtualization 不理解 Edge Edge Devices 边缘网络包括网关、IoT设备和边缘数据服务器等多种不同设备，这些设备可能被攻击者物理访问和损坏。边缘数据中心是攻击者的主要攻击目标。例如rogue攻击可能造成管理者完全失去控制权，一旦攻击者夺取了控制权，他就可以控制资源以及所连接的其它设备。边缘服务器同时受到内外两方面攻击的威胁。 对设备进行身份验证防止篡改，以及使用入侵检测系统（ids）检测和监视边缘服务器和边缘数据中心上的各种威胁。 Global Virtualization 不理解 Global Cloud DoS/DDoS攻击在云端更为频繁，被认为是数据和服务不可用的主要原因。消费者还担心他们在云端存储的数据，因为不清楚在服务器上如何保护数据。因此，用户缺乏对自己数据的控制使其容易受到各种安全威胁。云也容易受到Web和API的安全攻击。在这种环境下，访问控制和身份管理将变得非常复杂，需要高度重视。由于云服务是由多个利益相关者提供和使用的，因此在用户和其他实体之间就服务的各个方面达成法律协议至关重要。 不同的加密技术（如同态加密和基于属性的加密）被用于保证云端用户数据的安全、机密和完整以及访问控制。Web和API在开发和运行的生命周期应保证安全。 Blockchain Smart Contract Multiple function attack; self destruct function; timestamp dependency Blockchain Node eclipse attack; Sybil attack Blockchain Platform DAO; re-entrance attack Blockchain General Blockchain 51% problem; private key security threats ","date":"2019-10-24","objectID":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/:4:0","tags":["论文笔记"],"title":"SEC-BlockEdge Security Threats in Blockchain-Edge based IIoT Network","uri":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/"},{"categories":["研究生的区块链学习之路"],"content":"理解和想法 文中提出的区块链-边缘计算框架是在 Local-Edge-Cloud 这一套体系的基础上加入区块链，解决各参与方之间的信任问题，提供一些服务和功能。这些服务包括目前广泛研究的身份认证、访问控制、数据共享、全局状态审计等功能。区块链运行在所有参与方中有足够能力的设备中。 但区块链的能力应当不至于此，通过智能合约和Dapp，可以提供更强大的功能，如一些流程、文书工作的自动化，以及平时以云为后端运行的各种应用。也许不再将云视作对立，将其一同纳入区块链范畴是一种思路，但将参与各方的服务器组织起来进行协同计算以及提供分布式的云存储同样可行。 区块链的节点应散布在整个架构的所有设备中，终端IoT设备是否作为区块链节点存在应分类讨论或根据场景决定，安装哪种类型的节点（全节点、轻节点还是slock.it这种IoT设备专用节点）根据设备能力确定。如设计中有云的存在，云也应当作为区块链节点。 由于每个人都能访问链上信息，公链恐怕不适合产业界的使用。无论联盟或大或小，都应使用联盟链/私链，共识的选择同样根据场景而定。除吞吐量和延迟的限制外，联盟链/私链的准入机制和隐私支持是有别于公链而应被企业接受的主要理由。 区块链不适合海量数据的存储，但可以使用数据哈希来间接的实现该功能。这一机制解决的问题同云使用同态加密或基于属性额加密解决的问题是相同的，但使用基于云的方案还是基于区块链的方案则各有所得。 异常检测应当是和区块链并行的，每个区块链节点同样有资格作为协作入侵检测(CIDS)的节点，检测区块链网络本身的异常，但同时也可以检测作为区块链节点的物联网设备或边缘设备的异常，这两种应该是统一的。检测的算法可以定义在智能合约或共识算法中，但同样可以独立于区块链网络单纯的利用机器学习算法检测网络中产生的数据。框架中谈到的传感器/执行器状态的监督以及场景整个运行流程的全局状态监督应当指的就是异常检测的一方面。 关于认证，原先依赖可信第三方建立PKI体系进行认证的设备现在可以依赖区块链建立信任，但本地短距离通信技术面临的种种威胁区块链无法起作用，智能通过传统的密钥协商方案解决。 如因资源受限使用分层管理的体系，区块链客户端不安装在最底层的IoT设备中，还是会出现单点故障问题，代理网关的沦陷意味着与之连接的所有设备的沦陷，应当采用某种手段如定期的检查代理网关状态，在检测到异常时将网关代理的所有设备技术移交其它网关管理。异常检测依然会在该问题中起到重要作用。 ","date":"2019-10-24","objectID":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/:5:0","tags":["论文笔记"],"title":"SEC-BlockEdge Security Threats in Blockchain-Edge based IIoT Network","uri":"/2019/sec-blockedge-security-threats-in-blockchain-edge-based-iiot-network/"},{"categories":["平日里的白日梦"],"content":"2019.10.24 从社交平台看到有人分享的山本文绪关于一个人生活的描写，起了兴趣，遂决定读一读。 山本文绪笔下一个人的生活： 我很喜欢一个人在家喝酒。先把房间打扫干净，再准备好新洗过的浴巾和睡衣泡个热水澡，认真地洗干净头发和身体，一身清爽后悠闲地看着电视，喝着冰镇的酒，这是我现在生活里最放松的时间。不管喝多少，心情都绝不会悲伤或寂寞。只是非常坦诚、单纯地感觉到幸福。 一个人逛街，一个人吃饭，一个人旅行，一个人做很多事。一个人的日子固然寂寞，但更多时候是因寂寞而快乐。极致的幸福，存在于孤独的深海。在这样日复一日的生活里，我逐渐与自己达成和解。 我讨厌和人抱怨，那会让我觉得很悲哀。我想要没有怨言地生活下去。为此还是一个人好，因为我不会和自己抱怨。对自己严厉还是温柔，都是我的自由。 一直都是一个人，也就更擅长取悦自己。 有份工作，朋友不多但有几个亲密的，没有特别大的烦恼，房租、饭钱还有买酒的钱暂时还不用担心，我真的觉得多幸福啊。 消耗体力也好，花费金钱也罢，我都要找回我的\"没有理由就是开心”。 真自由啊，什么都可以做，哪儿都能去，想到这儿我就高兴得一塌糊涂。 电视是没有干劲时绝好的避难所。 所谓恋爱咨询，并非只有好朋友才行，谁都可以胜任，聊过之后能振奋精神的才是最棒。 一个人工作，一个人看书，一个人吃饭，一个人看着电视乐，一个人睡觉。感觉寂寞难耐的，定会找个人同住吧。但我并没觉得寂寞难耐。要说难耐的，反倒是想一个人的时候无法一个人。 满满的满满的我。 2019.11.26 花了一个月，终于看完了，没有记录多少句子，但很喜欢山本文献笔下一个人的生活，打算重新看一遍。 ","date":"2019-10-24","objectID":"/2019/%E7%84%B6%E5%90%8E%E6%88%91%E5%B0%B1%E4%B8%80%E4%B8%AA%E4%BA%BA%E4%BA%86/:0:0","tags":["读书笔记"],"title":"然后，我就一个人了","uri":"/2019/%E7%84%B6%E5%90%8E%E6%88%91%E5%B0%B1%E4%B8%80%E4%B8%AA%E4%BA%BA%E4%BA%86/"},{"categories":["爱编程爱技术的孩子"],"content":"对任何系统来讲，桌面的整理都是重中之重。有些人喜欢文件触手可及，所有东西都放在桌面。有些人喜欢极简美观，桌面一尘不染，全部通过快速搜索完成。也有人做了折衷，桌面只放常用的文件并使用一些整理工具管理。没有对错，没有优劣，这种事情全看个人喜好，自己用着舒服就行。 至于我自己，大概属于第二种吧。以下也按我的习惯来介绍，主要分三部分：壁纸，桌面，任务栏。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:0:0","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 壁纸 无论个人喜好，壁纸的选择都应以不影响使用为原则，过于花里胡哨的壁纸将严重影响对应用和文件的识别，即使桌面干净的用户，复杂的图片也绝对挑战着人的观感和耐心。因此，挑选壁纸不仅要注意分辨率的大小，还要注意构图尽可能简单，最好拥有1/3以上的邻近色区域。以下两张图片就是一个鲜明的对比。 除此之外，壁纸可分为静态壁纸和动态壁纸两类。 静态壁纸的使用是主流，但动态壁纸也有不少拥趸。比较有名的动态壁纸软件是steam上的Wallpaper Engine，在社区中提供了大量高质量的动态壁纸，并且不仅仅是常规意义的动态壁纸，还可以通过鼠标进行交互式控制，甚至直接在壁纸上玩游戏，可以说是把这种类型做到了极致。但该软件的缺点在于比较消耗系统资源，同时在电脑启动时要级联启动steam和该软件，拖累了电脑启动速度，在用了一段时间后，新鲜感下降，我也就弃它而去了。以效率和极简的原则来看，动态壁纸的使用性价比并不高，若为了体验一番或电脑配置较高可以使用，但普通情况下不作建议。 静态壁纸最重要的就是好的壁纸来源。我个人来讲主要有两个，一个是「Windows聚焦」功能每日更换的锁屏壁纸，遇到喜欢的就保存下来，作为桌面使用；另一个是壁纸网站Wallpaperplay，提供了大量高质量的图片，可以挑选作为自己的壁纸使用。我最常使用的是以Minimalist开头的分类中的图片。以下的示例图片和本文开头的两张对比图片都来自该网站。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:1:0","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 桌面 之所以把桌面和壁纸分开，是为了谈一谈桌面管理。一般情况下，桌面存在的内容包括软件快捷方式图标和常用文档，也有人放置Todo清单。随意放置的话，即使挑选了一张好的壁纸，最后也会把桌面弄得一团糟。因此有人使用了最简单的四象限分类法，将壁纸设为如下的四象限壁纸，把图标和文件放到不同的区域。 也有人使用Fences或腾讯桌面整理，把文件归档，桌面于是变成了下面这种样子。 但就我自己而言，四象限法不够优雅美观，桌面整理工具又会破坏桌面整体性，还会在右键菜单添加一大堆不需要的东西，因此我选择不放图标和文件在桌面。常用的软件都固定在了底部任务栏，文件则即用即删，同一时间工作的文档不会很多，同时也提醒自己尽快完成工作，之后就可以从桌面移走。如下是我的桌面。 从上图中注意到的另外一点是我在桌面中央放置了一个时钟，使得整个桌面更加和谐，不至于空荡荡的，时钟的位置可以根据壁纸的图案进行调整。而该时钟插件则来源于Rainmeter。 实际上关于桌面美化，Rainmeter恐怕不得不提，原本只是一个系统状态监视软件的它，由于强大的可定制性和扩展性，发展出了一个极为庞大的社区，并产生了数量难以估计的插件程序和皮肤样式，从而为我们进行系统桌面的美化提供了极大便利，一个官网提供的示例如下 Rainmeter可以显示CPU、内存、硬盘容量、网络等系统信息，可以从网络获取如天气、RSS源等信息，而且占用资源极小。但它不能修改如任务栏外观、开始按钮外观等系统视觉样式，也不能替代与之关联的程序，如果一个皮肤关联了网易云，使用的条件必须是网易云在后台运行。 因此，出于极简与效率的考虑，我们摒弃了在桌面使用插件显示CPU、内存、硬盘等系统信息的想法，这些一般情况下查看的频率极小，没有必要放在桌面显示，需要的时候在任务管理器界面查看即可，更加的详细。 我们只简单的添加了一个时钟插件，至于天气信息是否添加，随自己所愿。 最后是便签，我是曾想过使用那种贴边隐藏的便签的，但思来想去，对我的作用恐怕不是很大，一来便签软件随电脑启动又会增加一项负担，另外就是我个人还是更偏爱使用实际的便签纸贴在工位上，尤其是在看过逃避虽可耻但有用后，新垣结衣工作中使用的便签法给我了极大的启发。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:2:0","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 任务栏 在我的认知中，任务栏的作用可真的是太大了，不仅仅原先在桌面的软件现在全靠任务栏的图标启动，快速搜索、时间线、日期时间显示等都依赖它。不过在介绍各项功能调整之前，我们先来介绍两个任务栏美化的小技巧。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:3:0","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 任务栏透明 任务栏透明的工具千千万，而我独爱TranslucentTB。说实话，任务栏透明的工具还是不少的，但TranslucentTB集中于这一个功能，把它做到了极致。我曾经使用过很长一段时间坑晨大佬的Win10 萌化通用工作箱，但到最后发现其中很多功能，包括文件夹背景自定义、系统窗口半透明等我都用不到，或者说这些功能不符合我的使用原则，造成了极大的生产力浪费。直到我找到了TranslucentTB。 一些高级功能暂且不表，TranslucentTB支持任务栏的Blur，Clear，Normal，Opaque，Fluent五种显示方式，但最为令人惊喜的细节在于，可以在桌面环境和窗口模式下透明，而在全屏模式下不透明。只有经历过的人才会懂这个功能有多么有用。 TranslucentTB可以直接从 Win10 商店里下载。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:3:1","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 任务栏居中 任务栏居中可以通过简单的调整实现，无需安装软件。 首先在磁盘任意位置建立一个空文件夹，命名为自己喜欢的名字。我选择在F盘根目录建立了文件夹Minimalism。 右键任务栏，选择工具栏—\u003e新建工具栏 在弹出的窗口中选择刚刚新建的空文件夹，确认选择。因为我已经操作过一次，所以图中已经可以看到之前新建的Minimalism工具栏。 这一步操作之后任务栏应当是如下模样 可以看到，名为Minimalism的文件夹出现在了任务栏，可以通过这一特性在任务栏定制自己喜欢的文字，但最好不要太长。同时由于该文件夹成为了新的工具栏，之后也不要往里面放文件，不然会一同显示在任务栏中，出现这种情况。 此时继续右键任务栏，取消勾选锁定任务栏 取消勾选后，Minimalism前将出现双竖线。鼠标点击双竖线使劲向左水平拖动，直到左侧的一堆图标自动移动到右边。 然后拖动图标左侧的双竖线移动到任务栏中央，重新锁定任务栏，调整完毕。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:3:2","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 小图标设置 前两步走完之后，其实大体的优化都已经结束了，剩下的是一些细节的说明，包括右侧小图标的显示与否，以及我们把桌面清空之后如何快速搜索软件和文档等。当前主要介绍右下角的小图标设置。 右键任务栏，点击任务栏设置，所出现的就是我们所有可做的调整了，也许有人从未关注过这些功能，不过其实都挺有意思的，下面将逐个介绍。 在桌面模式下自动隐藏任务栏，如文所述，勾选之后，任务栏将自动隐藏，无论是窗口模式还是全屏模式，只有当鼠标移动到任务栏的位置时任务栏才会显示。也许有人喜欢这样的方式，但我自己来说，即使我喜欢极简，当影响到使用时一样无法接受。由于之前已经将桌面清空，大部分功能依赖任务栏完成，因此对任务栏的使用频率极高，自动隐藏会使人使用起来非常难受，这也是我为什么第一次见到这项功能十分惊喜，但使用连一天都没坚持下来。 下面的两个图并不是我没有截任务栏哦，是自动隐藏了。 使用小任务按钮，曾经用过一段时间，作用是将任务栏的大小缩小一号，但人年纪大了，眼睛不好，后来还是换了回来(滑稽)。 当我右键单击“开始”按钮或按下Windows键+X时，在菜单中将命令提示符替换为Windows PowerShell，如文所述，而且一般人用不到。主要决定开始按钮的右键菜单中是出现cmd还是PowerShell。 在任务栏按钮上显示角标，以闹钟为例，将其固定到任务栏并开启闹钟后，图标会显示一个角标。我很少固定系统应用在任务栏，以前只是在邮件应用上见过角标，非系统应用还没有见过，所以应该对非系统应用不起作用。而且，角标什么的，对强迫症来讲太难受了。 任务栏在屏幕的位置，有四种选项，分别是底部，顶部，靠左，靠右。各有喜好吧，Mac和Ubuntu任务栏都在顶部，所以也许用惯了这两种的人比较习惯放在顶部。我的话，顶部、靠右都试过一段时间，但最后还是觉得在底部最舒服。 合并任务栏按钮，三个选项，始终合并按钮，任务栏已满时，从不。除了选始终合并，其它两种都会出现如下效果，说实话，我觉得显示名称没有意义，好不容易调整的任务栏也被破坏，而且有时候一打开就是好多软件，选始终合并最适合不过了。 Win10 本身还在设置里提供了一个如何自定义任务栏的官方教程，介绍了不少使用方法，除我们上面介绍的外，还包括更改任务栏的颜色，更改任务栏的高度等，不过这些都很简单，基本都能猜出来怎么做，猜不出来的可以点链接看官方说明。 选择哪些图标显示在任务栏上，如文所述，选择在通知区域显示的图标，我的选择原则是使用频率，当然是越少越好，目前留下的只有QQ和网络。其它的像音量什么的，其实使用频率不是很高，所以就直接隐藏了，当然这因人而异。 打开或关闭系统图标，很多其实都不是一直显示的，唯一比较麻烦的是输入指示，如果它只显示汉字中或英还好，问题是旁边会附带拼字样。考虑了很久后，最后还是把输入指示关闭掉了，因为一共就两种情况，切换也就一个快捷键的事情，试错成本比较低，就不放着碍眼了。 时间和日期，右键时间和日期同右键任务栏出现的选项有所不同，多出了一个调整日期/时间的选项，单击后会进入设置里的日期和时间页面，主要的功能选项其实没什么可谈的。但右侧有两个很有意思的选项。 一个是添加不同时区的时钟，如下图我们添加了美国东部时间(和老师视频用)。 单击任务栏的时间和日期或者鼠标悬停在上面都可以看到附加的时钟，对于跨国恋的情侣来说，或者其它经常跨国交流的人，这个功能也是很实用了。 另一个设置是日期、时间和区域格式，区域的设置没有什么意义，但我们可以点击更改数据格式，调整日期和时间的显示形式。也许有人觉得没用，那是因为你没有注意到，在不同的显示器上，时间部分显示的完整性是不一样的，比如我的笔记本屏幕比较小，就只显示当前时间，而实验室的显示屏会同时显示当前时间和日期。通过调整这里的显示格式，可以适应不同大小的屏幕，当然，手动调整任务栏的大小也会显示更多内容。 通知与操作，右键日期与时间，选择自定义通知图标，可以添加、删除或重新排列操作中心的操作，同时可以选择接收或不接受某些应用的通知，因为很多时候某些应用的通知我们完全不关心，这个功能还是很有用的。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:3:3","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 应用图标 很多人喜欢统一化应用图标的风格，我当然没有意见，但这个操作往往涉及很多问题。因为无论是专门的软件还是手动更改，仅仅是在属性页面替换了一下图标文件(ico文件)。应用变动时，比如更新，删除后重装都会失效，而且逐个更改工作量简直爆炸。应用原始图标辨识度也比较高，相比之下，我就不动图标样式了。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:3:4","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["爱编程爱技术的孩子"],"content":"3.5 搜索及时间线 任务栏最左侧的开始按钮以后的文章再讲，与之相邻的Cortana被我取消了显示，因为无论在宿舍还是实验室，语音的交互都会影响到他人。留下的只有搜索和时间线，这两个功能同样在任务栏的右键菜单开启。 桌面清空各种常用文件和应用之后，搜索的作用变的大了起来，任务栏固定的只是使用频率高的软件，其它的软件和常用文件都通过搜索来快速访问，完全不会影响效率。只是要注意的是搜索历史默认会上传到云端，不过可以在设置中关闭。 任务视图的核心作用有两个，一个是新建和切换桌面，将不同的任务分隔开来，比如我的两个桌面一般情况一个是看论文查资料用的，因为开的窗口过多。当我编程或写作的时候就会切换到桌面2；另一个是时间线，可以回顾最近一段时间每天的工作，用来总结蛮合适的。 就这样了，开始菜单涉及的东西比较多，就换下次介绍吧。最后来看一下完整的桌面。 ","date":"2019-10-23","objectID":"/2019/efficient-use-of-win10-3-desktop-management/:3:5","tags":["Win10"],"title":"Win10效率优化3-桌面整理","uri":"/2019/efficient-use-of-win10-3-desktop-management/"},{"categories":["Golang学习之路"],"content":"本文介绍 Go 中的常量、变量、基本数据类型和常用的类型转换。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:0:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"1. 常量 常量用于存储程序运行过程中不会改变的数据，试图改变会引发编译错误。Go 中常量使用关键字 const 定义，声明与初始化语句放在一起，格式如下 const identifier [type] = value 常量的值必须在编译时能够确定，因此只能是基本数据类型和表达式。一个常量定义的例子如下 const Pi float64 = 3.14159 另外，由于 Go 的一些特性，常量的定义有一些不同的形式 Go 支持根据值推断其类型，因此类型定义可省略 const Pi = 3.14159 Go 支持在同一行同时定义多个值，称为多重赋值 const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6 Go 支持批量声明，这种定义形式叫做因式分解关键字 const ( Monday, Tuesday, Wednesday = 1, 2, 3 Thursday, Friday, Saturday = 4, 5, 6 ) 此外，Go 还提供关键字 iota，用作常量计数器，只能在常量定义时使用。iota 在 const 关键字出现时被重置为 0，每新增一行常量声明新增一个计数，能极大的简化定义。一个例子如下 const a = iota // a=0 const ( b = iota //b=0 c //c=1 相当于c=iota ) 可以使用空白标识符跳过不想要的值 const ( a = iota // 0 _ c // 2 ) 同一行有多个变量不产生影响，中间有数值插队也不产生影响，因为 iota 的值是每新增一行声明增加 1 const ( a,b = iota,iota+1 // 0,1 c,d // 1,2 e,f // 2,3 ) const ( a = iota // 0 b = 3.14 c // 2 ) ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:1:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"2. 变量 变量使用 var 关键字声明，格式为 var identifier type 当一个变量被声明后，系统会自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。 变量与常量的一个不同之处在于，一般情况下，声明与初始化是分离的，一个例子如下 var a int a = 15 但变量也可以将声明和初始化放到一起，就像常量一样，这也是最常使用的方式 var a int = 15 最后，由于常量部分提到的三个 Go 的特性，变量的声明和使用也有一些不同的形式 类型推断，从而可以省略类型定义 var a = 15 多重赋值 var a, b, c = 5, 6, 7 批量声明 var ( a = 15 b = false str = \"Go says hello to the world!\" numShips = 50 city string ) 上面提到的所有方式可以用于全局变量，也可以用于局部变量，但还有一种更加简短的声明与定义方式，仅能用于局部变量（函数体内，包括 main 函数），这是我们使用非常多的一种写法 a := 15 这里详细介绍一下常量部分提到过的空白标识符，空白标识符指的是下划线 _，也叫做匿名变量，只允许写入，任何类型都可以赋值给它，但无法使用它的值。我们在使用 iota 关键字时可以使用空白标识符跳过不想要的值，另外一种常见的使用场景是在多重赋值中抛弃不需要的变量 _, b = 5, 7 匿名变量不会被分配内存，因此不占用内存空间，多次声明也不会引起冲突。 Go 还提供了一种非常友好的功能，如果想要交换两个变量的值，可以直接使用 a, b = b, a 这种形式，不需要再使用临时变量，为程序编写带来了极大的便利。 变量的命名规则最好遵循驼峰命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips。但当全局变量需要对外部包可见时，首个单词首字母需要大写(可见性原则)。 变量作用域的规则同 C 语言相同，关于值类型和引用类型的理解也和 C 语言相同，Go 中引用类型包括指针、切片、映射和通道，值类型存储在栈中，引用类型存储在堆中，以便进行垃圾回收。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:2:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3. 基本数据类型 Go 拥有 4 大类共7种基本数据类型 布尔类型 bool 数字类型： 整型 int，根据位数的不同包括 int8, int16, int32, int64 四种以及相对应的 uint 浮点型 float，包括 float32 和 float64 两种 复数 complex，包括 complex32 和 complex64 两种，复数类型并不常用 字符类型： byte，uint8 的别名，完全等同 rune，int32 是别名，完全等同 字符串类型 string ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.1 布尔类型 使用bool关键字声明，值只可以是常量 true 或 false var b bool = true 两个类型相同的值可以使用关系运算符来获得一个布尔类型的值。布尔类型的值之间也可以使用逻辑运算符来产生另一个布尔值，运算规则与其它语言相同。 类型相同是一个很严格的规定，涉及到了 Go 的比较规则，我们将 Go 中不可比较类型总结如下，除此之外，其它类型都是可比较的 切片类型 映射类型 函数类型 任何字段为不可比较类型的结构体类型，以及任何元素类型为不可比较类型的数组类型 对于接口而言，情况更加复杂一点，如果值的类型是接口，那么它们必须实现了相同的接口。如果条件不满足，则必须事先进行类型转换才可以比较。或者直接一点， 布尔值（以及任何结果为布尔值的表达式）最常用在流程控制的的条件语句中，如：if、for 和 switch 结构。 另外值得注意的一点是，Go 中的布尔值并不等于数字 1 和 0，因此不能直接进行运算。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:1","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.2 数字类型 Go 中数字类型分为三种，整型、浮点型和复数类型。 整型 整型提供有符号和无符号两种，每一种又分别提供对应 8、16、32、64bit 大小的四种类型，总计八种，列表如下 整型 无符号整型 int8（-128 -\u003e 127） uint8（0 -\u003e 255） int16（-32768 -\u003e 32767） uint16（0 -\u003e 65,535） int32（-2,147,483,648 -\u003e 2,147,483,647） uint32（0 -\u003e 4,294,967,295） int64（-9,223,372,036,854,775,808 -\u003e 9,223,372,036,854,775,807） uint64（0 -\u003e 18,446,744,073,709,551,615） 除此之外还提供两种不带位数的类型声明：int 和 uint。这两种类型的大小取决于所运行的平台处理器支持的字长，例如，在 32 位操作系统上，使用 32 位（4 个字节），在 64 位操作系统上，使用 64 位（8 个字节）。 尽管 int 有可能是 32 位，但在需要时 int 和 int32 之间也必须显式进行类型转换。 最后还有一种无符号整型 uintptr，它没有指定具体的 bit 大小但被设定为足够容纳一个指针。uintptr 类型只有在底层编程时才需要，特别是 Go 语言和 C 语言函数库或操作系统接口相交互的地方，一般用于指针计算。 int型是计算最快的类型，也是最常使用的类型。 浮点型 Go 语言中没有 float 类型，没有 double 类型，只有 float32 和 float64。它们的算术规范由IEEE-754标准定义，该标准被所有现代的 CPU 支持。 float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。通常应该优先使用 float64 类型，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。 复数类型 Go语言拥有两种复数类型，分别是 complex64（32 位实数和虚数）和 complex128（64 位实数和虚数）。 var c1 complex64 = 5 + 10i 内置的 complex 函数用于构建复数，内置的 real 和 imag 函数分别返回复数的实部和虚部： var cl complex128 = complex(1, 2) // 1+2i fmt.Println(real(cl)) // \"1\" fmt.Println(imag(cl)) // \"2\" cmath 包中包含了一些操作复数的公共方法。如果对内存的要求不是特别高，最好使用 complex128 作为计算类型，因为相关函数都使用这个类型的参数。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:2","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.3 字符类型 Go语言的字符有两种： byte 型，代表了 ASCII 码的一个字符。 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。 严格来说，字符只是整数的特殊用例。byte 类型是 uint8 的别名，刚好一个字节，足以表示传统 ASCII 编码的字符。例如：var ch byte = 'A'；rune是int32的别名，四个字节，足以表示最长的UTF-8字符。 另一方面，由于字符只是整数的别名，因此其零值也是 0。 字符使用单引号括起来。 包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）： 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:3","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.4 字符串类型 字符串底层约定是字节的一个序列，编码方式建议是 UTF-8，但不是必须遵守，通常是ASCII。因此取字符串单个字符的类型通常是 byte，只有遇到中文等语言是才是 rune。另外，使用 for-range 结构遍历时字符串的单个字符类型是rune 字符串是值类型，且值不可变，即创建一个字符串后无法再次修改它的内容 Go 支持以下 2 种形式的字符串： 解释字符串：该类字符串使用双引号括起来，其中的转义字符将被替换，这些转义字符包括： \\n：换行符 \\r：回车符 \\t：tab 键 \\u 或 \\U：Unicode 字符 \\\\：反斜杠自身 非解释字符串：该类字符串使用反引号括起来，当使用多行字符串时使用这种形式。 a := `abc def` fmt.Println(a) // Output: abc def string 类型的零值为长度为零的字符串，即空字符串 \"\"。 Go 中的字符串是根据长度限定的，而非特殊字符\\0，其长度可以使用内置函数len()来获取，长度的基本含义是字符串在内存中所占字节的个数，所以下面的例子虽然是两个中文，但长度是6 a := \"中国\" fmt.Println(len(a)) // 6 可以将字符串看作数组而索引其内的单个字符，如第i个字节表示为str[i-1] 使用拼接符+可以拼接两个字符串，以下是一个多行字符串拼接的例子 str := \"Beginning of the string \" + \"second part of the string\" +必须放在第一行末尾，因为编译器会在行尾自动补全分号。当然，+=一样可用于字符串 s := \"hel\" + \"lo,\" s += \"world!\" fmt.Println(s) //输出 “hello, world!” 在循环中使用+拼接字符串并不是最高效的做法，更好的办法是使用string.join()，或者使用字节缓冲bytes.Buffer ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:4","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.5 类型别名 使用某个类型时可以给它起个别名在程序中使用，用于简化名称或解决名称冲突 在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。 package main import \"fmt\" type TZ int func main() { var a, b TZ = 3, 4 c := a + b fmt.Printf(\"c has the value: %d\", c) // 输出：c has the value: 7 } 实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法；TZ 可以自定义一个方法用来输出更加人性化的时区信息。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:5","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"4. 类型转换 Go语言中类型转换是可行的，但是不存在隐式类型转换，所有的转换都必须显式说明。类型转换的基本格式为 valueOfTypeB = typeB(valueOfTypeA) 两条转换原则如下 只有相同底层类型的变量间可以进行相互转换（如int16和int32），不同底层类型的变量相互转换会引发编译错误 类型转换只有从取值范围小的类型转换到取值范围大的类型才能成功，反过来会发生精度丢失（截断） var a,b int16 var c int32 A := int32(a) // 标准转换 B := bool(b) //类型不匹配，引发编译错误 C := int16(c) //取值范围变小，精度丢失 浮点型可以转换为整型，转换时会将小数部分去掉，只保留整数部分 a := 12.54 fmt.Println(int(a)) //输出12 精度丢失可以使用专门的函数保证安全，如int型到int8 func Uint8FromInt(n int) (uint8, error) { if 0 \u003c= n \u0026\u0026 n \u003c= math.MaxUint8 { // conversion is safe return uint8(n), nil } return 0, fmt.Errorf(\"%d is out of the uint8 range\", n) } 其它的类型转换则需要使用一些库函数 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:4:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"4.1 bool与string Go语言中bool类型值与数字1和0不等同，因此不能和数字类型相互转换（可以简单的使用if-else结构完成这一功能）。但借助strconv包，可以和string类型转换。 //string-\u003ebool b, err := strconv.ParseBool(\"true\") //bool-\u003estring s := strconv.FormatBool(true) 两个函数的原型如下 //ParseBool返回字符串代表的bool值，接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False作为传入参数，其他参数均返回error func ParseBool(str string) (bool, error) { switch str { case \"1\", \"t\", \"T\", \"true\", \"TRUE\", \"True\": return true, nil case \"0\", \"f\", \"F\", \"false\", \"FALSE\", \"False\": return false, nil } return false, syntaxError(\"ParseBool\", str) } // FormatBool returns \"true\" or \"false\" according to the value of b. func FormatBool(b bool) string { if b { return \"true\" } return \"false\" } ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:4:1","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"4.2 int/float与string 与字符串相关的类型转换都是通过strconv包实现的。最常用的是Atoi(string to int)和Itoa(int to string)函数 i, err := strconv.Atoi(\"-42\") s := strconv.Itoa(-42) 函数原型如下 func Atoi(s string) (int, error) func Itoa(i int) string 字符串-\u003e数字类型 ParseFloat, ParseInt, 和ParseUint可以将字符串转化为对应的值 f, err := strconv.ParseFloat(\"3.1415\", 64) i, err := strconv.ParseInt(\"-42\", 10, 64) u, err := strconv.ParseUint(\"42\", 10, 64) 浮点型函数原型如下 func ParseFloat(s string, bitSize int) (float64, error) bitSize指定了返回值的类型，当bitSize=32，返回float32类型（结果仍是float64，但会转换为float32)；当bitSize=64，返回float64类型。只有这两种情况。 整型函数原型如下 func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (uint64, error) 如果base为0那么实际上base由string的前缀指定，0x意味着base=16，0意味着base=8，否则base=10，本质上是进制的前缀。若base等于1，小于0或超过36，返回一个error。 bitSize仍然指定返回值类型. 其值为 0, 8, 16, 32, 和 64 分别对应 int, int8, int16, int32和int64. bitSize值小于0或大于64，返回一个error。 数字类型-\u003e字符串 FormatFloat, FormatInt, 和FormatUint可以将值转换为字符串 s := strconv.FormatFloat(3.1415, 'E', -1, 64) s := strconv.FormatInt(-42, 16) s := strconv.FormatUint(42, 16) 浮点型的函数原型如下 func FormatFloat(f float64, fmt byte, prec, bitSize int) string bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。 fmt表示格式：‘b’ (-ddddp±ddd, 二进制指数), ‘e’ (-d.dddde±dd,十进制指数), ‘E’ (-d.ddddE±dd, 十进制指数), ‘f’ (-ddd.dddd, 没有指数), ‘g’ (指数很大时用‘e’, 否则用 ‘f’ ), ‘G’ (指数很大时用‘E’, 否则用 ‘f’ ). 精度prec控制数字的个数 (排除指数)。对’e’, ‘E’, 和 ‘f’ ，表示小数点后的数字位数. 对 ‘g’ 和 ‘G’ 是有效数字位数 (trailing zeros are removed)。prec等于-1时则使用最少数量但又必须的数字来表示f。 整型的函数原型如下 func FormatInt(i int64, base int) string func FormatUint(i uint64, base int) string 返回base指定进制的整数i的字符串形式，2 \u003c= base \u003c= 36。使用小写字母 ‘a’ 到 ‘z’ 表示大于10的数字。 忽略可能出现的转换错误，可以给出如下例子： package main import ( \"fmt\" \"strconv\" ) func main() { var orig string = \"666\" var an int var newS string an, _ = strconv.Atoi(orig) fmt.Printf(\"The integer is: %d\\n\", an) an = an + 5 newS = strconv.Itoa(an) fmt.Printf(\"The new string is: %s\\n\", newS) } //输出： The integer is: 666 The new string is: 671 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:4:2","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"4.3 []rune与string 用 for range 遍历字符串可以返回每个字符，返回的字符类型是 rune。但 []rune 类型也经常需要转换为 string，和单个 rune 类型相似，都可以直接进行显示类型转换，如下： a := []rune{'a', 'b', 'c'} b := 'g' c := string(a) d := string(b) fmt.Println(reflect.TypeOf(a), reflect.TypeOf(b), reflect.TypeOf(c), reflect.TypeOf(d)) fmt.Println(a, b, c, d) //Output []int32 int32 string string [97 98 99] 103 abc g ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:4:3","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["爱编程爱技术的孩子"],"content":"得益于苹果的生态，MacOS上的优秀软件不少，因此网上存在大量介绍如何利用Mac有效率的学习、工作和生活的文章。但对于Win10来说，这方面的文章就乏善可陈了，但Win10作为一款消费级操作系统，拥有最大的市场占比，更在不断迭代优化，其软件数量也远远超过Mac，因此我相信它是有改善我们学习或工作模式的潜力的。 我想要收集一些信息，并结合自身的使用经验，做一次这方面的总结，给自己一个备份，也给其他人一些借鉴。相信不论出于何种原因身处Win10的阵营，一颗追求效率和极简的心想必依然是有的。 我们遵循极简和效率的理念来使用Win10，也以同样的理念安排这一个系列的文章。不过，有别于Mac，在Win10领域有一个庞大的社区是关于美化的，好的视觉效果能让人心情愉快，美观也是我们追求的目标，但这一目标位于效率和极简之后，意思是，美化不应当造成任何操作上的不便。这就是我使用Win10的三原则。 先来一次头脑风暴，将会涉及的方面包括： 锁屏 桌面：包括壁纸、桌面管理、任务栏。 文件管理 文件资源管理器的初始界面 磁盘划分 文件归档 文件命名 文件同步和设备间文件互传 系统功能：包括截图、连接、投影、夜间模式、搜索、时间线、VPN、热点等等。 软件管理 软件安装和卸载工具：IObit Uninstaller, Chocolatey 通信：QQ, 微信 压缩解压工具：7zip 浏览器：Edge dev 安全软件，应包括磁盘扫描，垃圾清理，漏洞修复，火绒 编程IDE和其它编程相关：VScode, Github 文献管理：Zotero 文档编辑：Typora 音乐、视频播放软件：网易云，迅雷影音 邮件和日程管理 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-1-overview/:0:0","tags":["Win10"],"title":"Win10效率优化1-综述","uri":"/2019/efficient-use-of-win10-1-overview/"},{"categories":["爱编程爱技术的孩子"],"content":"Win10 系统中，锁屏是我们登录系统前看到的一个界面。它的作用是当我们暂时离开电脑时阻止别人操作，但早晨当我们打开电脑时，第一眼看到也是锁屏界面，因此它可以影响我们的心情，所以要选择好的图片作为锁屏背景。微软提供了一些关于锁屏的有用的功能，包括： 自定义锁屏背景图片 在锁屏界面显示当前时间和日期 在锁屏界面显示日历中日程信息和软件通知 所有的设置基本都位于个性化设置中的锁屏界面设置。以下我们就来介绍如何定制一个合适的锁屏界面。 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:0:0","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 锁屏背景 Win10 允许我们以三种方式设置锁屏背景： Windows 聚焦，图片和幻灯片放映。具体的设置方式为 打开设置 点击个性化 点击锁屏界面 在背景下拉菜单中选择自己要使用的方式 选择图片作为锁屏背景后，需要点击「浏览」按钮在电脑中选择自己喜欢的图片，所选图片最好不要影响左下角的时间和通知显示，若能相互辉映最好。 选择幻灯片放映，则需要选择一个图片文件夹，锁屏界面将循环播放这些图片，每个图片的停留时间大约在10秒左右。 单张图片容易看腻，幻灯片不仅需要自己劳心劳力寻找图片，切换速度也比较快。这种情况下，第三个选择Windows 聚焦 最好不过了。 「 Windows 聚焦」是 Win10 内置的一个锁屏壁纸自动换功能，开启后会在锁屏界面每天更换一张新的壁纸。这里需要注意的是，每天第一次登录电脑看到的依然是昨天的背景图片，因为只有在系统启动并联网后才会自动下载壁纸，当你第二次登录时，壁纸就会更新了。 Windows 聚焦的壁纸多数为风景照，质量都非常高，而且右上角会有提示询问是否喜欢这张壁纸，选择“不喜欢”将会更换新壁纸，每次选择都会为「 Windows 聚焦」后续筛选壁纸提供参考，从而令锁屏界面出现的壁纸越来越符合个人喜好。 上图是我的电脑今天的锁屏壁纸，可以看到，在左上角和中间还有一些文字，一般情况都是对壁纸内容的简单介绍，有时候也会是一些使用小贴士。而右上角除了喜欢与不喜欢的选项外，还显示了该景点的名称和所在地，单击景点名称然后解锁屏幕，Edge浏览器将自动启动并展示该景点更详细的信息。有的时候我们对某个图片的景点喜爱至极，非常想知道是哪个地方，所以这个功能可谓是十分重要了。 如前所述，在经过长时间的使用和反馈之后， Windows 聚焦选择的壁纸将会越来越符合我们的喜好，通常大家都会有将其保存下来的冲动。这些壁纸在电脑中的保存路径为 C:\\Users\\user\\AppData\\Local\\Packages\\Microsoft. Windows .ContentDeliveryManager_cw5n1h2txyewy\\LocalState\\Assets 其中user字段是个人的用户名。此处保存的所有的壁纸都没有后缀，需要我们手动添加图片格式后缀。不过在将其转变为图片之前，为了不影响当前壁纸的显示，最好把它们复制到一个新的文件夹，如下图Spotlight Wallpapers。之后就可以更改这些文件的后缀为图片类型了，推荐使用批量修改文件名这一软件，更方便一点，文件类型使用.png最好，但.jpg和.jpeg等其它类型也都可以使用。另外，对Asset文件夹中的原始文件按修改日期排序，可以找到当天的壁纸图片。 最后还有一点， Windows 聚焦同时提供两种分辨率格式的图片，为1080×1920和1920×1080，前一种可以用于竖屏显示器或手机。 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:1:0","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 应用通知 除了时间和日期， Win10 还支持在锁屏界面显示一个应用的详细状态和多个应用的快速状态。设置按钮位于锁屏背景设置的下方。 支持显示的应用基本是 Win10 的系统应用，多数我们平时都不会使用，但天气信息的显示对大部分人都有意义，而Outlook日历用户也是一个不小的群体，因此这两个应用显示在锁屏上是对我们有帮助的。应用显示之前首先应在系统中初始化，比如天气应当首先设置好城市。 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:2:0","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 登录界面 在应用通知设置的下方，有一个「在登录屏幕上显示锁屏界面背景图片」的按钮。该按钮出现在 Win10 1903版本之后，会在密码输入页面将锁屏壁纸模糊化显示，取消勾选此选项则只有一片灰色背景，两种情况对比如下，对我个人来讲，更喜欢壁纸模糊化的显示。 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:3:0","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 手环解锁 Win10 登录方式有人脸、指纹、PIN、物理密钥、图片密码和普通的登录密码。人脸和指纹自然是好的，但老旧的电脑和台式电脑恐怕都力不从心，这种情况下，PIN是最常用的办法。但现在，小米手环可以通过官方的商店应用「小米智能解锁」来快速解锁屏幕。 从 Win10 商店下载并安装这款免费应用，跟随提示进行一步步设置，设置完成后，以后只要把手环靠近电脑，敲击键盘任意键就可解锁。但需笔记本保持蓝牙开启和创建PIN码。 手环解锁固然方便，要是锁屏也可以就好了。在 Win10 的登录选项中，有一种叫做动态锁的功能，使用这种功能， Win10 可以通过与电脑配对的设备获悉我们何时离开电脑，并在这些设备超出范围时锁定电脑。可惜的是这一配套功能不支持手环，只能使用手机，但对手机来讲，平时没有人会持续开启蓝牙，可以说是鸡肋了。 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:4:0","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 其它设置 Win10 支持在锁屏界面就唤醒Cortana，但在工位上用语音多少会影响别人，至于屏保，个人认为这一功能没有存在的意义，默认设置为无，我们无需更改。 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:5:0","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 附录 在文章写作过程中涉及到对系统的锁屏和登录界面截图，比较特殊，记录如下。 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:6:0","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["爱编程爱技术的孩子"],"content":"6.1 锁屏界面截图 锁屏界面的截图极为简单，只需要在锁屏界面按下键盘的PrtSc SysRq键（即截图键），锁屏的截图即保存至了粘贴板中，后续登录系统后，及时粘贴保存即可。 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:6:1","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["爱编程爱技术的孩子"],"content":"6.2 登录界面截图 登录界面截图无法使用自带的截图键，但可巧妙地利用登录界面右下角地轻松使用功能来完成截图。 首先在注册表中如下位置新建项utilman.exe，具体路径为HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ Windows NT\\CurrentVersion\\Image File Execution Options 在新建的utilman.exe中新建字符串值，值名为debugger，值数据为C:\\ Windows \\System32\\cmd.exe 至此，我们将cmd命令行关联到了轻松使用，接下来需要先下载 Windows 地截图命令行工具nircmd，下载完成后解压到C盘根目录，并重命名为nircmd。 按下win+L键锁屏，单击进入登录页面，点击右下角的轻松使用，将会弹出cmd的窗口，在命令行中执行如下命令。 timeout 5 \u0026 c:\\nircmd\\nircmd.exe savescreenshot c:\\\\screenshot.png 该命令将会延时5秒截取整个屏幕并将截图保存在C盘根目录下，我们需要在延时结束前最小化cmd窗口避免将其置入截图界面。预计截图结束后登录进入系统，将可以在C盘根目录成功找到命名为screenshot.png的截图文件 ","date":"2019-10-21","objectID":"/2019/efficient-use-of-win10-2-lockscreen-and-login/:6:2","tags":["Win10"],"title":"Win10效率优化2-锁屏与登录","uri":"/2019/efficient-use-of-win10-2-lockscreen-and-login/"},{"categories":["我所热爱的生活啊"],"content":"时隔五年重游大帅府，早已物是人非。18年95周年校庆的时候东大与大帅府签了合约，共庆华诞，邀请全球校友回返参观。一年之后，19年10月，东大与帅府再次发出邀请，免费参观张氏帅府，因此有了我和同学们今天的重游活动。 因为几个同学周六有课，因此选在了周五，不再是以往我独自一人例行的周六。同时下午还得早早的赶回来，于是坐了早8点的校车到南湖校区。已很久未到南湖这边来，上次来的时候图书馆还在施工，这次过来图书馆开放，大家先乘着兴致重新参观了一次图书馆。变动还是蛮大的，墙壁、栏杆、天花板、藏书的格局都与以往不同，装修整体上升了一个格局，给人感觉很舒适，各楼层都留出了专门的阅读区，放有沙发和桌椅，连茶水间都豪华的令人惊叹（ 滑稽，原谅我没有拍照）。二楼有个专门的国风馆，藏了一些文物，还有全套的四库全书啊什么的（新书，不是文物），馆内的布置也是屏风等古风特色的东西。一个小细节是楼梯没动，还是原来的感觉。 就到这里了，我们从图书馆出来到东门坐222公交到了大南门的大帅府下车，不过下车的地方是帅府出口的小巷，只好绕道前门取票，万幸，尽管我预约的是16号，票依然可以取，而且竟然是三个景点的通票，帅府内的几个文物展厅也可以参观。 帅府一如五年前游人如织，我却已不再是当初的我，当初满怀对大学生活的期望，现在全是前途的迷惘。前两天整理照片时看到的东西再一次以实物的形式出现在眼前，心里却没有多少波澜，一路上聊天打闹，心思竟全没在参观上，便是到了有名的大青楼，也只是匆匆留了个照片当作打卡。 照片拍的歪了些，但不会也未有时间修图，就这样罢。既然心思不在此处，脑海又全无映像，也就不多啰嗦了。小青楼也是看了两眼，关帝庙去也没去，直接就出了府。赵一荻故居的陈设比帅府新潮了些，整体的感觉还是一致的，这些都是上次参观过的，而我这人，即使最爱，也向来不喜欢重复。 金融博物馆上次不知何故没有参观，因此这次带来些新意。大厅的假人栩栩如生，分不出真假，导致我们一路上多次假人认作真人，真人认作假人，闹出好些笑话，在同学的提醒下，发现这些假人的皮肤竟是仿生触感，与真人相似，看来是下了许多功夫的。 多个展馆依次是从古到今的各种钱币样式，多是清朝、民国和现代，映像深刻的有种种金元银元，金元宝银元宝和世界各国钱币展，途中还参观了一个地下金库，也算是全了一个梦。与同学同游的一个问题是谈话间时光流逝，上一秒刚进博物馆，下一秒已出现在出口，一个人许会记得深一点，但与一个人的孤独相比，也不知孰优孰劣。 即使步伐匆匆，这一圈下来也到了中午，一行四人去了团购的阿尔卑斯比萨牛排自助西餐厅，吃不惯不熟的牛排，棉花糖太硬，上校鸡块出锅时间太久，不过虽然比不上韩盛，整体感觉也还算可以。其实本是打算将长安寺等其它几个景点一同游览了的，但同学下午有课，只好打车回了学校。下次再去了。 重游的感觉难以言表，不再多说了。 ","date":"2019-10-18","objectID":"/2019/commander-zhangs-mansion/:0:0","tags":["旅行记录"],"title":"张氏帅府及沈阳金融博物馆","uri":"/2019/commander-zhangs-mansion/"},{"categories":["平日里的白日梦"],"content":"15年思修课的作业，央视纪录片《信仰》的观后感 视频地址：http://tv.cntv.cn/videoset/C38054 看完《信仰》视频后，我久久不能平静，无数人的浴血奋斗，百年的风霜雨雪，在中国人民寻求民族独立和现代化的道路上，信仰展现了它无与伦比的魅力。 “磊落奇才唱大同，龙津水浅借潜龙。愿消天下苍生苦，尽入尧云舜日中。我无法想象26岁的澎湃如何写出这样的句子，每个动乱的年代都有奇才涌现，或许澎湃就是那个年代的弄潮儿。一个大地主，却宣称“我即贫民”，他的心已不再彭家那高高的院墙里，他在为积弱的中国考虑，从叛逆制度开始，财富名利在澎湃眼里已成为一个笑话。而面对各式各样的主义，寻找一个正确的作为信仰并藉此以拯救中国是何等不易，徘徊彷徨的中国人民最终遇到了共产主义，在这个信仰缺失的年代，也许我们无法体会那种找到信仰的激动，但不论怎样那都是我们为之努力的目标。而烧毁了那些契约，在有了信仰的澎湃眼中，不过是再正常不过的一件事情了。 “天下从此不能有皇帝”，澎湃看的是如此的清楚只有推翻千年的封建王朝，中国才有希望，他那坚定的眼神，激昂的演讲深深感染了我，他的生命已在最美的年华里绽放出了最耀眼的光芒，回过头来想想现在的我们，跨越了百年时空的同龄人们到底领先了我们多少啊，想起网上流传的一段话：一想到未来就在你们这群上课睡觉扣手机，考试前才拼命天天担心挂科的人手里面，我的心就一阵抽搐。原话可能不少，但都记不得了，总之就是说以我们现在的状态，未来真的堪忧。彭伊娜的话给了我启发，一群关注国家与民族未来的年轻人，在寻找与践行信仰的道路上，是甘愿放弃自己所有的其他一切的。永不背叛自己的信仰，能找到信仰是多么难的事，坚守信仰便是一生的准则。背叛信仰不就是背叛自己的心吗，我一直无法理解，在背叛自己的心之后人们是如何继续活下去的。方志敏说那样的人“是猪，是狗，是畜生，是猪狗畜生不如的东西”，多么畅快淋漓的一句话，是啊，好不容易找到了信仰，再背叛，那脊梁，还能挺直吗？ 飞夺泸定桥，这是很小的时候就学的一篇课文，24小时240公里的奔袭，途中还面对国民党部队的围追堵截，到达之后又焕发强大的战斗力飞夺泸定桥，怎么看怎么像一个奇迹，然而这确确实实被红军办到了，重走长征路，走的不仅仅是240公里的路途，更是当年红军坚定不移的信念，两个不同的历史空间，两种不同的生命力量，我们究竟差在了哪里。 陈树湘说：“誓为苏维埃流尽最后一滴血”，老人诉说那个惨烈的故事时，我真的震惊了，断肠，这是怎样一种悲壮而崇高的选择，那又是怎样一种痛苦，他真的，为苏维埃流尽了最后一滴血。“此去泉台招旧部，旌旗十万斩阎罗”，陈毅的信仰真是令人难以想象的自觉与豪迈，也许，这正是为什么红军和共产党最后能够胜利的原因。 两个月，一千多公里的路程，青年们追求信仰的决心任谁都无法阻挡，真的很羡慕啊，拥有信仰是一件多么幸福的事情。《为人民服务》这篇文章也是学过的，张思德一个普通的共产党人，还是一个青年，在为信仰付出的路上，露出的那动情的笑容也许说明了什么。没有实践的信仰是空想，文水县，15岁的刘胡兰牺牲的地方，我甚至连续两年去那里游玩，这个年龄甚至比我们还小的女孩，面对生死却拥有比我们更为坚定的决心，这一切只在于她有一个坚定的信仰，放弃生命所坚守的，是她觉得真正值得的付出的，共产党给人民带来了好处，便值得人民去坚守。 小萝卜头，白公馆，渣滓洞，这些从小耳熟能详的名词，代表的是一段黑暗的历史，而那面染血的红旗，代表的是狱中的共产党人对新中国这个当时大家为之奋斗的理想的美好期望，他们离见证理想实现只有一步之遥，这一步，却是天堑之别，他们值得我们铭记。镰刀铁锤，苏维埃，民族解放，新中国，五星红旗，这些在实践中化为一个个具体目标的信仰，无数人为之付出，信仰让人们凝聚。为信仰而奋斗，就是为未来而奋斗。 回国是不需要理由的，不回国才需要理由，一封致全美中国留学生的公开信，正是那些漂泊海外求学的的学子们信仰的体现，26岁的朱光亚毅然回国给了我们很大的震撼，尤其是现在无数出国留学的学子们走出去就不回来，朱光亚无疑树立了一面旗帜，中华民族仍然走在屹立世界民族之林的路上，中国现在面临的机遇与挑战丝毫不逊于当初，祖国需要这些精英们。还记得当初看到鸟巢的震撼，联想当年中国的钢产量，像孟泰一样钢铁工人们的不懈努力才造就了一个产钢的奇迹，这种钢铁精神也是新中国成立后信仰信仰新的体现，同时，和孟泰一起的劳动模范们所绽放的新的激情和信仰，正是用劳动创造一个美好的未来。 抗美援朝，还处于襁褓中的新中国用信仰赢得了与世界头号强国美国这场力量悬殊的较量，11万的烈士，他们的生命是为自己的祖国付出的，是为保卫家乡的人民付出的，不管身前什么身份，都是为了同一个信仰，那就是自强不屈地建设和保卫新中国。信仰是一团火，一滴水，张秉贵，这个普通的劳动人民，一手绝活，带给了人民温馨甜蜜和快乐，他让我想起了冯骥才笔下天津那些一手绝活的人们，快乐，幸福，这是底层民众唯一的追求，心中一团火，劳动才能创造价值，放射出灿烂的光华，劳动，是信仰最朴实的实现形式。 雷锋，这个名字真的很小就如雷贯耳，小学品德课关于雷锋事迹的描述，影响了我们这么多年，出差一千里，好事做了一火车，雷锋是我们乐于助人品德额启蒙者，正是他让我们懂得了奉献，用信仰去净化，用奉献去呵护，用执着去努力，我们要努力成长为雷锋式的一滴水。那些艰苦创业的信仰，拿下大庆的铁人，林县的红旗渠，这些信仰，是建设社会主义的坚定信仰，是改善自己生活的坚定信仰。 信仰是一种力量，一种使生命焕发光彩，促使自己不断进步的力量，千千万万这样的力量组合起来，便是祖国进步的源头。 ","date":"2019-10-17","objectID":"/2019/%E4%BF%A1%E4%BB%B0/:0:0","tags":["杂谈"],"title":"信仰","uri":"/2019/%E4%BF%A1%E4%BB%B0/"},{"categories":["平日里的白日梦"],"content":"这篇读书笔记同样属于思修课的作业，写于2015年1月。 拿起《汉谟拉比法典》，静静品读三千七百年前的光明与黑暗，这部刻印在黑色玄武岩柱上的最古老最完整的法典，映射了人类所潜藏的最原始的欲望。 在古巴比伦国王汉莫拉比统治时期，两河流域的君主制经过长期的斗争得以确立，为巩固奴隶主政权颁布的《法典》，涉及刑事、民事、贸易、婚姻、继承、审判等方面，人性的明亮与晦暗表现的及其透彻。 法律的严密性值得称著，“失物买卖案”提到失主、买主与卖主之间的利益纷争，考虑到了多方面可能出现的情况并对症下药，较为有效德避免了钻法律空子现象的出现。法典还体现了强烈的证据意识，一方面，在处理案件时，如出现控告或出庭作证等问题时，需要经过严格证实，否则将被判诬告或伪证反告；另一方面，当出现经济纠纷时，如一方既无人证又无文约，那么他将白白丧失许多东西，甚至生命。通过法律的约束或者说间接统治，增强了人们的证据意识，促进了社会和谐，巩固了奴隶统治。 法典同样显现了伦理的光辉。首先，法典点出了百善之首——孝的重要性，当然，“如果儿子打了他的父亲，应割掉他的手”。种种刑罚，是对忤逆者的无言的控诉。在世界的每一个角落，穿越时间的长河，百善孝为先始终是人类的坚守。 法典中的内容同样较多的解释了“责任”这个词的含义。从“放水灌溉致冲坏邻田”，到“职业人员从业问题”，再到立法明确的租赁关系，无不宣讲“何人应向何人负责任的”的道理。而明确责任后的双方，争斗发生的可能性将大大减小，，有利于营造良好的气氛。 私有财产神圣不可侵犯是现在的共识，而今，在看到《汉谟拉比法典》中有关私有财产的条文后，不禁感叹古巴比伦人民的智慧和眼光。“如果一个人破宅而入，那么应该在那豁口处将他处死，再把他吊起来。”这样严酷的法律用来保护私有财产，文明与野蛮交织，反应的是人类的进步。 法典固然亮点多多，但毕竟是三千年前的法律，在特定的历史背景下，他无疑也保存了一些古老的传统，这些恰恰是令人诟病的地方。其中，最令人惊讶的是它的复仇原则——“以牙还牙，以眼还眼”。地位同等的两人，如一方给另一方制造了伤害，则他本身亦应接受同等伤害，毫无借口可言。更甚的是，当两者地位不同时，奴隶主施加在奴隶身上的伤害时，那么用钱可以解决一切问题，这虽然时奴隶社会必然出现的现象，然而在现代同样能看到类似的影子。 现代人追求科学，然而在古代，神灵似乎就是当时的“科学”。在处理“控告别人犯巫术罪”和“不贞嫌疑”时，其采取神罚手段，要求把嫌疑人浸到河里，让河神证明其清白。再者，提到“抢劫无患投资”或“租牛被神击而死”问题时，当事人只要对神发誓就没有责任了。从个人角度讲，法典将判决案件交由神来解决或对神起誓就了事，似乎太过儿戏。这也反应了古巴比伦王国法律还存在严重的缺失，不过我想，对于信奉神灵的古巴比伦人，对神发誓也许代表的意味并不那么简单，更像是一种心灵上的约束。 而法典中同样有许多歧视妇女的条文，虽然早知道那时候不论东西方妇女地位都不高，但这样不平等的刑罚还是让人出乎意料。“如果歹徒在卖酒妇的店里聚集，而她没有抓住那些歹徒…….将被处死”。毫无原则，一点不考虑事实，一个妇女怎么能制服凶悍的歹徒，更何况还是聚集的，由此可见法典的苛刻与不公。关于一夫多妻，法典也同样以明文认同了这种行为并作出规定。 但需要正视的是，法典对妇女权益也有一些保护，即有些并不那么严苛，如一个人被俘，其妻子可根据家中是否有粮食来规定自身的行为。还有的条目中规定，若一个人的妻子得了皮肤病，他可以再娶但须供养患病的妻子，若是她要离去，则他得同意并全数偿还嫁妆。相比于中国古代确实已经好多了。 作为一部有着特殊意义产生于特殊时代的法典，它不可避免产生一些局限性，但它的价值也不容忽视，后世那么多法律，或多或少都看到了它的影子，这在于它的地位——世界上现存的古代第一部比较完整的成文法典。 从《汉谟拉比法典》真的能学到好多，无论过去，现在，还是未来。 ","date":"2019-10-17","objectID":"/2019/%E6%B1%89%E8%B0%9F%E6%8B%89%E6%AF%94%E6%B3%95%E5%85%B8/:0:0","tags":["读书笔记"],"title":"汉谟拉比法典","uri":"/2019/%E6%B1%89%E8%B0%9F%E6%8B%89%E6%AF%94%E6%B3%95%E5%85%B8/"},{"categories":["平日里的白日梦"],"content":"这篇读书笔记其实写于2015年1月，属于思修课的作业，今天整理文档的时候看到了，记录在此。 《罪与罚》这部小说以主人公拉斯柯尔尼科夫犯罪及犯罪后受到良心和道德惩罚为主线，描绘了那些走投无路的俄国城市贫民，暗无天日的彼得堡，眼睛被打得发青的妓女，污浊的河水中挣扎着的投河自尽的女工，穷困潦倒的小公务员被马车撞倒在街头，发疯的女人带着孩子沿街乞讨……与此同时，高利贷老太婆瞪着凶狠的眼睛，要榨干穷人的最后一滴血汗，满身铜臭的市侩不惜用诱骗、诬陷的手段残害“小人物”，以达到利己的目的，而荒淫无度的贵族地主为满足自己的兽欲，不断干出令人发指的勾当……在感受到作者同情和激愤的同时，彼得堡的黑暗、赤贫、绝望和污浊一起无情地展现出来。 拉斯柯尔尼科夫具有双重人格：他是一个心地善良、乐于助人的穷大学生，一个有天赋、有正义感的青年，但同时他的性格阴郁、孤僻，“有时甚至冷漠无情、麻木不仁到了毫无人性的地步”，为了证明自己是个“不平凡的人”，竟然去行凶杀人，“在他身上似乎有两种截然不同的性格在交替变化”。正是这双重人格之间的激烈冲突，使他不断地动摇在对自己关于“平凡的人”与“不平凡的人”的观点的肯定与否定之间。对于拉斯柯尔尼科夫来说，如果甘愿做逆来顺受的“平凡的人”，那么等待他的是马尔美拉陀夫的悲惨结局，如果去做一个不顾一切道德准则的“人类主宰者”，那就会与为非作歹的卑鄙之徒卢仁和斯维德里加伊洛夫同流合污。他的人格中的主导面最终在白热化的搏斗中占了优势，并推动他最后否定自己的“理论”，向索尼娅靠拢。 这是一个简单的故事，并没有轩然大波的追逐场面或者华丽的镜头，更多的则是人物的语言和内心表达。很显然，托斯陀耶夫斯基想讨论的是精神层面的犯罪与救赎。 杀人，是一个很简单的词汇，非常的普通，不仅在语言上，甚至是在真实世界中，这并非悚然听闻。的确，对于当今这个和平而发展的年代，出现死伤是人们最不愿意看到的，也是不得不面对的。但问题并不在于死了人，因为如果因为天灾而死或者自然死亡，人们怀有的是悲痛与惋惜之情。因为人们不知道自己并非真的很强大，至少在肉体上，我们是渺小的。但如果是因为一场谋杀或者是恐怖袭击而产生了伤亡，那么人们在拥有悲痛与惋惜以外，更多的还有恐惧。因为这竟然是同一个种族，同一种生物内的互相残杀，倘若是在大自然，这种现象的原因归结起来也不过只有几条：食物缺失，争求配偶等，可是对于人类，这必需上升到道德层面：人杀人，究竟为了什么？ 这或许也是主人公拉斯科尔尼科夫想知道答案的问题。在他看来，拿破仑为了领土而展开战争，导致血流成河，他是杀人犯，但最终却当上了皇帝，即使是被流放，也是以一个战俘的身份去服苦役。后人大都对他表示敬仰，但他却是一个杀人犯，应该说是杀了许多人的杀人犯。但问题在于他为什么没被逮捕呢？拉斯科尔尼科夫很迷惑，他甚至认为那样的杀人对某些非凡的家伙来说是随心所欲，而且是不受谴责的。于是他也自认为是一个不平凡的人，用斧头砍死了一个放高利贷的老太婆。尽管这个老婆子是那么的邪恶，狡猾，危害他人，但是事实是拉斯科尔尼科夫杀了人。 于是，拉斯科尔尼科夫并未从迷惑中解脱，他没有找到答案，反而在灵魂上不停地残害自己，他在受到惩罚，一种自我惩罚，有良心的人，如果意识到自己的错误，他就会感到痛苦，这就是对他的惩罚——苦役以外的惩罚。拉斯科利尼科夫是有良心的，虽然他杀的老太婆十恶不赦，应该死，但他仍然会痛苦，这边是对他最残忍的惩罚。 某部小说说过：“人一生只能杀一次人，那就是自己，倘若杀死了别人，那么你永远无法得到安息。”我不知道这对不对，有没有根据，但至少可以说它传达了一条信息：无论为了什么而导致的人杀人都是无法原谅的。 回过头来看看眼下这个世界，每天都在不停地死人，这并不可怕，可以说这只是命运，是一种常态，要哪一天全世界没有一个人死，那就太见鬼了。 而对于人为的杀害也并非每一样都是可怕的，因为找到了其根源，我们就可以阻止它，避免一场屠杀。就像恐怖袭击，有的为了复仇，有的是为了引起骚乱，这一切都可以避免，而最最可怕的杀人则是那种找不到任何根源或者是由于精神层面的紊乱而导致的犯罪，比如以杀人为乐的家伙，亦或者像拉斯科尔尼科夫这样的人。 2013年4月,上海复旦大学医学院研究生黄洋遭他人投毒后死亡,犯罪嫌疑人为被害人室友林森浩，林森浩在生活中是个很优秀的人，以至于事发后周围的人都不愿相信这一事实。还有美国时常发生的校园枪击案，有些甚至没有任何动机，丹麦的一起恶性爆炸枪击事件，“独狼”布雷维克竟对自己犯下的罪行没有丝毫的忏悔，他甚至说像他这样的“独狼”还有很多。 于是，恐怖袭击已算不上什么，而个人无预兆犯罪却成为了对人类社会有着巨大的威胁的定时炸弹。你能想象有一天你的朋友突然用枪指着你什么都不说一句然后扣下了扳机？很难，但却十分有可能。这一种犯罪类型由多方面因素组成， 但不管有多少因素，当人的道德底线被击溃时，便什么事都干得出。 “一生只能杀一个人，那就是自己。”这不是鼓励自杀，而是警示那些潜在的威胁。 ","date":"2019-10-17","objectID":"/2019/%E7%BD%AA%E4%B8%8E%E7%BD%9A/:0:0","tags":["读书笔记"],"title":"罪与罚","uri":"/2019/%E7%BD%AA%E4%B8%8E%E7%BD%9A/"},{"categories":["研究生的区块链学习之路"],"content":"Morishima S, Matsutani H. Acceleration of anomaly detection in blockchain using in-GPU Cache[C]. international conference on big data and cloud computing, 2019: 244-251. ","date":"2019-10-16","objectID":"/2019/acceleration-of-anomaly-detection-in-blockchain-using-in-gpu-cache/:0:0","tags":["论文笔记"],"title":"Acceleration of Anomaly Detection in Blockchain Using In-GPU Cache","uri":"/2019/acceleration-of-anomaly-detection-in-blockchain-using-in-gpu-cache/"},{"categories":["研究生的区块链学习之路"],"content":"引言 区块链的不可篡改特性带来安全性的同时，由操作失误或密钥被盗造成的欺诈交易同样无法取消，因此产生的非法交易可能造成危害。可能的对策是即时的发现非法交易，从而在确认前纠正。 Pham等人提出一种基于K-means聚类，马氏距离和局部离群因子的区块链异常检测方法，利用该方法对比特币网络历史交易中的异常交易做了检测，但可通过特定特征量和算法检测到的异常交易是有限的，实际实施需要通过改变特征量和算法来重复异常检测，计算量大，计算时间长，该文使用了GPU加速异常检测，减少检测时间。 T. Pham, S. Lee, “Anomaly Detection in Bitcoin Network Using Unsupervised Learning Methods”, Compution Research Repository, vol. abs/1611.03941, pp. 1-5, Nov. 2016. 我们不关注如何使用GPU加速异常检测，关心的是使用了什么方法进行异常检测，因此该文大部分都会略过 ","date":"2019-10-16","objectID":"/2019/acceleration-of-anomaly-detection-in-blockchain-using-in-gpu-cache/:1:0","tags":["论文笔记"],"title":"Acceleration of Anomaly Detection in Blockchain Using In-GPU Cache","uri":"/2019/acceleration-of-anomaly-detection-in-blockchain-using-in-gpu-cache/"},{"categories":["研究生的区块链学习之路"],"content":"特征量提取 Pham等人提出的方法使用图来代表以用户为中心的交易流，如下图所示，用户是顶点，交易是边，当B向A发起交易时，会创建一条B到A的边，随着交易增加，边也随之变多，图结构变复杂。 该图用于提取每个区块链用户的特征量，例如，顶点入边的数目是收入交易的数目，出边的数目是支出交易的数目，Pham使用收入交易数目、支出交易数目、平均收入金额、平均支出金额等六个特征量进行异常检测，此外还使用了K-means聚类、马氏距离和局部离群因子三种异常检测算法。采用基于用户图的方法，对比特币网络中两期盗窃案件做了分析。但，即使检测到了异常交易，也很难判断是否真的是欺诈交易，因为大部分盗窃的具体信息并不公布。 ","date":"2019-10-16","objectID":"/2019/acceleration-of-anomaly-detection-in-blockchain-using-in-gpu-cache/:2:0","tags":["论文笔记"],"title":"Acceleration of Anomaly Detection in Blockchain Using In-GPU Cache","uri":"/2019/acceleration-of-anomaly-detection-in-blockchain-using-in-gpu-cache/"},{"categories":["研究生的区块链学习之路"],"content":"K-means异常检测 该文使用了相同的方法提取特征量，但异常检测方法使用了K-means聚类。K-means本身是用来将大量数据分类成簇的，当使用K-means进行异常检测时，如果用户特征量距离聚类中心较远，则被视为异常，当簇的数量为K时，使用K-means聚类进行异常检测的步骤如下： 初始聚类被随机地分配给每个顶点的特征量向量 计算聚类中心 计算每个顶点特征量与聚类中心的距离，然后划归最近的聚类中心的簇 重复2，3步直到收敛，完成聚类 计算顶点特征量与聚类中心的距离，超过阈值则为异常 ","date":"2019-10-16","objectID":"/2019/acceleration-of-anomaly-detection-in-blockchain-using-in-gpu-cache/:3:0","tags":["论文笔记"],"title":"Acceleration of Anomaly Detection in Blockchain Using In-GPU Cache","uri":"/2019/acceleration-of-anomaly-detection-in-blockchain-using-in-gpu-cache/"},{"categories":["研究生的区块链学习之路"],"content":"EdgeChain设计 EdgeChain的核心思想是集成一个许可区块链和内部货币系统，将边缘云资源池与每个物联网设备的账户和资源使用行为关联起来。基于信用的资源管理系统主要根据设备优先级、应用类型和历史行为调整设备信用，控制设备可以从边缘服务器获取多少资源，同时面向资源使用智能合约强制执行预定义规则和策略，规范物联网设备的行为。整个思路的问题空间和解决方案空间概览如下 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:1:0","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"1. 设备 EdgeChain使用许可区块链（私链）换取更高的交易吞吐量和一个受控制和监管的环境，挖矿工作由边缘服务器完成，并将IoT设备分为两类： legacy devices(EdgeChain-unaware)：不需要获取资源，不需要安装区块链客户端，由IoT代理创建区块链账户代表这些设备和区块链交互 non-legacy devices(EdgeChain-aware)：安装区块链客户端，和边缘服务器交互获取资源 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:1:1","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"2. 基于信用的资源管理 EdgeChain使用内部货币把边缘云资源池与IoT设备账户和资源使用行为相关联。每个设备有一个区块链账户，给予一定的初始货币作为信用积分，积分余额决定了设备获取资源的能力。边缘服务器会记录信用积分使用情况，根据一组预定义的规则分配资源，这组规则综合考虑了预定义的优先级、应用类型和历史行为。 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:1:2","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"3. 面向资源，基于智能合约规范化物联网行为 EdgeChain根据IoT设备的资源使用与活动来监控和调节其行为，根据预定义的优先级、应用类型和历史行为，智能合约可以自动执行相关资源分配策略。有助于抵御内部攻击，快速识别、控制恶意节点，并且可以采用进一步的行为如黑名单阻止设备的进一步操作。 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:1:3","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"4. 部署 EdgeChain可以两种模式部署，独立模式如smart home，以及分布式模式如smart campus和smart city。以下是smart home的一个例子，这样独立部署的一个模块可以称作一个box，多个独立部署的box合作就可以构成一个分布式部署的场景。 基于边缘服务器和货币系统的资源管理方案暂且不考虑，目前有借鉴作用的是对物联网行为规范化的处理，基于智能合约预定义策略，同时考虑利用货币系统定义的信用积分，用来做恶意行为检测，提升区块链安全性。 设备分类在架构设计时是应考虑的，考虑作为安装客户端的轻节点还是由网关代理与区块链交互，但在具体的场景中，比如对摄像头或传感器进行管理，是固定的，一般不需要分类。看最后定什么样的场景再决定吧。 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:1:4","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"框架和基本模块 总体架构如下图所示，分为IoT代理、智能合约接口、智能合约、区块链服务器和应用接口五个功能模块 IoT代理：主要功能是监听和嗅探legacy device的活动，为设备创建区块链账户，协助它们与区块链和智能合约交互。注册方式与non-legacy device相同，因此行为规范化的策略也适用它们，除了不能自己直接和区块链交互，和non-legacy device没什么不同。 智能合约接口：当物联网活动发生时会触发智能合约并执行相关的管理策略，主要由web3协议完成。物联网活动包括注册、设备通信、资源请求、数据发送等。 智能合约：包括两部分，一是数字货币系统，用来定义设备信任基本并决定资源分配；二是策略管理模块，分析设备行为并进行判决，以及根据货币系统的信用定义分配调度资源。 区块链服务器：运行共识维持区块链以及运行智能合约完成预定义策略 应用接口：连接区块链服务器和边缘云服务器，设备与区块链的交互有两种结果，1）账户余额有限或存在恶意行为，请求被拒绝；2）请求通过，移交边缘服务器分配相应资源。一旦确认有足够的资源，边缘服务器即和资源分配的合约交互，进行资源分配，分配完成后，物联网设备直接和边缘服务器上的应用交互。 这里提到的资源包括计算能力、内存、存储、网络等，由于不同程序的要求不同，这些资源以虚拟机为单位提供。 特别的结构是IoT代理和应用接口，当设备类型确定时，代理的工作由网络直接完成，可以取消这一部分，应用接口主要与资源分配有关，也可以略过。最重要的其实还是定义设备信用的货币系统和策略管理两部分合约的算法，对我们是有用的。 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:2:0","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"关键过程和工作流 区块链部署和合约部署流程略过，这里只介绍设备注册过程和设备行为管理。 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:3:0","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"1. 设备注册 注册起始于判断设备类型，对legacy设备，IoT代理会为每个设备创建账户并在注册合约中注册，non-legacy设备可以通过安装的客户端直接与区块链交互。 注册信息的内容主要根据制造商使用说明定义，主要包括输入/输出数据类型、边缘资源请求、mac地址、ip地址、网络端口、通信协议和指示标志。此外，每个设备都有一个唯一的区块链账户地址。注册后，边缘服务器验证上述信息，并添加更多的参数如优先级，账户余额，信用和请求时间戳等用于设备管理。具体定义在数据库的字段如下图所示 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:3:1","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"2. 设备行为管理 这一部分是EdgeChain的核心功能，分为三部分解释：细节工作流，边缘资源分配算法和行为管理方案 1) 细节工作流 当接收到来自物联网设备的活动或请求时，根据设备类型进行不同的处理，具体细节如下 2) 基于定价方案的资源分配 资源分配的优化目标是最大化用户请求的接受率，分配的算法不作详细了解因为不会用到。 3) 行为管理 旨在检测潜在的恶意活动或请求，并采取措施避免进一步的损失。使用一个信用体系进行行为管理，该信用系统与同类方案的不同是信用影响边缘服务器资源分配而不是设备间的协作，但信用与资源定价策略没有直接关系，这种影响是通过奖励或惩罚措施完成的。考虑的行为主要包括： Resource Requests：设备请求的资源量说明设备是否正常工作，过度的资源需求可能表示异常行为和恶意活动 Price Threshold：假设每个设备只运行一种应用并发送一种资源请求，为此设备设定特定的价格阈值，当请求的价格超过该阈值，请求可以被视为恶意行为，并降低设备信用 Request Frequency：设备以过高频率发送请求，可能是恶意行为 Network Port：设备应以预定义的端口号通信 Data Traffic Destination：设备的通信目标一般是固定的，当目标改变时可能是被恶意控制了 系统会比较设备请求和正常的行为，发现异常则降低信用，每个新注册的设备拥有相同的初始信用，信用降到0的时候设备将无法再进行任何活动，基于信用的变动，返回的代币计算公式如下，其中η是改变的影响因子： $$ \\begin{equation*} Coins_{return}=Coins_{charged}+\\Delta Credit*\\eta \\end{equation*} $$ 恶意行为的定义比较重要，但这里五种行为并不都符合我们的需求，需要以此为思路继续考虑 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:3:2","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"实验与评估 设计了一个实验证明了关键的功能在可接受的性能开销下是可行的。 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:4:0","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"1. 实验环境 实验包括后端边缘云集群，前端物联网设备、代理和接入点。边缘云集群通过OpenStack部署管理，包括五台高性能服务器，一台交换机。前端由一台树莓派3B（附带摄像头，sense hat，麦克风和Google bonnet），一套Google AIY voice kit，一套Google AIY vision kit，和一台laptop组成。一台桌面计算机作为IoT Proxy，一台路由器。如下图所示 边缘服务器使用CentOS7，使用以太坊区块链，Solidity为合约编程语言，Truffle为合约部署攻击，node.js为物联网和区块链的交互界面。树莓派使用Raspbian系统，并安装了Go-ethereum客户端。laptop系统是MacOS，desktop系统为Ubuntu16。 实验中边缘服务器提供云资源，同时作为区块链全节点，树莓派和laptop作为区块链客户端将资源请求发送给边缘服务器，作为亲节点。desktop作为设备代理和区块链交互。 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:4:1","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"2. 区块链和合约操作开销 指区块链挖矿和智能合约的交互两类开销，主要针对设备注册和资源分配两个功能来分析，开销主要来自于三个方面：计算、通信和存储 设备挖矿的开销不关注了，考虑区块同步的延迟，边缘服务器同步新块的平均时间为4.09ms，物联网设备为35.9ms。区块平均大小为128.78KB，每个块最多存储208个设备注册信息，统计得1000台设备注册平均生成1.8MB区块链数据。 同步延迟受网络影响较大，网络出问题几百ms都可能，很难估计。 对于合约交互，常规交易对CPU得占用比较低，但对内存占用较高，即使空闲时间，区块链客户端也占8%。合约得交互延迟一般小于50ms，满足实时应用得需求。 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:4:2","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"3. 两种典型物联网应用得开销比较 作者考虑得主要是边缘计算场景，因此找到例子是人脸识别和自然语言处理。树莓派连接的摄像头和麦克风正是用于这两种场景实验。 定价方案的资源管理性能不关注 ","date":"2019-10-15","objectID":"/2019/edgechain-an-edge-iot-framework-and-prototype/:4:3","tags":["论文笔记"],"title":"EdgeChain An Edge-IoT Framework and Prototype","uri":"/2019/edgechain-an-edge-iot-framework-and-prototype/"},{"categories":["研究生的区块链学习之路"],"content":"本文是在前面搭建好的区块链实验平台基础上，对 Smart contract-based access control for the internet of things1 这篇论文提出的访问控制方案进行复现，记录整个复现和测试的过程。 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:0:0","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"1. 智能合约 论文中提出的访问控制系统主要包括三种合约：Register Contract（RC，注册合约），Access Control Contract（ACC，访问控制合约）和 Judge Contract（JC，判决合约）。复现的代码已放在了我的 github 仓库，仓库名为 BBRAC:truffle-zhang，其中 truffle-zhang 是其所在分支。下面介绍三种合约的作用及其中定义的功能。 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:1:0","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 注册合约 RC 的作用主要是注册 ACC 和 JC，在需要的时候返回它们的相关信息，使用了一个 lookupTable 来存储每个已注册合约的基本信息，这些基本信息包括： 字段名 解释 scName 注册的合约名 subject subject-object 对中的 subject 地址 object subject-object 对中的 object 地址 creator 合约创建者地址 scAddress 合约地址 使用了一个映射结构来构造该信息表，mapping(bytes32=\u003eMethod) public lookupTable，以上基本信息均作为结构体 Method 的一部分，作为表的值。表的键是 bytes32 类型，是方法(method)名，这里方法的含义很模糊，作用应该是描述已注册合约的作用。RC 合约定义了如下功能： methodRegister：ACC和JC注册 methodScnameUpdate：已注册的合约名字段更新 methodAcAddressUpdate：已注册的合约地址字段更新 methodNameUpdate：方法名更新 methodDelete：方法删除 getContractAddr：获取方法名对应的合约地址 存在的问题 作为表键的方法名除了带来大量的 gas 消耗没有任何益处，反而由于处理的难题，使用内联汇编带来了大量 gas 消耗。可以用注册合约的合约地址作为键，而在 Method 结构体中新增合约描述字段 结构体中合约名也没有意义，可与合约描述字段合并，或者更改为合约类型字段，用于区分 ACC 和 JC 存储注册合约的 abi 没有意义，反而带来处理上的难题和大量 gas 消耗，实际上，实验中存在的 abi 只有三种，RC，ACC 和 JC，预先记录即可，如果考虑到ACC 或 JC 合约内容变动，可设置指向函数，在改变合约时将请求指向新合约。 如果解决这些问题，属于实现上的优化，目的在于减少 Gas 消耗和提高可操作性。 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:1:1","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 访问控制合约 ACC 的作用是对 subject 和 object 对的每个访问控制方法做描述。拥有两个表，Misbehavior表 记录行为用作判决，PolicyItem表 记录访问控制策略用于访问控制。并使用了一个事件返回访问控制相关结果。合约相关函数如下： setJC：设置 JC 合约地址，用于调用 JC 合约 policyAdd：策略添加 getPolicy：策略查询 policyUpdate：策略权限字段更新 minIntervalUpdate：策略时间间隔字段更新 thresholdUpdate：策略阈值字段更新 policyDelete：策略删除 accessControl：实施访问控制 getTimeofUnblock：获取惩罚时间 deleteACC：合约自我销毁 ACC由 object 部署，可以控制 subject 发起的访问请求。我们假设 subject 和 object 就多条访问控制方法达成了一致，因此，一个 subject-object 对应多个ACC，但一个 ACC 只对应一个 subject-object。 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:1:2","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"1.3 判决合约 JC 的表结构记录了恶意行为，并拥有恶意行为判决函数，同时有一个事件返回判决基本信息，其函数如下： misbeaviorJudge：进行恶意行为判决 getLatestMisbehavior：获取最新判决的一个恶意行为 deleteJC：合约自我销毁 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:1:3","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"2. 合约功能测试 这一部分对合约功能进行测试，由于使用 Remix 编辑器编写代码，为了操作方便，测试的过程也在 Remix 中完成。我们选择的测试方法是按照下面的步骤自己部署合约及调用相关的函数，要注意的是，Remix 提供了编写相关单元测试所需的库，可以利用这些库额外编写几个自动化的测试合约，但是，这些测试合约只能测试单个的函数，而我们需要测试的功能往往需要按顺序调用多个函数，因此不可行。 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:2:0","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 注册 注册新的访问控制方法/恶意行为判决方法 step1：为新方法创建新的 ACC step2：部署新创建的 ACC 到区块链 step3：调用 RC 合约的 methodRegister 方法注册 ACC ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:2:1","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 更新 更新已有的访问控制方法（不觉得有存在的必要） step1：创建新的 ACC，用于替换旧的 step2：部署新创建的 ACC step3：调用 RC 合约的 methodUpdate 方法更新相关字段，如 ScName, ScAddress, ABI 等 step4：调用旧 ACC 的 deleteACC 方法自我销毁 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:2:2","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 删除 删除已有的访问控制方法 step1：调用 RC 合约的 methodDelete 方法从注册表删除方法的相关信息 step2：调用 ACC 合约的 deleteACC 方法自我销毁 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:2:3","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 策略管理 添加，更新和删除策略，主要调用 ACC 合约的 policyAdd, policyUpdate 和 policyDelete 方法完成 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:2:4","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"2.4 访问控制 假设 subject 和 object 知道它们间所有可用的访问控制方法，当前有一个 subject 想访问 object 的资源，需要执行下列步骤 step1：subject 调用 RC 合约的 getContract 方法检索用于访问控制的 ACC step2：RC 合约返回所查询 ACC 的 address 和 ABI 给发起查询的 subject step3：subject 调用 ACC 合约的 accessControl 方法发起访问控制，该交易将被收集到区块中，区块被确认后，accessControl 方法得以执行 step4：访问控制执行期间，ACC 调用 JC 合约的 misbehaviorJudge 方法查看该 subject 是否存在恶意行为 step5：misbehaviorJudge 完成恶意行为检测与判决，将判决结果返回给 ACC step6：访问控制结束后，结果同时返回给 subject 和 object ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:2:5","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"3. 实施访问控制 功能测试完成后，我们模拟 subject 向 object 发起访问控制请求的场景，验证所设计的系统的可行性。实际实施以 pi3B+ 作为 subject，以 pi3B 作为 object，实验流程如下 在台式电脑中安装web3.js，之后通过websocket远程操作树莓派 # 安装npm和node $ sudo apt-get install npm # 更新npm到最新 $ sudo npm install npm@latest -g # 安装node管理工具 $ sudo npm install n -g # 更新node.js到最新 $ sudo n lts # 授权普通用户否则npm无法对模块进行本地安装 $ sudo chown -R $(whoami) ~/.npm $ sudo chown -R $(whoami) ~/.config # 安装web3.js $ npm install web3@1.0.0-beta.18 # 查看已安装本地模块列表 $ npm list --depth 0 /home/shuzang/istanbul └── web3@1.0.0-beta.18 不建议直接使用npm install web3，默认会安装web3@1.2.1版本，函数调用出现了Transaction has been reverted by the EVM的问题，论坛提到这是版本问题，切换了不少版本，但直到1.0.0-beta.18才执行成功。已安装高级版本情况下可以使用如下命令覆盖 $ npm install web3@1.0.0-beta.18 --save 在 node0 根目录启动 geth $ ps | grep geth $ killall -INT geth $ ./startall.sh $ geth attach data/geth.ipc 解锁账户（之后执行操作脚本都有实现解锁账户，默认账户解锁维持5分钟） \u003e personal.unlockAccount(eth.accounts[0]) 使用 Remix 编译注册合约(RC)，并在Compilation Details中获取WEB3DEPLOY，复制并粘贴在 geth 控制台运行，记录返回的交易哈希和合约地址。 以同样的方法部署判决合约(JC)，记录返回的交易哈希和合约地址。合约初始化需要的两个参数设置为 base = 2 interval = 3 调用 RC 合约的 methodRegister 函数，注册判决合约 在 object 部署 ACC 合约，合约初始化参数为 subject 节点的账户地址，记录返回的交易哈希和账户地址。 调用 ACC 合约的 SetJC 函数，传入的参数为 JC 合约地址，用于进行合约调用 调用 ACC 合约的 policyAdd 函数预定义一批访问控制策略，传入的参数中令时间间隔minInterval=100，阈值threshold=2 Resource Action Permission ToLR file A read allow 例如：2019-10-04 10:47 file A write deny program A execute deny … … … … 调用 ACC 合约的 getPolicy 函数验证定义的策略 调用 RC 合约的 methodRegister 函数，注册访问控制合约 编写 object 下的 monitor.js，用于监听访问控制请求 var Web3 = require('web3'); var web3 = new Web3(Web3.givenProvider || \"ws://192.168.191.4:8545\"); var rcAbi = [] var accAbi = \" \" var rcAddr = \"0xa49fe05a90c49c44b7d533c64b8cc33e5e6d582e\"; var methodName = \"Access Control\"; var register = new web3.eth.Contract(rcAbi, rcAddr); register.methods.getContractAddr(methodName).call({ from: \"0x44d13e0c0d91a2ebe570c58cdadef2b99bf55bc1\", gas: 10000000 },function(error,result){ if(!error) { listen(result); } }); function listen(accAddr) { var myACC = new web3.eth.Contract(accAbi, accAddr); myACC.events.ReturnAccessResult({ fromBlock: 0 }, function(error, result){ if(!error) { console.log(\"Contract: \"+result.address); console.log(\"Block Number: \"+result.blockNumber); console.log(\"Tx Hash: \"+result.transactionHash); console.log(\"Block Hash: \"+result.blockHash); console.log(\"Time: \"+result.returnValues._time); console.log(\"Message: \"+result.returnValues._errmsg); console.log(\"Result: \"+result.returnValues._result); if (result.returnValues._penalty \u003e 0) { console.log(\"Requests are blocked for \" + result.returnValues._penalty +\"seconds!\") } console.log('\\n'); } }) } 编写 subject 下的 requester.js，用于发起访问控制。 var Web3 = require('web3'); var readline = require('readline'); var web3 = new Web3(Web3.givenProvider || \"ws://192.168.191.3:8545\"); var rcAbi = []; var accAbi = []; var subject = \"0x9abf7020cc405fce60fdfb84168fb9457bde52e2\"; var rcAddr = \"0xa49fe05a90c49c44b7d533c64b8cc33e5e6d582e\"; var methodName = \"Access Control\"; var register = new web3.eth.Contract(rcAbi, rcAddr); register.methods.getContractAddr(methodName).call({ from: \"0x9abf7020cc405fce60fdfb84168fb9457bde52e2\", gas: 10000000 },function(error,result){ if(!error) { sendAccessControl(result); } }); function sendAccessControl(accAddr) { var myACC = new web3.eth.Contract(accAbi, accAddr); var previousTxHash = 0; var currentTxHash = 0; var rl = readline.createInterface({ input: process.stdin, output: process.stdout, prompt: 'Send access request?(y/n)' }); rl.prompt(); rl.on('line',(answer) =\u003e { if('y' == answer) { var currentTime = new Date().getTime()/1000; myACC.methods.accessControl(\"File A\", \"read\", currentTime).send({ from: \"0x9abf7020cc405fce60fdfb84168fb9457bde52e2\", gas: 10000000 },function(error,result){ if(!error){ currentTxHash = result console.log(\"currentTxHash\", result) } }) myACC.events.ReturnAccessResult({ fromBlock: 0 }, function(error, result){ if(!error) { if(previousTxHash != result.transactionHash \u0026\u0026 currentTxHash == result.transactionHash) { console.log(\"Contr","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:3:0","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"4. 附录 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:4:0","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"附录1 两个js脚本的算法 Algorithm 2 Access Request JavaScript Input: resource, action, time Output: result, penalty 1: Create a RC instance register. 2: Specify the access control method name method. 3: (addr, abi)4— register.getContract(method). 4: Create an ACC instance acc with addr, abi. 5: Send a transaction containing parameters (resource, action, time) to the accessControl ABI of acc. 6: while ture do 7: if Event returnResult() is captured then 8: (result, penalty) 4— returnResult(). 9: break. 10: end if 11: end while 12: return result, penalty Algorithm 3 Access Monitor JavaScript 1: Create a RC instance register. 2: Specify the access control method name method. 3: (addr, abi)4— register.getContract(method). 4: Create an ACC instance acc with addr, abi. 5: while ture do 6: if Event returnResult() is captured then 7: (result, penalty) 4— returnResult(). 8: Display result, penalty. 9: end if 10: end while ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:4:1","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"附录2 web3.js与节点交互的参考文档 https://blog.csdn.net/dieju8330/article/details/83090660 https://blog.csdn.net/dieju8330/article/details/83149164 ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:4:2","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"附录3 可能遇到的问题及解决方案 获取节点账户列表 \u003e eth.accounts 解锁账户 \u003e personal.unlockAccount(eth.accounts[0]) # 可以解锁时直接添加密码和持续时间(未添加持续时间默认300s，即5分钟) \u003e personal.unlockAccount(address, \"password\", 300) 查看已连接节点 \u003e admin.peers 启动geth时即解锁账户 geth --unlock \"0x...\" --password \"密码\" 启动geth时允许远程web3接入 geth --rpccorsdomain \"*\" remix通过web3 provider部署合约，网址栏https改为http，否则无法连接 更多关于账户的命令参见 Managing your accounts ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:4:3","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"附录4 合约部署的方式 复制 Remix 中合约编译生成的 web3deploy 到 geth 控制台执行 使用 Remix 的 web3 Provider 远程部署（最方便） 利用 web3.js 编写 js 脚本进行部署 使用 truffle ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:4:4","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["研究生的区块链学习之路"],"content":"附录5 执行js命令的方法 方法1：geth控制台执行以下命令，默认路径为执行geth attach的路径 loadScript('requester.js') 但总出现类似“err: TypeError: ‘send’ is not a function”的问题，无法解决，可能是web3.js的问题，网上有人建议换用ethers.js 方法2：执行geth attach时添加参数 geth --exec 'loadScript(\"request.js\")' attach data/geth.ipc 使用举例见JavaScript Console 方法3：使用node直接运行 $ node requester.js 方法3是唯一执行成功的。 Zhang Y, Kasahara S, Shen Y, et al. Smart contract-based access control for the internet of things[J]. IEEE Internet of Things Journal, 2018. ↩︎ ","date":"2019-10-15","objectID":"/2019/access-control-prototype-system-implementation/:4:5","tags":["科研记录"],"title":"研究记录7-原始论文复现","uri":"/2019/access-control-prototype-system-implementation/"},{"categories":["平日里的白日梦"],"content":"我还是很喜欢你，像风走了八千里，不问归期。 我还是很喜欢你，像日月轮回交替，不理朝夕。 我还是很喜欢你，像云漂泊九万里，不曾歇息。 我还是很喜欢你，像星辰砸向大地，至死而已。 我还是很喜欢你，像日光洒满天地，温柔惬意。 我还是很喜欢你，像风吹在心里，酥酥靡靡。 我还是很喜欢你，像雨洒落在热带与极地，不远万里。 我还是很喜欢你，像鲸沉于海底温柔呼吸，痴极嗔极。 我还是很喜欢你，像等了多年的老城门，茕茕孑立。 我还是很喜欢你，像鲸鱼缺氧于六千四百米的深海，乐此不疲。 我还是很喜欢你，像臣民等待王朝复辟，遥遥无期。 我还是很喜欢你，柳动蝉鸣，日落潮汐，不能自己。 我还是很喜欢你，像云漂泊九万里，不曾歇息。 我还是很喜欢你，像太阳升了落去，无论朝夕。 我还是很喜欢你，像星辰奔波亿万年黑夜，不诉怨语。 我还是很喜欢你，像春雨洒落八百里，淅淅沥沥。 我还是很喜欢你，像春草染绿山脊，不容置疑。 我还是很喜欢你，像泼妇骂街，不讲理。 我还是很喜欢你，像雨落连夜翠琼滴，娟娟不惜。 我还是很喜欢你，像梅雨时节的落雨，延绵无期。 我还是很喜欢你，像炊烟袅袅几许，棠梨煎雪又落雨。 我还是很喜欢你，像飞鸟眷恋海鱼，去留难定，不知所以。 我还是很喜欢你，像聒噪的秘密，千言万语。 我还是很喜欢你，像庭院那株海棠落了又开，周而复始。 我还是很喜欢你，像日月轮流交替，不理朝夕。 我还是很喜欢你，像层云凝成片语，点点滴滴。 我还是很喜欢你，像夜空中星辰闪烁，霓虹迷离。 我还是很喜欢你，像风中簌簌飘落的桂叶，辗落成泥。 我还是很喜欢你，像雨滴落在绿苔红泥，柔软散去。 我还是很喜欢你，像星光坠入眼眸里，一眼万里。 我还是很喜欢你，像钗头凤阁下最后一笔，相思成疾。 我还是很喜欢你，像春宵红帐入梦无息，犹恐念起。 我还是很喜欢你，像凹凸绊住滂沱大雨，入渠几许。 我还是很喜欢你，像云烟缱绻成蛟绡骤雨，温柔暴烈全给你。 我还是很喜欢你，像飘零太久的僧侣，百难皈依。 我还是很喜欢你，像春日绿叶夏日阳光，都不如你。 我还是很喜欢你，像断崖卷起千堆雪，岁岁如夕。 我还是很喜欢你，像满天流星坠地，烟花肆意。 我还是很喜欢你，像海浪一次次拥抱礁石，竭尽全力。 我还是很喜欢你，像鱼儿顺着洋流回到故地，不期而遇。 我还是很喜欢你，像风缠绕在耳畔的低语，心动不已。 我还是很喜欢你，像咿咿呀呀学语的孩童，词不达意。 我还是很喜欢你，像雨中子规的鸣啭，不如归去。 我还是很喜欢你，像梦里情不自禁的呓语，全都是你。 我还是很喜欢你，像盛装等候一场十年的假期，情不知所以。 我还是很喜欢你，像思念如江河东逝，马不停蹄。 我还是很喜欢你，像悬崖变平地再生出整片森林，你在树荫里。 我还是很喜欢你，像黄花堆积满地，故人万里。 我还是很喜欢你，像是如鲠在喉，甘之如饴。 我还是很喜欢你，像沧海变换桑田，斗转星移。 我还是很喜欢你，像老故事里的泛黄桥段，半聋半哑，失了声息。 我还是很喜欢你，像星辰奔波亿万年黑夜，不诉怨语。 我还是很喜欢你，像旧城里的老折子戏，温言软语。 我还是很喜欢你，像霸王别了虞姬，情非得已。 我还是很喜欢你，像孤星落月，不忍相弃。 我还是很喜欢你，像清寂梨花，逐风而去。 我还是很喜欢你，像红豆黯淡，相思成疾。 我还是很喜欢你，像春燕剪雨，不顾湿衣。 我还是很喜欢你，像沙起千丈荒漠里，无人问起。 我还是很喜欢你，像雨落湖心惊联谊，廖无声息。 我还是很喜欢你，像酒藏曲巷阡陌里，难掩心迹。 我还是很喜欢你，像乐起心间弦声里，宫商角徵羽。 我还是很喜欢你，像少林寺的青灯古佛，不愿渡己。 我还是很喜欢你，像鹿隐于深林茕茕孑立，怯极望极。 我还是很喜欢你，像饮鸩止渴般痴迷，药石无医。 我还是很喜欢你，像雨从天坠七万米，不惧成泥。 我还是很喜欢你，像日光倾城，春风十里。 我还是很喜欢你，像桑移沧海，橘植北地，不合时宜。 我还是很喜欢你，像千里戎马走单骑，八方为敌。 我还是很喜欢你，老了杜若，败了荼蘼。 我还是很喜欢你，像枯草燃尽，昨夜风又起。 我还是很喜欢你，像隐者朝饮山岚夕醉余霞，心境如洗。 我还是很喜欢你，像蚍蜉撼树，不自量力。 我还是很喜欢你，像坠入无边的梦魇，深睡不醒。 我还是很喜欢你，像沙误入眼底，涕零如雨。 我还是很喜欢你，像年复一年，野草逶迤，满山遍地。 我还是很喜欢你，像大鹏乘风九万里，非梧不栖。 我还是很喜欢你，像研磨挥毫染素衣，盈香自欣。 我还是很喜欢你，像九卿笙澜，心棠未然，西城言歌，锦凌凤息。 我还是很喜欢你，像蚕愿缫丝，生死不理。 我还是很喜欢你，像十里的春风，都不及你。 我还是很喜欢你，哪怕此生，后会无期。 我还是很喜欢你，像这十万评论，翻不到底，满满是你 ","date":"2019-10-14","objectID":"/2019/i-still-love-you/:0:0","tags":["文摘"],"title":"我还是喜欢你","uri":"/2019/i-still-love-you/"},{"categories":["研究生的区块链学习之路"],"content":"Dey S. A Proof of Work: Securing Majority-Attack in Blockchain Using Machine Learning and Algorithmic Game Theory[J]. International Journal of Wireless and Microwave Technologies, 2018, 8(5): 1-9. ","date":"2019-10-10","objectID":"/2019/securing-majority-attack-in-blockchain-using-machine-learning/:0:0","tags":["论文笔记"],"title":"Securing Majority-Attack in Blockchain Using Machine Learning","uri":"/2019/securing-majority-attack-in-blockchain-using-machine-learning/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 多数人攻击(majority-attack)对公链网络可能不是一个威胁，但对联盟链来说则不是这样，因为联盟链部分成员可能串通作恶。本文提出了一种使用监督机器学习和博弈论理论的方法，利用智能软件代理(Intelligent Software Agent)来监控区块链网络中利益相关者的活动，从而检测诸如串通等异常。 ","date":"2019-10-10","objectID":"/2019/securing-majority-attack-in-blockchain-using-machine-learning/:1:0","tags":["论文笔记"],"title":"Securing Majority-Attack in Blockchain Using Machine Learning","uri":"/2019/securing-majority-attack-in-blockchain-using-machine-learning/"},{"categories":["研究生的区块链学习之路"],"content":"Methodology 根据Rosenfeld的研究，确保攻击者攻击成功（双花攻击）的概率在10%，1%和0.1%以下需要确认的区块数分别为2，4和6次，而一旦攻击者的hashrate超过全网hashrate的一半，不论确认多少区块，都将无法阻止攻击。与此同时，考虑实际执行攻击的可能性，假设商品价值为v，攻击者挖了o个区块，每个区块的价值为B，如果攻击成功，攻击者将获得价值v，如果攻击失败，攻击者将失去价值v+oB。综合考虑这两个方面，攻击者的回报payoff(s)符合如下公式： $$ s = \\begin{cases} { v , } \u0026 { \\text { if } q \\ge 0.5 } \\ { - ( v + o B ) , } \u0026 { \\text { if } q \u003c 0.5 } \\end{cases} \\tag{1} $$ 其中q是hashrate。该回报函数可以用来对是否可能发起攻击进行判定。由于攻击的结果只有两种：成功或失败，因此可以从博弈论的视角进行分析，一些博弈论的术语如下： Self-Interested Agents：可以是任意实体如个人，公司或其它机构。这些实体是区块链网络的一员，拥有自己的偏好和效用，可能是诚实的或恶意的。 Player：参与区块链网络的每个Self-Interested Agents。假设这里有N个players：N = (1,2...,n)，N为有限集合，并由i索引 Action：每个player基于它们的偏好和效用执行的动作，假设player i 执行的一组动作为Ai = (a1, a2, an) Payoff：每个palyer收到的奖励 回报函数payoff(s)可以重新表示如下： $$ u(a)=\\begin{cases} {v,} \u0026 {\\text { if } q \\ge 0.5} \\ {-(v+o B),} \u0026 {\\text { if } q \\lt 0.5} \\end{cases} \\tag{2} $$ 其中u是效用，a是攻击者采取的动作，q是攻击者的哈希速率，v是商品/服务的价值，o是挖掘的区块数，B是每个区块的价值。 该回报函数将根据商品/服务的价值来判定攻击者是否会发起攻击，我们可以将此回报函数提供给监督机器学习算法，对攻击是否可能发生进行分类。如果攻击可能发生，系统将实施一系列规则阻止区块链确认来自攻击者的交易或者阻止交易直到发起新的公平的交易。 要实现这一想法，可以实施一个建立在区块链应用层上的智能软件代理，该软件代理由两部分组成： 基于过去的交易历史判定利益相关者攻击的可能性 基于当前交易中涉及的商品/服务的当前价值判定利益相关者攻击的可能性 一个工作流如下图所示，新的区块发布到网络中后，应用层的智能软件代理将使用回报函数根据利益相关者的动机和当前商品/服务的价值进行分类。如果利益相关者的动机被认为是恶意的，将要串通发起多数人攻击，该交易将被取消，所有利益相关者将被请求发起新的交易。这里，商品不一定是网络中有实际价值的东西，有可能是对利益相关者重要的或关联紧密的东西，这种情况下，智能软件代理需要推断当前交易中商品/服务对利益相关者的重要性或关联程度，以便计算回报函数，从而得出多数人攻击发生的概率。 graph TD A[New Block is Released For Verification] --\u003eB[Intelligent Software Agent] B --\u003e C{Fair Transaction?} C --\u003e|No| A C --\u003e|Yes| D[Block Released For Further Validation] ","date":"2019-10-10","objectID":"/2019/securing-majority-attack-in-blockchain-using-machine-learning/:2:0","tags":["论文笔记"],"title":"Securing Majority-Attack in Blockchain Using Machine Learning","uri":"/2019/securing-majority-attack-in-blockchain-using-machine-learning/"},{"categories":["研究生的区块链学习之路"],"content":"Discussion 短短四页的论文仅仅是阐述了一个基本思想，作者可能只是想占一个坑，但这一思路却非常值得借鉴。至于异常检测的逻辑是定义在智能合约中还是定义在共识代码中，就有待之后仔细分析了。 ","date":"2019-10-10","objectID":"/2019/securing-majority-attack-in-blockchain-using-machine-learning/:3:0","tags":["论文笔记"],"title":"Securing Majority-Attack in Blockchain Using Machine Learning","uri":"/2019/securing-majority-attack-in-blockchain-using-machine-learning/"},{"categories":["我所热爱的生活啊"],"content":"收集整理一些日常生活中要注意的一些个人卫生，养成良好的习惯，注意包括口腔，眼睛和睡眠三方面。 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:0:0","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"1. 口腔与牙齿 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:1:0","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"1.1 基本知识 口腔（oral cavity）是消化道的起始部分，前为唇，后为咽，侧壁为颊，顶为腭，内部有牙和舌等器官，口腔底还有粘膜和肌等结构。 牙位于口腔内，是人最重要的器官之一。人的一生先后有两组牙，第一副叫乳牙，共20颗，从出生后6个月左右开始长，到3岁时基本长齐。第二副牙齿叫恒牙，共32颗，在6岁左右开始逐渐长出，替换脱落的乳牙，除了第3磨牙外，其余的28颗一般在12－14岁左右就全部长出。第3磨牙长出的时间较晚，在18-30岁，故又称迟牙或智牙，也有的人终生不长或只长一部分（全部共4颗），故人的恒牙数目在28－32不等。恒牙是人的最后一幅牙齿，脱落后不再有新牙长出。下图中，第3磨牙就是常说的智齿，尖牙是人们常说的虎牙。 牙分牙冠、牙颈、牙根三部分，暴露在口腔内的即牙冠，嵌于牙槽的称牙根，两者之间被牙龈包绕的部分称牙颈。牙的内部空腔称牙腔，位于牙根内的称根管，与牙槽相连，牙腔内有牙髓，富含血管和神经，牙髓发炎时，可引起剧烈疼痛。 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:1:1","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"1.2 相关疾病 口腔和牙齿可能的疾病中，龋齿最常见，其次是牙周病和口腔溃疡。 龋齿是口腔中多种因素复合作用导致的牙齿硬组织损害，表现为无机质的脱落和有机质的分解，会有一个从色泽变化到实质性损害的演变过程，是人类最普遍的疾病之一，平均发病率在50%，也是口腔最主要的疾病。龋齿一般不会危及生命，但不及时修复导致病变发展，会感染牙齿内部的牙髓组织和根尖周组织，引起牙髓炎等并发疾病，导致剧烈疼痛和组织破坏。牙体硬组织的破坏，还会造成牙冠缺损，导致牙齿丧失，不仅破坏咀嚼器官的完整性，而且影响消化。另外，龋齿及其并发疾病可能引起咽炎、扁桃体炎等其它疾病。所以，发现龋齿一定要及时去补牙。 牙周病主要包括牙龈病和牙周炎两大类，前者只发生在牙龈，后者则累及牙龈、牙周膜、牙槽骨和牙骨质四种牙周支持组织，表现为牙龈炎症、出血、牙槽骨高度降低、牙齿松动、移位、咀嚼无力等，严重者牙齿会自行脱落或必须拔出牙齿。牙龈发炎会导致口臭，不利于人际交往。 口腔溃疡是一种常见的发生于口腔黏膜的溃疡性损伤病症，大小可从米粒至黄豆大小、成圆形或卵圆形，溃疡面为凹、周围充血。多见于唇内侧、舌头、舌腹、颊黏膜、软腭等部位，这些部位的黏膜缺乏角质化层或角化较差。口腔溃疡发作时疼痛剧烈，局部灼痛明显，严重者还会影响饮食、说话，对日常生活造成极大不便；可并发口臭、慢性咽炎、便秘、头痛、头晕、恶心、乏力、烦躁、发热、淋巴结肿大等全身症状。口腔溃疡诱因可能是局部创伤、精神紧张、食物、药物、激素水平改变及维生素或微量元素缺乏，很大程度上与个人身体素质有关，一般一至两个星期可以自愈。想完全避免其发生可能性不大，但可以尽量避免诱发因素从而降低发生率。目前的治疗方法主要是消炎止疼，促进溃疡愈合。 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:1:2","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"1.3 疾病预防 口腔卫生的重点在清除软垢、菌斑、食物碎屑、牙面色素和牙石。软垢是停留在牙面和齿缝的软而白的污物，主要成分是有机物，是口腔细菌滋生的聚集处；食物碎屑是软垢中和嵌塞于齿缝中的食物残渣或食物纤维；牙面色素来源食物．香烟、药物、茶和饮料、产色细菌以及唾液中有色分泌物等；牙石是牙龈上下的坚硬的石灰样沉淀物，主要成分是无机物；牙菌斑是沉积在牙面的斑块，含有口腔细菌、无机盐、上皮细胞和食物残渣，而以细菌为主。菌斑在一日之内无时无刻不在沉积，但在不进食时比进食时沉积得更快，故在夜间形成得菌斑较多，如果睡前不刷牙，夜间沉积得菌斑就相当致密而粘厚。吃糖后形成得菌斑也与此相似，都不易去除。这种稠厚得菌斑，有时连自己也能察觉，用舌头舔一舔牙面，可能感到已变得粗糙，刷一次牙难以刷净。正是这种菌斑诱发龋齿和牙周病。 应养成良好的口腔卫生习惯，如刷牙、漱口，多喝水，多吃新鲜水果蔬菜，少喝碳酸饮料，少吃含糖食物、粘性大的食物，以及过冷、过热、辛辣的食物。许多不良习惯不利于牙齿保护，如长期用单侧牙咀嚼，用口呼吸，咬笔杆，睡前吃糖果，用牙咬碎杏核等坚果，用牙开啤酒瓶盖等。 刷牙 应早晚各刷牙一次，顺着牙缝竖刷而不是横刷，横刷不易刷出牙缝中的食物残渣，而且会损伤牙表面的珐琅质，直接用牙膏不沾水先刷可提高牙膏与牙齿的接触面而增强效果，实际上，牙膏就是借助摩擦力帮助清洁牙齿的。牙刷头位于牙颈部，使刷毛和牙面成45°角，轻压使刷毛一部分进入牙缝，来回4-6次，幅度1-2毫米，向牙尖的方向旋转牙刷，每个牙面都要刷到，总持续约3分钟。刷牙时应使用温水。 牙刷的形状以平刷和直柄为宜，牙膏中有摩擦剂、洗涤剂或药品成分有助于机械性去污，使刷牙者感到爽口，可消除口臭，并具有杀菌和抗病作用，低档牙膏颗粒较粗，易损坏牙齿，最好不用，用牙粉或精盐刷牙也不可取。长期使用某一种牙膏不利于预防口腔疾病，应交替使用含氟和含杀菌药物的牙膏和交替使用含药物和不含药物的牙膏。 漱口 每天除早晚刷牙外，还应间隔2小时漱一次口，特别是吃饭前，可用清水、淡盐水或茶水，漱口时注意水温。牙齿长期受到骤冷或骤热刺激，一样容易引发疾病。 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:1:3","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"2. 眼睛 虽然已经近视了，但还是要注意用眼卫生，避免情况恶化和保持身体健康，因为人是一个整体。 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:2:0","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"2.1 基本知识 眼睛是人的视觉器官，具有屈光和调节作用，屈光系统主要包括透明的角膜、房水、晶状体和玻璃体，其中任何部分出现异常都会影响视力。 近视：看近物清楚，看远物模糊，是由于远处物体经眼球折射后聚焦于视网膜前造成的 远视：看远物清楚，看近物模糊，是由于近处物体经眼球折射后聚焦于视网膜后造成的 散光：看物体可能出现重影，是由于物体经眼球折射后在视网膜上形成多个焦点造成的 青光眼：眼压增高导致房水流出，视盘凹陷，出现视野缺损，是致盲的主要疾病 白内障：晶状体浑浊导致视力下降，多见于老年人，是致盲的主要疾病 飞蚊症：是指眼前有飘动的小黑影，一般由玻璃体液化变性产生的浑浊物投影在视网膜上产生的，是一种自然老化现象，没有多大危害。 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:2:1","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"2.2 用眼卫生 用眼卫生基本上是从小教育的那些知识，包括 读书写字保持良好的姿势 不要躺在床上看书，不要在晃动的车船上看书 看屏幕，看书的时间不要太长，每隔45-60分钟休息10-15分钟，休息时应隔窗远眺或进行室外活动 光线过强过弱，闪烁不定都不适合看书、写字 注意营养，保证膳食，积极参见体育锻炼，作息规律，睡眠充足 坚持练习眼保健操等眼部按摩有助于促进眼球血液循环，缓解眼疲劳，调节眼内压力平衡，从而保护视力。 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:2:2","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"2.3 盲人 盲人有先天性的，有外力致眼球损毁的，但这些都是不可抗力，我们只讨论病理性引发的。引发致盲的疾病主要有白内障、青光眼、老年黄斑、其他疾病导致的视网膜病变等，老人和婴幼儿是高发人群，但中青年用眼过度、高度近视等都可能引发致盲，所以要注意用眼卫生。 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:2:3","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["我所热爱的生活啊"],"content":"3. 睡眠 睡眠的需要量同年龄密切相关，儿童一天需要12-14小时，成人7-9小时，老人只需要5-7小时。但每个人不尽相同，成人每夜睡眠超过9小时者属于长睡者，少于6小时者属于短睡者。 长睡型与短睡型的区别：长睡型多数性格内向，兴趣广泛，善于思考，有独立见解，有抑郁倾向；短睡型多数性格外向，精力充沛，充满信心，喜爱交际，比较乐观。 睡眠是否充足，主要依靠醒后的感觉判断，如果醒后头脑清醒，精力充沛、周身舒适，则可以认为睡够了，反之醒来感到头昏脑胀，萎靡乏力，周身不适，则可能还没睡够。 睡眠模式因人而异，有的早睡早起，有的喜欢夜间工作而早上休息，这和个人的性格、生活习惯、工作性质和环境条件有关，但无论哪种模式，保证充足的睡眠才有利于健康。 睡眠时相分为两个交替出现的阶段，一个是非快速眼动睡眠，这个阶段心率减慢，呼吸频率降低，机体代谢降低，脑垂体释放生长激素和性激素，同时全身肌肉、关节放松，有助于消除疲劳、恢复体力、增强免疫力；另一个是快速眼动睡眠，这个阶段因眼球快速运动得名，并经常做梦，主要用于恢复脑力。 保证健康的睡眠主要需做到以下几点： 加强体育锻炼，尤其是对经常处于静坐状态的脑力劳动者而言，参见体育锻炼有助于大脑的兴奋与抑制平衡 舒适卧具：床要软硬适度，枕头不能太高，否则可能影响脊椎和颈部自然弯曲度 正确卧姿：尽量右侧卧睡 注意饮食：睡前不要吃的过饱或过度饮水，但睡前喝杯牛奶有助于睡眠 生活习惯： 定时睡觉和定时起床有助于形成良好生理时钟，偶尔晚睡早上依然要按时起床，周末避免懒觉，睡眠无法贮藏与补充，多睡无益 每天保持一定的体育锻炼，但借助睡眠前剧烈运动使身体疲劳从而快速入睡的想法是错误的 睡前放松，不要做劳心或劳力的工作，可以热水洗脚使全身放松或听轻音乐，有助于快速入睡 卧房远离噪声，不要开灯睡觉 不要在床上看书、看电视或玩手机等，进行这些活动通常会破坏固定的入睡时间 总结及计划：睡前喝一杯牛奶，并热水洗脚，以听轻音乐作为入睡仪式；右侧卧睡，入睡和起床时间固定 ","date":"2019-10-05","objectID":"/2019/medicine-and-health-1-daily-life-hygiene/:3:0","tags":["生活技能"],"title":"医药健康5-日常生活卫生","uri":"/2019/medicine-and-health-1-daily-life-hygiene/"},{"categories":["研究生的区块链学习之路"],"content":"Meng W, Tischhauser E, Wang Q, et al. When Intrusion Detection Meets Blockchain Technology: A Review[J]. IEEE Access, 2018: 10179-10188. Abstract：以识别网络威胁和可能的事故为目的，入侵检测系统（IDS）已被广泛用于各种计算机网络。为了增强单个IDS的检测能力，协作入侵检测系统被提出（collaborative IDS， CIDS），它允许IDS节点间彼此交换数据。然而，当前检测架构中数据和信任管理仍然是两个主要的问题，能够降低检测系统的有效性。区块链可以保护数据存储的完整性和确保过程透明，因此有潜力被用于入侵检测领域。受此启发，本文就IDS和区块链的交叉做了一个综述，讨论区块链在入侵检测中的适用性，并明确该方向可能的挑战。 论文内容主要分为如下几部分： 介绍入侵检测和协作入侵检测(CID)的概念，声明CID当前面临的挑战：数据共享和信任管理。 介绍了区块链的概念，原理和主要应用。 叙述了在CID中，区块链如何用于解决数据共享和信任管理问题。 引言部分也是对IDS和CIDS的说明，因此和后文进行合并，区块链部分的介绍已较为熟悉，浏览后未发现值得记录的知识，因此跳过。以下分为[入侵检测](##Intrusion Detection)，[协作入侵检测](##Collaborative Intrusion Detection)，[协作入侵检测的问题](##Challenges in Collaborative Intrusion Detection)，[基于区块链的解决方案](##Blockchain-Based Solutions)，[未来的研究方向](##Challenges and Future Trends)四部分对论文总结说明。并记录阅读时产生的想法。 ","date":"2019-10-03","objectID":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/:0:0","tags":["论文笔记"],"title":"When Intrusion Detection Meets Blockchain Technology A Review","uri":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/"},{"categories":["研究生的区块链学习之路"],"content":"Intrusion Detection 入侵检测描述了为了发现可能发生的事故的迹象监控网络或系统事件的过程。IDS是实现入侵检测过程的一种应用，主要提供两个功能： 信息记录：一个IDS可以监控目标对象并在本地记录信息，收集的数据可以发送到其它设施（如中心化的事件管理服务器）进行分析。 警报生成：一个IDS的重要任务是生成警报将识别的重要异常通知安全管理员。误报率是衡量一个IDS是否有效的重要指标。 基于IDS节点部署的位置，可以分为 host-based IDS (HIDS) and network-based IDS (NIDS)两种类型。前者主要监控本地系统的特征和主机中的系统事件，以防恶意活动。后者监测网络流量，并分析网络协议和可疑事件的流量负载。这种分类还可以更具体，比如wireless-based IDS，通过监控无线网络的packages和协议识别恶意活动。实际应用中，经常结合HIDS和NIDS使用，因为它们可以相互补充，从而提供更好的保护。如下图 基于检测方法也可将IDS分为两类：signature-based IDS(也称作 misuse-based IDS) 和 anomaly-based IDS。基于签名的IDS通过比较存储的签名和观察到的系统或网络事件，防止可能发生的事故，签名（或规则）是一种描述已知攻击的模式。基于签名的检测对已知威胁是有效的，但对于未知威胁和已知威胁的变种是无效的，例如，定义一个搜索malware.exe文件的签名，攻击者将攻击程序重命名为malware1.exe就可以轻松绕过检测。 基于匿名的检测则通过识别预定义的正常配置文件和观察到的事件间的显著差别来寻找可疑活动。正常配置文件通常通过在一段时间内监视典型活动的特征来创建，因此可以代表与用户、网络连接和应用相关的正常行为。如果发现异常情况，将会生成警报。大量文献研究了如何使用机器学习分类器来构建正常配置文件，另外，实际使用中，配置文件可以是静态或动态的，静态文件不会更新，但动态文件会根据安全策略周期性地更新。高误报率是anomaly-based IDS的最大限制。 除了以上两种检测方法外，还有一种方法叫做specification-based detection，它识别预定义的benign profile和观察到的事件间的偏差，benign profile和normal profile的不同在于前者定义了预先被接受的事件，比如，一个benign可以指定某种协议如何使用或不能如何使用。 基于签名的IDS事先定义各自攻击模型，检测通过和这些攻击比较实现，现在所做的实验中的恶意行为判决一定意义也属于这种情况，事先定义了单位时间的请求数量，通过对比做出决策，并添加了判决，根据预定义规则进行惩罚。 基于匿名的IDS中normal profile可以用智能合约代替，不仅可以保证无篡改，还可以根据安全策略动态更新。本地节点做完机器学习分类后，生成配置文件，作为智能合约定义到区块链中，或者更新已有的智能合约。 ","date":"2019-10-03","objectID":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/:1:0","tags":["论文笔记"],"title":"When Intrusion Detection Meets Blockchain Technology A Review","uri":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/"},{"categories":["研究生的区块链学习之路"],"content":"Collaborative Intrusion Detection 协作入侵检测在实际应用中包括CIDN和CIDS，主要以增强单个IDS的性能为目标，因为单个IDS很容易被高级或复杂的攻击绕过，比如DoS攻击。根本原因是单个IDS没有关于它保护的环境的信息，而协作入侵检测框架则允许各IDS节点通过相互交换数据和信息来理解上下文。例如，通过收集不同检测传感器的流量特征，中央服务器对网络异常比单个IDS更敏感。传统的协作可分为如下类型： Hierarchical collaboration systems like EMERALD and DIFS； Subscribe collaboration systems like COSSACK and DOMINO； Peer-to-peer(P2P) query-based collaboration systems like Netbait and PIER。 一个典型的协作入侵检测网络架构如下图所示，CIDN中的各节点可以交换彼此需要的信息。一个节点通常由以下几个部分组成：IDS模型，协作组件，P2P通信组件。具体而言，IDS模型执行入侵检测，监控网络流量和记录事件；协作组件负责帮助节点和其它节点交换需要的数据，以及执行某些操作如信任计算；P2P通信组件用于帮助建立和其它IDS节点的物理连接。 CIDS和区块链看起来具有天然的可结合性，P2P通信由区块链本身完成，IDS模型由节点本身完成，信息和数据的交换（协作组件）通过发起交易或智能合约完成。 由于区块链本身通过共识实现了信任，一般不需要信任计算，若仍然需要，可以利用区块链中的激励机制实现，比如将信任度定义为通过智能合约定义的代币。 ","date":"2019-10-03","objectID":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/:2:0","tags":["论文笔记"],"title":"When Intrusion Detection Meets Blockchain Technology A Review","uri":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/"},{"categories":["研究生的区块链学习之路"],"content":"Challenges in Collaborative Intrusion Detection 异常检测已经研究了很久，但实际应用中仍有很多问题未解决，这些问题能显著减弱检测性能。 处理能力跟不上流量大小：在流量较大的网络中，过量的数据包能显著降低检测系统性能，如果流量超过了IDS的最大处理能力，大量的数据包将被丢弃。 签名覆盖范围有限：基于签名的检测的检测能力严重依赖于可用签名，换句话说，检测性能受限于签名的数量和质量，然而，签名通常难以覆盖所有已知攻击和漏洞。 不准确的配置文件：基于匿名的检测很难建立准确的配置文件，具体而言，因为基于匿名的IDS通常利用机器学习建立配置文件，而训练数据，尤其是有标签的攻击数据，实际上限制很大，这回导致机器学习分类器的不准确。 大量错误警报：IDS生成准确的警报并通知安全管理员非常重要，然而，由于不成熟的签名和不准确的配置文件，错误的警报是一个大挑战，它们会显著降低检测性能，增加安全分析的压力。例如，一个大公司一天会产生超过10000个警报。 尽管入侵检测已经研究了40年，数据共享和信任管理仍然是协作环境的两个主要挑战。 数据共享：数据共享是一个主要的问题，因为让参与者信任彼此很难。PKI体系可以建立一定的信任，但并不总是有用。更进一步，由于对隐私的担心，参与者可能不愿意共享数据，而没有足够的数据，就不可能优化检测算法从而构建一个稳健的识别模型。例如，异常检测通常运用机器学习来构建正常配置文件，其中，分类器需要大量训练条目，但由于隐私问题，一些组织可能不想共享它们的数据，使得检测性能很难优化。 信任管理：众所周知，CIDN/CIDS对内部攻击是脆弱的，因为攻击者有权限访问网络。通常，计算信任被用于量化不同节点的信任级别，实际应用中，一般使用中央服务器收集节点流量和行为数据来计算每个节点的信任值。然而，当组织变得庞大，参与者变多，信任管理就会出现问题，因为很难找到可信第三方，例如，中央服务器可能被破坏。 ","date":"2019-10-03","objectID":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/:3:0","tags":["论文笔记"],"title":"When Intrusion Detection Meets Blockchain Technology A Review","uri":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/"},{"categories":["研究生的区块链学习之路"],"content":"Blockchain-Based Solutions 区块链取消了可信第三方的存在，拥有不可篡改的特性，使得它能用于解决入侵检测的以上问题。 数据共享：数据共享问题主要由两方面引起：相互信任和数据隐私。相互信任意味着共享数据时，协作实体必须相信彼此不会泄露数据。数据隐私则是指共享的数据可能包含与参与者相关的一些信息，比如IP地址等，可能引起隐私泄露。 区块链是一种可能的解决方案，具体而言。数据共享可以被视为一系列的交易，参与的各方将数据共享的规则定义在区块链中，保持公开和不可变，这种情况下，其它的参与者可以访问区块链，阅读协议并确认数据所有权。协议的永久可见确保了一方不可以单方面否定它。 对于数据隐私，一个解决方案是共享转换后的数据而非原始数据。例如，实体A想用实体B的数据验证其设计的分类器的性能，可以将该分类器上传到区块链，实体B检索这一分类器在本地使用自己的数据运行，并将最后的结果返回给实体A。这样，实体B就可以维持原始数据的隐私。总的来说，对于数据共享问题，区块链可以作为数据所有者和其他方之间协议的永久性账本，帮助建立协作各方之间的相互信任，并保护数据隐私。 信任管理：通常，协作网络架构可以分为中心化的、层次的和分布式的。分布式架构以及进行了广泛的研究，而另外两种架构被认为受到可扩展性和单点故障的影响。对CIDN而言，在不同IDS节点间交换警报是极为重要的，这可以用来帮助寻找异常发生在哪儿。一些协作检测方法（如基于挑战的CIDN）利用警报评估其它节点的可信度，区块链可用于处理这一问题，例如，验证收到的警报信息是否未篡改。 另外，警报交换也可以用来计算网络内节点的可信度。例如，Fung等设计了一个基于挑战的CIDN，其中节点可信度可以通过基于接收到的警报信息的满意度来计算。他们所提出的架构对一些内部攻击如newcomer attack和Betrayal attack是鲁棒的，但对协作攻击（一组恶意节点为了破坏网络协作提供错误的警报）没有用。因此，如何以一种稳健的方式执行信任计算仍是一个挑战。 区块链技术提供了一种可能的方式来解决这一问题。例如，Alexopoulos引入了基于区块链的CIDS，用区块链增强IDS节点间的信任，他们将每个IDS生成的原始警报视作区块链中的交易，从而在CIDN的协作节点间传播。所有协作者通过共识对其验证，可以保证存储在区块链中的警报信息是防篡改的。 区块链和入侵检测可以相互补充。一方面，如前所述，区块链用于提升IDS的性能，尤其是CIDS在数据共享和信任管理方面，另一方面，入侵检测可以帮助区块链系统中的异常。 要注意，用不用区块链解决入侵检测问题需要具体评判，传统方案依然值得研究。 总体思路，节点在本地运行机器学习分类器生成正常配置文件，以智能合约的形式存储在区块链中，并根据安全策略周期性的更新，运行过程中检测系统事件并和配置文件比较，发现异常后生成警报并在区块链中记录保证不可篡改，判决合约根据警报和节点历史行为做出判决。 ","date":"2019-10-03","objectID":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/:4:0","tags":["论文笔记"],"title":"When Intrusion Detection Meets Blockchain Technology A Review","uri":"/2019/when-intrusion-detection-meets-blockchain-technology-a-review/"},{"categories":["研究生的区块链学习之路"],"content":"上篇文章已经确定了使用 Quorum 区块链，本文记录搭建 Quorum 私有区块链网络的过程。值得一提的是，相比于之前区块链平台搭建的尝试，本篇所述内容已经是一个完整无冗余的方案，后续对区块链平台搭建过程的优化，更多的是根据具体情况进行取舍，以及使用新出的一些更好用的工具。 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:0:0","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"1. 设备整理 首先整理下手头现有的设备，包括开发板、MCU或其它套件、传感器/执行器等的列表如下 名称 分类 数量 状态 实物图 树莓派 开发板 2 已购买 BeagleBone Black 开发板 2 老师手里 LoRa/GPS Hat 扩展板 1 已购买 CC1350 LaunchPad 扩展版 2 老师手里 Grove XBee Carrier 扩展板 2 实验室抽屉 RFBee 配套Xbee的部件 2 实验室抽屉 UartSBee v5 转换器 2 实验室抽屉 Grove-Loudness Sensor 传感器 1 实验室抽屉 Grove-Dust Sensor 传感器 1 实验室抽屉（损坏，不可用） Grove-Chainable RGB LED 执行器 1 实验室抽屉 LoRa/GPS HAT，CC1350 LaunchPad都内置一个温度传感器，LoRa/GPS HAT除了支持LoRa通信，还可以收集并上传GPS数据 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:1:0","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"2. 设备选择与方案构思 主要考虑使用哪些设备，为了反映所设计的系统的基本结构，需要包括网关和终端IoT设备。有下面几种思路。 有线直连，树莓派/BBB + 传感器/执行器 将传感器/执行器直接接到树莓派或BBB开发板上，在开发板中使用Python相关库从传感器/执行器读取相关数据并进行处理。工作量较小 有线直连，树莓派 + Arduino + 传感器/执行器 Arduino连接传感器/执行器，并通过串口与树莓派通信，在树莓派中使用Python相关库处理Arduino传过来的数据并进行处理。工作量较小，但目前没有Arduino。 无线通信，LoRa Arduino连接传感器/执行器，同时连接LoRa模块作为LoRa节点，将收集自传感器的数据通过LoRa模块发送到网关。树莓派连接 LoRa/GPS Hat 作为 LoRa网关接受来自LoRa节点的数据，并提交到The Things Network(TTN) 网络，从TTN后台获取实时数据供区块链处理 目前没有Arduino，且缺少一个LoRa模块与LoRa/GPS HAT协作传输数据。 这一方式工作量较大。 无线通信，Sub 1GHz CC1350 LaunchPad作为终端设备从传感器获取数据，通过Sub 1GHz发送给另一台作为收集器的CC1350，收集器与BeagleBone Black串口通信，网关运行在BBB上。 CC1350 LaunchPad 编程处理传感器工作量比Arduino大，不熟悉；如何从运行在BBB上的本地网关获取暂时数据也不清楚 这一方式工作量较大 最后选择的方案是：使用两台树莓派，通过WiFi连接到电脑，终端 IoT 设备通过区块链账户表示，不连接实物。 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:2:0","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"3. 网络拓扑 在正式开始本实验之前，已经尝试过使用两台电脑和两台树莓派搭建 Quorum 网络，主要使用的是虚拟机，但到最后由于网络质量的问题，共识协议无法正常运行，导致合约部署无法完成。估计主要原因是 PC 上的节点装在了虚拟机里，虚拟机又使用桥接模式，导致最后丢包率和延迟都比较高。因此这次对实验做一定的调整，主要有两点： 撤销 laptop 的节点，只使用台式机，节点仍然安装在虚拟机中，但不使用桥接模式，而是通过外接无线网卡直接连到路由器的无线网络； 扩展节点数量到 6 个，虚拟机中设置 4 个验证者节点，以端口号区分，两台树莓派分别代表一个普通节点，在之后加入。 最终使用了两台树莓派和一台计算机搭建完成 6 节点的 Quorum 网络，采用了 IBFT 共识，未启用隐私管理器。网络拓扑如下： 注意，当前虚拟机和树莓派都是通过无线网卡接入路由器共享的无线网络(网络名为 quorum)。 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:3:0","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 设备和操作系统选择 实验平台共使用了一台台式电脑和两台树莓派。设备和操作系统的详细信息如下，台式电脑的内存和硬盘信息是虚拟机分配的容量。 设备 CPU 操作系统 内存 硬盘 清华同方(台式电脑) Intel Core i5-4460, 3.2GHz Ubuntu 18.04 LTS(虚拟机) 2GB 50GB Raspberry Pi 3 Model B Plus quad-core ARM Cortex A53, 1.4GHz Raspbian Buster 1GB 32GB(microSD card) Raspberry Pi 3 Model B quad-core ARM Cortex A53, 1.2GHz Raspbian Buster 1GB 16GB(microSD card) ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:3:1","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 静态ip分配 台式电脑的操作环境是在虚拟机上完成的，涉及到网络相关操作，这里事先对各设备进行静态ip的分配 设备 主机名 节点编号 IP地址 操作系统 清华同方（PC） validator node0 192.168.191.2:30300 Ubuntu 18.04 LTS 清华同方（PC） validator node1 192.168.191.2:30301 Ubuntu 18.04 LTS 清华同方（PC） validator node2 192.168.191.2:30302 Ubuntu 18.04 LTS 清华同方（PC） validator node3 192.168.191.2:30303 Ubuntu 18.04 LTS Pi 3B+ lightnode1 node4 192.168.191.3 Raspbian Buster Pi 3B lightnode2 node5 192.168.191.4 Raspbian Buster ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:3:2","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"4. 主机设置 在 VMware 中安装 Ubuntu 18.04 虚拟机，安装完成后完成如下基础配置。 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:4:0","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 系统初始化 更新源和系统 $ sudo apt-get update $ sudo apt-get upgrade 调整系统时间 # 查看系统时区是否正确 $ timedatectl Local time: 五 2019-09-13 11:07:13 +08 Universal time: 五 2019-09-13 03:07:13 UTC RTC time: 五 2019-09-13 03:07:13 Time zone: Asia/Ulaanbaatar (+08, +0800) System clock synchronized: yes systemd-timesyncd.service active: yes RTC in local TZ: no # 若不正确，使用下列命令设置时区，时区根据自己所处位置调整 $ timedatectl set-timezone Asia/Shanghai 设置主机名 $ sudo hostnamectl set-hostname validator 重启终端查看新的主机名 $ hostnamectl Static hostname: validator Icon name: computer-vm Chassis: vm Machine ID: fea6d1013b564af9ad3667732e5417fc Boot ID: 326e1f8c6fd04269803413d6ac7c6167 Virtualization: vmware Operating System: Ubuntu 18.04.3 LTS Kernel: Linux 5.0.0-23-generic Architecture: x86-64 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:4:1","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 静态ip设置 执行ifconfig命令需要安装net-tools工具 $ sudo apt-get install net-tools Ubuntu18.04 必须使用netplan管理网络，但因为这里是 Desktop 版，可以可视化设置，所以暂时不需要理解。 在设置页面选择无线网络，然后点击网络连接的 quorum 网络的小齿轮图标，进入网络设置页面 点击IPv4选项卡，选择Manual，输入我们之前预先设计的IP192.168.191.2，子网掩码、网关和DNS都做相应的设置，然后点击应用。 查看设置好的网络地址 $ ifconfig ... wlxb8de5e4dad9c: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 192.168.191.2 netmask 255.255.255.0 broadcast 192.168.191.255 inet6 fe80::bfba:dc41:82e0:e788 prefixlen 64 scopeid 0x20\u003clink\u003e ether b8🇩🇪5e:4d:ad:9c txqueuelen 1000 (Ethernet) RX packets 238 bytes 190654 (190.6 KB) RX errors 0 dropped 1 overruns 0 frame 0 TX packets 261 bytes 36065 (36.0 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 最后取消有线网络的自动连接，确保网络连接处于quorum无线网络上，不过还需要在每次虚拟机启动时手动断开网卡和主机的连接，然后连到虚拟机上。 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:4:2","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"4.3 软件编译安装 获取与安装go1.13 $ wget https://dl.google.com/go/go1.13.linux-amd64.tar.gz $ sudo tar -xzf go1.13.linux-amd64.tar.gz -C /usr/local $ rm go1.13.linux-amd64.tar.gz # 设置环境变量 $ sudo nano /etc/profile # 在打开的文件末尾添加下列语句 export PATH=$PATH:/usr/local/go/bin # 更新的环境变量在下一次登录之前不会生效，但可以通过下面的命令使其直接生效 $ source /etc/profile # 查看生效后的环境变量设置 $ go version go version go1.13 linux/amd64 # 注：真正生效必须重启系统 安装geth for quorum # 获取编译后的二进制包 $ wget https://bintray.com/quorumengineering/quorum/download_file?file_path=v2.2.5/geth_v2.2.5_linux_amd64.tar.gz # 解压缩并安装 $ sudo tar -xzf download_file?file_path=v2.2.5%2Fgeth_v2.2.5_linux_amd64.tar.gz -C /usr/local/bin $ rm download_file?file_path=v2.2.5%2Fgeth_v2.2.5_linux_amd64.tar.gz # 测试安装 $ geth version WARN [10-11|09:41:31.463] Sanitizing cache to Go's GC limits provided=1024 updated=655 Geth Version: 1.8.18-stable Git Commit: c894c2d70eacf30740d03b53ed2fb39e42641295 Quorum Version: 2.2.5 Architecture: amd64 Protocol Versions: [63 62] Network Id: 1337 Go Version: go1.11.12 Operating System: linux GOPATH= GOROOT=/home/travis/.gimme/versions/go1.11.12.linux.amd64 获取并编译istanbul-tools，该工具用来初始化 IBFT 共识网络及进行网络测试 $ sudo apt-get install git $ mkdir istanbul \u0026\u0026 cd istanbul $ git clone https://github.com/jpmorganchase/istanbul-tools.git $ cd istanbul-tools # 执行编译 $ sudo apt-get install -y build-essential $ make # 编译后的文件位于/build/bin目录下，执行测试 $ ./build/bin/istanbul --version istanbul version v1.0.1 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:4:3","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"5. 树莓派启动及配置 以 Pi 3B+ 为例，Pi 3B 配置操作基本相同 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:5:0","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"5.1 树莓派启动 将 Raspbian Buster 镜像写入准备好的 SD卡，重新加载在电脑中的 SD 卡会出现 boot 盘，同时也是树莓派的/boot目录。在 boot 盘根目录新建名为ssh的文件，开启 SSH 连接。同时新建wpa_supplicant.conf文件，编辑其内容如下： ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=CN network={ ssid=\"WiFi名\" psk=\"密码\" priority=10 } 将其中的 ssid 和 psk 更改为自己无线网络的网络名和密码。将配置好的 SD 卡卸载并插入树莓派，通电启动。使用 Advanced IP Scanner 扫描无线网络的网段，获取树莓派 ip，本实验无线网络网段为192.168.191.1-254。 使用扫描到的 ip 通过 Putty 利用 SSH 协议进行登录。 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:5:1","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"5.2 树莓派基本配置 A. 更新源及系统 编辑/etc/apt/sources.list文件 sudo nano /etc/apt/sources.list 注释掉原来的源，将源更新为： deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 保存退出，编辑/etc/apt/sources.list.d/raspi.list文件 sudo nano /etc/apt/sources.list.d/raspi.list 将源更新为： deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 更新源文件列表，更新软件 $ sudo apt-get update $ sudo apt-get upgrade B. 安装xrdp供远程连接 $ sudo apt-get install xrdp # 确认安装 $ dpkg -l | grep xrdp ii xorgxrdp 1:0.2.9-1 armhf Remote Desktop Protocol (RDP) modules for X.org ii xrdp 0.9.9-1 armhf Remote Desktop Protocol (RDP) server C. 开启ftp供文件传输 安装vsftpd $ sudo apt-get install vsftpd # 确认安装 $ dpkg -l | grep vsftpd ii vsftpd 3.0.3-12 armhf lightweight, efficient FTP server written for security 编辑配置文件 $ sudo nano /etc/vsftpd.conf 启用对树莓派的写入权限 # Uncomment this to enable any form of FTP write command.write_enable=YES 保存退出，启用vsftpd $ sudo service vsftpd start D. 修改pi账户密码，时区和主机名 $ sudo raspi-config 选择第一项Change User Password，键入新密码并确定， 选择第四项Localisation Options，选择Change Timezone，将时区更改为Asia/Shanghai 全部设置完成后选择Finish退出，终端将看到如下输出 Current default time zone: 'Asia/Shanghai' Local time is now: Fri Sep 13 18:40:56 CST 2019. Universal Time is now: Fri Sep 13 10:40:56 UTC 2019. New password: Retype new password: passwd: password updated successfully OK 设置主机名 $ sudo hostnamectl set-hostname node5 编辑/etc/hosts文件，将127.0.1.1对应的raspberry更改为node5 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters 127.0.1.1 node5 退出终端并使用新密码重新登录，主机名将更改为node5。注意此时用户名仍为pi。 E. 设置静态ip 编辑/etc/dhcpcd.conf文件 $ sudo nano /etc/dhcpcd.conf 在末尾添加如下内容 interface wlan0 static ip_address=192.168.191.3/24 static routers=192.168.191.1 static domain_name_servers=192.168.191.1 重启并以新的ip登录树莓派。 F. 获取并安装geth 已经交叉编译过了，这里下载的是最后生成的文件，放到了Github上。交叉编译的过程可以参考本系列文章的两篇补充说明。 $ git clone -b gethonly https://github.com/shuzang/quorum-raspbian.git $ cd quorum-raspbian $ sudo cp geth /usr/local/bin $ sudo chmod +x /usr/local/bin/geth 测试安装是否成功 $ geth version WARN [09-13|19:51:40.051] Sanitizing cache to Go's GC limits provided=1024 updated=308 Geth Version: 1.8.18-stable Quorum Version: 2.2.5 Architecture: arm Protocol Versions: [63 62] Network Id: 1337 Go Version: go1.11.6 Operating System: linux GOPATH= GOROOT=/usr/lib/go-1.11 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:5:2","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"6. 网络搭建及测试运行 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:6:0","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"6.1 主机 各节点数据和相关文件的前期生成都在台式电脑中由 istanbul-tools 工具完成。切换到台式电脑，在 istanbul 目录下创建各节点的工作目录 $ cd ~/istanbul $ mkdir node0 node1 node2 node3 进入领导节点（这里是node0）目录，使用 istanbul-tools 工具为各节点生成文件，该命令会为所有的初始验证者节点生成 static-nodes.json, genesis.json和 nodekeys 三种文件。 $ cd node0 $ ../istanbul-tools/build/bin/istanbul setup --num 4 --nodes --quorum --save --verbose 将输出生成的文件信息 validators { \"Address\": \"0x7fec892a867a2da2e4f1ae1646c29e40d0d7a5c6\", \"Nodekey\": \"d698db367eeb7a43c6eb6c79213482ba6ca6f2781c03e8bc8b6d4d2b9bbfd7e5\", \"NodeInfo\": \"enode://7117f995cdb2d79eb90bc4a575c5f82bbe4aa6ac87f966b18e2e19bd29e728ba9ca85062a6af5c188bb159641392e2ac3559712d9a31e965220659412a4a8c3e@0.0.0.0:30303?discport=0\" } { \"Address\": \"0x65cc0df8e88fa0fbda0337b3e0b10be9c27325c3\", \"Nodekey\": \"0010d6506fe219d1e0c35f481ee4bd1fc26cadb84c0510128f186e32d7be3f0f\", \"NodeInfo\": \"enode://cb790b57310d70bfb13e417e9dc22f3b0afc0065f4c5babc2f95e3ff75e99d343547585a0b2ad6be6f0497f401e93c16dadec5a68d820cb918fa0255696940f2@0.0.0.0:30303?discport=0\" } { \"Address\": \"0x786083c93b12404fd4100ec497810b5cfa0a7191\", \"Nodekey\": \"51fbf8274352fe6d39dbe99be75b13a2a882af210e84ea16935a5b52aa68c662\", \"NodeInfo\": \"enode://0e6118122721993e84da84416cb9752a4b5c1b0077a915eb89d0cdff00862c3f13d9edc676c583997f6d9051245ba0f5587750d09d04482774a11f6d13a1c43b@0.0.0.0:30303?discport=0\" } { \"Address\": \"0x28cd575468829f98dabe99f22fd6f3f09b658700\", \"Nodekey\": \"e2ebbcdb7a82c3cac3f0d25a14b57f21dd4a2616f6797a73ab51e8c10b522055\", \"NodeInfo\": \"enode://8d510973b1b245cb8cec8369948080b7e5adca90730112739307096ab445182415e92967de7096c013644f4b92025c7e29db23a145040cb3b9d46831fab0e8e2@0.0.0.0:30303?discport=0\" } static-nodes.json [ \"enode://7117f995cdb2d79eb90bc4a575c5f82bbe4aa6ac87f966b18e2e19bd29e728ba9ca85062a6af5c188bb159641392e2ac3559712d9a31e965220659412a4a8c3e@0.0.0.0:30303?discport=0\", \"enode://cb790b57310d70bfb13e417e9dc22f3b0afc0065f4c5babc2f95e3ff75e99d343547585a0b2ad6be6f0497f401e93c16dadec5a68d820cb918fa0255696940f2@0.0.0.0:30303?discport=0\", \"enode://0e6118122721993e84da84416cb9752a4b5c1b0077a915eb89d0cdff00862c3f13d9edc676c583997f6d9051245ba0f5587750d09d04482774a11f6d13a1c43b@0.0.0.0:30303?discport=0\", \"enode://8d510973b1b245cb8cec8369948080b7e5adca90730112739307096ab445182415e92967de7096c013644f4b92025c7e29db23a145040cb3b9d46831fab0e8e2@0.0.0.0:30303?discport=0\" ] genesis.json { \"config\": { \"chainId\": 10, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip150Hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"eip155Block\": 0, \"eip158Block\": 0, \"byzantiumBlock\": 0, \"constantinopleBlock\": 0, \"istanbul\": { \"epoch\": 30000, \"policy\": 0 }, \"txnSizeLimit\": 64, \"isQuorum\": true }, \"nonce\": \"0x0\", \"timestamp\": \"0x5e00998d\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000f89af854947fec892a867a2da2e4f1ae1646c29e40d0d7a5c69465cc0df8e88fa0fbda0337b3e0b10be9c27325c394786083c93b12404fd4100ec497810b5cfa0a71919428cd575468829f98dabe99f22fd6f3f09b658700b8410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x1\", \"mixHash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"28cd575468829f98dabe99f22fd6f3f09b658700\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" }, \"65cc0df8e88fa0fbda0337b3e0b10be9c27325c3\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" }, \"786083c93b12404fd4100ec497810b5cfa0a7191\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" }, \"7fec892a867a2da2e4f1ae1646c29e40d0d7a5c6\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } 查看生成的文件 $ ls -l total 24 drwxr-xr-x 2 shuzang shuzang 4096 Dec 23 18:40 0 drwxr-xr-x 2 shuzang shuzang 4096 Dec 23 18:40 1 drwxr-xr-x 2 shuzang shuzang 4096 Dec 23 18:40 2","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:6:1","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["研究生的区块链学习之路"],"content":"6.2 树莓派 以 raspberry pi 3B+ 为例，介绍添加节点到当前网络的操作，raspberry pi 3B 操作相似。 在台式电脑中创建节点工作目录 $ mkdir node4 进入工作目录，生成相关文件 $ cd node4 $ ../istanbul-tools/build/bin/istanbul setup --num 1 --verbose --quorum --save validators { \"Address\": \"0x93b770a0d6f1b4eb8a96daf8a3f1e9a2d860696c\", \"Nodekey\": \"244857df9699fab362c80864888a497caa5d98d48cd87a9cebd12696fcb0289b\", \"NodeInfo\": \"enode://195c4a09528db47ba3625cbb21de2c8f0f15cf1a821a95e2decd46837369e7b1d192a7108b627a3840ece306baba38ca6c11ab0dc236a3542bc56ab9204eb75e@0.0.0.0:30303?discport=0\" } genesis.json { \"config\": { \"chainId\": 10, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip150Hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"eip155Block\": 0, \"eip158Block\": 0, \"byzantiumBlock\": 0, \"constantinopleBlock\": 0, \"istanbul\": { \"epoch\": 30000, \"policy\": 0 }, \"txnSizeLimit\": 64, \"isQuorum\": true }, \"nonce\": \"0x0\", \"timestamp\": \"0x5e00afc6\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000f85ad59493b770a0d6f1b4eb8a96daf8a3f1e9a2d860696cb8410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x1\", \"mixHash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"93b770a0d6f1b4eb8a96daf8a3f1e9a2d860696c\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } 将产生的节点信息添加到node0目录的static-nodes.json文件，设置 IP 地址和端口号 [ \"enode://7117f995cdb2d79eb90bc4a575c5f82bbe4aa6ac87f966b18e2e19bd29e728ba9ca85062a6af5c188bb159641392e2ac3559712d9a31e965220659412a4a8c3e@192.168.191.2:30300?discport=0\", \"enode://cb790b57310d70bfb13e417e9dc22f3b0afc0065f4c5babc2f95e3ff75e99d343547585a0b2ad6be6f0497f401e93c16dadec5a68d820cb918fa0255696940f2@192.168.191.2:30301?discport=0\", \"enode://0e6118122721993e84da84416cb9752a4b5c1b0077a915eb89d0cdff00862c3f13d9edc676c583997f6d9051245ba0f5587750d09d04482774a11f6d13a1c43b@192.168.191.2:30302?discport=0\", \"enode://8d510973b1b245cb8cec8369948080b7e5adca90730112739307096ab445182415e92967de7096c013644f4b92025c7e29db23a145040cb3b9d46831fab0e8e2@192.168.191.2:30303?discport=0\", \"enode://195c4a09528db47ba3625cbb21de2c8f0f15cf1a821a95e2decd46837369e7b1d192a7108b627a3840ece306baba38ca6c11ab0dc236a3542bc56ab9204eb75e@192.168.191.3:30303?discport=0\" ] 复制已运行区块链的static-nodes.json和genesis.json文件到当前节点相应目录 $ cp ../node0/genesis.json . 复制新的static-nodes.json文件到所有节点的data目录 $ mkdir -p data/geth $ cp ../node0/static-nodes.json data $ cd .. $ cp node0/static-nodes.json node0/data $ cp node0/static-nodes.json node1/data $ cp node0/static-nodes.json node2/data $ cp node0/static-nodes.json node3/data 复制之前生成的 nodekey 到新节点工作目录的geth目录 $ cd node4 $ cp 0/nodekey data/geth 利用 win10 的远程桌面连接(xrdp已安装)或者 ftp 等文件(vsftpd已安装)传输协议，将 node4 整个工作目录复制到 raspberry pi 3B+ 中 生成节点账户并记录账户地址 $ cd node4 $ geth --datadir data account new 初始化节点 $ geth --datadir data init genesis.json 创建 start.sh 脚本用于启动节点，脚本基本内容如下 #!/bin/bash PRIVATE_CONFIG=ignore nohup geth --datadir data --nodiscover --istanbul.blockperiod 5 --syncmode full --verbosity 5 --networkid 10 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,istanbul --ws --wsorigins=\"*\" --wsaddr 0.0.0.0 --wsport 8545 --emitcheckpoints --port 30303 2\u003e\u003enode.log \u0026 授予 start.sh 脚本执行权限，执行该脚本 .... 跳转到脚本所在目录 $ sudo chmod +x start.sh $ ./start.sh 执行完后查找 geth 进程是否启动，并执行geth attach命令接入 geth 控制台 $ ps | grep geth 16877 pts/0 00:00:01 geth 接下来可在任一设备的节点目录下通过 websocket 进行操作。 至此利用 Quorum 搭建私链网络完毕，用作之后的实验平台，接下来进行交易验证、合约部署和测试。 ","date":"2019-10-02","objectID":"/2019/build-quorum-private-blockchain-network/:6:2","tags":["科研记录"],"title":"研究记录6-Quorum区块链实验平台搭建","uri":"/2019/build-quorum-private-blockchain-network/"},{"categories":["爱编程爱技术的孩子"],"content":"学习一些更高级或更有趣的 Git 用法，包括子模块、徽章、开源协议选择等。 ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:0:0","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 开源协议 代码的开源协议比较多，这里附一张阮一峰大神的图片说明如何选择。 ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:1:0","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 子模块 当我们在一个 Git 项目上工作时，有时候需要在其中使用另外一个 Git 项目。这个情况可以在 Git 中使用子模块 submodule 来进行管理。submodule 允许我们将一个 Git 仓库当作另外一个 Git 仓库的子目录。这允许我们克隆另外一个仓库到自己的项目中并且保持我们的提交相对独立。 Hugo 的博客源码文件中，主题的源码就是作为子模块进行添加和管理。本文中以本地项目 blog 为例，将远程主题项目 LoveIt 作为子模块进行管理。 ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:2:0","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 添加子模块 将远程项目 LoveIt 克隆到本地 blog/themes 文件夹，blog 需要本身就是一个 Git 项目 $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 添加子模块后运行git status, 可以注意增加了一个文件 .gitmodules, $ git status On branch master Your branch is up to date with 'origin/master'. Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) new file: .gitmodules new file: themes/LoveIt 这个文件用来保存子模块的信息。 [submodule \"themes/LoveIt\"] path = themes/LoveIt url = https://github.com/dillonzq/LoveIt.git ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:2:1","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 查看子模块 $ git submodule bf7c4b5173c3baba02b87a410ce04909c1b86cf6 themes/LoveIt (v0.1.4) ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:2:2","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 更新子模块 作为子模块的主题经常需要追随远程更新，这也是最常见的一种情况，即只使用子项目并不时获取更新，而不在子项目中做任何更改。 最容易的方式是添加参数 --remote，Git 会进入子模块然后抓取并更新 $ git submodule update --remote 该命令假设我们想要更新子模块仓库的 master 分支，如果想要设置为其它的分支，可以在 .gitmodules 中进行设置 $ git config -f .gitmodules submodule.themes/LoveIt.branch develop $ git submodule update --remote Submodule path 'themes/LoveIt': checked out 'b6ce753ae7892839899962b879e2cc5808c60732' 使用 git diff 可以查看到变动，.gitmodules多了一行，子模块的分支号有了变动 $ git diff diff --git a/.gitmodules b/.gitmodules index a6f32d0..5376abf 100644 --- a/.gitmodules +++ b/.gitmodules @@ -1,3 +1,4 @@ [submodule \"themes/LoveIt\"] path = themes/LoveIt url = https://github.com/dillonzq/LoveIt.git + branch = develop diff --git a/themes/LoveIt b/themes/LoveIt index bf7c4b5..b6ce753 160000 --- a/themes/LoveIt +++ b/themes/LoveIt @@ -1 +1 @@ -Subproject commit bf7c4b5173c3baba02b87a410ce04909c1b86cf6 +Subproject commit b6ce753ae7892839899962b879e2cc5808c60732 当运行 git submodule update --remote 时，Git 默认会尝试更新 所有 子模块， 所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。比如 $ git submodule update --remote themes/LoveIt ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:2:3","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 克隆包含子模块的项目 如果像下面这样直接克隆包含子模块的项目，虽然有子模块目录，但是是空的 $ git clone https://github.com/shuzang/blog.git $ cd blog $ ls themes/LoveIt $ 查看子模块时前面有一个-，也说明子模块文件还未检入（空文件夹）。 $ git submodule -87c33888f3fa86b8cc096bc3f6d7f2efe9ccba66 themes/KeepIt 此时需要运行两个命令，git submodule init 用来初始化子模块 $ git submodule init Submodule 'themes/KeepIt' (https://github.com/Fastbyte01/KeepIt.git) registered for path 'themes/KeepIt' git submodule update 用来抓取数据 $ git submodule update Cloning into 'C:/Users/lylw1/Desktop/blog/themes/KeepIt'... Submodule path 'themes/KeepIt': checked out '87c33888f3fa86b8cc096bc3f6d7f2efe9ccba66' 不过有一个更简单的方法，就是给 git clone 命令传递 --recurse-submodules 参数，这样就会自动初始化并更新仓库中每一个子模块，包括可能存在的嵌套子模块 $ git clone https://github.com/shuzang/blog.git --recurse-submodules ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:2:4","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"2.5 修改子模块 在子模块中修改文件后，直接提交到远程项目分支。 $ git add . $ git commit -m \"modify submodule\" $ git push origin master ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:2:5","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"2.6 删除子模块 之前从网上找到的办法是，手动删除相关的文件，以删除KeepIt文件夹为例 删除子模块文件夹 $ git rm --cached themes/KeepIt $ rm -rf themes/KeepIt 删除.gitmodules文件中相关子模块信息 [submodule \"themes/KeepIt\"] path = themes/KeepIt url = https://github.com/Fastbyte01/KeepIt.git 删除.git/config中的相关子模块信息 [submodule \"themes/KeepIt\"] url = https://github.com/Fastbyte01/KeepIt.git 删除.git文件夹中的相关子模块文件 $ rm -rf .git/modules/themes/KeepIt 不过实际上，这是一种比较野的做法，不建议使用。根据官方文档的说明，应该使用 git submodule deinit 命令卸载一个子模块。这个命令如果添加上参数 --force，则子模块工作区内即使有本地的修改，也会被移除。 $ git submodule deinit themes/LoveIt $ git rm themes/LoveIt 执行 deinit 的效果，是自动在 .git/config 中删除了如下信息 [submodule \"themes/LoveIt\"] url = https://github.com/dillonzq/LoveIt.git 执行 rm 的效果，是移除了 themes/LoveIt 文件夹，并删除了 .gitmodules 中的相关内容 此时关于子模块的信息基本已经删除完毕，只剩 .git/modules 下还有一些残留，但执行 commit 后残留会被删除 $ git commit -m \"delete submodule themes/LoveIt\" ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:2:6","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 徽章 逛github的时候，经常能在 README.md 页面看到如下所示的徽章，通常展示了项目的相关信息，这种形式比单纯的文字描述更加吸引人，今天就来学一学如何在项目中插入这些徽章。 ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:3:0","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 徽章简介 GitHub 项目的 README.md 中可以添加徽章（Badge）对项目进行标记和说明，这些好看的小图标不仅简洁美观，而且还包含了清晰易读的信息。 这些徽标的本质仍然是图片，并没有脱离markdwon语法的限制。其基本原理是，徽标的官方网站shields.io提供了一批“标签小程序”，它们可以抓取一些github项目的动态数据并自动生成标签图片，比如抓取github上项目的最新release版本号生成release标签等。使用这种标签能够保证每次刷新网页都会重新抓取数据，并且更新标签上的文字，这样就实现了动态变化的徽章标签。 徽标图片的话一般由左半部分的名称和右半部分的值组成，徽章则主要由图片和对应的链接（链接可以不填）组成，如下所示，正是github上git项目的唯一徽标的格式，前半部分的方括号里的是图片，后半部分的圆括号里的是链接。 [![Build Status](https://dev.azure.com/git/git/_apis/build/status/git.git)](https://dev.azure.com/git/git/_build/latest?definitionId=11) 也可以点击这里看一下Git项目中该徽章表现形式，当然，正式使用时可以在官网shields.io中可以预览徽标样式，然后选择自己喜欢的徽标添加到项目中。 注：徽章不是添加的越多越好，因为徽章的根本作用还是清晰易懂的说明项目相关信息，合理地选择适合项目地徽标做针对性地添加才是理性地做法。 ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:3:1","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 徽章添加 我们进入shields.io的Version标签页，点开GitHub release这一条的链接，如下： 会看到如下界面 在which中选择release或release-pre，在user下填入用户名，在repo下填入项目名，以Tencent的tinker项目为例，徽章预览如图所示，点击下面的Copy Badge URL即可复制链接。然后放到README中使用即可。 注：style中可以选择徽章形式，链接复制有适用于markdown或其它文本等四种形式。 ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:3:2","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 自定义徽章 如果想要生成的徽章字样和颜色shields没有，shields.io也支持自定义一个自己想要的徽章，从主页拉到Your Badge部分，如下图 在上图中的框中填入相关信息，三条横线从前到后依次是label,message,color，color有选项可以选择，上图的预览样式如下： ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:3:3","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 常用徽章 项目下载量 项目被下载地次数，各平台统计独立，详见 shields.io 的 Downloads 一栏，图标示例如下 项目支持平台 详见 shields.io 的 Platform \u0026 Version Support 一栏，图标示例如下 项目语言 即项目所用编程语言，通过自定义徽标实现，图标示例如下： 开源协议类型 详见 shields.io 的 License 一栏，图标示例如下 还有其它很多，shields首页标签栏从build,Downloads到Other共提供了17类，还可以自定义标签。 ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:3:4","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"参考文献 [1] EyreFree. GitHub项目徽章地添加与设置. https://juejin.im/post/5a32157c6fb9a0450b6667ac. 2017.12. [2] AnSwEr不是答案. Github徽章整理. https://blog.csdn.net/u011192270/article/details/51788886. 2016.06. [3] ShikiEiki. 为你地Github README生成漂亮地徽章和进度条. 2017.03. [4] Shields项目. https://github.com/badges/shields. [5] 知乎-孤单彼岸. Git中submodule的使用. 2019-10-17 [6] Git文档. Git工具-子模块. 2nd Edition. ","date":"2019-09-30","objectID":"/2019/git-learning-deep-into/:4:0","tags":["git"],"title":"Git深入-子模块, 徽章, 开源协议","uri":"/2019/git-learning-deep-into/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 基础知识 通过一个简单的主题开发流程，理解需要的基本知识，为自己进行主题修改和美化打基础，这里参考create a new theme一文。 ","date":"2019-09-30","objectID":"/2019/hugo-blog-theme-beautify/:1:0","tags":["Hugo"],"title":"hugo搭建个人博客4-主题美化","uri":"/2019/hugo-blog-theme-beautify/"},{"categories":["爱编程爱技术的孩子"],"content":"开发准备 Ubuntu安装hugo $ snap install hugo --channel=extended hugo (extended/stable) 0.58.3 from Hugo Authors installed 该命令将安装extendedSass/SCSS版本(apt-get 安装的hugo版本较低) 建立博客文件 $ hugo new site newTheme $ ls -l total 28 drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 15:52 archetypes -rw-r--r-- 1 shuzang shuzang 82 Sep 25 15:52 config.toml drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 15:52 content drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 15:52 data drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 15:52 layouts drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 15:52 static drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 15:52 themes 创建主题 $ hugo new theme LeaveIt $ find themes -type f | xargs ls -l -rw-r--r-- 1 shuzang shuzang 8 Sep 25 16:09 themes/LeaveIt/archetypes/default.md -rw-r--r-- 1 shuzang shuzang 0 Sep 25 16:09 themes/LeaveIt/layouts/404.html -rw-r--r-- 1 shuzang shuzang 0 Sep 25 16:09 themes/LeaveIt/layouts/_default/list.html -rw-r--r-- 1 shuzang shuzang 0 Sep 25 16:09 themes/LeaveIt/layouts/_default/single.html -rw-r--r-- 1 shuzang shuzang 0 Sep 25 16:09 themes/LeaveIt/layouts/index.html -rw-r--r-- 1 shuzang shuzang 0 Sep 25 16:09 themes/LeaveIt/layouts/partials/footer.html -rw-r--r-- 1 shuzang shuzang 0 Sep 25 16:09 themes/LeaveIt/layouts/partials/header.html -rw-r--r-- 1 shuzang shuzang 1081 Sep 25 16:09 themes/LeaveIt/LICENSE.md -rw-r--r-- 1 shuzang shuzang 436 Sep 25 16:09 themes/LeaveIt/theme.toml find themes -type f将themes目录及其子目录的所有一般文件列出 xargs ls -l在find命令基础上列出这些文件的基本信息 LeaveIt 包含 templates (以 .html为后缀的文件), license 文件, 主题描述 (theme.toml 文件), 和一个空的archetype. license文件默认填充MIT协议 根据引号中的描述编辑theme.toml文件，声明主题基本信息，参照hugoThemes的说明 $ nano themes/LeaveIt/theme.toml name = \"Theme Name\" license = \"MIT\" licenselink = \"Link to theme's license\" description = \"Theme description\" homepage = \"Website of your theme\" tags = [\"blog\", \"company\"] features = [\"some\", \"awesome\", \"features\"] min_version = \"0.57.0\" [author] name = \"Your name\" homepage = \"Your website\" # If porting an existing theme [original] author = \"Name of original author\" homepage = \"His/Her website\" repo = \"Link to source code of original theme\" 编辑config.toml文件，在文件名添加theme字段，启用主题 $ nano config.toml baseURL = \"http://example.org/\" languageCode = \"en-us\" title = \"My New Hugo Site\" theme = \"LeaveIt\" 重新生成网站，public文件夹和themes/LeaveIt都将生成js和css文件夹用于控制格式 $ hugo --verbose $ ls -l public total 24 drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 15:56 categories drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 16:09 css -rw-r--r-- 1 shuzang shuzang 468 Sep 25 16:43 index.xml drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 16:09 js -rw-r--r-- 1 shuzang shuzang 437 Sep 25 16:43 sitemap.xml drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 15:56 tags $ find themes/LeaveIt -type d | xargs ls -ld drwxr-xr-x 5 shuzang shuzang 4096 Sep 25 16:32 themes/LeaveIt drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 16:09 themes/LeaveIt/archetypes drwxr-xr-x 4 shuzang shuzang 4096 Sep 25 16:09 themes/LeaveIt/layouts drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 16:09 themes/LeaveIt/layouts/_default drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 16:09 themes/LeaveIt/layouts/partials drwxr-xr-x 4 shuzang shuzang 4096 Sep 25 16:09 themes/LeaveIt/static drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 16:09 themes/LeaveIt/static/css drwxr-xr-x 2 shuzang shuzang 4096 Sep 25 16:09 themes/LeaveIt/static/js ","date":"2019-09-30","objectID":"/2019/hugo-blog-theme-beautify/:1:1","tags":["Hugo"],"title":"hugo搭建个人博客4-主题美化","uri":"/2019/hugo-blog-theme-beautify/"},{"categories":["爱编程爱技术的孩子"],"content":"开发流程 删除public文件夹，执行hugo server命令并添加–watch参数，打开浏览器查看网站，修改主题文件，浏览器页面将会实时更改 建议：不要直接在主题上开发，使用git，在开发分支开发，确认功能无误后合并到主分支 # 删除public文件夹 $ rm -rf public # 以watch模式实时查看改动 $ hugo server --watch --verbose 更新Home Page 模板，位于layout/目录下： index.html _default/list.html _default/single.html 现在，模板文件是空的，添加以下内容到模板文件 $ nano themes/LeaveIt/layouts/index.html \u003chtml\u003e \u003cbody\u003e \u003cp\u003ehugo says hello!\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 浏览器将显示p标签中的语句 hugo中有三种类型的模板，home页面模板刚刚已修改，single类型的模板用于生成单个内容的文件，list类型的模板用于生成多个内容的文件，即single.html和list.html 还存在partial，content views和terms三种类型的模板，这里不做详细介绍。 更新index.html使之能显示主页 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e {{ range first 10 .Data.Pages }} \u003ch1\u003e{{ .Title }}\u003c/h1\u003e {{ end }} \u003c/body\u003e \u003c/html\u003e hugo使用Go模板引擎，引擎将扫描模板文件中”{{“和”}}“中间的命令内容并执行，上面的index.html文件中包含三个命令 range .Title end range是迭代器，用于遍历前十个page，hugo创建的每个html文件都属于page，所以遍历pages将查看创建的每个文件 .Title打印title变量的值，hugo从markdown文件前面的格式说明中获取该值 end结束range开启的迭代 hugo会在创建html文件前将所有内容加载到变量中，然后模板对其进行处理 因此，更新后的index.html文件将显示first.md和second.md两篇博文的标题 到此开发一个主题的所有知识就全部介绍完毕了，剩下的就是熟悉Go模板的命令及使用它。但这里还有一些内容可以令我们更容易地创建模板 修改single.html文件使之展示博文内容 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e{{ .Title }}\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e{{ .Title }}\u003c/h1\u003e {{ .Content }} \u003c/body\u003e \u003c/html\u003e 修改index.html为博文标题标题添加链接 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e {{ range first 10 .Data.Pages }} \u003ch1\u003e\u003ca href=\"{{ .Permalink }}\"\u003e{{ .Title }}\u003c/a\u003e\u003c/h1\u003e {{ end }} \u003c/body\u003e \u003c/html\u003e 在content目录创建about.md文件，作为主页面顶级菜单 +++ title = \"about\" description = \"about this site\" date = \"2014-09-27\" slug = \"about time\" +++ ## about us i'm speechless 浏览器主页面将显示about菜单，单击即可跳转查看其内容，但它和博文标题放在一起，因此修改index.html文件 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003ch1\u003eposts\u003c/h1\u003e {{ range first 10 .Data.Pages }} {{ if eq .Type \"post\"}} \u003ch2\u003e\u003ca href=\"{{ .Permalink }}\"\u003e{{ .Title }}\u003c/a\u003e\u003c/h2\u003e {{ end }} {{ end }} \u003ch1\u003epages\u003c/h1\u003e {{ range .Data.Pages }} {{ if eq .Type \"page\" }} \u003ch2\u003e\u003ca href=\"{{ .Permalink }}\"\u003e{{ .Title }}\u003c/a\u003e\u003c/h2\u003e {{ end }} {{ end }} \u003c/body\u003e \u003c/html\u003e 主页面将分两部分显示：博文和页面。并链接到不同的页面。 改变配置文件中的permalinks，设置页面名 [permalinks] page = \"/:title/\" about = \"/:filename/\" 如果模板文件存在重叠，可以把重叠部分以共享模板的形式放在themes/LeaveIt/layouts/partials/目录。通常，模板文件引用都会有一个指定的路径，但是partials没有，hugo会沿着TODO定义的搜索路径去使用，因此可以编辑这里的内容来覆盖主题的表达。 $ vi themes/LeaveIt/layouts/partials/header.html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e{{ .Title }}\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e $ vi themes/LeaveIt/layouts/partials/footer.html \u003c/body\u003e \u003c/html\u003e partials和普通模板调用的不同是没有路径，比如 {{ template \"theme/partials/header.html\" . }} vs {{ partial \"header.html\" . }} 更新index.html文件内容 {{ partial \"header.html\" . }} \u003ch1\u003eposts\u003c/h1\u003e {{ range first 10 .Data.Pages }} {{ if eq .Type \"post\"}} \u003ch2\u003e\u003ca href=\"{{ .Permalink }}\"\u003e{{ .Title }}\u003c/a\u003e\u003c/h2\u003e {{ end }} {{ end }} \u003ch1\u003epages\u003c/h1\u003e {{ range .Data.Pages }} {{ if or (eq .Type \"page\") (eq .Type \"about\") }} \u003ch2\u003e\u003ca href=\"{{ .Permalink }}\"\u003e{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u003c/a\u003e\u003c/h2\u003e {{ end }} {{ end }} {{ partial \"footer.html\" . }} 更新single.html文件 {{ partial \"header.html\" . }} \u003ch1\u003e{{ .Title }}\u003c/h1\u003e {{ .Content }} {{ partial \"footer.html\" . }} 此时浏览器中主页面about菜单将额外展示类型和标题 更新single.html文件，添加对博文日期的渲染 {{ partial \"header.html\" . }} \u003ch1\u003e{{ .Title }}\u003c/h1\u003e \u003ch2\u003e{{ .Date.Format \"Mon, Jan 2, 2006\" }}\u003c/h2\u003e {{ .Content }} {{ partial \"footer.html\" . }} 此时浏览器博文页面将展示创建日期 有多种方式使日期只展示在博文页面中，一种是在index.html中添加if条件语间，另一种是为博文创建单独的模板。当主题比较复杂时，创建针对博文的单独模板 $ mkdir themes/LeaveIt/layouts/post $ nano themes/LeaveIt/layouts/_default/single.html {{ partial \"header.html\" . }} \u003ch1\u003e{{ .Title }}\u003c/h1\u003e {{ .Content }} {{ partial \"footer.html\" . }} $ nano themes/LeaveIt/layouts/post/single.html {{ partial \"header.html\" . }} \u003ch1\u003e{{ .Title }}\u003c/h1\u003e \u003ch2\u003e{{ .Date.Format \"Mon, Jan 2, 2006\" }}\u003c/h2\u003e {{ .Content }} {{ partial \"footer.html\" . }} 移除了默认的single模板中对日期的指定，而在post的single模板添加 至此对主题的基本结构有了了解，接下来应该进一步学习Hugo中Go模板的语法，参见Introduction to Go Templates 注意，以下的调整都是对原主题样式的调整，需要修改主题源码，因此最好clone主题仓库进行开发。 ","date":"2019-09-30","objectID":"/2019/hugo-blog-theme-beautify/:1:2","tags":["Hugo"],"title":"hugo搭建个人博客4-主题美化","uri":"/2019/hugo-blog-theme-beautify/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 调整引用样式 主题原有的引用样式如下 引用样式示例 修改assets/css/_common/_core/base.scss文件如下调整引用样式 } blockquote { - font-size: 1rem; - display: block; - border-width: 1px 0; - border-style: solid; - border-color: $light-border-color; - padding: 1.5em 1.2em 0.5em 1.2em; - margin: 0 0 2em 0; - position: relative; - - \u0026:before { - content: '\\201C'; - position: absolute; - top: 0em; - left: 50%; - transform: translate(-50%, -50%); - width: 3rem; - height: 2rem; - font: 6em/1.08em 'PT Sans', sans-serif; - color: $light-post-link-color; - text-align: center; - - .dark-theme \u0026{ - color: $dark-post-link-color; - } - } - \u0026:after { - content: \"#blockquote\" attr(cite); - display: block; - text-align: right; - font-size: 0.875em; - color: $light-post-link-color; - - .dark-theme \u0026{ - color: $dark-post-link-color; - } - } + font: 14px/22px normal helvetica, sans-serif; + margin-top: 10px; + margin-bottom: 10px; + margin-left: 2%; + margin-right: 0%; + padding-left: 15px; + padding-top: 10px; + padding-right: 10px; + padding-bottom: 10px; + border-left: 3px solid #ccc; + background-color:#f1f1f1; .dark-theme \u0026 { - border-color: $dark-border-color; + background-color:#252529; } } ","date":"2019-09-30","objectID":"/2019/hugo-blog-theme-beautify/:2:0","tags":["Hugo"],"title":"hugo搭建个人博客4-主题美化","uri":"/2019/hugo-blog-theme-beautify/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 添加阅读进度条 首先在layouts/partials/header.html文件中如下所示插入代码 \u003cnav class=\"navbar\"\u003e + {{ if (and .IsPage (not .Params.notsb)) }} + \u003cdiv class=\"top-scroll-bar\"\u003e\u003c/div\u003e + {{ end }} \u003cdiv class=\"container\"\u003e \u003cdiv class=\"navbar-header header-logo\"\u003e \u003ca href=\"{{ .Site.BaseURL }}\"\u003e{{ .Site.Title }}\u003c/a\u003e @@ -13,7 +16,10 @@ \u003c/div\u003e \u003c/nav\u003e \u003cnav class=\"navbar-mobile\" id=\"nav-mobile\" style=\"display: none\"\u003e + {{ if (and .IsPage (not .Params.notsb)) }} + \u003cdiv class=\"top-scroll-bar\"\u003e\u003c/div\u003e + {{ end }} \u003cdiv class=\"container\"\u003e \u003cdiv class=\"navbar-header\"\u003e \u003cdiv\u003e \u003ca href=\"javascript:void(0);\" class=\"theme-switch\"\u003e\u003ci class=\"iconfont icon-sun\"\u003e\u003c/i\u003e\u003c/a\u003e\u0026nbsp;\u003ca href=\"{{.Site.BaseURL}}\"\u003e{{ .Site.Title }}\u003c/a\u003e\u003c/div\u003e \u003cdiv class=\"menu-toggle\"\u003e 然后在assets/css/_cusstom.scss文件中添加进度条样式 // 顶部阅读进度条 .top-scroll-bar { position: fixed; top: 0; left: 0; z-index: 9999; display: none; width: 0; height: 3px; background: #ef3982; } 之后新建一个 js 脚本文件 assets/js/_custom.js ，来控制进度条 // 顶部阅读进度条 $(document).ready(function () { $(window).scroll(function(){ $(\".top-scroll-bar\").attr(\"style\", \"width: \" + ($(this).scrollTop() / ($(document).height() - $(this).height()) * 100) + \"%; display: block;\"); }); }); 最后， js 脚本引入到博客中，使其生效。 在 /layouts/partials/js.html 文件中添加以下内容，然后将 $custom 加入到变量 $vendorscript 中 {{ $custom := resources.Get \"/js/_custom.js\" }} 重新编译后预览博客就可以看到阅读进度条了。 ","date":"2019-09-30","objectID":"/2019/hugo-blog-theme-beautify/:3:0","tags":["Hugo"],"title":"hugo搭建个人博客4-主题美化","uri":"/2019/hugo-blog-theme-beautify/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 添加侧边栏目录 原本LeaveIt主题不支持文章目录导航，可以按如下方法添加，但样式不是很合适 首先在/assets/css/_custom.scss添加侧边栏目录(toc)样式 // 添加toc栏 .post-toc { position: absolute; width: 200px; margin-left: 800px; padding: 10px; word-wrap: break-word; box-sizing: border-box; .post-toc-title { margin: 0; font-weight: 400; text-transform: uppercase; } .post-toc-content { \u0026.always-active ul { display: block; } \u003enav\u003eul { margin: 10px 0; } ul { padding-left: 0; list-style: none; ul { padding-left: 15px; display: none; } .has-active \u003e ul { display: block; } } } a:hover { color: #c05b4d; -webkit-transform: scale(1.1); -ms-transform: scale(1.1); transform: scale(1.1); } a { display: block; line-height: 30px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; -webkit-transition-duration: .2s; transition-duration: .2s; -webkit-transition-property: -webkit-transform; transition-property: -webkit-transform; transition-property: transform; transition-property: transform,-webkit-transform; -webkit-transition-timing-function: ease-out; transition-timing-function: ease-out; } } @media only screen and (max-width: 1224px) { .post-toc { display: none; } } 然后在 layouts/partials/ 下新建 toc.html 文件，内容如下 \u003cdiv class=\"post-toc\" id=\"post-toc\"\u003e \u003ch2 class=\"post-toc-title\"\u003e{{ T \"toc\" }}\u003c/h2\u003e {{ $globalAutoCollapseToc := .Site.Params.autoCollapseToc | default false }} \u003cdiv class=\"post-toc-content{{ if not (or .Params.autoCollapseToc (and $globalAutoCollapseToc (ne .Params.autoCollapseToc false))) }} always-active{{ end }}\"\u003e {{.TableOfContents}} \u003c/div\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e window.onload = function () { var fix = $('.post-toc'); var end = $('.post-comment'); var fixTop = fix.offset().top, fixHeight = fix.height(); var endTop, miss; var offsetTop = fix[0].offsetTop; $(window).scroll(function () { var docTop = Math.max(document.body.scrollTop, document.documentElement.scrollTop); if (end.length \u003e 0) { endTop = end.offset().top; miss = endTop - docTop - fixHeight; } if (fixTop \u003c docTop) { fix.css({ 'position': 'fixed' }); if ((end.length \u003e 0) \u0026\u0026 (endTop \u003c (docTop + fixHeight))) { fix.css({ top: miss }); } else { fix.css({ top: 0 }); } } else { fix.css({ 'position': 'absolute' }); fix.css({ top: offsetTop }); } }) } \u003c/script\u003e 在文章页的模板 layouts/_default/single.html 中\u003c/header\u003e标签后引入toc模板 {{ if ( .Site.Params.toc | default true ) }} {{ partial \"toc.html\" . }} {{ end }} 添加后重新使用hugo生成静态页面，只要文章有多级标题，就能在侧边栏看到导航目录 最后在站点配置文件config.toml中添加如下配置 toc = true # 是否开启目录 autoCollapseToc = true # Auto expand and collapse toc ","date":"2019-09-30","objectID":"/2019/hugo-blog-theme-beautify/:4:0","tags":["Hugo"],"title":"hugo搭建个人博客4-主题美化","uri":"/2019/hugo-blog-theme-beautify/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 图片添加阴影 在 assets/css/style.scss中添加以下代码 // 图片阴影 .post-content { img { box-shadow: 0 0 15px 5px rgba(0, 0, 0, .28); max-width: 1080px; } } ","date":"2019-09-30","objectID":"/2019/hugo-blog-theme-beautify/:5:0","tags":["Hugo"],"title":"hugo搭建个人博客4-主题美化","uri":"/2019/hugo-blog-theme-beautify/"},{"categories":["研究生的区块链学习之路"],"content":"对区块链进行异常检测（Anomaly detection）也是一个重要的方向，不过有的论文中也称作侵入检测（Intrusion detection），尤其是协作入侵检测（Collaborative Intrusion Detection, CID）的概念比较流行。我们虽然在搜索论文时对两种都进行了统计，但在下文说明中统一称呼为「异常检测」。 通过阅读论文，可以大致将该领域的研究分为两个方向，一个是对区块链系统进行异常检测，另一个是利用区块链系统解决异常检测领域的问题，多数为利用区块链存储异常检测的数据。 ","date":"2019-09-27","objectID":"/2019/blockchain-and-anomaly-detection/:0:0","tags":["科研记录"],"title":"研究记录5-区块链与异常检测方向探索","uri":"/2019/blockchain-and-anomaly-detection/"},{"categories":["研究生的区块链学习之路"],"content":"1. 论文查找 以下的论文是从SCI，EI，知网和arvix四个数据库检索得到的，检索的关键词有两种组合： blockchain和anomaly blockchain和intrusion 所有的论文根据数据库进行分类，但排序不分先后。关于CID，很多论文在后面添加系统或网络一词，因此全称为CIDS/CIDN。几篇协同入侵检测但与区块链无关的论文单列在其它分类中。 在每个数据库的搜索结果中，我们又将论文分为三类 综述 对区块链系统进行异常检测 利用区块链系统解决异常检测领域的问题 下面是一些额外的说明 标号规则举例：SCI-1代表SCI检索结果列表的第一篇文章，同样，EI-2代表EI检索结果第二篇文章。 关联性说明：括号中是和研究目标的关联性级别，关联性越强，阅读优先级越高 分类是通过阅读各论文摘要完成的，可能出现错误，在具体阅读论文完毕后，若发现分类错误，将进行修改，添加删除线的为已确认分类的论文 EI-11和EI-16两篇，SCI-8和SCI-9两篇都极为相似，可不必重复阅读 类别 论文列表 综述 - SCI-4：比特币系统存在的安全威胁及解决方案（弱） - ~~SCI-11：区块链和入侵检测交叉综述（强）~~ - EI-13：从四个维度分析区块链，其中有一个是入侵检测（中） - EI-17：详细介绍了区块链和入侵检测的情况（强） 对区块链进行异常检测 - SCI-3(强)；SCI-12(强)；SCI-10(强) - EI-1(强)；EI-2；EI-3(强)；EI-5(中)；EI-9(强)；EI-12(中)；EI-18(强) - arvix-1(强)；arvix-2；arvix-3 利用区块链解决异常检测领域的问题 - SCI-5(中)；SCI-7 - EI-9；EI-10；EI-11；EI-12；EI-14；EI-15；EI-16 - 区块链存储异常检测的数据： SCI-1(中)；SCI-6(弱)；SCI-8(中)；SCI-9； EI-4(中)；EI-6(弱)；EI-7(弱) - 智能合约定义异常检测算法：SCI-2(强) ","date":"2019-09-27","objectID":"/2019/blockchain-and-anomaly-detection/:1:0","tags":["科研记录"],"title":"研究记录5-区块链与异常检测方向探索","uri":"/2019/blockchain-and-anomaly-detection/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 论文搜索结果 SCI Chained Anomaly Detection Models for Federated Learning: An Intrusion Detection Case Study 攻击者越来越擅长将恶意行为数据隐藏到正常行为数据中，异常检测的时间逐渐增加，为了解决这一问题，采用联邦学习来监测数据。这种方法主要的难题在于联邦学习的过程中攻击者容易添加恶意训练样本影响本地的机器学习模型，从而规避检测，因此，作者使用区块链来存储联邦学习模型的增量数据，从而可审计模型数据的正确性。 Collaborative Anomaly Detection on Blockchain from Noisy Sensor Data 提出了一种框架用于区块链的协作异常检测，以condition-based的工业资产管理为例，从传感器数据中检测工业资产的异常。将区块链看作一个协作学习的平台而不仅仅是一个可追踪、不可变和分布式的数据管理系统，主要是把机器学习的异常检测算法定义在智能合约中，通过区块链的共识运行完成完整的异常检测过程。 Securing Majority-Attack in Blockchain Using Machine Learning and Algorithmic Game Theory: A Proof of Work 多数人攻击(majority-attack)对公链来说不是威胁，但对于私链/联盟链来讲，可能会有部分节点串通作恶。这篇文章的作者提出使用智能软件代理来监控区块链网络中利益相关者的活动，从容检测节点串通作恶。主要使用的是监督机器学习算法和算法博弈理论来阻止多数人作恶的发生。 Bitcoin Concepts, Threats, and Machine-Learning Security Solutions 介绍比特币系统及其主要技术（包括区块链协议）的现有威胁和弱点，总结现有的安全研究和解决方案，提出面临的挑战和未来的研究趋势。 Transaction Immutability and Reputation Traceability: Blockchain as a Platform for Access-controlled IoT and Human Interactivity 解决通信双方的信任问题，其中一种方法是区块链异常检测与评估 Seeing is understanding - anomaly detection in blockchains with visualized features 提出针对可交互性优化的用于异常检测的在线机器学习方法，将系统特性以图形方式表达，适用于任何时间序列的数据，数据存储在以太坊区块链中保证不可篡改。 A Collaborative Intrusion Detection Approach Using Blockchain for Multimicrogrid Systems 实例场景：Multimicrogrid(mmg) 系统，设计了一种使用区块链的协作入侵检测（CID）用于保护该系统安全，不需要可信权威和中心服务器，同时以协作方式提高了检测准确性。它结合了周期性和触发性模式来生成CID目标，即提案生成。根据生成的提案和mmg模型，利用共识实现CID。最终的结果存在区块链上，使用激励机制促进单个微电网参与共识。最后通过一个mmg实例分析了方法有效性。 Designing collaborative blockchained signature-based intrusion detection in IoT environments 应对协作入侵检测签名伪造的情况，通过区块链增量更新可信签名数据库，增强基于签名的CID的有效性。 CBSigIDS: Towards Collaborative Blockchained Signature-based Intrusion Detection 和第10篇相似 Intrusion Detection and Mitigation System Using Blockchain Analysis for Bitcoin Exchange 比特币使用传统入侵检测系统具有高风险。该文描述了比特币交易中的三种入侵模型，并针对每种入侵模型都提出了一种基于区块链分析的检测和缓解系统。不过这篇文章中提到的三种入侵模型有两种都是关于交易所的，第三种讨论的还是15%攻击，对加密货币型的区块链可能很有用，但对其他类型的就不怎么样了。 When Intrusion Detection Meets Blockchain Technology：A Review 区块链和侵入检测交叉综述，蛮有意思，竟然已经有人写这个了 Anomaly Detection in Bitcoin Network Using Unsupervised Learning Methods 构建了以用户为节点和以交易为节点的两个图，进行特征量提取，并使用K-means、马氏距离和无监督支持向量机三种异常检测算法，检测比特币网络中的可疑交易和可疑用户。 EI Advise: Anomaly Detection tool for blockchain systems 提出用于区块链系统的异常检测工具Advise，利用区块链分叉数据在网络中手机恶意请求，同时抵御eclipse攻击，该系统收集并分析恶意分叉，以构建一个威胁数据库，从而检测和预防未来的攻击。arvix的BAD: a blockchain anomaly detection solution和这个是同一篇，该文是其正式发表的名称。 Anomaly detection model over blockchain electronic transactions 提出一种比特币交易异常检测模型，用支持向量机检测异常值，用k-means分组相似的异常值，通过生成检验结果评估该方案，在精度上得到了高性能的结果。 Blockchain-based auditing of transparent log servers 为了保证用于密钥管理的公钥服务器的可靠性，使用了防篡改的数据结构，并在客户端之间使用了gossip协议（区块链）,但缺乏对恶意客户端的检测。该文使用以太坊区块链进行信任度审计，并提出一种轻量级异常检测算法来保护客户端。(还没具体看论文，不知道说的轻量级异常检测算法是什么) Federated Blockchain-based Tracking and Liability Attribution Framework for Employees and Cyber-physical Objects in a Smart Workplace 一个工业实例，但主要是用区块链保存异常检测数据，利用其不可篡改性提供有效监管。 Securing instant messaging based on blockchain with machine learning 以网购的即时消息通信安全为例，提出一种基于国密的区块链即时通信方案。首先设计了一个消息认证模型用于避免伪造攻击和重放攻击，其次设计了一个加密哈希模式来保护消息完整性，第三，设计了一个消息加密模型来保护用户隐私。最后，提出一种基于机器学习的方法进行区块链异常检测。 Detecting Robotic Anomalies using RobotChain 实例场景：使用区块链保存工厂机器人运行日志，确保这些数据不被篡改，并结合异常检测模块检测这些数据。 Services as Enterprise Smart Contracts in the Digital Factory 以工厂设备预测性维护为例，使用区块链记录设备异常信息。 A Model for Detecting Cryptocurrency Transactions with Discernible Purpose 通过检测加密货币钱包的元数据，识别可疑交易。采用无监督学习期望最大化算法进行数据的聚类，基于无监督学习得到的特征，使用Random Forest(RF)进行异常检测。 Towards blockchain-based collaborative intrusion detection systems 利用区块链技术改进CID，提高各监视器之间的信任，并提供问责制和共识。提出了一个将区块链纳入cids领域的通用架构，并分析了实现这种架构所需做出的设计决策。 On Blockchain Architectures for Trust-Based Collaborative Intrusion Detection 考虑使用区块链技术解决CID系统的信任管理问题，提出使用区块链保护CID对等节点间共享信息的完整性，增强其问责机制，通过阻止内部攻击来确保协作，称为信任链。提出了一种结合了PoS和PoW的共识，使协作的CID节点能维持该链。 Enhancing challenge-based collaborative intrusion detection networks against insider attacks using blockchain 计算机网络中入侵变得越来越复杂，协同入侵检测被用于这种情况，但内部攻击是这种抵御手段的主要威胁，基于挑战的信任管理可以帮助抵御内部攻击，但高级内部攻击仍然具有较高威胁，使用区块链可以增强基于挑战的入侵检测系统抵御高级内部攻击的鲁棒性。（和EI-18非常相似","date":"2019-09-27","objectID":"/2019/blockchain-and-anomaly-detection/:1:1","tags":["科研记录"],"title":"研究记录5-区块链与异常检测方向探索","uri":"/2019/blockchain-and-anomaly-detection/"},{"categories":["研究生的区块链学习之路"],"content":"2. 提出问题 在论文的阅读过程中，主要考虑以下几个问题： 区块链系统中存在哪些类型的异常 多数人攻击：私链或联盟链有应对此种攻击的必要，通过回报函数判断是否有攻击倾向 金融网络中的盗窃或非法交易，通过无监督学习检测可疑用户和交易 异常不只是链上的交易数据，还有链下设备的行为，设备可能本身就一直提交错误数据 如何检测可能的异常 强化学习是否可应用到这种场景 额外的组件添加到区块链系统是否影响可信度 ","date":"2019-09-27","objectID":"/2019/blockchain-and-anomaly-detection/:2:0","tags":["科研记录"],"title":"研究记录5-区块链与异常检测方向探索","uri":"/2019/blockchain-and-anomaly-detection/"},{"categories":["研究生的区块链学习之路"],"content":"3. 后续进展 结合之前阅读的论文，当前检测的异常有： 恶意用户及与恶意用户有关的盗窃资金的恶意交易 多数人攻击中有倾向勾结获取有利于自身利益的节点 具体的恶意行为定义，如设备请求的资源量、设备请求的频率、设备通信目标或通信手段的改变等。 当前检测的手段有： 机器学习：K-means聚类，马氏距离（Mahalanobis distance），无监督支持向量机 扩展的马尔可夫模型 当前关于异常检测的思路三个 Anomaly Detection in Bitcoin Network Using Unsupervised Learning Methods一文以区块链账户为节点，以账户交易为边，构建了用户图模型，从中提取特征向量，以此向量为基础，通过K-means聚类，马氏距离，无监督支持向量机三种方法检测异常。但这篇论文针对的重点是货币型区块链，从构建的用户图提取的特征向量都是与货币有关的，检测的是对加密货币的盗窃行为。在我们的实验中，如果以区块链账户为节点，由于每个账户代表的是IoT设备或其它实体，发起的交易一般与访问控制相关，因此用户图提取的特征向量将是访问控制场景下的恶意用户和恶意访问控制，由此进行异常检测。这一思路的检测是非实时的。 CIoTA Collaborative IoT Anomaly Detection via Blockchain中使用扩展的马尔可夫模型做设备节点的异常检测，但矩阵的值是设备状态转变的概率。但如果矩阵中的值不填充概率，而是根据奖励函数填充设备信用的变化，也可以最终得出异常。而且，该论文在本地定义检测模型，又通过共识运行维持一个结合的检测模型，是通过对共识机制的调整进行实现，不具备适用性。如果将检测模型定义在智能合约中，很多设计可以得到简化。这一思路的检测是一定程度的实时检测。 预定义各种行为和节点信用，每种行为都会引起信用变化，信用的具体化可以使用合约构建内部货币系统或其它方式，信用降到0拒绝节点的任何行为。异常检测算法则可以使用合约实现或定义在共识过程中。 之后要做的事（按优先级排序） 总结异常检测的参数（检测量） 整个体系哪些地方可能出现异常 分层讨论，共识层、网关层和设备层每一层可能的异常行为 寻找如何进行异常模拟或生成 学习异常检测算法 ","date":"2019-09-27","objectID":"/2019/blockchain-and-anomaly-detection/:3:0","tags":["科研记录"],"title":"研究记录5-区块链与异常检测方向探索","uri":"/2019/blockchain-and-anomaly-detection/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 异常智能合约 两类异常检测系统：detection of anomalies on BC and BC helps anomaly detection. 当前考虑的系统是BC based access control in IIoT. 常规意义的异常检测有大量可用的算法，但需要找到有效的监测参数。 其实区块链的验证机制有抑制异常智能合约的功能。以我们的系统为例，我有以下几个问题： 对矿工的奖励机制是什么？ IBFT中没有矿工，只有验证者，没有奖励机制。若确实需要一套奖励机制，可以利用智能合约实现一套货币系统。 有什么样的典型异常智能合约？ 智能合约的内容在部署前所有参与者应达成共识，部署后所有参与者可以验证合约未经修改，智能合约一旦部署无法修改。关于智能合约可能出现的异常包括： 智能合约源代码在编写的时候出现的错误和漏洞，在部署后被人发现并利用。这种漏洞因合约内容而异，主要依赖于在合约部署前进行安全性检查 对合约的调用问题，比如节点短时间发起过多请求 拒绝执行合约通过的访问控制请求，或者返回假的执行结果 注册不存在的设备或恶意设备，并关联相关的合约 私自对部署的合约代码进行修改，从而避过合约内置的安全检查或谋取利益。 除了阻止异常智能合约生成，能否发现并锁定企图制造异常智能合约的用户？ 网关部署的访问控制合约需要在注册合约中进行注册，在注册时进行安全性检查，比对合约ABI是否被篡改。 如果问题3的回答是可行，谁负责组织实施发现和锁定操作？ 注册合约，通过对ABI进行检查确认合约内容未经篡改。不过实际上ABI由网关提交，网关有可能部署恶意合约但提交正常合约的ABI。 ","date":"2019-09-27","objectID":"/2019/blockchain-and-anomaly-detection/:3:1","tags":["科研记录"],"title":"研究记录5-区块链与异常检测方向探索","uri":"/2019/blockchain-and-anomaly-detection/"},{"categories":["平日里的白日梦"],"content":"读完《老舍幽默小说》后不过瘾，但又想读轻松点的，遂又找了同系列的《废名田园小说》。 废名（1901-1967），原名冯文炳，中国现代文坛著名作家，其小说以“散文化”闻名，新文艺的《废名田园小说》节选了他的部分短篇小说，可供鉴赏。 首篇《柚子》出自废名的第一本短篇小说集《竹林的故事》，描写的是作者与姨妈家的女儿柚子的故事。全文层次分明的分为两部分，第一部分童年的生活充满了天真烂漫，有些语句也极有意思，比如写高兴写作“喜得做猪崽叫”，令人印象深刻。作者节选了了童年一些比较有代表性的事件，从播窟眼钱（我们那边叫做“打宝”）到吃饴糖，从“我”折了杜鹃花给柚子到柚子把“我”最爱的菜心让给“我”吃，期间亦有打水草与夏日晚间嬉乐的场景，正如后来作者妻子的评价，“做孩子的时候太亲密狠了”。此童年确实 的无忧且快乐，却也更显得长大之后的境遇令人悲伤。作者与柚子或许没变，但这世间的发展却是由不得人，终究是有缘无份罢了，但作者未写自己的悲伤，写的是满心的思念，重相见时的无言以及再别离的无可奈何，这又比直写心中的悲伤情感更触动人心。 那些生命中曾经出现过的人啊，总有一天要离去，这人生，终究是要自己走下去。世事的变化往往出人意料，哪有称人心意，不过挣扎着生存罢了。把那些美好的会议，统统都藏在心底吧。 从《柚子》一篇来看，结果是不致令人失望的。迥异于老舍的幽默讽刺，废名的文章读起来较为平缓，仿佛只是将身边的琐事娓娓道来，这也正是我选这本书的初衷。只是故事中还带着一股淡淡的哀愁，许是对人世的感伤，亦或者对时过境迁的感叹，但也更添了一分魅力。文章里决看不出时代的风云变幻，若非文末的落款，便称是当下的作品，也是有人信的，与同时代其它作者像老舍，鲁迅等人相比，可以说是少见了。 《浣衣母》一文别具特色，初看完是不懂的，只觉得作为洗衣妇的李妈心地善良，由此赢得了旁人的尊敬与帮助，整体充斥着乡间美好的风俗人情，反映出了人性的光辉，只是对李妈驼背的姑娘的死略微悲伤，李妈的姑娘同样是个善良的人，也得到了别人友好的回应，但早逝总是令人感伤的。故事的结局就不懂了，也不知因为什么，大家突然的对李妈失了尊敬，一切变得冷漠起来。 直到读了《浣衣母》：圣母的悲哀这一份书评，才算是略微懂了，但究竟如何，又是见仁见智。李妈以她仁慈的光辉普照了其他人，小孩子喜欢她，她口袋里常装着糖，姑娘们也把李妈这里当成了欢乐的地方，下河洗衣服，在李妈这里歇息一会儿，受到李妈母亲般的呵护，连卖柴的乡下人，守城的士兵也受了李妈的照拂，乡下人给李妈送来新鲜的蔬菜，士兵给李妈挑来几担柴禾，以报李妈好意。李妈家是城门前的茅屋，背后是城墙，左是沙滩，又是通到城门的大路，前面是小河，河两岸连着石桥，孩子们在沙滩玩耍，姑娘们在小河边洗衣妇，桥下的树荫和李妈家门前由着过往的人歇息。这独特的地理位置，李妈宽大仁慈的胸怀，和着清贫的生活一同造成了李妈高大的形象，家境艰难而矢志守节符合了人们对贤良女性的想象，所以人们对她尊敬。但李妈的宽厚与诚心是无所求的，大家的尊敬却有所求，当李妈最后想同那个比她大儿子大四岁的中年汉子一起过活，这建立在大家心中的贤良形象就有了破损，于是都变得疏离与冷漠了。我之前所见的的美好的民俗风情不过一张纸罢了，其中包含着的狭隘一如既往透露着悲伤。 ","date":"2019-09-21","objectID":"/2019/%E5%BA%9F%E5%90%8D%E7%94%B0%E5%9B%AD%E5%B0%8F%E8%AF%B4/:0:0","tags":["读书笔记"],"title":"废名田园小说","uri":"/2019/%E5%BA%9F%E5%90%8D%E7%94%B0%E5%9B%AD%E5%B0%8F%E8%AF%B4/"},{"categories":["Golang学习之路"],"content":"本篇介绍Go中的基础命令，包和模块。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:0:0","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"1. 命令 Go 在安装后自带一个命令行工具，名为 go，用来下载、编译、安装、测试 Go 的包和源文件，关于 Go CLI 的发展历史和设计理念，可以查看 About the go command，这里只介绍如何使用这些命令。 Go 命令的用法如下 go \u003ccommand\u003e [arguments] 可用命令如下，使用 go help \u003ccommand\u003e 可获取对应命令的帮助信息 bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages 其它的一些帮助主题如下，使用 go help \u003ctopic\u003e 可以查看相关主题的说明 buildmode build modes c calling between Go and C cache build and test caching environment environment variables filetype file types go.mod the go.mod file gopath GOPATH environment variable gopath-get legacy GOPATH go get goproxy module proxy protocol importpath import path syntax modules modules, module versions, and more module-get module-aware go get module-auth module authentication using go.sum module-private module configuration for non-public modules packages package lists and patterns testflag testing flags testfunc testing functions 我们之前已经接触过几种命令，包括查看环境变量的 go env，查看go版本的 go version，用于编译和安装的go install和go build，已经对它们有了一定的了解，下面详细解释所有的命令，明确它们的作用，弄清楚它们的区别。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:1:0","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"1.1 command 当前命令一共17个，使用 go help \u003ccommand\u003e可以查看这些命令的详细说明 go build go build [-o output] [-i] [build flags] [packages] go build 编译导入的包和依赖，但会忽略掉以 _test.go 结尾的文件，因为这些文件是用来测试的。 编译main包时，输出的可执行文件会放到当前目录下，可执行文件的后缀取决于操作系统，只有在windows下后缀才会是.exe，而可执行文件的名字同编译的go文件名相同，如ed.go会编译成ed.exe。 编译多个包或单个非main包时，编译器不会输出可执行文件，仅仅作为这些包是否可编译的一个检查。 以 hello world 程序为例，编译后的 hello.exe 文件位于项目根目录下 $ go build github.com/shuzang/hello $ ls go.mod go.sum gotest.exe main.go 加入 -o 参数可以指定输出文件，-i则在编译后自动执行安装过程（默认只会编译不会安装） go install go install 命令在编译的基础上增添了安装这一步，安装 的基本含义是将生成的可执行文件放到指定的目录，默认为 GOBIN 环境变量指定的目录，即 $GOPATH/bin。仍以hello为例，如下命令执行后，hello.exe文件将位于$GOPATH/bin目录下 \u003e go install github.com/shuzang/hello go get go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages] go get 相比 go install 又多了一步：解析与添加依赖到当前包。完成这一步后自动编译和安装它们。 go get 下载的默认路径是 GOPATH/pkg/mod ，默认下载最新版本，但版本的选择规则比较复杂，可以查看命令说明。下面是一个使用实例 \u003e go get -v github.com/google/codesearch/index github.com/google/codesearch (download) github.com/google/codesearch/sparse github.com/google/codesearch/index -v参数输出下载安装的详细过程，并输出debug信息，其它的一些可选参数说明如下 -d只下载不安装 -fix在对下载的包解析依赖项或编译前先运行修复工具 -t下载为指定的包生成测试需要的包 -u用于更新已有的包和依赖 go run 以上三个命令虽然都包含编译过程，但也到此为止，在生成可执行文件后将不再做任何操作，需要自己来执行。go run命令则在编译后直接执行运行操作，以hello为例 \u003e go run github.com/shuzang/hello Hello, Go! go version go version在没有参数时，会打印自身的版本信息 \u003e go version go version go1.13.4 windows/amd64 但是go version后也可以跟一个目录，这时会递归的查找该目录下的可执行文件，并打印它们的版本信息，以bin目录为例 PS C:\\Users\\lylw1\\go\u003e go version bin bin\\cobra.exe: go1.13.4 bin\\dlv.exe: go1.13.4 bin\\go-outline.exe: go1.13.4 bin\\go-symbols.exe: go1.13.4 bin\\gocode-gomod.exe: go1.13.4 bin\\gocode.exe: go1.13.4 bin\\godef.exe: go1.13.4 bin\\golint.exe: go1.13.4 bin\\gopkgs.exe: go1.13.4 bin\\gorename.exe: go1.13.4 bin\\goreturns.exe: go1.13.4 bin\\guru.exe: go1.13.4 bin\\hello.exe: go1.13.4 添加-m参数会打印包导入的模块信息，添加-v参数会将无法识别的文件信息也打印出来，以stringutil为例 \u003e go version -v src/github.com/shuzang/stringutil src\\github.com\\shuzang\\stringutil\\reverse.go: not executable file go env go env [-json] [-u] [-w] [var ...] go env的基本作用是打印go的环境变量信息，添加-json参数可以以 JSON 的格式打印，但没有默认的脚本形式可读性高。添加 -w 参数可以设置某个环境变量的值，比如 \u003e go env -w GOPATH=d:\\go 与之相反，重置某个环境变量为默认值可以使用-u参数 \u003e go env -u GOPATH 其它 其它的命令使用频率没有上面几个高，因此只简单介绍其作用，用的时候再去查用法即可，go test和go mod两个命令以后单独介绍。 go bug，作用是打开默认浏览器并启动新的 Bug 报告，该报告包含有用的系统信息。 go clean，移除源码包中编译生成的文件 go doc，显示包或符号的文档 go fix，用来更新老版本的代码到新版本 go fmt，go的代码有严格的格式要求，该命令用来做格式化，但一般IDE都会帮忙做这件事 go generate，通过处理源码生成go文件 go list，列出当前安装的包或模块 go mod，模块维持 go test，自动读取源码目录下名为*_test.go的文件进行测试 go tool，运行指定的go工具，后面跟的参数是其它命令 go vet，用于检查Go语言源码中的静态错误 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:1:1","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"1.2 topic topic有15个，本质是对Go中的一些概念作解释，所以它实际上是一些文档说明，使用go help \u003ctopic\u003e查看，这些topic包括 buildmode：构建模式的描述 c：Go和c的相互调用 cache：构建和测试缓存 environment：环境变量 filetype：文件类型 go.mod：go.mod文件 gopath：GOPATH环境变量 gopath-get： goproxy：模块代理协议 importpath：导入路径语法 modules：模块，模块版本等 modules-get： packages：包列表的描述 testflag：测试符号描述 testfunc：测试函数描述 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:1:2","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2. 包 包是Go语言代码组织和代码编译的一个基本结构，一个包可能由一个或多个.go文件组成，而一个或多个包可以构成完整的项目(仓库)。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:0","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2.1 包名 每个Go源文件(.go文件)都必须在非注释的首行声明属于哪个包 package name name就是包名，包名的命名遵循命名规范，而且不得使用大写字母。每个Go应用程序都必须包含一个main包 一个Go程序通过import关键字将一组包衔接在一起，如 import \"fmt\" 包名需要用双引号包围，多个包可以使用多个import语句，也可以使用一个小括号全部放在一起，如 import ( \"fmt\" \"os\" \"crypto/rot13\" \"github.com/shuzang/hello\" ) 包名也是导入路径的最后一个字段，比如crypto/rot13，其包名为rot13；github.com/shuzang/hello，其包名为hello 没有必要刻意使用不同的包名，只要导入路径保持唯一即可 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:1","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2.2 标准库 像 fmt、os 等这样具有常用功能的内置包在 Go 语言中有 150 个以上，它们被称为标准库，大部分内置于Go本身，位于C:\\Go\\pkg\\windows_amd64，即$GOROOT/pkg/$GOOS__$GOARCH目录下，不需要额外的下载、安装和编译，详细列表和说明可以在 Go Packages 查看，这里简单介绍一些常用包的基本功能 unsafe: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中 系统操作类 os: 提供给我们一个平台无关性的操作系统功能接口，采用类Unix设计，隐藏了不同操作系统间差异，让不同的文件系统和操作系统对象表现一致 os/exec: 提供我们运行外部操作系统命令和程序的方式 syscall: 底层的外部包，提供了操作系统底层调用的基本接口 archive/tar 和 /zip-compress：压缩(解压缩)文件功能。 输入输出类 fmt: 提供了格式化输入输出功能 io: 提供了基本输入输出功能，大多数是围绕系统功能的封装 bufio: 缓冲输入输出功能的封装 path/filepath: 用来操作在当前系统中的目标文件名路径 flag: 对命令行参数的操作　 字符串操作类 strings: 提供对字符串的操作 strconv: 提供将字符串转换为基础类型的功能 unicode: 为 unicode 型的字符串提供特殊的功能 regexp: 正则表达式功能 bytes: 提供对字符型分片的操作 index/suffixarray: 子字符串快速查询 数学 math: 基本的数学函数 math/cmath: 对复数的操作 math/rand: 伪随机数生成 sort: 为数组排序和自定义集合 math/big: 大数的实现和计算 数据结构 list: 双链表 ring: 环形链表 时间 time: 日期和时间的基本操作 log: 记录程序运行时产生的日志,我们将在后面的章节使用它 编/解码 encoding/json: 读取并解码和写入并编码 JSON 数据 encoding/xml:简单的 XML1.0 解析器 text/template:生成像 HTML 一样的数据与文本混合的数据驱动模板 网络 net: 网络数据的基本操作。 http: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。 html: HTML5 解析器 runtime: Go 程序运行时的交互操作，例如垃圾回收和协程创建。 reflect: 实现通过程序运行时反射，让程序操作任意类型的变量。 Go的生态远不止这些标准库，社区里存在大量的第三方包或项目，在开发自己的项目时，最好先查找下是否有已存在的第三方包或可用的库。 Go Walker 支持根据包名在海量数据中查询。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:2","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2.3 导入包 导入包的基本格式如下 import \"包的路径或 URL 地址\" ”包的路径“指可以是以下这种形式 import \"./pack1/pack1\" 而URL地址指的是下载的外部安装包 import \"github.com/org1/pack1” 导入时可以对包进行重命名，比如 import packx \"github.com/org1/pack1” 也可以重命名为两种特殊符号：.和_，前者可以在使用时省略包名，直接使用对外部可见的函数和变量，后者则只执行其中的init函数和初始化其全局变量，无法调用函数 import . \"./pack1\" import _ \"./pack1/pack1\" ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:3","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2.4 使用脚本编译或安装 在 Linux/OS X 下可以用 Makefile 脚本 实现自动检测机器架构并调用正确的编译器和链接器 include $(GOROOT)/src/Make.inc TARG=pack1 GOFILES=\\ pack1.go\\ pack1b.go\\ include $(GOROOT)/src/Make.pkg 通过 chmod 777 ./Makefile确保它的可执行性，然后在终端使用make工具 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:4","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3. 模块 自 Go 1.11 起，开始支持使用 Go Module 进行包管理，这里参考 Go Blog 中的 Using Go Modules 一文对其进行介绍。 模块(module)通过项目根目录下go.mod文件起作用，项目中使用的所有包的集合都在该文件中定义。go.mod文件定义了模块路径，用于项目中包的导入路径。以 delve 的go.mod文件为例 module github.com/go-delve/delve go 1.10 require ( github.com/cosiner/argv v0.0.0-20170225145430-13bacc38a0a5 github.com/cpuguy83/go-md2man v1.0.8 // indirect github.com/inconshreveable/mousetrap v1.0.0 // indirect github.com/kr/pretty v0.1.0 // indirect github.com/mattn/go-colorable v0.0.0-20170327083344-ded68f7a9561 github.com/mattn/go-isatty v0.0.3 github.com/onsi/ginkgo v1.8.0 // indirect github.com/onsi/gomega v1.5.0 // indirect github.com/peterh/liner v0.0.0-20170317030525-88609521dc4b github.com/pkg/profile v0.0.0-20170413231811-06b906832ed0 github.com/russross/blackfriday v0.0.0-20180428102519-11635eb403ff // indirect github.com/sirupsen/logrus v0.0.0-20180523074243-ea8897e79973 github.com/spf13/cobra v0.0.0-20170417170307-b6cb39589372 github.com/spf13/pflag v0.0.0-20170417173400-9e4c21054fa1 // indirect github.com/stretchr/testify v1.3.0 // indirect go.starlark.net v0.0.0-20190702223751-32f345186213 golang.org/x/arch v0.0.0-20171004143515-077ac972c2e4 golang.org/x/crypto v0.0.0-20180614174826-fd5f17ee7299 // indirect golang.org/x/sys v0.0.0-20190626221950-04f50cda93cb golang.org/x/tools v0.0.0-20181120060634-fc4f04983f62 gopkg.in/airbrake/gobrake.v2 v2.0.9 // indirect gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect gopkg.in/gemnasium/logrus-airbrake-hook.v2 v2.1.2 // indirect gopkg.in/yaml.v2 v2.2.1 ) 注意，使用模块进行包管理独立于原来的使用 gopath 进行包管理，可以在任意位置建立项目。如果go.mod文件放在$GOPATH/src，即原来的统一工作区，是不起作用的，会被旧的GOPATH模式屏蔽。自 Go 1.13 开始，module 模式已经成为了 Go 开发的默认模式。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:0","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.1 创建新模块 在$GOPATH/src外的任意位置创建项目目录，cd进入该目录，创建hello.go文件 package hello func Hello() string { return \"Hello, world.\" } 为它写一个测试文件hello_test.go package hello import \"testing\" func TestHello(t *testing.T) { want := \"Hello, world.\" if got := Hello(); got != want { t.Errorf(\"Hello() = %q, want %q\", got, want) } } 现在，项目中有了一个包，因为项目目录位于F:/hello，执行go test的结果如下 $ go test PASS ok _/F_/hello 0.240s 因为我们在 $GOPATH 外进行的测试，而且现在还没有go.mod文件，所以Go命令不知道导入路径，只能根据目录名生成一个导入路径。现在我们来创建go.mod文件并再次执行go test命令 $ go mod init example.com/hello go: creating new go.mod: module example.com/hello $ go test PASS ok example.com/hello 0.214s go mod init命令用于创建go.mod文件，初始化Go模块，其内容如下 $ pwd /f/hello $ ls go.mod hello.go hello_test.go $ cat go.mod module example.com/hello go 1.13 go.mod文件位于项目根目录，其中的模块路径也只显示到项目根目录，子目录中包的导入路径由模块路径+子目录路径组成。我们在当前项目目录下创建world子目录，其导入路径将会是example.com/hello/world ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:1","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.2 添加依赖 使用Go模块的首要目的是提升别的开发者使用我们编写的代码的体验。编辑hello.go文件，导入rsc.io/quote，然后用它来实施Hello package hello import \"rsc.io/quote\" func Hello() string { return quote.Hello() } 现在运行go test $ go test go: finding rsc.io/quote v1.5.2 go: downloading rsc.io/quote v1.5.2 go: extracting rsc.io/quote v1.5.2 go: finding rsc.io/sampler v1.3.0 go: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c go: downloading rsc.io/sampler v1.3.0 go: extracting rsc.io/sampler v1.3.0 go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c go: extracting golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c PASS ok example.com/hello 0.023s Go使用go.mod文件中列举的依赖模块版本来解析导入的包，但是当在go.mod文件中找不到这个包是，就会自动的查找包含这个包的模块的最新版本，然后添加到go.mod文件。上例中自动下载了模块rsc.io/quote v1.5.2，还下载了它依赖的两个其它模块：rsc.io/sampler和golang.org/x/text。不过只有直接依赖会被记录到go.mod文件 $ cat go.mod module example.com/hello go 1.13 require rsc.io/quote v1.5.2 下载的包位于$GOPATH/pkg/mod，再次运行go test命令，就不会重新下载了，因为已经存在。 $ go test PASS ok example.com/hello 0.020s 需要注意的是，尽管使用模块使得添加包管理简单轻松，但并非没有代价，当前代码的安全性、正确性和许可等都依赖于导入的模块，关于这个问题的详细描述可以查看 Our Software Dependency Problem. 如上所述，添加一个直接依赖通常会引入一些间接的依赖，使用go list -m all可以列举当前模块和它们所有的依赖。 $ go list -m all example.com/hello golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c rsc.io/quote v1.5.2 rsc.io/sampler v1.3.0 在go list的输出中，当前模块是主模块，总是位于第一行，其它的模块按模块路径顺序显示。 go.mod文件外，Go还维持一个名为go.sum的文件，包含特定模块版本内容的加密哈希。Go使用该文件确保将来下载该模块时内容与第一次下载的内容相同，从而保证所依赖的模块没有被恶意或非恶意的更改。 $ ls go.mod go.sum hello.go hello_test.go $ cat go.sum golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZO... golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:Nq... rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3... rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPX... rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/Q... rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9... go.mod和go.sum文件都应该包含到版本控制系统中，也就是说随着源代码文件一起提交到远程仓库。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:2","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.3 更新依赖 Go模块使用的版本号分三部分：主版本号(major)，次版本号(minor)和修订版本号(patch)。例如，v0.1.2，主版本号是0，次版本号是1，修订版本号是2。首先以一个次版本号的更新举例说明 前面go list -m all的输出中我们可以看到golang.org/x/text使用的不是标准的版本号，我们可以使用go get命令将其更新 $ go get golang.org/x/text go: finding golang.org/x/text v0.3.0 go: downloading golang.org/x/text v0.3.0 go: extracting golang.org/x/text v0.3.0 $ go test PASS ok example.com/hello 0.013s 现在再次列举所有的模块以及查看go.mod文件 $ go list -m all example.com/hello golang.org/x/text v0.3.0 rsc.io/quote v1.5.2 rsc.io/sampler v1.3.0 $ cat go.mod module example.com/hello go 1.12 require ( golang.org/x/text v0.3.0 // indirect rsc.io/quote v1.5.2 ) 可以看到两者中golang.org/x/text都已经更新到了最新的版本号v0.3.0，注释中的indirect说明这个依赖不是直接被引用的，只是被其它的模块间接引用。 现在我们更新rsc.io/sampler的次版本号 $ go get rsc.io/sampler go: finding rsc.io/sampler v1.99.99 go: downloading rsc.io/sampler v1.99.99 go: extracting rsc.io/sampler v1.99.99 $ go test --- FAIL: TestHello (0.00s) hello_test.go:8: Hello() = \"99 bottles of beer on the wall, 99 bottles of beer, ...\", want \"Hello, world.\" FAIL exit status 1 FAIL example.com/hello 0.014s 测试失败说明版本不匹配，列举所有可用版本 $ go list -m -versions rsc.io/sampler rsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99 之前使用的是v1.3.0，v1.99.99也被证明无法使用，因此换用v1.3.1 $ go get rsc.io/sampler@v1.3.1 go: finding rsc.io/sampler v1.3.1 go: downloading rsc.io/sampler v1.3.1 go: extracting rsc.io/sampler v1.3.1 $ go test PASS ok example.com/hello 0.022s 通过@来指定具体的版本号，go get的参数实际上应该带有版本号，不明确指定会使用默认的@latest，从而使用最新版本。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:3","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.4 在主版本号上添加依赖 主版本号的更新是不同的，会看作一个独立的依赖。在hello.go中添加一个新的函数Proverb()，它使用了rsc.io/quote的v3版本，导入格式为rsc.io/quote/v3 package hello import ( \"rsc.io/quote\" quoteV3 \"rsc.io/quote/v3\" ) func Hello() string { return quote.Hello() } func Proverb() string { return quoteV3.Concurrency() } 然后为其添加测试函数 func TestProverb(t *testing.T) { want := \"Concurrency is not parallelism.\" if got := Proverb(); got != want { t.Errorf(\"Proverb() = %q, want %q\", got, want) } } 测试结果如下 $ go test go: finding rsc.io/quote/v3 v3.1.0 go: downloading rsc.io/quote/v3 v3.1.0 go: extracting rsc.io/quote/v3 v3.1.0 PASS ok example.com/hello 0.024s 现在我们的模块同时依赖于rsc.io/quote和rsc.io/quote/v3 $ go list -m rsc.io/q... rsc.io/quote v1.5.2 rsc.io/quote/v3 v3.1.0 Go模块的每个主版本号(v1, v2, and so on)都使用一个不同的模块路径，从v2开始，路径必须以主版本号结尾，比如rsc.io/quote的v3版本模块路径为rsc.io/quote/v3，这种惯例称作 semantic import versioning ，给不兼容的包提供了不同的名字。相反，同一个主版本号，如v1.6.0应该向前兼容，和rsc.io/quote使用同一个名字，在同一个项目中，每个主版本号Go只允许出现一种，比如v1.5.2和v1.6.0不能同时存在，但不同的主版本号可以同时存在，这是为了使程序可以逐步过渡到新的版本。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:4","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.5 更新依赖到新的主版本号 比如从rsc.io/quote迁移到rsc.io/quote/v3，由于大版本更新，某些不兼容的API可能被删除、重命名或做其它的更改，阅读文档，我们可以发现HelloV3相对于Hello做了如下改动 $ go doc rsc.io/quote/v3 package quote // import \"rsc.io/quote\" Package quote collects pithy sayings. func Concurrency() string func GlassV3() string func GoV3() string func HelloV3() string func OptV3() string 检查并更新我们的源码 package hello import quoteV3 \"rsc.io/quote/v3\" func Hello() string { return quoteV3.HelloV3() } func Proverb() string { return quoteV3.Concurrency() } 由于没有冲突，这里导入的包不再需要重命名，因此可以继续简化 package hello import \"rsc.io/quote/v3\" func Hello() string { return quote.HelloV3() } func Proverb() string { return quote.Concurrency() } 运行测试 $ go test PASS ok example.com/hello 0.014s ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:5","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.6 移除不使用的依赖 我们已经不再使用rsc.io/quote，但它依然存在于go list -m all的输出和go.mod文件中 $ go list -m all example.com/hello golang.org/x/text v0.3.0 rsc.io/quote v1.5.2 rsc.io/quote/v3 v3.1.0 rsc.io/sampler v1.3.1 $ cat go.mod module example.com/hello go 1.12 require ( golang.org/x/text v0.3.0 // indirect rsc.io/quote v1.5.2 rsc.io/quote/v3 v3.0.0 rsc.io/sampler v1.3.1 // indirect ) 这是因为编译单个包时无法自动检测是否可以安全的移除某个包，只能通过手动执行go mod tidy命令清理不再使用的依赖 $ go mod tidy $ go list -m all example.com/hello golang.org/x/text v0.3.0 rsc.io/quote/v3 v3.1.0 rsc.io/sampler v1.3.1 $ cat go.mod module example.com/hello go 1.12 require ( golang.org/x/text v0.3.0 // indirect rsc.io/quote/v3 v3.1.0 rsc.io/sampler v1.3.1 // indirect ) $ go test PASS ok example.com/hello 0.020s $ 最后是关于发布自己的模块版本的注意，参考两篇文章 Publishing Go Modules Go Modules: v2 and Beyond ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:6","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["平日里的白日梦"],"content":"9月8日在图书馆闲逛，找到了新文艺的《老舍幽默小说》，同系列还有不少名家的小说集，但以幽默最爱，故先看老舍的作品，至昨日，经两周，终于看完，只得感叹一声：人生百态。 老舍有多篇文章入选中小学课本，包括《猫》、《趵突泉》、《济南的春天》、《骆驼祥子》节选等，其中猫的顽皮可爱，济南的引人之处，祥子的悲惨一生，均令人印象深刻。《骆驼祥子》全本当年已读过，其它名著如《猫城记》和《四世同堂》则未曾涉猎，这次找到的《老舍幽默小说》，本是想着轻松的，却没想到，幽默之下，仍是一场场悲剧。 小说集共包含二十一篇短篇小说或小小说，老舍先生用幽默的风格将每个形象都刻画的栩栩如生，反映了种种社会现状，有些直到现在依然具有讽刺意味。《狗之晨》写狗，我们却能从中看到那些欺软怕硬的人的形象，可悲又可怜。《同盟》则借写一段恋爱追求过程，告诉了我们真诚永远是最打动人心的品质。《马裤先生》是最为有名的一篇，以前应也在别处看过，通过描述在火车上遇到的一位穿马裤的旅客的令人厌恶的举止，描绘出了一个极为市侩的人物形象。书中收录的多篇小说都描写的是火车上的人物和场景，看起来老舍先生对此颇有感悟，《不远千里而来》描写了一个“王先生”在日军威胁北平之际挤上火车，南下济南的旅途，《番表》则是一个乘客费劲心思用各自手段买打折票的经历，《“火”车》一文是一群除夕占便宜的乘客演出的喜怒哀乐，尤其是最终火车着火的画面，历历在目，读着书却有看到电影慢镜头画面的感觉。 书中很多人物是讽刺的，却也是可怜的，有时候可怜会多于厌恶，陷于旧制度下的人很多都是跟不上时代发展，才演绎出了一场场令人啼笑皆非的情景。正如《有声电影》中的一大家子，愚傻，却愚傻的可怜。《抱孙》中的王老太太，因循守旧，不相信科学和医院，不仅导致了前后三个孩子夭折，最后还导致了儿媳妇也去世，这种情况下不仅不思己过，还将过错全部推给他人，倚老卖老，令人厌恶却无可奈何。《柳家大院》是最为令人心痛的一篇，小王的媳妇最终被硬生生虐待逼迫至死，没有一个人真正关心，人命啊，真是贱，老舍先生笔墨一向是幽默的，讽刺也通常是隐含的，这篇文章却锋利无比，直抒胸臆，字里行间透露着愤怒和无奈，反映的不仅仅是旧制度下女子地位的低下，还是人们陈腐的思想观念得不到解放，最终导致的一场人间悲剧。 有几篇是现在也毫不过时的，《善人》一文描写的汪太太，借着丈夫的钱，做着些不切实际的提议，伪装着善人，却从骨子里透露出恶心，伪善一词被演绎的淋漓尽致。《开市大吉》则描绘了一座医院借助种种歪门邪道手段营业的故事，像雇人排队，拖延治病流程，多开药，要挟，曲意逢迎不顾真实病情等，很多都能在现代看到影子，总之就是一切为了钱，其它的什么都不管。《买彩票》则充分反映了一件事：世上本无事，庸人自扰之。 当然，文章并不总是读来令人难受的，还是有几篇充斥着温馨的生活气息。《爱的小鬼》描绘了夫妻之间的日常，虽然也告诉我们夫妻之间信任最重要的道理，但读来是舒适的。《一天》则描写了老舍先生自己的一天，时间总是在浪费的不明不白，颇具同感。《当幽默变成油抹》描写的是孩子和大人的不同理解带来的趣事。但即使如此，这些轻松向的小说也总能让人读出些什么来。 老舍先生描写人是入骨的，总是能三言两语间让一个人的形象跃立在我们眼前，借助市井小民的生活，往往能反映出整个社会的现状，读来确实令人收获良多。也正如序中所写：老舍先生爱以幽默的方式写悲剧。讽刺往往是冷眼旁观，幽默却并不赶尽杀绝，而是充满同情，这种写法是引人入胜的，是有趣的，也是我所喜欢的。也因此，愿意多读一些老舍先生的小说，故将老舍先生的主要作品整理如下，留待以后阅读。 注：《老舍幽默小说》中的短篇小说主要节选自以下几本短篇小说集。 附录1 老舍主要作品 长篇小说：《老张的哲学》《赵子曰》《二马》《猫城记》《离婚》《牛天赐传》《文博士》《骆驼祥子》《火葬》《四世同堂》《鼓书艺人》《我这一辈子》《正红旗下》（未完成） 中篇小说：《月牙儿》《阳光》 短篇小说集：《赶集》《樱海集》《蛤藻集》《火车集》《贫血集》《集外》 剧本：《茶馆》《龙须沟》《桃李春风》《大地龙蛇》《残雾》《神拳》 等 附录2 本书中的小说 按出自的短篇小说集分类 《赶集》 《樱海集》 《火车集》 《集外》 其它 热包子 善人 “火”车 旅行 一天 爱的小鬼 柳屯的 狗之晨 当幽默变成油抹 同盟 记懒人 买彩票 马裤先生 不远千里而来 开市大吉 辞工 柳家大院 有声电影 抱孙 丁 番表 ","date":"2019-09-16","objectID":"/2019/%E8%80%81%E8%88%8D%E5%B9%BD%E9%BB%98%E5%B0%8F%E8%AF%B4/:0:0","tags":["读书笔记"],"title":"老舍幽默小说","uri":"/2019/%E8%80%81%E8%88%8D%E5%B9%BD%E9%BB%98%E5%B0%8F%E8%AF%B4/"},{"categories":["我所热爱的生活啊"],"content":"乘坐公交的路上，经常能看到一座古建筑风格的院落，以及白塔堡的一座白塔。这座白塔确是能做到看第一眼就让人觉得白塔此名名副其实。恰逢朋友相约，便去了这两个心仪已久的地点。 白塔 沈阳白塔，又称无垢净光塔，塔身洁白如玉，其所在地白塔堡因此得名。传白塔建于明永乐四年，塔座以白石砌成，塔身呈八角形，共七层，取“救人一命，胜造七级浮屠”之意。 清咸丰十年，塔顶被狂风吹毁，塔身震出裂纹，其年秋雨连绵，引发洪水，由此衍化了“白塔镇孽龙”的民间神话。传说白塔下有“海眼”，建此塔以镇东海犯境之孽龙，被镇孽龙要逃出白塔，于是便“兴风作浪”。 1905年，日军总攻沈阳。日俄两军在沈阳郊区发生激烈交战，白塔被日军当成了俄军的军事观察所，为了防止俄军通过制高点侦察到日军的行动，日军用大炮摧毁了具有百年历史的白塔。 1999年白塔重建，由于误判白塔为辽代建筑，重建的塔为辽代风格。白塔全貌如图，当从街道路过远望白塔时，更能感受其“无垢光明”之意。 弥陀寺 围绕白塔修有白塔公园，在公园内，与白塔相邻，还有一座名为弥陀寺的寺庙，这也是到了白塔附近才发现。 弥陀寺是与白塔相伴的寺庙，至于是否一同诞生不得而知，但1905年却与白塔一同毁于炮火。1999年白塔复建完成，但弥陀寺直到2012年才得以重建。 重建的弥陀寺颇为宏伟壮丽，寺门正门并不开，只开旁边的侧门，谢绝自带香火，只能从里面买（无语）。寺内各殿一应俱全，进门首先是天王殿，天王殿后是大雄宝殿，再往后是僧人休息处，两侧伽蓝、地藏、观音、祖师等等俱有。进门时大雄宝殿还有僧人诵经。 碧霞宫 碧霞宫地处偏僻，若不是乘坐公交看到这一片建筑群，怕是无法发现。开放时间是早八点到下午三点，初一和十五是早七点到下午四点，但逢道教戊日休息不开放。并且，道院不许游人观光，只许信众参拜，所以只是在门口看了一眼，并没有进去。 道观人烟稀少，交通不便，进入的道路也并不好，但这里却是全真龙门正宗道场。此观始建于清雍正三年，原址位于沈河区，道光年间翻修重建，文革时被毁，1996年在东陵区白塔异地重建。道院是明清建筑风格，主殿为元君殿，供奉东岳泰山圣母天仙碧霞元君。去之前查到的资料称还有帝君殿和护法殿，但因没进去，并没有看到。 宫前还有一座灵官殿（应该没有认错字），很像99版西游记动画孙悟空和二郎神大战时所变化的建筑，很是有趣。 ","date":"2019-09-15","objectID":"/2019/scaleless-net-light-tower/:0:0","tags":["旅行记录"],"title":"白塔、弥陀寺及碧霞宫","uri":"/2019/scaleless-net-light-tower/"},{"categories":["Golang学习之路"],"content":"1. 起源与发展 Go/Golang 起源于2007年，并于2009年正式对外发布，是一个完全开源的项目，背后的支持者是谷歌公司，核心设计者是三位著名IT工程师：Ken Thompson，Rob Pike，Robert Griesemer。分别是如下从左到右三位 其中 Ken Thompson 是 Unix 操作系统的设计者，并因此获得图灵奖，也是C语言前身B语言的设计者，UTF-8 编码设计者之一，计算机史的重要人物，2006年加入谷歌，和另外两人一起设计了Go语言。 Rob Pike 是 Ken 的老搭档。 随后又有 lan Lance Taylor 和 Russ Cox 两人加入团队，前者是 gccgo 编译器的作者和 cgo工具链的维护者，后者加入团队后着手Go语言标准库的开发。下图分别是他们两个 Go语言以囊地鼠(Gopher)为图标和吉祥物，这是一种原产于加拿大的啮齿类动物，Go语言开发者也一般自称为 Gopher。下图中左边是囊地鼠，右边是 Go logo. Go语言相比于其它语言的最大优势在于它的执行性能与开发效率，这得益于Go在并发编程、内存回收等许多方面的良好设计，并因此大规模用于服务器编程、网络编程、数据库和云平台领域。 比较出名的Go语言项目有(不限于这些) Go语言本身： https://github.com/golang/go Docker： https://www.docker.com/ kubernetes： https://github.com/kubernetes/kubernetes Ethereum： https://github.com/ethereum/go-ethereum fabric： https://github.com/hyperledger/fabric Hugo： https://github.com/gohugoio/hugo TiDB： https://github.com/pingcap/tidb InfluxDB： https://github.com/influxdata/influxdb ETCD： https://github.com/etcd-io/etcd 使用Go的国外公司有：Google, Docker, NetFlix, CloudFlare, Dropbox, MongoDB, Uber等 使用Go的国内公司有：七牛、字节跳动、bilibili、京东、百度，其它公司如小米、腾讯、阿里等也都在使用Go，但可能不是主力 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:1:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"2. 跟踪最新动态 最直接的方式是跟踪Go语言的源码库，关注提交历史和issue 原始代码库： https://go.googlesource.com/go github镜像： https://github.com/golang/go 其它活跃论坛或动态 golang-dev：Google邮件列表的Go开发组讨论区 golang-nuts：Google邮件列表的Go讨论社区 golang-announce：发布Go版本或Go开发的最新状态 go.dev：刚刚上线(2019.11.14)的Go开发人员中心 gotime：Go的一个播客，每周一更，内容有干货 @golang：Go 语言在 Twitter 的官方帐号 此外还有每年举办的几个大会 Gopher Con，举办地在美国，时间不定，今年在7月，2020年会在6月份举行。会议总结 GopherChina，举办地在中国，每年4月份。会议总结 dotGo，举办地在欧洲，每年3月份 详细的会议列表可查看 https://github.com/golang/go/wiki/Conferences Go 下载地址和相关的文档、标准库等访问地址为 官网 https://golang.org/ 国内的镜像网站 https://golang.google.cn/ Go语言中文网 是国内最活跃的Go社区，每周会发行一份Go语言爱好者周刊 Go相关资料聚集最多的还是go wiki ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:2:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3. 下载安装 Windowns下快速安装可以使用 chocolatey ，执行如下命令即可 \u003e choco install golang 自动配置环境变量，安装完重启终端即可使用。下面开始介绍常规的安装方法，以win10和Ubuntu为例。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.1 下载 Golang中国官网下载页面为 golang.google.cn/dl，为windows，macOS和Linux三种环境都提供了安装包。 windows默认下载文件为go1.14.windows-amd64.msi，双击启动即可安装，默认安装位置为C:\\Go，环境变量将自动设置。但如果下载了以.zip为后缀的版本，则需要自己解压到合适的路径，并自己设置环境变量。 Linux默认下载文件为go1.14.linux-amd64.tar.gz，将其解压缩到/usr/local，然后手动将/usr/local/go/bin添加到 PATH 环境变量中。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:1","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.2 安装 windows msi后缀的安装版本双击安装，环境变量将会自动设置，打开powershell，使用go env命令查看环境变量 \u003e go env set GO111MODULE= set GOARCH=amd64 set GOBIN= set GOCACHE=C:\\Users\\lylw1\\AppData\\Local\\go-build set GOENV=C:\\Users\\lylw1\\AppData\\Roaming\\go\\env set GOEXE=.exe set GOFLAGS= set GOHOSTARCH=amd64 set GOHOSTOS=windows set GOINSECURE= set GONOPROXY= set GONOSUMDB= set GOOS=windows set GOPATH=C:\\Users\\lylw1\\go set GOPRIVATE= set GOPROXY=https://goproxy.cn,direct set GOROOT=c:\\go set GOSUMDB=sum.golang.org set GOTMPDIR= set GOTOOLDIR=c:\\go\\pkg\\tool\\windows_amd64 set GCCGO=gccgo set AR=ar set CC=gcc set CXX=g++ set CGO_ENABLED=1 set GOMOD= set CGO_CFLAGS=-g -O2 set CGO_CPPFLAGS= set CGO_CXXFLAGS=-g -O2 set CGO_FFLAGS=-g -O2 set CGO_LDFLAGS=-g -O2 set PKG_CONFIG=pkg-config set GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\lylw1\\AppData\\Local\\Temp\\go-build192094374=/tmp/go-build -gno-record-gcc-switches 使用 go version 查看版本同时验证安装 \u003e go version go version go1.13.4 windows/amd64 Linux 以Ubuntu 20.04 LTS 为例说明，首先在 golang.org/dl 页面右击要下载的版本获取下载链接，使用wget下载文件。也可以直接下载。 $ wget https://dl.google.com/go/go1.14.linux-amd64.tar.gz 将文件解压缩到指定目录/usr/local，-C参数用于指定目标文件夹，解压缩后删除压缩文件。 $ sudo tar -xzf go1.14.linux-amd64.tar.gz -C /usr/local $ rm go1.14.linux-amd64.tar.gz 查看安装目录 $ ls /usr/local bin etc games go include lib man sbin share src $ ls /usr/local/go AUTHORS CONTRIBUTORS PATENTS SECURITY.md api doc lib pkg src CONTRIBUTING.md LICENSE README.md VERSION bin favicon.ico misc robots.txt test 设置环境变量 $ sudo nano /etc/profile # 在打开的文件末尾添加下列语句 export PATH=$PATH:/usr/local/go/bin 更新的环境变量可以通过下面的命令使其直接生效 $ source /etc/profile # 查看生效后的环境变量设置 $ go version go version go1.14 linux/amd64 Linux 全部环境变量如下 $ go env GO111MODULE=\"\" GOARCH=\"amd64\" GOBIN=\"\" GOCACHE=\"/home/shuzang/.cache/go-build\" GOENV=\"/home/shuzang/.config/go/env\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"linux\" GOINSECURE=\"\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"linux\" GOPATH=\"/home/shuzang/go\" GOPRIVATE=\"\" GOPROXY=\"https://proxy.golang.org,direct\" GOROOT=\"/usr/local/go\" GOSUMDB=\"sum.golang.org\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/go/pkg/tool/linux_amd64\" GCCGO=\"gccgo\" AR=\"ar\" CC=\"gcc\" CXX=\"g++\" CGO_ENABLED=\"1\" GOMOD=\"\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build153919612=/tmp/go-build -gno-record-gcc-switches\" 注：将环境变量添加到/etc/profile可使go全局启用，也可添加到$HOME/.profile，对当前登录用户起作用。 注：可以使用apt-get命令安装，但安装的go不会是最新版本，同样，也可以使用snap安装，可以安装最新版本。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:2","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.3 环境变量说明 常规的使用除了GOPATH外无需关心其它环境变量，但在进行交叉编译时，需要进行一定的设置，详细的环境变量说明可以查看 $GOPATH environment variable set correctly，以下解释几个主要的环境变量。 GOOS与GOARCH：目标操作系统和处理器架构， GOHOSTOS和GOHOSTARCH是宿主机操作系统和处理器架构。 GOBIN：编译器和链接器的安装位置，默认是$GOROOT/bin，一般将其设置为空值，Go会使用默认值。 GOROOT：电脑上安装的Go的根目录，Linux下一般为$HOME/go，windows下为C:\\go GOPATH：go install、go get等命令默认路径都是GOPATH，是编译后二进制文件的存放目的地、下载后包的存放路径以及 import 包时的搜索路径 我们需要关心的唯一一个环境变量是GOPATH，可以看到，默认的GOPATH是c:\\Users\\lylw1\\go，其中lylw1是自己的用户名。 GOPATH 所代表的路径是 go 的工作区，可以选择任意自己喜欢的文件夹作为go的工作区，如果不想使用默认的路径，需要自己进行修改，使用 go env 命令 \u003e go env -w GOPATH=/somewhere/else 更多的环境变量修改方式可以查看Setting GOPATH，需要注意的一点是GOPATH不能设置为Go的安装目录C:\\go ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:3","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.4 安装目录清单 安装完成的Go根目录（$GOROOT）文件夹结构除了README.md，AUTHORS，LICENSE等常规文件外，基本结构应如下所示： /bin：包含可执行文件，如：编译器，Go 工具 /doc：包含示例程序，代码工具，本地文档等 /lib：包含文档模版 /misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例 /pkg/os_arch：包含标准库的包的对象文件（.a） /src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言） /src/cmd：包含 Go 和 C 的编译器和命令行脚本 这是之前的介绍，网上搜到的多是这个说明，但当前还多了api和test两个文件夹。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:4","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.5 代码目录结构 Go 1.13之前，所有代码在一个工作区，Go 1.13及之后，使用 Go module 进行管理，项目代码不再必须放到 GOPATH 下。本文假设使用 Go 1.13 及以后的版本。对于之前的方式不再介绍。 Go 程序以包（package）的形式进行组织，一个包就是一个目录，该目录下可能有一个或多个源文件，同一个包的所有代码会被一起编译。另外，同一个包中定义的变量、常量、类型、函数，即使在不同的源文件中，也可以相互访问。 Go 项目以模块的方式进行组织，模块（module）是一组相关包的集合。一个项目通常是一个仓库（repository），而一个 Go 仓库（repository）只能包含一个模块，但可导入使用多个其它模块，仓库根目录下的 go.mod 文件用来声明这些导入模块的路径。和 go.mod 文件一起位于仓库根目录的是一个一个的子目录，每个子目录可能是一个包，也可能是一个子模块，是否为子模块要看子目录下是否存在 go.mod 文件。 值得注意的是，尽管项目代码以仓库的方式进行组织，但在编写完成构建之前，代码不需要上传到云端，模块可以本地存在，仓库形式仅仅是因为我们总有一天会将代码上传到云的。 模块的路径不仅作为导入路径，同样也说明了模块的下载路径，比如 golang.org/x/tools， Go 命令将知道从 https://golang.org/x/tools 去下载它。包的导入路径是模块路径 + 包名，比如，模块 github.com/google/go-cmp 包含一个包（子目录）cmp，这个包的导入路径就是 github.com/google.go-cmp/cmp。Go 的标准库导入不需要模块路径前缀，可以仅使用包名。 最后，所有的模块都会下载到 GOPATH 的 pkg/mod 目录下，并被所有项目共享，因此，模块代码是只读的。 本部分说明可以阅读第二篇文章后再来看。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:5","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"4. 第一个程序 编辑并运行我们的第一个程序，按照编程界的惯例，输出hello, world!。 首先创建项目文件夹并初始化模块，模块路径自行选择 $ mkdir hello $ cd hello $ go mod init example.com/user/hello go: creating new go.mod: module example.com/user/hello $ cat go.mod module example.com/user/hello go 1.14 $ 然后在该目录下创建hello.go文件，使其包含如下代码 package main import \"fmt\" func main() { fmt.Println(\"Hello, world.\") } 使用go install命令编译安装 \u003e go install github.com/shuzang/hello 该命令会编译程序并产生一个二进制包，然后将该二进制包安装到 $HOME/go/bin/hello ，如果是 Windows，会安装到 %USERPROFILE%\\go\\bin\\hello.exe。 安装目录受 GOPATH 和 GOBIN 影响，如果 GOBIN 被设置，则二进制包会被安装到设置的目录，如果 GOPATH 被设置，二进制包将按照到 GOPATH 列表的第一个目录的 bin 子目录，如果都没有被设置，就会安装到默认 GOPATH 的 bin 子目录($HOME/go or %USERPROFILE%\\go)。 go install 命令执行需要在仓库根目录下，且下面三个命令是等效的 $ go install example.com/user/hello $ go install . $ go install 将$GOPATH/bin添加到电脑的PATH环境变量中，这样可以直接执行 $ hello Hello, world! 可能是因为我使用chocolatey安装的原因，这一环境变量也已经自动设好了，所以我可以直接执行命令。 完成编辑后，就可以使用版本控制工具初始化仓库并上传代码了，示例如下（这一步不是必须的） $ git init Initialized empty Git repository in C:/Users/lylw1/go/src/github.com/shuzang/hello/.git/ $ git add go.mod hello.go $ git commit -m \"initial commit\" [master (root-commit) 0b4507d] initial commit 1 file changed, 7 insertion(+) create mode 100644 go.mod hello.go 一种最方便的方式是将模块路径与仓库路径匹配，比如将以上模块声明为 github.com/username/hello，多数版本控制服务商都支持这种格式。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:4:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5. 编辑器/IDE Golang 开发最流行的两个工具是 Goland 和 VScode，我自己是 VScode 的使用者。除了这两个工具外，官方还提供了一份IDE和插件列表。 VScode 中的 Go 扩展提供了大量的特性，如自动补全、悬停信息显示、括号匹配等，原本属于第三方开发者维护，现在交给了 Go 团队。详细的特性说明查看官网，下面进行一些简单介绍。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5.1 Go工具链 微软在开发 VS Code 过程中, 定义了一种协议： 语言服务器协议 ，用来为每种语言提供诸如自动完成，代码提示等功能。gopls 就是Go语言的服务器, 安装命令为 $ go get -v golang.org/x/tools/gopls 事实上，编辑 Go 代码时如果没有安装，VScode 会在右下角弹出提示，只要直接点击 Install 即可，不需要自己输入命令。同时，因为没有设置go.toolsGopath，默认使用了 GOPATH 作为安装路径 go.toolsGopath setting is not set. Using GOPATH C:\\Users\\lylw1\\go Installing 1 tool at C:\\Users\\lylw1\\go\\bin in module mode. gopls Installing golang.org/x/tools/gopls SUCCEEDED Reload VS Code window to use the Go language server All tools successfully installed. You're ready to Go :). Go代码的调试需要 delve 工具 $ go get -v github.com/go-delve/delve/cmd/dlv 除此之外，还有一批需要安装的分析工具，如下 # Below tools are needed for the basic features of the Go extension. gocode gopkgs go-outline gocode-gomod godef goreturns 所有这些工具只需要在右下角弹出提示后点击 Install 即可 不过上述提到的很多插件不翻墙都无法下载，可以自己手动到github下载然后解压到GOPATH/src，建立起对应的目录结构，然后运行go install将其安装 微软设置了默认的代理服务器，现在(2020.03.18)所有插件均可在不翻墙的情况下顺利安装，而且速度很快 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:1","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5.2 用户和工作区设置 使用 VScode 需要关心的一个重要部分是用户和工作区设置，几乎所有的事情都和它们有关。 这是两种不同的设置范围 用户设置：是一个全局的设置，适用于打开的任何VScode窗口 工作区设置：如题，项目工作区的设置，只适用于对应的工作区 工作区的设置会覆盖掉用户设置，它针对具体的项目，配置文件位于项目根目录.vscode文件夹，可与其它开发者共享。.vscode文件夹还用于存放调试配置和任务配置。 点击左下角的齿轮，选择设置，默认的设置界面如上，是一个可视化的界面，不过也可以使用settings.json配置文件 用户设置文件在windows中位于%APPDATA%\\Code\\User\\settings.json 工作区设置文件位于根目录的.vscode文件夹中 最后，VScode大量的操作都可以通过命令完成，使用快捷键Ctrl+Shift+P可以打开命令输入框。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:2","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5.3 特性说明 在用户或工作区设置中，将 go.autocompleteUnimportedPackages 设为true ，可以在代码中点击包名跳转查看包的具体内容。 鼠标悬停在变量、函数和结构体的名称上方可以查看它们的签名等信息，这一功能由前面安装的godef工具实现，同样可完成这一功能的工具还有godoc和gogetdoc，通过在用户或工作区设置中调整go.docsTool来切换工具。 代码导航功能无需设置默认实现。 对源码的保存操作会自动触发格式化、编译和代码质量检查。格式化工具为gofmt，可选的替代工具有goreturns和goimports，在用户或工作区设置中调整go.formatTool来设置。编译的过程使用go build命令。代码质量检查的工具为golint，也可以使用gometalinter，用来检查代码的规范性，检查得到的errors和warning会在编辑器里以红色/绿色波浪线标出来，下面的输出窗口也会显示详细信息。 所有可选的替代工具都需要自己安装，使用快捷键打开命令面板，输入 Go: Install/Update Tools ，选择要安装的工具，点击确定即可。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:3","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5.4 使用 调试使用的是前面安装的delve工具。在 VScode 中，按F5启动调试，一般情况下使用默认的调试配置即可，不过还是应当对调试配置选项有一定的了解。 默认是没有调试配置文件的，当我们需要进行配置时，输入命令 Debug: Open launch.json ，第一次会在工作区根目录的.vscode文件夹中创建launch.json文件，文件中默认的配置信息如下 { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Launch\", \"type\": \"go\", \"request\": \"launch\", \"mode\": \"auto\", \"program\": \"${fileDirname}\", \"env\": {}, \"args\": [] } ] } 可设置的配置属性可查看Debugging Go code using VS Code，更多关于VScode中Go调试的相关信息都可查看该文档。 这里需要注意的是args，调试时程序需要传入的参数数组是该配置参数的值 运行程序使用快捷键Ctrl+F5，和调试使用的是同一个配置文件。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:4","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["研究生的区块链学习之路"],"content":"先声明结论：最后由于网络原因没有成功，这种在多台电脑中安装虚拟机来联网的方式是存在一定问题的，其次，本篇所述的搭建方法过于繁琐，稍有不慎需要全部从头再来，在后面的实验中我们使用了简化的搭建流程。 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:0:0","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"一. 前言 为了设计一个对物联网的访问控制方案，首先利用两台树莓派和两台计算机搭建完成了一个 Quorum 区块链实验平台，并采用了 Istanbul-BFT 共识算法，但未启用隐私管理器。之后将在该实验平台上部署编写的访问控制合约。实验平台的网络拓扑如下： IBFT 共识允许的最小节点数量为 4，所以设置了 4 个节点，其中，两台电脑作为管理者或者用户的角色，能比较容易的和区块链交互，因为传感器和执行器本身没有足够的能力运行区块链节点，两台树莓派作为 IoT 设备的网关，我们所验证的是其中一台树莓派管理的设备向另一台树莓派管理的设备发起的访问。这里要注意两点： 系统中不止设备对设备的访问，一定还包括用户通过 PC 或移动设备对 IoT 设备的访问； 使用树莓派的原因是尽量模拟实际的环境，但事实上，树莓派依然与实际环境相差巨大，更多的是验证当前方案在资源受限的网关设备上运行的可能性及对设备造成的运行压力。 下面介绍平台的搭建过程，主要分为以下几步 计算机环境配置 树莓派启动和环境配置 Quorum 私链网络搭建和测试运行 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:1:0","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"二. 计算机环境配置 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:2:0","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"1. 设备和操作系统选择 实验平台共使用了两台计算机和两台树莓派。设备和操作系统的详细信息如下： 设备 CPU 操作系统 内存 硬盘 清华同方 Intel Core i5-4460, 3.2GHz Ubuntu 18.04 LTS(虚拟机) 2GB 50GB 华硕A550 Intel Core i5-4200, 2.8GHz Ubuntu 18.04 LTS(虚拟机) 2GB 50GB Raspberry Pi 3 Model B Plus quad-core ARM Cortex A53, 1.4GHz Raspbian Buster 1GB 32GB(microSD card) Raspberry Pi 3 Model B quad-core ARM Cortex A53, 1.2GHz Raspbian Buster 1GB 16GB(microSD card) ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:2:1","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"2. 静态ip分配 两台计算机的操作环境是在虚拟机上完成的，涉及到网络相关操作，这里事先对各设备进行静态ip的分配 设备 主机名 IP地址 操作系统 清华同方（PC） NodeA 192.168.191.2 Ubuntu 18.04 LTS 华硕（Laptop) NodeB 192.168.191.3 Ubuntu 18.04 LTS Pi 3B+ NodeC 192.168.191.4 Raspbian Buster Pi 3B NodeD 192.168.191.5 Raspbian Buster 注：以下以 PC 为例进行相关配置，Laptop 配置操作基本相同。 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:2:2","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"3. 操作系统设置 在 VM ware 中安装 Ubuntu 18.04 虚拟机，安装完成后完成如下基础配置操作： (1) 更新源和系统 根据自己需要选择是否更换软件源，此处我使用了原生的源 $ sudo apt-get update $ sudo apt-get upgrade (2) 调整系统时间 查看系统时区是否正确 $ timedatectl Local time: 五 2019-09-13 11:07:13 +08 Universal time: 五 2019-09-13 03:07:13 UTC RTC time: 五 2019-09-13 03:07:13 Time zone: Asia/Ulaanbaatar (+08, +0800) System clock synchronized: yes systemd-timesyncd.service active: yes RTC in local TZ: no 若不正确，使用下列命令设置时区，时区根据自己所处位置调整 $ timedatectl set-timezone Asia/Shanghai (3) 设置主机名 $ sudo hostnamectl set-hostname NodeA 重启终端查看新的主机名 $ hostnamectl Static hostname: NodeA Icon name: computer-vm Chassis: vm Machine ID: d16107a02250422baa2e04fb10c98558 Boot ID: ea8fbdb520774a52a205281b4034f8b0 Virtualization: vmware Operating System: Ubuntu 18.04.3 LTS Kernel: Linux 4.15.0-20-generic Architecture: x86-64 (4) 设置静态ip 安装 net-tools 工具 $ sudo apt-get install net-tools 设置虚拟机网络为桥接模式，桥接到无线网卡。在/etc/netplan目录下创建配置文件 $ sudo nano /etc/netplan/02_config.yaml 在配置文件中添加如下信息 network:version:2renderer:networkdethernets:ens33:addresses:- 192.168.191.2/24gateway4:192.168.191.1nameservers:search:[mydomain,otherdomain]addresses:[1.1.1.1,8.8.8.8] ens33是网卡名，addresses下的内容为自定义的静态ip，gateway4为网关地址。保存退出，使用netplan启用设置，并查询更改后的ip地址 $ sudo netplan apply $ ifconfig ens33: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 192.168.191.2 netmask 255.255.255.0 broadcast 192.168.191.255 inet6 fe80::94ff:42f8:57d5:a20f prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:0c:29:09:08:33 txqueuelen 1000 (以太网) RX packets 155321 bytes 207407688 (207.4 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 76320 bytes 4839627 (4.8 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: ... (5) 重新安装VMware tools 只有安装 VMware tools 之后，虚拟机界面才会自动调整全屏，并且能在虚拟机和主机之间互传文件。 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:2:3","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"4. 区块链环境配置 使用的是 Quorum 区块链，共识是 Istanbul BFT。 (1) 安装golang 获取与安装 go1.13 $ wget https://dl.google.com/go/go1.13.linux-amd64.tar.gz $ sudo tar -xzf go1.13.linux-amd64.tar.gz -C /usr/local $ rm go1.13.linux-amd64.tar.gz 设置环境变量 $ sudo nano /etc/profile # 在打开的文件末尾添加下列语句 export PATH=$PATH:/usr/local/go/bin 更新的环境变量在下一次登录之前不会生效，但可以通过下面的命令使其直接生效 $ source /etc/profile # 查看生效后的环境变量设置 $ go version go version go1.13 linux/amd64 注：真正生效必须重启系统 (2) 安装geth for quorum 获取编译后的二进制包 $ wget https://bintray.com/quorumengineering/quorum/download_file?file_path=v2.2.5/geth_v2.2.5_linux_amd64.tar.gz 解压缩并安装 $ sudo tar -xzf download_file?file_path=v2.2.5%2Fgeth_v2.2.5_linux_amd64.tar.gz -C /usr/local/bin $ rm download_file?file_path=v2.2.5%2Fgeth_v2.2.5_linux_amd64.tar.gz 测试安装 $ geth version WARN [09-13|16:03:38.966] Sanitizing cache to Go's GC limits provided=1024 updated=655 Geth Version: 1.8.18-stable Git Commit: c894c2d70eacf30740d03b53ed2fb39e42641295 Quorum Version: 2.2.5 Architecture: amd64 Protocol Versions: [63 62] Network Id: 1337 Go Version: go1.11.12 Operating System: linux GOPATH= GOROOT=/home/travis/.gimme/versions/go1.11.12.linux.amd64 (3) 获取并编译istanbul-tools istanbul-tools 用来初始化 istanbul-BFT 共识网络及进行网络测试 $ sudo apt-get install git $ mkdir istanbul \u0026\u0026 cd istanbul $ git clone https://github.com/jpmorganchase/istanbul-tools.git $ cd istanbul-tools 执行编译 $ sudo apt-get install -y build-essential $ make 编译后的文件位于/build/bin目录下，执行测试 $ ./build/bin/istanbul istanbul --version istanbul version v1.0.1 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:2:4","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"三. 树莓派启动及环境配置 以Pi 3B+为例，Pi3B 配置操作基本相同 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:3:0","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"1. 树莓派启动 将 Raspbian Buster 镜像写入准备好的SD卡，重新加载在电脑中的SD卡会出现boot盘，同时也是树莓派的/boot目录。在boot盘根目录新建名为ssh的文件，开启SSH连接。同时新建wpa_supplicant.conf文件，编辑其内容如下： ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=CN network={ ssid=\"WiFi名\" psk=\"密码\" priority=10 } 将其中的ssid和psk更改为自己无线网络的网络名和密码。将配置好的SD卡卸载并插入树莓派，通电启动。使用Advanced IP Scanner扫描无线网络的网段，获取树莓派ip，本实验无线网络网段为192.168.191.1-254。 使用扫描到的ip通过Putty利用SSH协议进行登录。 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:3:1","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"2. 树莓派基本配置 (1) 更新源及系统 编辑/etc/apt/sources.list文件 sudo nano /etc/apt/sources.list 注释掉原来的源，将源更新为： deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 保存退出，编辑/etc/apt/sources.list.d/raspi.list文件 sudo nano /etc/apt/sources.list.d/raspi.list 将源更新为： deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 更新源文件列表，更新软件 $ sudo apt-get update $ sudo apt-get upgrade (2) 安装xrdp供远程连接 $ sudo apt-get install xrdp (3) 开启ftp供文件传输 安装vsftpd $ sudo apt-get install vsftpd 编辑配置文件 $ sudo nano /etc/vsftpd.conf 启用对树莓派的写入权限 # Uncomment this to enable any form of FTP write command.write_enable=YES 保存退出，启用vsftpd $ sudo service vsftpd start (4) 修改pi账户密码，时区和主机名 $ sudo raspi-config 选择第一项Change User Password，键入新密码并确定， 选择第四项Localisation Options，选择Change Timezone，将时区更改为Asia/Shanghai 全部设置完成后选择Finish退出，终端将看到如下输出 Current default time zone: 'Asia/Shanghai' Local time is now: Fri Sep 13 18:40:56 CST 2019. Universal Time is now: Fri Sep 13 10:40:56 UTC 2019. New password: Retype new password: passwd: password updated successfully OK 设置主机名 $ sudo hostnamectl set-hostname NodeC 编辑/etc/hosts文件，将127.0.1.1对应的raspberry更改为NodeC 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters 127.0.1.1 NodeC 退出终端并使用新密码重新登录，主机名将更改为NodeC。注意此时用户名仍为pi。 (5) 设置静态ip 编辑/etc/dhcpcd.conf文件 $ sudo nano /etc/dhcpcd.conf 在末尾添加如下内容 interface wlan0 static ip_address=192.168.191.4/24 static routers=192.168.191.1 static domain_name_servers=192.168.191.1 重启并以新的ip登录树莓派。 (6) 获取并安装geth $ git clone -b gethonly https://github.com/shuzang/quorum-raspbian.git $ cd quorum-raspbian $ sudo cp geth /usr/local/bin $ sudo chmod +x /usr/local/bin/geth 测试安装是否成功 $ geth version WARN [09-13|19:51:40.051] Sanitizing cache to Go's GC limits provided=1024 updated=308 Geth Version: 1.8.18-stable Quorum Version: 2.2.5 Architecture: arm Protocol Versions: [63 62] Network Id: 1337 Go Version: go1.11.6 Operating System: linux GOPATH= GOROOT=/usr/lib/go-1.11 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:3:2","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"四. 私链网络搭建及测试运行 各节点数据和相关文件的前期生成都在NodeA中由istanbul-tools工具完成。切换到NodeA节点的PC，在istanbul目录下创建四个节点的工作目录 $ cd ~/istanbul $ mkdir NodeA NodeB NodeC NodeD 进入领导节点（这里是NodeA）目录，使用istanbul-tools工具为四个节点生成安装玩家，该命令会为所有的初始验证者节点生成 static-nodes.json, genesis.json和 nodekeys三种文件。 $ cd NodeA $ ../istanbul-tools/build/bin/istanbul setup --num 4 --nodes --quorum --save --verbose 将输出生成的文件信息 validators { \"Address\": \"0x93c20b1ffa9bf8738bf194d5203e3d2e2a48428d\", \"Nodekey\": \"6f17ec19de39281ea72a6d91d1e780bf5a0e35602f0e844e82dcc9d6a9ba7716\", \"NodeInfo\": \"enode://faa50654f681a890c28be2faeef9211afaf1563c08ddb8990f6b39c561e002ea687707be68c16363f65c0755f785cb16e3b7be84e5e4eb260b0d4a6f6f83ef87@0.0.0.0:30303?discport=0\" } { \"Address\": \"0xff75bd429c43de6719c2983c1e991b0279909559\", \"Nodekey\": \"b7c11c512d33e3c1de97abd8a690cdbcfac9c6802a43a6ff850b244d90258908\", \"NodeInfo\": \"enode://c286de4e89f4f209a6b32284b31829251ccb23bf5ab3bbe57ba08754392635ae755848dd6c4f367c7d92284e54e4b9f0d1a896924309380eb947e3b8c6641392@0.0.0.0:30303?discport=0\" } { \"Address\": \"0xf22670e572a42729a2c10fb26f57bba46cbc3a42\", \"Nodekey\": \"9b3740640431f0d6543f730308509fb9bc35307f826b1dd838b6812a6067f477\", \"NodeInfo\": \"enode://cb50baa67204df2246b143e2982e40a89b2924e5c19e2834876c34042f0a81a2e2604ab210d19a048762f5355258d9840932ba868227857d928495d398c04af0@0.0.0.0:30303?discport=0\" } { \"Address\": \"0x350686ae7615e87a046fc4261fe58fda3872aa65\", \"Nodekey\": \"b6fd16bc88c8f96430b9ec0c4f6991c0f958e70026fce1abc959b295774f4e94\", \"NodeInfo\": \"enode://214dce3278a2b45fb0bf2a1d53c24eb213c5cbb08307e842feab0202cad4f685c5c62a4197d29318f07eb813bf4189db05096b551849039bf81fb74f0211320f@0.0.0.0:30303?discport=0\" } static-nodes.json [ \"enode://faa50654f681a890c28be2faeef9211afaf1563c08ddb8990f6b39c561e002ea687707be68c16363f65c0755f785cb16e3b7be84e5e4eb260b0d4a6f6f83ef87@0.0.0.0:30303?discport=0\", \"enode://c286de4e89f4f209a6b32284b31829251ccb23bf5ab3bbe57ba08754392635ae755848dd6c4f367c7d92284e54e4b9f0d1a896924309380eb947e3b8c6641392@0.0.0.0:30303?discport=0\", \"enode://cb50baa67204df2246b143e2982e40a89b2924e5c19e2834876c34042f0a81a2e2604ab210d19a048762f5355258d9840932ba868227857d928495d398c04af0@0.0.0.0:30303?discport=0\", \"enode://214dce3278a2b45fb0bf2a1d53c24eb213c5cbb08307e842feab0202cad4f685c5c62a4197d29318f07eb813bf4189db05096b551849039bf81fb74f0211320f@0.0.0.0:30303?discport=0\" ] genesis.json { \"config\": { \"chainId\": 10, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip150Hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"eip155Block\": 0, \"eip158Block\": 0, \"byzantiumBlock\": 0, \"constantinopleBlock\": 0, \"istanbul\": { \"epoch\": 30000, \"policy\": 0 }, \"txnSizeLimit\": 64, \"isQuorum\": true }, \"nonce\": \"0x0\", \"timestamp\": \"0x5d7c4ae8\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000f89af8549493c20b1ffa9bf8738bf194d5203e3d2e2a48428d94ff75bd429c43de6719c2983c1e991b027990955994f22670e572a42729a2c10fb26f57bba46cbc3a4294350686ae7615e87a046fc4261fe58fda3872aa65b8410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x1\", \"mixHash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"350686ae7615e87a046fc4261fe58fda3872aa65\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" }, \"93c20b1ffa9bf8738bf194d5203e3d2e2a48428d\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" }, \"f22670e572a42729a2c10fb26f57bba46cbc3a42\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" }, \"ff75bd429c43de6719c2983c1e991b0279909559\": { \"balance\": \"0x446c3b15f9926687d2c40534fdb564000000000000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } 查看生成的文件 $ ls -l total 24 drwxr-xr-x 2 shuzang shuzang 4096 Sep 14 10:05 0 drwxr-xr-x 2 shuzang shuzang 4096 Sep 14 10:05 1 drwxr-xr-x 2 shuzang shuzang 4096 Se","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:4:0","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"五. 总结 由于网络质量问题，区块链共识无法正常运行，合约部署无法完成。 INFO [09-14|10:56:00.419] Commit new mining work number=1 sealhash=1305ae…019d90 uncles=0 txs=0 gas=0 fees=0 elapsed=556.954µs TRACE[09-14|10:56:00.420] Dial error task=\"staticdial 5e62fd3b39e5ae25 192.168.191.5:30303\" err=\"dial tcp 192.168.191.5:30303: connect: connection refused\" DEBUG[09-14|10:56:00.421] Can't resolve node id=0x8e6a40 err=\"discovery is disabled\" TRACE[09-14|10:56:00.421] Dial task done task=\"staticdial 5e62fd3b39e5ae25 192.168.191.5:30303\" TRACE[09-14|10:56:00.420] handleRequest address=0x93C20b1ffA9BF8738BF194d5203e3D2E2A48428d state=\"Accept request\" seq=1 number=1 hash=23cc4d…b11876 TRACE[09-14|10:56:00.422] Dial error task=\"staticdial c31b4abe77e8a91a 192.168.191.4:30303\" err=\"dial tcp 192.168.191.4:30303: connect: connection refused\" 主要原因估计是PC上的节点装在了虚拟机里，虚拟机又使用桥接模式，导致最后丢包率和延迟都比较高。 解决Hyper-V内虚拟机网络延迟高的问题(ping延时大) ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:5:0","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"附录 树莓派安装 quourm 节点 在熟悉了树莓派并和虚拟机顺利组网以后，首要面临的事情就是在树莓派中安装quorum节点，由于暂时不使用隐私保护功能，不安装隐私管理器Tessera或Constellation。需要安装的只包括： quorum的客户端geth Istanbul BFT共识配置工具istanbul-tool ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:6:0","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"交叉编译（2019.09.09） quorum项目没有提供可用于arm架构的二进制包，只能自己编译。然而，在树莓派中直接进行编译存在两个问题 会占用很多不必要的空间，quorum项目文件编译后大小在360M以上 编译istanbul-tool依赖于golang的某些包，需要访问google，很多ip无法访问。 因此，最终选择了在PC中进行交叉编译，幸运的是，由于quorum的源项目ethereum可以交叉编译，quorum继承了交叉编译的功能。文档仍然需要看Cross compiling Ethereum。交叉编译依赖于名为xgo的包，而这个包依赖于Docker和Go，因此，交叉编译之前需要先安装它们。 注：交叉编译在Ubuntu18.04系统下进行。 安装golang $ sudo snap install go --classic $ go version 安装docker(使用脚本) $ curl -fsSL https://get.docker.com -o get-docker.sh $ sudo sh get-docker.sh \u003coutput truncated\u003e # 想在非root用户下运行，需要将用户添加到docker group。执行如下命令 $ sudo usermod -aG docker your-user 下载quorum $ git clone https://github.com/jpmorganchase/quorum.git 执行交叉编译 $ cd quorum $ make geth-linux-arm-7 $ cd build/bin # 在该目录下可以找到编译后的geth文件 心态爆炸，交叉编译后的geth在树莓派中无法执行，Ubuntu18.04下原本编译完直接放到/usr/local/bin下面即可使用，raspbian中当我放到同样的目录下不起作用，也不知道是交叉编译失败了还是raspbian系统不支持。考虑到raspbian基于Debian，现在不知道Debian应该把可执行文件放在哪里，网上找了很久没找到相关资料。(交叉编译其实可以，直接跳到文章最后可看到方法) ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:6:1","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"Ubuntu mate（09.10 am） quorum的issue中有个项目组的回答，其中说quorum运行在树莓派中是肯定可以的，这一点终于可以放心，还推荐用Ubuntu，那就试试。 “Yes. Whilst I haven’t tried it, I’m aware that folks have done this and you can find articles on the internet describing how to do it for Ethereum (Quorum will be the same). My suggestion would be to install Ubuntu on the Rasberry and follow the normal steps for building Quorum.” 树莓派官网提供的Ubuntu可用镜像有三种：Ubuntu Mate，Ubuntu Core，Ubuntu Server。看到Ubuntu Mate的种种特性，我动心了，看起来好像是专门定制的。 Ubuntu Mate说明及下载，选择的镜像是 Raspberry Pi(recommended) For aarch32(ARMv7)computers,like: - Raspberry Pi Model B 2 - Raspberry Pi Model B 3 - Raspberry Pi Model B 3+ 下载，镜像写入，根目录预先建立ssh和wpa_supplicant.conf文件，插入树莓派，启动运行，扫描不到ip，看起来WiFi没法自动联网。通过网线接到PC上共享网络，ssh访问被拒，接到路由器上一样不行。找资料，关于Ubuntu mate的资料比较少，最终在官方下载页-Additional feature找到一个对特性的说明，称Ubuntu mate没有像raspbian的pi账户一样预定义的用户账户，所有的配置需要在第一次启动时手动完成，ssh预先也没有安装，需要启动后自己安装openssh-server并启用。完了，彻底崩溃，本来没有用户账户就无法登录，连ssh都没有，第一次必须得用屏幕了。屏幕，我没有。。。 考虑到笔记本电脑上有个HDMI接口，买线总比买屏幕便宜，跑到商店买了根双头HDMI线。回来一试，没用，网上说是因为笔记本的HDMI只能输出信号，没法输入，因此不能作为HDMI屏幕使用。转眼又看到了VGA接口，这个怎么样，结果一查，HDMI转VGA也没用，笔记本的VGA同样只有输出功能，平板，手机全都不行，不能作为显示设备，最多只能用ssh连接。 台式机的显示器总行了吧，资料上说要自带电源，怕烧坏树莓派。没事，台式的显示器本来就接电源线。又去店里换一个HDMI转VGA的线，是店里唯一的线，结果是坏的，把线接到树莓派上没有反应，提示请检查线缆而不是无信号输入，拿笔记本试了一下，果然不行，完全检测不到第二屏幕。换！店里没线了怎么办，本来想换HDMI转DVI的，因为显示器后面还有个DVI接口，但店员小哥不推荐，说是用DVI的少，最后拿了HDMI转VGA母口的线，又多买了一根双头VGA线，亏到爆。 不过，总算好使了。 当在显示器上看到Ubuntu mate的界面时我是激动的，太不容易了。初始配置之后还需要进行系统安装，怪不得没法直接进入。但是路由器的WiFi接入不了，或者连接后没法上网，完全没有头绪，只好先用手机开了热点，这倒是没问题。 把之前交叉编译的geth文件拷贝到了Ubuntu mate，放到/usr/local/bin目录下，运行geth version测试，倒是可以了，可惜屏幕打印的文本乱码。重新启动了一下树莓派，结果无限循环启动。初始界面提示如下 Driver 'sdhost-bcm2835' already registered, aborting... 论坛上也有人遇到了这个问题，但从去年11月到今年5月，回帖的所有人都遇到同样的问题而没有办法解决，我已经放弃了。 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:6:2","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"Raspbian下自编译quorum(09.10 pm) 树莓派上编译使用quorum的人不多，但编译ethereum的人绝对不少，现在想起来，终于意识到一件事，大部分人还是在raspbian系统下编译使用的，既然ethereum的geth客户端可以，quorum没道理不行。有可能不是系统的问题，因为raspbian和ubuntu其实都属于基于Debian的发行版，那就是交叉编译问题了。找不到哪里出的错，干脆直接在Raspbian下编译一次quorum吧，空间占用多一点就多一点，还是足够的，唯一的问题只有翻墙，但这是没办法的事情，而且geth的编译暂时还不需要，istanbul-tool才需要。 注：其实raspbian下翻墙试过了，我有surfshark的账号，官方也给了步骤，How to set up Surfshark VPN on Raspberry Pi，但最后一步连接总是出错，错误提示为 TLS Error: TLS handshake failed 网上关于这个Error的问题不少，但都没起作用，就放弃了。 重新写入了之前备份的raspbian镜像（备份真的很有用，能省好多事儿）。启动树莓派，使用预定义的静态ip登录，安装go，下载github上的quorum项目(主要是这里直接下载比git clone快多了)。执行编译，注意使用sudo make all，因为编译需要分配存储空间，不给权限过不了。 树莓派卡死了。。。 重启了一次，第二次又卡死了，看来不是意外，应该是编译出了问题，果然，等了很久后，编译退出，系统正常了，但出现了错误提示，是一个存储问题。 running gcc failed: fork/exec /usr/bin/gcc: cannot allocate memory Ethereum的论坛有人在编译时遇到了同样的问题，Installing geth on Raspberry Pi 3 - cannot allocate memory error，回帖提到是因为编译所需的内存不够的缘故，建议杀掉内存占用大而且不用的进程。使用free -h查看 total used free shared buff/cache available Mem: 926Mi 119Mi 575Mi 7.0Mi 231Mi 744Mi Swap: 99Mi 0B 99Mi 不算少啊，700多M呢，再用top命令看进程，并按M键按内存占用排序，发现杀哪个进程都不合适。回帖中还有人提到可以调整交换空间大小，就是第二行的Swap，树莓派默认100M，可以调大点，问题的说明及解决方案见How to set up swap space。 树莓派使用dphys-swapfile文件定义交换空间大小，打开配置文件 $ sudo nano /etc/dphys-swapfile 启用内容只有一行 CONF_SWAPSIZE=100 代表默认100M交换空间大小，把数值改成合适的内容，我直接改了1024。然后重新启用新的配置文件。 $ sudo /etc/init.d/dphys-swapfile restart 完成后再用free -h命令查看交换空间大小就变了，此时重新编译，编译速度会大大加快，等待一段时间后，编译顺利执行完毕。将编译得到的文件复制到/usr/local/bin目录下。 $ sudo cp build/bin/geth /usr/local/bin $ sudo cp build/bin/bootnode /usr/local/bin # 验证 $ geth version 成功。 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:6:3","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"istantul-tool(09.11 am) istantul-tool的编译毫无办法，编译过程要访问google，有些ip无法访问，但既然这里编译没有指明针对arm架构，明天把虚拟机编译好的文件拿过来试试。 Linux编译得到的istanbul文件在树莓派中无法执行，错误提示为 -bash: ./istanbul: cannot execute binary file: Exec format error 使用file istanbul命令查看文件信息 istanbul: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64 .so.2, for GNU/Linux 3.2.0, Go BuildID=Whu77pcg5_4qdJyzC6lH/RiHbDbxGfs3BFqYFYhdk/Uvgfkwy9en1ShuGpCcPB/qCr7Qg3bewybrm4 vmE3B, BuildID[sha1]=588353ce35513ef4a2d9695f458a338e226093b1, not stripped x86-64的，看来还是架构相关，项目本身没有提供对arm的编译功能，没有办法了。不过有可能不需要在树莓派中运行，我们只需要在作为主节点的虚拟机利用它生成各节点数据，然后拷贝到树莓派中就行。 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:6:4","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["研究生的区块链学习之路"],"content":"运行geth文件（09.11 am） 直接拷贝编译的geth文件到另一个树莓派，并使用cp命令复制到/usr/local/bin目录无法执行，提示 -bash: /usr/local/bin/geth: Permission denied 是因为没有执行权限，使用chmod命令授予权限即可顺利执行 $ cd quorum $ sudo cp build/bin/geth /usr/local/bin $ sudo chmod +x /usr/local/bin/geth $ geth version WARN [09-11|03:13:38.840] Sanitizing cache to Go's GC limits provided=1024 updated=308 Geth Version: 1.8.18-stable Quorum Version: 2.2.5 Architecture: arm Protocol Versions: [63 62] Network Id: 1337 Go Version: go1.11.6 Operating System: linux GOPATH= GOROOT=/usr/lib/go-1.11 这样看来，交叉编译的结果也不是因为系统不支持，应该也是没有执行权限，下面是使用geth version命令测试交叉编译的geth的结果。 WARN [09-11|03:27:52.671] Sanitizing cache to Go's GC limits provided=1024 updated=308 Geth Version: 1.8.18-stable Git Commit: 7e87e403407fcb3b3c417739eef2fe1dae923add Quorum Version: 2.2.5 Architecture: arm Protocol Versions: [63 62] Network Id: 1337 Go Version: go1.12 Operating System: linux GOPATH= GOROOT=/usr/local/go 走了好多弯路。。。原来一开始的结果就可以。 ","date":"2019-09-13","objectID":"/2019/using-virtual-machine-to-build-experimental-platform/:6:5","tags":["科研记录"],"title":"研究记录4-利用虚拟机搭建实验平台(失败)","uri":"/2019/using-virtual-machine-to-build-experimental-platform/"},{"categories":["爱编程爱技术的孩子"],"content":"双系统时常折腾容易坏电脑，因此一般是在虚拟机中使用Linux系统，常用的虚拟机为VMware，本文对VMware的相关知识以及使用过程中的一些问题做介绍。 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:0:0","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"三种网络模式辨析 VMware有三种网络模式，分别是桥接模式、NAT模式和主机模式 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:1:0","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"1. Bridged(桥接模式) 在桥接模式下，VMware虚拟出来的操作系统就像是局域网中的一独立的主机，它可以访问网内任何一台机器。不过你需要空闲的IP地址，并且需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。 如果你想利用VMware在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:1:1","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"2. NAT(网络地址转换模式) 使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。 如果你想利用VMware安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。（也可以配置静态IP，后面会介绍） ","date":"2019-09-06","objectID":"/2019/vmware-usage/:1:2","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"3. Host-only(主机模式) 在某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔离开，这时你就可采用Host-only模式。 在Host-only模式中，所有的虚拟系统是可以相互通信的，但虚拟系统和真实的网络是被隔离开的。可以利用Windows XP里面自带的Internet连接共享(实际上是一个简单的路由NAT)来让虚拟机 通过主机真实的网卡进行外网的访问。虚拟系统的TCP/IP配置信息(如IP地址、网关地址、DNS服务器等)，都是由VMnet1(Host-only)虚拟网络的DHCP服务器来动态分配的。如果你想利用VMware创建一个与网内其他机器相隔离的虚拟系统，进行某些特殊的网络调试工作，可以选择Host-only模式。 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:1:3","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"静态ip设置 虚拟机中安装的是Ubuntu18.04，因项目需要对其进行静态IP设置 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:2:0","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 桥接模式 首先查看虚拟机网络配置信息，选择菜单栏编辑—\u003e虚拟网络编辑器，在三个网络中选择VMnet0，桥接模式中选择网卡，我选择了有线网卡，可以根据需要选择无线网卡。 其次编辑虚拟机网络模式，点击编辑虚拟机设置，选择网络适配器，在网络连接部分选择桥接模式。 ###　2. NAT模式 首先依然是查看虚拟机网络配置信息，选择菜单栏编辑—\u003e虚拟网络编辑器，在三个网络中选择VMnet8，点击NAT设置，查看并记录子网ip和网关。虚拟网络编辑器中的使用本地DHCP服务将IP地址分配给虚拟机选项不要取消勾选，因为看到很多教程说要取消勾选，实际上取消掉之后就没网了。 注：这一步是查看，没有需要更改的内容。 然后编辑虚拟机网络模式。查看完配置信息后，在要设置静态ip的虚拟机界面下，点击编辑虚拟机设置，进入后选择网络适配器，在网络连接部分从NAT模式切换到自定义特点虚拟网络，并选择VMnet8(NAT模式)。点击确定后退出。 注：这一步需要在关闭虚拟机的状态下进行，挂起状态无法设置 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:2:1","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 静态ip设置 Ubuntu18.04的静态ip设置是通用的，不因使用虚拟机不同。官方对静态ip设置的说明位于Network Configuration，步骤如下： 使用ifconfig可以查看当前ip和网关地址和网卡名，若有必要可以自己测试一下网络是否畅通。 在/etc/netplan目录下创建配置文件02_config.yaml，因为该目录下已有01开头的文件。 $ sudo nano /etc/netplan/02_config.yaml 在配置文件中添加如下信息 network:version:2renderer:networkdethernets:ens33:addresses:- 192.168.191.4/24gateway4:192.168.191.1nameservers:search:[mydomain,otherdomain]addresses:[1.1.1.1,8.8.8.8] ens33是网卡名，即之前使用ifconfig命令查到的ip最前面的字段。addresses下的ip是自定义的静态ip，根据子网ip自己选择设置即可，掩码是24位的。gateway4就是之前在NAT设置中看到的网关地址。nameservers下的addresses是域名服务器地址，这里写的两个是常用的。 保存退出，使用netplan启用配置 $ sudo netplan apply 再次查询即可看到新的ip地址，为我们设置的静态ip，最后可以ping一下8.8.8.8和百度测一下网络是否可用。 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:2:2","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"桥接模式静态ip变动问题 联网试验期间突然有设备连不上了，经查发现使用netplan编辑启用的静态ip已变更，但这种情况只发生在虚拟机中。使用sudo netplan apply命令重新启用，但一段时间后会再次变为其它ip。是虚拟机桥接模式的设置问题，还是Ubuntu18.04本身设置静态Ip的方式问题，暂时不清楚。 桥接模式存在“复制物理网络连接状态”的选项，用于笔记本电脑在有线和无线网络之间切换时的ip地址续订。未确认是否对ip地址变动有影响，鉴于连接无线网络不做变动，已取消勾选。 官方解释-为现有虚拟机配置桥接模式网络连接 您可以为现有虚拟机配置桥接模式网络连接。 要为新虚拟机配置桥接模式网络连接，请在运行新建虚拟机向导时选择自定义硬件。 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:3:0","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"过程 选择虚拟机，然后选择虚拟机 \u003e 设置。 在硬件选项卡中，选择网络适配器。 选择桥接模式: 直接连接物理网络。 如果在笔记本电脑或其他移动设备上使用虚拟机，请选择复制物理网络连接状态。 当您在有线或无线网络之间进行移动时，该设置会导致 IP 地址续订。 单击确定保存所做的更改。 第一种解决思路是虚拟机直接连接无线网络，但囿于笔记本的虚拟机无法检测到无线网卡，作罢，同时也不知道最后是否真的能起作用 目前打算直接从路由器后台针对MAC地址设置静态ip，虚拟机的MAC地址可以使用ifconfig命令查看，虽然网上都称应查看HWaddr后的地址，但并没有这个标识，只在ens33的描述信息中存在如下描述，ether后的地址为MAC地址 ether 00:0c:29:5d:1f:a1 txqueuelen 1000 (Ethernet) 也可以从虚拟机设置—\u003e网络适配器—\u003e高级查看MAC地址，两者应是一致的。 然后在路由器后台选择IP与MAC绑定—\u003e静态ARP绑定设置，绑定设备MAC和要使用的静态IP即可。这里使用的路由器是水星MW306R。 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:4:0","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"ping出现DUP！ 主机和树莓派都接入了路由器开启的WiFi网络，树莓派之间相互ping没有问题，但当树莓派ping虚拟机的系统，或者虚拟机的系统ping任何一个网址，返回的数据包都会出现DUP！错误。网上的解决办法是禁用然后重新启用VMnet8，但并没有起作用。 经测试，有线网卡和无线网卡都接入了路由器的网络，虚拟机桥接到了无线网卡上，可能因此造成了环路（并不确定）。当我将虚拟机直接桥接到有线网卡上，再次发起ping命令，并断开了无线网卡的连接，DUP!错误就消失了。没有明白原理，但确实解决了错误。 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:5:0","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"重启后界面变小 虚拟机重启后有时候窗口会变得只有中间一小块且没法放大，虽然可以通过重新安装vm-tools来修复，但经常重装也太麻烦了。实际上这种故障是由于vm-tools的服务没有正常启动造成的，可以通过执行下面的命令解决。 $ sudo systemctl restart opoen-vm-tools github上open-vm-tools项目的#253和#303两个issue都是讨论这个问题的。 ","date":"2019-09-06","objectID":"/2019/vmware-usage/:6:0","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"参考 [1] 陆小呆-虚拟机网络NAT模式配置静态IP ","date":"2019-09-06","objectID":"/2019/vmware-usage/:7:0","tags":["linux"],"title":"VMware虚拟机使用技巧","uri":"/2019/vmware-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"小米随身WiFi拥有两种模式，网卡模式可以令电脑搜索并接入其它的WiFi，AP模式可以开启一个WiFi供别的设备加入。现在拥有一台主机，插在上面的小米随身WiFi开启了热点模式，网关地址为192.168.191.1。另外还有两台树莓派，静态ip分别设置为了192.168.191.2和192.168..191.3。主机中利用VMware建立了一个虚拟机，系统为Ubuntu18.04。现在，虚拟机中的系统（之后简称为虚拟机）需要和两块树莓派联通。拓扑结构如下： 在NAT模式下对虚拟机设置了静态ip，但这种情况测试网络时发现虚拟机可以ping通两个树莓派，树莓派无法ping通Ubuntu，经过思考发现NAT模式下虚拟机所在网段和树莓派所在网段不是同一个，虚拟机共享了主机的网络，但树莓派处于AP热点网络下，无法访问。 将NAT模式改为桥接模式，虚拟机桥接到作为AP热点的小米随身WiFi上。但经试验无法联通，主要是因为桥接的本质是将虚拟机视为和主机在同一网络下的实体设备，桥接的对象也是拥有自己ip的终端设备，而小米随身WiFi此时处于AP模式，类似于路由器，只存在网关地址。理解了这个之后，转而将虚拟机桥接到有线网卡上，但有线网卡所在的实验室局域网和AP热点的局域网存在隔离，无法联通。 转而直接由虚拟机开启AP热点（安装驱动，利用create_ap开启AP热点），如果树莓派可以访问虚拟机，就能实现互通，经实验并不可以，是因为在AP模式下，小米随身WiFi仍然是路由器状态，虚拟机在网络上的ip取决于其有线网卡，然而有线网卡的地址仍然是实验室局域网ip，和树莓派不互通。 手机开启热点，主机上的随身WiFI切换回无线网卡模式，主机和树莓派都接入手机开启的热点网络。这种情况可以互通，但由于无法对手机热点的网段进行设置，从而无法设定各设备的静态ip。 主机利用随身WiFi开启热点，树莓派和另外一台笔记本电脑接入热点网络，笔记本电脑中开启两个Ubuntu18.04的虚拟机，每个都桥接到热点网络上。这种办法没有试验，一是主机电脑将会陷入闲置，而笔记本电脑的负载将加大。二是太麻烦了，此时打算直接用路由器开局域网让所有设备接入。 找同学借了一个水星MW306R的路由器，开了个局域网，默认网关是192.168.1.1，因为树莓派的静态ip已经设好了，不想动，于是把路由器的网关改成了192.168.191.1，然后树莓派，主机，笔记本都接到路由器的网络，主机和笔记本电脑各开一个虚拟机，虚拟机桥接到无线网络上，从而实现了互通。 ","date":"2019-09-06","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%84%E7%BD%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/:0:0","tags":["树莓派"],"title":"树莓派和虚拟机组网出现的问题及解决思路","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%84%E7%BD%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"},{"categories":["爱编程爱技术的孩子"],"content":"树莓派刷好系统，要进行联网使用，手里没有显示屏和HDMI线，实验室没有路由器，电脑也没有无线网卡，唯一的网口也被占用。只能通过网线和USB网口转换器直连电脑并使用SSH登录。 准备材料 刷好系统的树莓派，已添加ssh文件启用ssh 一根网线 一台已联网的电脑 USB网口转换器（如果有多余的网口可以不需要） 连接 使用USB网口转换器扩展一个网口出来，使用网线连接扩展的网口和树莓派。 网络设置 打开网络和共享中心，可看到已联网的网络以太网和树莓派连接的网络以太网3 设置网络共享 点击以太网3-\u003e属性-\u003e共享选项卡-\u003e双击“Internet协议版本4（TCP/IP)” –\u003e 选择“使用下面的ip地址” ，填入后点击确认 点击以太网-\u003e属性-\u003e共享选项卡-\u003e勾选“允许其他网络用户通过此计算机的Internet连接来连接” –\u003e 在家庭网络连接下面的下拉菜单中选择 “以太网3” ，点击确认（出现将ip设置为“192.168.137.1”的提示也点击确定，这里出现这个是因为事先设定了以太网3的IP） 查询树莓派的IP 在PowerShell或cmd中输入arp -a，寻找地址192.168.137.1下面的IP，第一个符合IP分配规则的地址就是树莓派的地址，如果查询不到，重新拔插树莓派的网线后再次查询即可。 也可以使用Advanced IP Scanner Portable工具扫描查询，名称为raspberrypi.mshome.net的既是树莓派，见名知意。 使用ssh工具连接 使用ssh工具（我用Putty），通过查询到的IP连接树莓派，默认用户名和密码是pi和raspberry ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BA%BF%E7%9B%B4%E8%BF%9E%E7%94%B5%E8%84%91/:0:0","tags":["树莓派"],"title":"树莓派使用网线直连电脑","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BA%BF%E7%9B%B4%E8%BF%9E%E7%94%B5%E8%84%91/"},{"categories":["爱编程爱技术的孩子"],"content":"记录树莓派使用过程中经常使用的一些设置。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:0:0","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"1. WiFi连接 这里指的是初次启动直连WiFi，主要是因为手里没有屏幕，因为使用的小米随身WiFi，所以可能有些废话，但为了保存资料，就写这里了。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:1:0","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 随身WiFi设置 按随身WiFi附带的说明会下载安装一个网络管理软件miwifi，驱动会默认安装。但使用这一软件，接入设备的ip无法ping通，只能选择卸载该软件单独安装驱动。驱动名为Xiaomi 802.11n USB Wireless Adapter，可以用必应或谷歌直接搜索下载即可。驱动安装完成后，安装猎豹免费wifi，用作wifi管理软件，查看到的设备ip可以使用。 注：使用win10自带的热点开启工具会出现不少问题，即使成功开启了，设备也连接不上。唯一能成功启用的方式还是在安装猎豹免费wifi后进行启用，然后关闭猎豹，不过这样就没什么意义了。 小米，百度，360的随身WiFi使用的都是mt7601u。其它关于小米随身WiFi的一些参数，查询如下： ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:1:1","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 树莓派设置 将刷好 Raspbian 系统的 SD 卡用电脑读取。在 boot 分区，也就是树莓派的 /boot 目录下新建 wpa_supplicant.conf 文件，按照下面的参考格式填入内容并保存 wpa_supplicant.conf 文件。 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=CN network={ ssid=\"WiFi名\" psk=\"密码\" key_mgmt=WPA-PSK priority=1 } priority：连接优先级，数字越大优先级越高（不可以是负数） scan_ssid：连接隐藏WiFi时需要指定该值为1 key_mgmt：加密方式，WPA和WPA2都填WPA-PSK，小米随身WiFi使用这种，其他的还有WEP等。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:1:2","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 开启SSH连接 在boot分区新建名为ssh的文件，要注意小写且没有扩展名。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:1:3","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 树莓派启动并访问 将配置好的SD卡卸载并插入树莓派，通电启动。不久即可以在WiFi管理软件中看到，设备名会是raspberrypi，极好辨认，同时能看到分配的ip。通过该ip使用SSH登录即可。 注：可以使用arp -a命令或IP扫描工具扫描，都不影响，只是从wifi管理软件看更快。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:1:4","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 数据源更新 基于众所周知的原因，需要将源更换为国内源，这里选择清华。 登录树莓派，使用管理员权限编辑/etc/apt/sources.list文件 sudo nano /etc/apt/sources.list 注释掉原来的源，将源更新为： deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 最后持续键入CTRL+O -\u003e ENTER-\u003e CTRL+X退出 使用管理员权限编辑/etc/apt/sources.list.d/raspi.list文件 sudo nano /etc/apt/sources.list.d/raspi.list 将源更新为： deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 更新源文件列表，更新软件 $ sudo apt-get update $ sudo apt-get upgrade ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:2:0","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 远程访问 树莓派安装xrdp $ sudo apt-get install xrdp win10使用Cortana搜索远程桌面连接，计算机名填写树莓派ip，用户名填写pi(如果未更改)，点击连接即可，后续设置不必调整，最后可进入树莓派桌面。是在没有买专门的屏幕的情况下一种可视化的方式。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:3:0","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 修改pi账户密码，开启root账户 使用password pi可修改pi账户密码。 由于树莓派使用的Linux基于debian，root账户默认没有密码，同时没有开启。若要启用，在pi账户下执行命令 $ sudo passwd root 执行此命令后会提示输入两遍root密码，输入密码后执行 $ sudo passwd --unlock root 即可解锁root账户 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:4:0","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 利用ftp进行文件传输 安装vsftpd $ sudo apt-get install vsftpd 启用ftp服务 $ sudo service vsftpd start 编辑配置文件 $ sudo nano /etc/vsftpd.conf 启用对树莓派进行写操作，不然只能从树莓派往PC传文件，没法往树莓派传 # Uncomment this to enable any form of FTP write command. write_enable=YES 保存退出，重启vsftpd $ sudo service vsftpd restart 最后在PC下使用FileZilla通过ssh登录即可进行文件互传。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:5:0","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 设置静态ip 涉及网络相关的项目，设置静态ip是必要的事。需要修改/etc/dhcpcd.conf文件 $ sudo nano /etc/dhcpcd.conf 在末尾添加如下内容 interface wlan0 static ip_address=192.168.191.2/24 static routers=192.168.191.1 static domain_name_servers=192.168.191.1 字段解释： interface：eth0代表有线，wlan0代表无线，多网卡事先用ifconfig命令查看确认 static ip_address：静态ip地址，要确认在网段范围内 static routers：网关地址 static domain_name_servers：域名服务器地址，多个地址使用空格分隔。这里填了网关地址。 保存退出，reboot命令重启，重启后即可使用静态ip登录。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:6:0","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["爱编程爱技术的孩子"],"content":"7. 系统备份 好不容易配置好的树莓派系统，更新了源，设置了静态ip，装好了环境或需要的软件，结果一个出错需要重新来，简直崩溃，所以备份一个系统是必要的事。 备份系统很简单，将配置好的SD卡插入电脑，使用将系统写入SD卡的win32diskimager软件，新建以.img为后缀的文件，在路径栏选择该文件，选择读取等待进度条完成即可。需要注意的是，这样备份的镜像文件大小是SD卡的容量大小，所以，如果备份了一个32G大的SD卡镜像，之后无法写入16G的新SD卡。 ","date":"2019-09-04","objectID":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/:7:0","tags":["树莓派"],"title":"树莓派常用设置","uri":"/2019/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"},{"categories":["平日里的白日梦"],"content":"1个人，87天，627英里。有关爱的回归、自我发现、日常生活的信念以及万物之美。当再次看到简介中的这段字，我终于明白了这本书的意义。 哈罗德·弗莱，六十岁，在酿酒厂干了四十年销售代表后默默退休，没有升迁，既无朋友，也无敌人，退休时公司甚至连欢送会都没开。他跟隔阂很深的妻子住在英国的乡间，生活平静，夫妻疏离，日复一日。一天早晨，他收到一封信，来自二十年未见的老友奎妮。她患了癌症，写信告别。震惊、悲痛之下，哈罗德写了回信，在寄出的路上，他由奎妮想到了自己的人生，经过了一个又一个邮筒，越走越远，最后，他从英国最西南一路走到了最东北，横跨整个英格兰。87天，627英里，只凭一个信念：只要他走，老友就会活下去！这是哈罗德千里跋涉的故事。从他脚步迈开的那一刻起，与他六百多英里旅程并行的，是他穿越时光隧道的另一场旅行。 现在，有多少人走着走着，身边就没有人了。当看到本书开篇中默默无闻的哈罗德时，仿佛看到了自己未来的样子，也因此，在哈罗德踏上这条旅途的时候，我无比期待未来的样子。实际上，当合上这本书，哈罗德这一路的分分秒秒，遇到的形形色色的人，都不断地浮现在脑海里。加油站的女孩，没有孩子的女人，远足的男人与他争吵的妻子，银发绅士，给哈罗德讲解癌症的医生，骑自行车的母亲，来自斯洛伐克的玛蒂娜，讨厌的里奇，小狗，以及经过的每一个城市和每个风景，在经历了这些之后，哈罗德才成功完成了蜕变。 来自斯洛伐克的玛蒂娜和追随的朝圣者是两个重要节点。玛蒂娜对哈罗德的照顾与关心使哈罗德的旅途变得轻快起来，我们不提要对陌生人充满善意这种话，而是想说，一点支持对一个人有多重要。而追随的朝圣者们则完全打乱了哈罗德的旅途，把他脱下了深渊，尤其是里奇，将哈罗德的旅途当作了自己赚取资本夺回孩子的途径，雷克斯说哈罗德的旅途是一个过程，里奇也是，这不过不一样而已。虽然明白如此，但始终不喜欢里奇这种做法，做事不仅目的重要，过程一样重要。 这本书教会我的最重要的一件事是，学会爱和学会表达爱。在读完整个故事后，我发现所有的事情都是因为不会这两件事造成的，哈罗德童年没有得到爱，后来得到了莫琳，当他们有了孩子，哈罗德无法将自己的爱表达出来，也许不只这个原因，但戴维得了抑郁症并自杀应该有这方面的原因，他无法感受来自父母的爱。戴维的死造成了奎妮的离去，造成了莫琳的分居，哈罗德与莫琳分居20年情况没有改善，还是与哈罗德不会表达爱有关。哈罗德从旅途中逐渐打开自己心扉的过程，也是学会表达爱的过程，也因此，最后才能水到渠成和莫琳复归原初。学会爱很重要，学会表达爱更重要，人始终是社交生物，如今大家的孤独感日益严重，抑郁症患者数量增加，怕也是感受不到爱与支持吧。我也没有，不会爱，不会表达爱，也许应该慢慢学习了。不是有人说过吗，童年不幸福的人长大后对待自己的孩子有两种方式，一种是将自己童年遭受的对待重复一遍，一种是不让孩子受到自己受过的对待。幸福的童年治愈一生，不幸的童年用一生去弥补，若我以后有孩子，一定要教会他/她爱与表达爱。 哈罗德的一路是一条自我发现之旅，不带手机，不开车，徒步经历这世界，这种心无旁骛的情况下，一个人才会回忆过去种种，才会思考，才能发现以前意识不到的问题。有了距离，莫琳也才发现了对哈罗德的爱从未改变。有时候，距离产生理解。 当哈罗德刚上路时，我们是不理解的，当哈罗德结束旅程时，我们觉得这趟旅程很有意义。我从中学到了爱与表达爱，但朝圣之旅是身体与心灵的双重蜕变之旅，也许以后再读这本书，会有不一样的感受。 ","date":"2019-08-29","objectID":"/2019/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/:0:0","tags":["读书笔记"],"title":"一个人的朝圣","uri":"/2019/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/"},{"categories":["平日里的白日梦"],"content":"其实我是对漫画没什么兴趣的，但是在微信读书看到小和尚的第一眼，就沉沦了进去，小和尚的形象仿佛能轻易击穿人的心房。故事中的小和尚同样如此，一禅与师父，以及周围善良淳朴的人们，他们的故事呈现了人性的美化与善良。也许，总有一天，也会有这么一个人出现在我的生命中，带给我温暖与力量。无论如何，小和尚让我知道，这个世界，总是美好的啊！ B站有一禅的动漫，画风虽然变了，但一样好看。 网易云也有一禅的电台，很惊喜。 ","date":"2019-08-28","objectID":"/2019/%E4%B8%80%E7%A6%85%E5%B0%8F%E5%92%8C%E5%B0%9A/:0:0","tags":["读书笔记"],"title":"一禅小和尚","uri":"/2019/%E4%B8%80%E7%A6%85%E5%B0%8F%E5%92%8C%E5%B0%9A/"},{"categories":["Golang学习之路"],"content":"如下列代码，在使用bufio包中的ReadString读取字符串之后，这个字符串无法进行类型转换，每次使用strconv.Atoi()函数返回值均为0。 inputReader := bufio.NewReader(os.Stdin) fmt.Println(\"Please input a number\") t, err := inputReader.ReadString('\\n') if err != nil { fmt.Println(\"can't read number!\") } fmt.Println(\"the number is\", t) if num, ok := strconv.Atoi(t); ok != nil { fmt.Println(\"convert to int error\", num) } //input 25 //output Please input a number the number is 25 convert to int error 0 因为这种写法其实经常遇到，之前编程的时候遇到这种情况没怎么注意，以为是算法问题，就换思路写了，直到这次只能用这种思路，才发现这里出现了问题。 Stackoverflow上相关的问题回答说这是因为ReadString读取字符串成功后会把'\\n'一起加在字符串后面。查找包说明发现函数的原型和解释如下 func (b *Reader) ReadString(delim byte) (string, error) /* ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. */ 这种情况给出的建议是利用strings.Trim…系列去除末尾添加的字符，比如，对上面的错误程序 inputReader := bufio.NewReader(os.Stdin) fmt.Println(\"Please input a number\") t, err := inputReader.ReadString('\\n') if err != nil { fmt.Println(\"can't read number!\") } fmt.Println(\"the number is\", t) t = strings.TrimRight(t, \"\\n\") if num, ok := strconv.Atoi(t); ok == nil { fmt.Println(\"convert succeed\", num) } //input 25 //output Please input a number the number is 25 convert succeed 25 ","date":"2019-08-27","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-bufio%E8%AF%BB%E5%8F%96%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:0:0","tags":["Go语法"],"title":"Golang查漏补缺-bufio读取的字符串无法直接进行类型转换","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-bufio%E8%AF%BB%E5%8F%96%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["平日里的白日梦"],"content":"愿你三冬暖，愿你春不寒 愿你天黑有灯，下雨有伞 愿你一路上，有良人相伴 愿你所有快乐，无需假扮 愿你此生尽兴，赤诚良善 愿时光能缓，愿故人不散 愿有人陪你颠沛流离 愿你惦念的人能和你互道晚安 愿你独闯的日子里不觉得孤单 愿你余生所遇之人，都是好人 每个人都是这世上独一无二的风景，弥足珍贵的你 愿你在前行路上，在薄情的世界永不忘深情地活着 此生不忘初心 ","date":"2019-08-26","objectID":"/2019/i-wish-you/:0:0","tags":["文摘"],"title":"愿","uri":"/2019/i-wish-you/"},{"categories":["我所热爱的生活啊"],"content":"08.24，又一个周六，从旅游软件中得知古生物博物馆周六日开馆，欣然前往，然后发现上周错过的航空博物馆竟然在路上，于是返程途中开森的进去了。 古生物博物馆 辽宁古生物博物馆位于沈阳师范大学，乘地铁二号线在师范大学站下车，出站即可看到，据称是中国规模最大的古生物博物馆。没有门票，是免费的，但也因此较为火热，我在10点左右到达，进入馆内观众已是熙熙攘攘，但11点半出馆时，为了限流，外面已经开始排队，不再能直接进入。 博物馆外形极为美观，参观的时候看到了对这栋建筑的介绍，以为网上可以找到，就没拍照，可惜回来后搜不到了。博物馆整体大致分三部分，左侧代表整块的地质板块，右侧代表恐龙骨架，中间的台阶及断崖是流淌的熔岩，代表了地质结构的变动和化石的形成过程（可能有错，记不清了，原文描述最能反映看到这栋建筑的第一感受）。正常的参观流程应该是拾台阶而上，从最上面开始参观，逐渐到第一层，然后结束。但去的时候台阶上的门已封闭，只能从一层进入，电梯到顶端，再往下走。 ] 博物馆共设有8个展厅，包括地球与早期生命、30亿年来的辽宁古生物、热河生物群、国际古生物化石、珍品化石、辽宁大型恐龙等主题。乘电梯上行后，首先是一个伸出楼层的半圆形高空平台，玻璃地面，可以直接看到一楼地面，就像景区的玻璃栈道，说实话，以前一直拒绝去这种地方，这次竟然不经意遇到了，上去之后往下看有点腿软，感觉就是你以为你不怕的事，真正遇到时还是不一样的，键盘侠绝不可取。当然，有恐高症的我即使平时，也不敢从楼上往下看。 未进入展厅之前就可以看到几个标志性的化石，包括赫氏近鸟龙，沈师龙，辽宁古果等，算是给个小惊喜。 第一展厅辽宁古生物博物馆实际上没开，直接进入第二展厅地球与早期生命。能看到各种陨石样本，石陨石，铁陨石等等，以及生命演化的小实验和寒武纪生命爆发等各种知识科普。然后就是早期的各种海洋生物化石，实际上如果不是很了解这方面的话，那些化石完全看不出什么，唯一识得的是最出名的三叶虫化石。 第三展厅就开始进入高潮了，各种大型动物的化石开始出现，可以一饱眼福。首先是猛犸象的化石，作为另一种大家熟知的史前生物，能唤起不少亲切感，同时，只有亲身接触，才能直观感受它的庞大。 有趣的许氏创口海百合，看起来像漂亮的百合花，其实是动物。下图旁边其实有一幅更大的化石，像壁画一样。 浅海的海龙，和海中霸主鱼龙。 鹦鹉螺一样的菊石，菊石堆放在鱼龙化石旁边，但还有一个大型菊石在一楼。 琥珀，但可惜这里没有很好的，唯一的几个都很小而且看不清楚。鱼类，啄木鸟，猴、短吻鳄这些常见动物，包括一个小原始马化石，在猛犸象旁边实际上还有一个原始牛的化石，可要大多了。 大名鼎鼎的始祖鸟化石，用了整整一面墙，展示了多个不同地区出土的不同形态的始祖鸟。以及最后的重头戏，由侏罗纪公园造成的人的潜在认知，古生物博物馆和恐龙博物馆必然存在的，大厅的巨大草食类恐龙，不过不是蛇颈龙，而是中国特色的黄河巨龙。 这时候基本就已经差不多结束了，在一楼还有一个海外回归化石展，有很多不错的化石，也有这些化石的归国之旅说明，向我们展示走私化石带来的危害和国家付出的努力，真的能感觉到全是珍品。放一幅潜龙化石。 全部游览大概需要一个半小时，这还是越往后逛的越没耐心的原因。实际上，最后我意识到，参观博物馆最好事先做好充分的准备，包括馆内有哪些珍品，以及关于它们的故事，要不然，在什么都不懂的情况下，会比较无聊。这一点在航空博物馆表现更为突出。 沈飞航空博物馆 与古生物博物馆相比，航空博物馆就显得冷清多了。全票30元，展馆内基本都是理论和模型介绍，如果不是对航空很感兴趣或相关专业，一点感觉都没有，我就是这样。 而航空博物馆对小白的吸引恐怕是那一架架真机，虽然这里外展坪上的真机数量有点配不上沈飞的名头，但摆在这里的，都是蛮有代表性的。包括歼5到歼8系列，以及最喜欢运5，因为运5的外形让我想起了《起风了》。最后还是想说，还是军绿色的飞机有感觉。 ","date":"2019-08-24","objectID":"/2019/paleontological-museum-of-liaoning/:0:0","tags":["旅行记录"],"title":"辽宁古生物博物馆及沈飞航空博物馆","uri":"/2019/paleontological-museum-of-liaoning/"},{"categories":["我所热爱的生活啊"],"content":"08.17，周六，前往游览了北陵公园，北陵公园核心的昭陵，祭拜了公园中偶然发现的烈士陵园，最后参观了北陵附近的新乐遗址。 ","date":"2019-08-17","objectID":"/2019/beiling-park/:0:0","tags":["旅行记录"],"title":"北陵公园及新乐遗址","uri":"/2019/beiling-park/"},{"categories":["我所热爱的生活啊"],"content":"北陵公园 北陵公园是辽宁省沈阳市最大的公园，占地330万平方米。1643年（清崇德八年）清太宗皇太极和孝端文皇后博尔济吉特氏的陵墓昭陵建成。 1927年，奉天省政府将清昭陵辟为公园，因位于市区北部，故得此名。 入园右行，先参观了油菜花海，然后继续沿河岸前行，到柳堤，从柳堤返回皇太极广场，然后直走到了神桥，之后进入昭陵。公园古树参天，环境优美，中老年比较多，应该是附近市民，也比较干净。 从昭陵出来后，因为要去新乐遗址，走了向西门的道路，没想到路上还发现了一座烈士陵园，缅怀革命先烈，附照片一张。向日葵不是我放的，但是这只向日葵真的神来之笔，站在陵园一下就有了感觉。 ","date":"2019-08-17","objectID":"/2019/beiling-park/:1:0","tags":["旅行记录"],"title":"北陵公园及新乐遗址","uri":"/2019/beiling-park/"},{"categories":["我所热爱的生活啊"],"content":"昭陵 北陵又称清昭陵是清朝第二代开国君主太宗皇太极以及孝端文皇后博尔济吉特氏的陵墓，占地面积16万平方米。现存古建筑38座（组），因位于沈阳古城北约十里，故称“北陵”。 昭陵始建于清崇德八年（1643年），同年葬皇太极于陵内，顺治元年（1644年）定陵号称昭陵，顺治七年（1650年）孝端文皇后入葬，顺治八年（1651年）陵制初备，经康熙、乾隆、嘉庆多朝增改，形成了清初“关外三陵”中规模最大、气势最宏伟的古建筑群。陵寝建筑的平面布局遵循“前朝后寝”的陵寝原则自南向北由前、中、后三个部分组成，其主体建筑都建在中轴线上，两侧对称排列，系仿自明朝皇陵而又具有满族陵寝的特点。全陵由南至北依次为： 前部，从下马碑到正红门，包括华表、石狮、石牌坊、更衣厅、宰牲厅； 中部，从正红门到方城，包括华表、石象生、碑楼和祭祀用房； 后部，是方城、月牙城和宝顶，这是陵寝的主体。 过神桥后看到石牌坊，左右宰牲厅更衣厅无法进入。检票在正红门，进入后直走即可，途径华表和石像群，左右有道路通往东西红门，但并不开，继续直走到大碑楼，但大碑楼和后面能看到的大明楼中的碑石字都已经没了。大碑楼往后，依仗、茶膳、漆器三房额外收费观看（20元），觉得没什么必要，就没进去。再往前就是隆恩门，门上的字也掉了，进隆恩门后就是方城， 上图是正中的隆恩殿，祭祀之所，广场东西侧还有东西配殿，西配殿前有焚帛亭。整体处在方城之中，通过楼梯能上到方城城墙上，城墙有四座角楼。隆恩殿后的城墙正中是大明楼，楼后是月牙城，有个玉璧。再往后就是宝顶了，这就是所有建筑。大明楼下，隆恩殿后到月牙城间，是一个门洞，如下图。 上图是从月牙城的方向拍的隆恩殿后。其实我发现昭陵的建筑都有一个特点，全都是朱墙，黄琉璃铺顶，四角飞檐挂有风铃，建筑彩绘的风格也相似，蛮好看的。一个人逛整体游玩时间不会超过两个小时。 ","date":"2019-08-17","objectID":"/2019/beiling-park/:2:0","tags":["旅行记录"],"title":"北陵公园及新乐遗址","uri":"/2019/beiling-park/"},{"categories":["我所热爱的生活啊"],"content":"新乐遗址 新乐文化遗址位于沈阳市皇姑区黄河北大街北运河北岸黄土高台之上，1977年首次发掘。这是一处原始社会母系氏族公社繁荣时期的村落遗址，占地面积17.8万平方米，集居地约2.5万平方米，房址密集，每隔3－5米就有一处，其中最大的房址面积约100平方米，座落在诸房址中心，其布局与半坡文化很相似，经中国社会科学院考古研究所碳14测定，新乐遗址距今已有7200多年历史。其出土文物相当丰富，石器有磨制精细的石斧、石凿、磨盘、磨棒、刮削器等，陶器有之字纹深腹罐、高足钵、簸箕形器等。 新乐遗址在北陵公园西侧，从西门出去，过马路，往南走三个路口，到龙山路，然后往里走就可以了，其实也可以看路边，因为有新乐遗址的地铁站很显眼，到了地铁站，往前一点就能看到龙山路的牌子。沿着龙山路往里走不远就能看到新乐遗址，人并不多。 遗址并不大，一眼能看到全部建筑，门后正前方是太阳鸟广场，广场上有一个很高的建筑，但是看不出太阳神鸟的样子，其实是展馆里一件木雕的模样，木雕上刻着太阳神鸟，参观的时候细心点能发现。广场往右是主展馆，直接从后门可以进去，因为时间赶的巧，我是2:20到的，正好遇上2:30的讲解，除了博物馆的讲解员，有些展馆是一群小学生志愿者，讲的挺好的，看得出来有点紧张，看到了自己的样子，但大家总是充满善意的不是吗。 一二楼共几个展厅也忘了，因为这时候已经走了大概10公里，还没休息，有点累，都没怎么能细心看下去，只看了下器物和简单介绍。印象深的就是各种石器、骨器和陶器，斧、匕、渔网石坠、陶罐等等，看得出来很粗糙。尤其是二楼有个额外的河姆渡展厅，应该是交流展，器物的对比比较明显，河姆渡的展品就精致了很多。回头一查，河姆渡是距今6000-7000年，原始社会，这年份差距造成的工艺进步，也不知道正常不，还是南北的差距。 从展厅出来，还有个史前建筑复原区，复原的半地穴式房屋，记得当初学历史的时候半坡遗址好像也是这种。另外还有几个发掘坑，用玻璃罩着，最大的一个发掘坑在屋子里。大概就是这样了，总参观时间都不到一小时。 对了，新乐遗址买门票的时候，扫的好像是一个大妈自己的支付宝二维码，也不知道正不正常。另外就是有些遗憾北陵公园东北角的神树没去看，因为有点远，走不动了。公园东北方向，园外还有航空博物馆，是回来才知道，也遗憾没去看。 ","date":"2019-08-17","objectID":"/2019/beiling-park/:3:0","tags":["旅行记录"],"title":"北陵公园及新乐遗址","uri":"/2019/beiling-park/"},{"categories":["Golang学习之路"],"content":"PAT乙级25分的题好多需要根据一个结构体类型的某个字段进行排序，第一次遇到时确实不知所措，然后查了不少解决方案，这里做个总结。 这一问题一般归结为对自定义类型排序，当然，基本指的是结构体，搜到的解决方案也基本是利用sort包。 sort包基本的排序都是针对切片的，直接调用的话能找到整型、浮点型和字符串三种类型切片的排序，最简单的整型排序如下： package main import ( \"fmt\" \"sort\" ) func main() { s := []int{5, 2, 6, 3, 1, 4} // unsorted sort.Ints(s) fmt.Println(s) } //Output:[1 2 3 4 5 6] ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/:0:0","tags":["Go语法"],"title":"Golang查漏补缺-对自定义类型排序","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/"},{"categories":["Golang学习之路"],"content":"调用sort.Sort() 不少文章都是通过调用sort.Sort()实现的对结构体的排序，如youyu岁月和Donne的文章就是使用的这种办法。 func Sort(data Interface) Sort函数会调用一次data.Len确定长度，调用O(n*log(n))次data.Less和data.Swap进行排序。但函数不能保证排序的稳定性。而调用Sort首先需要实现一个接口。 type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } 只要实现了Len, Less, Swap三个方法，就能调用Sort实现对结构体的排序，而其中主要就是Less比较逻辑的实现。 先看一下sort包本身对[]int类型的排序实现 // 首先定义了一个[]int类型的别名IntSlice type IntSlice []int // 获取此 slice 的长度 func (p IntSlice) Len() int { return len(p) } // 比较两个元素大小 升序 func (p IntSlice) Less(i, j int) bool { return p[i] \u003c p[j] } // 交换数据 func (p IntSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } // sort.Ints()内部调用Sort() 方法实现排序 // 注意 要先将[]int 转换为 IntSlice类型 因为此类型才实现了Interface的三个方法 func Ints(a []int) { Sort(IntSlice(a)) } 然后我们以一个人的结构体为例，结构体中包括其姓名和年龄，按照其年龄对结构体进行排序。 type Person struct { Name string Age int } type ByAge []Person 仿照[]int实现三个方法 func (a ByAge) Len() int { return len(a) } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByAge) Less(i, j int) bool { return a[i].Age \u003c a[j].Age } 然后写个完整的程序测试看一看 package main import ( \"fmt\" \"sort\" ) type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\"%s: %d\", p.Name, p.Age) } // ByAge implements sort.Interface for []Person based on // the Age field. type ByAge []Person func (a ByAge) Len() int { return len(a) } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByAge) Less(i, j int) bool { return a[i].Age \u003c a[j].Age } func main() { people := []Person{ {\"Bob\", 31}, {\"John\", 42}, {\"Michael\", 17}, {\"Jenny\", 26}, } fmt.Println(people) // There are two ways to sort a slice. First, one can define // a set of methods for the slice type, as with ByAge, and // call sort.Sort. In this first example we use that technique. sort.Sort(ByAge(people)) fmt.Println(people) } //输出结果如下： [Bob: 31 John: 42 Michael: 17 Jenny: 26] [Michael: 17 Jenny: 26 Bob: 31 John: 42] 如果要对某个结构体中多个字段进行排序，可以利用嵌套结构体实现，如下面的代码，该代码来自youyu岁月 package main import ( \"fmt\" \"sort\" ) type Person struct { Name string Age int } type Persons []Person // Len()方法和Swap()方法不用变化 // 获取此 slice 的长度 func (p Persons) Len() int { return len(p) } // 交换数据 func (p Persons) Swap(i, j int) { p[i], p[j] = p[j], p[i] } // 嵌套结构体 将继承 Person 的所有属性和方法 // 所以相当于SortByName 也实现了 Len() 和 Swap() 方法 type SortByName struct{ Persons } // 根据元素的姓名长度降序排序 （此处按照自己的业务逻辑写） func (p SortByName) Less(i, j int) bool { return len(p.Persons[i].Name) \u003e len(p.Persons[j].Name) } type SortByAge struct{ Persons } // 根据元素的年龄降序排序 （此处按照自己的业务逻辑写） func (p SortByAge) Less(i, j int) bool { return p.Persons[i].Age \u003e p.Persons[j].Age } func main() { persons := Persons{ { Name: \"test123\", Age: 20, }, { Name: \"test1\", Age: 22, }, { Name: \"test12\", Age: 21, }, } fmt.Println(\"排序前\") for _, person := range persons { fmt.Println(person.Name, \":\", person.Age) } sort.Sort(SortByName{persons}) fmt.Println(\"排序后\") for _, person := range persons { fmt.Println(person.Name, \":\", person.Age) } } ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/:1:0","tags":["Go语法"],"title":"Golang查漏补缺-对自定义类型排序","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/"},{"categories":["Golang学习之路"],"content":"调用sort.Slice() 更简单的是直接调用sort.Slice()，当然，由于golang官方的包说明稳定没法访问，一直查看的是国内的标准库说明文档，完全没有意识到它已经落后了，可能许久未更新，完全没有提到sort包中的Slice函数，但利用这个函数进行自定义类型排序是真有用，还是翻出去看官方说明比较好。 func Slice(slice interface{}, less func(i, j int) bool) sort.Slice()以给定的比较函数排序切片，但并不保证排序的稳定性，想要稳定性，可以调用sort.SliceStable()。因为切片类型的广泛使用，调用sort.Slice()能满足大部分的需求，同时减少了自己实现接口需要实现的Len和Swap两个方法，写法上也更加精炼。一个例子如下： package main import ( \"fmt\" \"sort\" ) func main() { people := []struct { Name string Age int }{ {\"Gopher\", 7}, {\"Alice\", 55}, {\"Vera\", 24}, {\"Bob\", 75}, } sort.Slice(people, func(i, j int) bool { return people[i].Name \u003c people[j].Name }) fmt.Println(\"By name:\", people) sort.Slice(people, func(i, j int) bool { return people[i].Age \u003e people[j].Age }) fmt.Println(\"By age:\", people) } //Output By name: [{Alice 55} {Bob 75} {Gopher 7} {Vera 24}] By age: [{Bob 75} {Alice 55} {Vera 24} {Gopher 7}] 值得注意的一点是，这里的排序结果依赖于less函数的内容，并不是默认升序，如上述程序。 ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/:2:0","tags":["Go语法"],"title":"Golang查漏补缺-对自定义类型排序","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/"},{"categories":["Golang学习之路"],"content":"最近在刷PAT乙级的题，因为PAT考点一般只提供C/C++或Java环境的缘故，网上找到的90%都是C++代码，剩下的又绝大部分是Java，还有一小部分Python，其他语言还真没看到。我用go来刷题，遇到很多问题还真的只能自己慢慢琢磨，倒也很是能锻炼人。 在PAT乙级1015（德才论）和1018（锤子剪刀布）两题中，历经万难，总有测试点显示“运行超时”。仔细一想，不应该啊，go的编译执行速度应该算比较快了，比C++应该差不了多少，这也是go的优点，怎么就运行超时呢，前两天写的时候没想出来，就这么放下了，但这两天心里一直惦记着。知道今天，想到一件事，1015（德才论）还好说，涉及排序，可能算法不够好。1018（锤子剪刀布）一题中也没排序，这么就运行超时了，于是去网上找到了Python解法，竟然过了，彻底陷入了迷惘，go的速度连Python都比不过了吗，肯定有没注意到的地方，于是开始了执行时间优化之旅。 1018（锤子剪刀布）的原始代码如下 /*题目说明 大家应该都会玩“锤子剪刀布”的游戏,现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式： 输入第 1 行给出正整数 N（≤10^5），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式： 输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例： 10 C J J B C B B B B C C C C B J B B C J J 输出样例： 5 3 2 2 3 5 B B 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB */ package main import \"fmt\" func findMax(a [3]int) int { var max, index int for k, v := range a { if v \u003e max { max = v index = k } } return index } func main() { var ( n int jiawin, yiwin int jia, yi [3]int str = \"BCJ\" ) fmt.Scanln(\u0026n) for i := 0; i \u003c n; i++ { var t [2]string fmt.Scanln(\u0026t[0],\u0026t[1]) if t[0] == \"B\" \u0026\u0026 t[1] == \"C\" { jia[0]++ } else if t[0] == \"B\" \u0026\u0026 t[1] == \"J\" { yi[2]++ } else if t[0] == \"C\" \u0026\u0026 t[1] == \"B\" { yi[0]++ } else if t[0] == \"C\" \u0026\u0026 t[1] == \"J\" { jia[1]++ } else if t[0] == \"J\" \u0026\u0026 t[1] == \"B\" { jia[2]++ } else if t[0] == \"J\" \u0026\u0026 t[1] == \"C\" { yi[1]++ } } jiawin = jia[0] + jia[1] + jia[2] yiwin = yi[0] + yi[1] + yi[2] fmt.Println(jiawin, n-jiawin-yiwin, yiwin) fmt.Println(yiwin, n-jiawin-yiwin, jiawin) fmt.Printf(\"%c %c\", str[findMax(jia)], str[findMax(yi)]) } 检查了半天实在找不到什么地方可以优化的，时间复杂度的大头是for循环，但能迁移出来的代码都已经迁移出来了，结果始终如下图 ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/:0:0","tags":["Go语法"],"title":"Golang查漏补缺-程序执行时间优化","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"categories":["Golang学习之路"],"content":"I/O性能 在google上搜go程序的执行时间怎么优化，最终在golang-nuts讨论组发现一个靠谱的问题以及有用的回答。 原来是I/O读写的问题，fmt包的读写这么不省心吗，怪不得，1015和1015如果测试点是边界值的话，循环要执行10000次，I/O读写出了问题，不超时才怪。看作者在之后的讨论中说他的程序“On my system: C runs in ~50ms, python in ~125ms and go in ~450ms.”也难怪Python都能通过，go通过不了了。 按照其他人的回答，使用bufio包替换了for循环中的fmt进行读取，改进的代码如下： package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func findMax(a [3]int) int { var max, index int for k, v := range a { if v \u003e max { max = v index = k } } return index } func main() { var ( n int jiawin, yiwin int jia, yi [3]int str = \"BCJ\" ) // 用fmt读取输入会有测试点超时 inputReader := bufio.NewReader(os.Stdin) fmt.Scanln(\u0026n) for i := 0; i \u003c n; i++ { s, _ := inputReader.ReadString('\\n') t := strings.Fields(s) if t[0] == \"B\" \u0026\u0026 t[1] == \"C\" { jia[0]++ } else if t[0] == \"B\" \u0026\u0026 t[1] == \"J\" { yi[2]++ } else if t[0] == \"C\" \u0026\u0026 t[1] == \"B\" { yi[0]++ } else if t[0] == \"C\" \u0026\u0026 t[1] == \"J\" { jia[1]++ } else if t[0] == \"J\" \u0026\u0026 t[1] == \"B\" { jia[2]++ } else if t[0] == \"J\" \u0026\u0026 t[1] == \"C\" { yi[1]++ } } jiawin = jia[0] + jia[1] + jia[2] yiwin = yi[0] + yi[1] + yi[2] fmt.Println(jiawin, n-jiawin-yiwin, yiwin) fmt.Println(yiwin, n-jiawin-yiwin, jiawin) fmt.Printf(\"%c %c\", str[findMax(jia)], str[findMax(yi)]) } 果然通过了，如下图，最后一个测试点28ms,一想想题目时间限制是200ms，从超时到28，这提升，看起来1015的德才论一题也有救了。 ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/:1:0","tags":["Go语法"],"title":"Golang查漏补缺-程序执行时间优化","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"categories":["Golang学习之路"],"content":"排序优化 1018德才论的原始代码如下： /* 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： 输入第一行给出 3 个正整数，分别为：N（≤10^5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（\u003c100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式： 输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例： 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例： 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB */ package main import ( \"fmt\" ) //L is student level weight const L = 100000000000000 //S is student grade weight const S = 100000000000 //D is student id weight const D = 100000000 func main() { var ( n, l, h int id, de, cai int sum, level, count int student []int64 ) fmt.Scanln(\u0026n, \u0026l, \u0026h) for i := 0; i \u003c n; i++ { fmt.Scanln(\u0026id, \u0026de, \u0026cai) if de \u003e= l \u0026\u0026 cai \u003e= l { sum = de + cai if de \u003e= h \u0026\u0026 cai \u003e= h { level = 4 } else if de \u003e= h \u0026\u0026 cai \u003c h { level = 3 } else if de \u003c h \u0026\u0026 cai \u003c h \u0026\u0026 de \u003e= cai { level = 2 } else { level = 1 } tmp := level*L + sum*S + de*D + D - id student = append(student, int64(tmp)) count++ } } for i := 0; i \u003c count; i++ { for j := i; j \u003c count; j++ { if student[i] \u003c student[j] { tmp := student[i] student[i] = student[j] student[j] = tmp } } } fmt.Println(count) for i := 0; i \u003c count; i++ { id = int(D - student[i]%D) sum = int(student[i] % L / S) de = int(student[i] % S / D) cai = sum - de fmt.Println(id, de, cai) } } 其实这已经是优化过了，之前写的时候用的正规的结构体的思路，为了优化，改成这种用权重的剑走偏锋的思路。但提交结果没有丝毫改变，超时就是超时。 改呗，第一个for循环里的输入改成用缓冲区的bufio，按1018的提升幅度，估计可以。改进部分的代码如下。 fmt.Scanln(\u0026n, \u0026l, \u0026h) inputReader := bufio.NewReader(os.Stdin) for i := 0; i \u003c n; i++ { s, _ := inputReader.ReadString('\\n') t := strings.Fields(s) id, _ = strconv.Atoi(string(t[0])) de, _ = strconv.Atoi(string(t[1])) cai, _ = strconv.Atoi(string(t[2])) //fmt.Scanln(\u0026id, \u0026de, \u0026cai) if de \u003e= l \u0026\u0026 cai \u003e= l { sum = de + cai if de \u003e= h \u0026\u0026 cai \u003e= h { level = 4 } else if de \u003e= h \u0026\u0026 cai \u003c h { level = 3 } else if de \u003c h \u0026\u0026 cai \u003c h \u0026\u0026 de \u003e= cai { level = 2 } else { level = 1 } tmp := level*L + sum*S + de*D + D - id student = append(student, int64(tmp)) count++ } } 第2个测试点过了，但第3，第4个还是没过。 回去一看代码，得，最后一个for循环有输出，用fmt又费不少时间，继续改缓冲区，正巧这时候查到了GO语言基础进阶教程：bufio包，分析了bufio提升文件读写效率的原因，于是参考说明改了输出，如下： fmt.Println(count) buf := bufio.NewWriter(os.Stdout) for i := 0; i \u003c count; i++ { id = int(D - student[i]%D) sum = int(student[i] % L / S) de = int(student[i] % S / D) cai = sum - de buf.WriteString(fmt.Sprintf(\"%d %d %d\\n\", id, de, cai)) } buf.Flush() 没怎么起作用，只是第2个测试点从290ms提升到了272ms。那就只能改排序了，程序里自己写了两层循环，本来以为能过，看来还是得用sort包。改进的完整代码如下： package main import ( \"bufio\" \"fmt\" \"os\" \"sort\" \"strconv\" \"strings\" ) //L is student level weight const L = 100000000000000 //S is student grade weight const S = 100000000000 //D is student id weight const D = 100000000 func main() { var ( n, l, h int id, de, cai int sum, level, count int student []int64 ) fmt.Scanln(\u0026n, \u0026l, \u0026h) inputReader := bufio.NewReader(os.Stdin) for i := 0; i \u003c n; i++ { s, _ := inputReader.ReadString('\\n') t := strings.Fields(s) id, _ = strconv.Atoi(string(t[0])) de, _ = strconv.Atoi(string(t[1])) cai, _ = strconv.Atoi(string(t[2])) //fmt.Scanln(\u0026id, \u0026de, \u0026cai) if de \u003e= l \u0026\u0026 cai \u003e= l { sum = de + cai if de \u003e= h \u0026\u0026 cai \u003e= h { level = 4 } else if de \u003e= h \u0026\u0026 cai \u003c h { level = 3 } else if de \u003c h \u0026\u0026 cai \u003c h \u0026\u0026 de \u003e= cai { level = 2 } else { level = 1 } tmp := level*L + sum*S + de*D + D - id student = ap","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/:2:0","tags":["Go语法"],"title":"Golang查漏补缺-程序执行时间优化","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"categories":["Golang学习之路"],"content":"总结 涉及大量数据的读写时，利用bufio包通过缓冲区进行读写比fmt要快的多。 排序的代码可以调用sort包，不仅仅是自己写两层循环排序的问题，不是必要的情况下，同样的排序算法，自己写的很难说比得过封装好的。更何况，无论是哪种语言，调用的执行排序算法的包其实不是单纯执行快排或堆排序等比较快的排序算法，而是根据输入在调整的，所以不管为了时间性能还是写的方便，直接调用sort包完事儿。 ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/:3:0","tags":["Go语法"],"title":"Golang查漏补缺-程序执行时间优化","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"关于网站 个人博客，欢迎交流 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于我 国企咸鱼一枚 喜欢效率和极简，喜欢看电影、读书、旅行和健身 想在这短短的一生中体验这世间美好的一切 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于版权 本站所有的原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 任何个人及媒体在转载本站原创内容（包含文字、自制图像、摄影作品）时请遵守以下版权要求： 注明转载 注明来源为本站首页网址 shuzang.github.io，或所转内容在本站的完整网址 本站图片部分来自互联网。 此类图片的原版权所有者可在任何时候、以任何理由要求本站停止使用有关图片，其中包括被本站编辑（比如加注中文说明）过的图片， 联系方式见本站首页。 ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["研究生的区块链学习之路"],"content":"待选题目 基于区块链的智能工厂支撑平台研究与设计 基于区块链的智能工厂存储与安全问题研究 基于智能合约的物联网访问控制方案设计与实现 基于区块链的物联网平台搭建及访问控制系统实现 区块链和工业物联网的集成系统及访问控制方案实现 用于IIoT的区块链平台分析及访问控制方案实现 区块链和工业物联网集成分析及访问控制方案实现 用于工业物联网的区块链分析及访问控制方案实现 ","date":"2019-07-14","objectID":"/2019/research-proposal-title-select/:0:1","tags":["科研记录"],"title":"研究记录3-开题确定题目","uri":"/2019/research-proposal-title-select/"},{"categories":["研究生的区块链学习之路"],"content":"参考 面向物联网应用的区块链支撑平台的研究与设计 区块链中的身份识别和访问控制技术研究 基于区块链的数据访问控制方法及应用研究 这三篇文章来自最近几年区块链方向的硕士毕业论文，查到的论文列表如下 作者 论文名 论文工作内容 专业 时间 大学 陈永丰 基于区块链的数据访问控制方法及应用研究 访问控制技术及区块链技术介绍 基于区块链的MAC访问控制模型实现 基于区块链的RBAC访问控制模型实现 计算机应用技术 2018 电子科技大学 梅晨 基于区块链的物联网安全平台的设计与实现 搭建分布式物联网安全平台 在平台实现物体接入控制 在平台实现信息访问控制 在平台实现简单的容忍入侵措施 计算机技术 2018 北京邮电大学 贺毅 面向物联网应用的区块链支撑平台的研究与设计 适用于物联网的共识算法比较 区块链平台设计及部署实现 一个去物联网数据购买的中心化应用实现 计算机科学与技术 2018 北京邮电大学 张青禾 区块链中的身份识别和访问控制技术研究 Fabric中二级证书机制研究与改进 联盟链中访问控制机制研究与改进 两套机制的系统实现 计算机技术 2018 北京交通大学 赵鹏 面向联盟链的一致性算法与事务问题研究 Raft共识算法优化 优化的Raft共识系统测试与验证 基于上述算法的分布式事务机制 计算机技术 2018 东北大学 张宗立 联盟链中交叉容错共识算法的研究 Raft共识算法优化 优化的Raft共识与联盟链的集成 计算机应用技术 2018 东北大学 任欢 基于区块链的文件存储模型及密文搜索算法研究 提出基于区块链技术的存储模型 基于该存储模型的密文多关键字搜索排序算法 计算机系统结构 2018 东北大学 焦通 区块链数据库内支持关键字查询的关键技术研究 区块链数据库系统框架 支持关键字查询的数据模型 支持关键字查询的查询优化方法 计算机软件与理论 2018 东北大学 白砚领 基于区块链的分布式存储系统的设计与实现 设计基于区块链的分布式存储模型DMB 设计并实现基于区块链的分布式存储系统 计算机技术 2018 东北大学 包子健 基于区块链技术的隐私保护策略及应用的研究与实现 基于公平盲签名的隐私保护协议Bscoin 基于多重签名的隐私保护协议Lockcoin 隐私保护的比特币投票应用 计算机应用技术 2018 东北大学 马衍崧 基于区块链技术的WBAN数据的云存储完整性研究 基于区块链技术的访问控制 基于区块链技术的完整性验证 计算机应用技术 2018 东北大学 ","date":"2019-07-14","objectID":"/2019/research-proposal-title-select/:0:2","tags":["科研记录"],"title":"研究记录3-开题确定题目","uri":"/2019/research-proposal-title-select/"},{"categories":["爱编程爱技术的孩子"],"content":"本文是 Hugo 使用记录的第二篇，介绍如何为Hugo开启更多的功能。 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:0:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 添加菜单栏页面 我们可以自己建立新的菜单页面1 ，比如我新建life页面用作展示阅读的书籍、电影和游览的景点。建立页面文件的命令如下： $ hugo new life.md 然后编辑项目根目录下的站点配置文件config.toml，添加页面说明。其中weight字段的值决定了该页面在菜单栏的顺序2，其值越大，顺序越靠后。按照习惯，About页面放在最后，所以其weight字段值设置为5。 # 添加Tags和Life菜单，并修改About菜单的weight字段值为5（为了调整菜单栏显示顺序） [[menu.main]] name = \"Tags\" url = \"/tags/\" weight = 3 [[menu.main]] name = \"Life\" url = \"/life/\" weight = 4 新建的life.md文件位于content目录下，编辑文件内容从而决定实际的页面显示内容。 $ ls content -l total 2 -rw-r--r-- 1 lylw1 197609 658 9月 16 11:34 about.md -rw-r--r-- 1 lylw1 197609 3343 9月 25 11:34 life.md ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:1:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 字数统计 中文(详情)统计的支持可以通过在config.toml中添加如下语句启用 hasCJKLanguage = true ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:2:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 开启评论 使用gitalk，首先在GitHub 上创建一个 Github Application，记录 Client ID 和 Client Secret 然后编辑config.toml以下字段 [params.gitalk] owner = \"shuzang\" # 你的GitHub ID repo = \"blog\" # 博客网址 clientId = \"\" # 刚刚记录的client ID clientSecret = \"\" # 刚刚记录的client secret labels = \"gitalk\" 提交到仓库后就能看到博文下开启了评论区 现在更换使用Valine评论系统，步骤暂未总结 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:3:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 打赏 有些主题支持加入打赏图片，但KeepIt不支持，不过这里还是记录一下。利用第九工厂的免费模板制作好看的打赏二维码。 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:4:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 英文URL 文章分享和访问时，中文URL是最麻烦的一件事情，为了解决这个问题，我阅读了一遍hugo文档中的URL Management，最终决定使用如下办法。 首先修改站点配置文件config.toml中的Permalinks字段如下 [Permalinks] posts = \"/:year/:month/:slug/\" 初始状态该字段值为posts = \"/:year/:month/:filename/\"，使用文件名作为URL，但是文件名作为管理和查找的手段，使用英文较为不便，而文章标题为了便于阅读，也不方便命名为英文，只能使用额外的slug字段。 之后在每篇文章头部的配置信息中添加slug字段即可，一个例子如下 title: Golang语法基础100问 date: 2019-12-23 slug: \"100 question of Golang basic syntax\" tags: [Golang] categories: [爱编程爱技术的孩子] 这篇文章最后的URL将会是http://shuzang.github.io/2019/12/100-question-of-golang-basic-syntax/ ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:5:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 图片插入 博客维护所面临的一个重要问题就是图床，一开始使用Github作为图床，后来迁移到Github issue，再后来因为图片经常加载不出来，迁移到了路过图床，不过用别的图床总归不放心，图片不多的情况下，最终决定将所有图片放到本地，操作步骤如下 首先，对于Hugo来说，所有的静态文件都应该位于根目录的static目录下，比如，我在该目录下存放了 example.img 图片，那么在文章中就可以用以下方式引用图片 ![](/example.img) 这是因为静态文件的查找规则就是以 static 为根目录，所以图片从这里寻找。为了保证清晰的文件结构，便于之后寻找图片，我们采用如下规则存放图片：一篇文章的所有图片放在以文章名命名的一个文件夹中，该文件夹放在static/images目录下。如本文文件名为「hugo搭建个人博客3-进阶设置」，则本文所有图片放在 static/images/hugo搭建个人博客3-进阶设置目录下，在文章中插入图片时，使用的路径为 ![](/images/example.img) 其中，example.img为图片名。至此为止，网页中可以正常显示插入的图片，但是Typora中无法显示图片，因此我们需要设置Typora的图片根目录，方法是在文章开头的YAML头中添加如下字段 路径根据自己的文章位置而定，也可以在工具栏选择「格式—\u003e图像—\u003e设置图片根目录」，产生的效果是相同的，也是在文章头部添加该字段。 最后，我们在Typora的偏好设置中，设置插入图片时自动复制到相应的目录下即可，这样所有的图片都可以和博客代码存放在一起。、 这种方法唯一的缺点是所有图片和博客项目源码的总大小不能超过1G，因为一个Github项目空间最大1G ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:6:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 自定义样式 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 config/css. 在 config/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 config/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:7:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"8. 添加独立域名 给部署在 GitHub Pages 上的博客添加独立域名，是早就想做的事，以前是因为没什么需求，.me域名比较贵，国内购买域名备案又比较麻烦，所以一直没做。这次选择了.top域名，买了三年才67，可以了，三年以后开始工作再考虑换.me域名，毕竟这个冷门的字段应该没人要。而且发现部署在github pages不需要备案，因为服务器不在国内。 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:8:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 选购域名 可能很多人已经买好了域名了，你可以[跳过这部分](#GitHub 上的设置) 要想给博客绑定独立域名，首先你得拥有一个域名。得去域名注册网站购买域名，国内的域名商推荐万网，国外的推荐 GoDaddy，因为他们分别是中国最大和世界最大的域名注册服务商。不了解的领域当然挑知名有信誉的总是没错的。 要是买.me域名就真的只能在GoDaddy买了，首年24，续费不知道，但是还需要购买隐私保护，这样就变成了每年60，要是工作后还负担的起，现在买这个还是算了。.io首年就320，更负担不起了。国内的话，.com，.net这些就不想了，基本都已经被注册了，于是选择了.top，一口气买了三年，一共67，而且在国内购买的好处是本身对WHOIS中的个人信息提供隐私保护。阿里云之前对域名提供的隐私保护服务已经停用了，主要是因为 为落实ICANN临时规范要求，自2018年5月25日起阿里云WHOIS查询公开信息中将不再显示域名注册人、管理联系人和技术联系人的个人数据，包括姓名、邮箱、电话、街道地址等。 这样域名的注册信息已得到默认保护，不再需要额外开通隐私保护。 具体选购过程大致是：搜索域名 -\u003e 将喜欢的域名加入购物车 -\u003e选择域名注册模板(没有的话要创建)-\u003e 付款 -\u003e 购买成功，实际使用还需要进行邮箱验证和实名认证，否则域名无法启用。 最为繁琐的域名备案过程可以跳过，因为博客挂载在github pages，而只有服务器在国内的网站才需要备案。 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:8:1","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 DNS解析 使用CNAME别名映射域名，比设置A记录更方便，最重要的是A记录无法开启https。参数设置如下图所示。 访问网址时可能会加www前缀，因此可以设置一个二级域名解析，方法相同。 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:8:2","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 GitHub 上的设置 到 Github shuzang.github.io仓库设置里，在 Custom domain 这里填写shuzang.top域名并保存。 Custom domain 下方 Enforce HTTPS 这个选项一并勾选，Github 跟 Let’s Encrypt 有合作，如果勾选了这个选项，Let’s Encrypt 就会给你的博客签发一张 SSL 证书，免费的。 发现上面这种方法每次提交后都需要重新填写custom domin字段，因此采用另一种方式，创建一个名为 CNAME 的文件放在content目录，其中的内容只写上你的域名，像这样 shuzang.top 使用hugo命令生成文件会将CNAME文件直接复制到public目录，并通过持续集成将其推送到master分支根目录。 等几分钟 (刷新 DNS 缓存)，然后在浏览器中输入shuzang.top，回车，不出意外看到了自己的博客。 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:8:3","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 其他玩法 除了将域名绑定给博客外博客，还可以用域名干一些别的事。 比如，使用 A 记录将 mail.shuzang.me 这个二级域名指向 207.46.149.80 就可以 “搭建” 一个 临时邮箱服务 (感谢 萌咖 | MoeClub.org 提供的服务器) 如果你还有一台拥有公网 IP 的服务器，可玩性就更高了！ 如果有能力，你甚至可以拥有自己的搜索引擎 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:8:4","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"9. 代码高亮 KeepIt主题本身对代码高亮的渲染是在本地执行的，使用的是google code prettify，高亮风格较少而且作者没提供配置选项，通过使用Highlight.js库可以自定义代码高亮格式3。 为了最大程度的保持原主题文件的代码，我们首先将主题文件夹下layouts/partials/js.html文件复制到Hugo项目文件夹，令其位于同样的目录，然后删除文件中的以下语句 {{ $prettify := resources.Get \"/js/prettify.min.js\" }} 之后删除js.html文件中所有$prettify字段。 复制主题文件夹layouts/partials/head.html文件到项目文件夹，并添加如下内容 \u003clink href=\"https://cdn.bootcss.com/highlight.js/9.15.10/styles/atom-one-light.min.css\" rel=\"stylesheet\"\u003e \u003cscript src=\"https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.bootcss.com/highlight.js/9.15.10/languages/go.min.js\"\u003e\u003c/script\u003e \u003cscript\u003ehljs.initHighlightingOnLoad();\u003c/script\u003e 以上代码使用了bootCDN对Highlight.js进行加速，并额外添加了对go语言代码高亮的支持。 最后需要删除主题文件夹中的某些内容，包括 assets/js/prettify.min.js文件 assets/css/main.scss的以下内容 @import \"_common/_prettyprint/default.scss\" 此时代码就可以以浅色的atom格式高亮了，不过可惜的是不显示代码行数，就只能等以后再说了。 还要注意的是以后每次更新主题都要删除主题文件夹中以上两个内容。 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:9:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"10. 视频 可以使用html代码直接在文章中嵌入视频，因为各视频网站一般会在分享链接中提供iframe格式的代码，以B站为例，复制如下代码放在文章中相应的位置即可 \u003ciframe src=\"//player.bilibili.com/player.html?aid=75064361\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 600px;\" \u003e \u003c/iframe\u003e 注意添加style字段调整高度与宽度，否则可能显示效果不会很好，上面的代码效果如下 也可以使用短代码来完成，Hugo提供了Shortcodes功能可以帮助我们定制一些语法，仍以B站视频为例，在项目根目录建立/layouts/shortcodes文件夹，在该文件夹内新建bilibili.html文件，文件内容编辑如下 \u003ciframe src=\"//player.bilibili.com/player.html?aid={{ .Get 0 }}\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 600px;\" \u003e \u003c/iframe\u003e 以后在文章中添加视频就可以使用如下格式的代码，其中的参数为视频代码，可以在视频URL中找到 video 75064361 使用iframe即使在本地的Typora编辑器也可以查看效果，但是代码较多，而是用shortcodes可以精简代码，但只有开启预览或将文章推送到云端才能看到，各有利弊，自己权衡。 最后还需要提一点，引入视频会导致网页加载速度大幅下滑，如非必要，最好不要引入。 ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:10:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"11. 音频 在文章中嵌入音频也是一个需求，尤其是歌曲，使用频率比较高，我们在这里注意使用使用 APlayer 和 MetingJS 完成这一功能。 在layouts目录下的head.html文件中添加如下内容 \u003c!--require APlayer --\u003e \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\"\u003e\u003c/script\u003e \u003c!--require MetingJS --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\"\u003e\u003c/script\u003e 然后在文章中可以通过如下语句添加音频 \u003cmeting-js auto=\"https://y.qq.com/n/yqq/song/000xRG4E4diqXD.html\"\u003e\u003c/meting-js\u003e 播放链接可以通过浏览器从各音乐平台获取，当然，和视频一样使用iframe格式的代码嵌入也是可以的 最后，也可以使用shortcodes缩短音频代码，在layouts/shortcodes目录下新建audio.html文件，编辑内容如下 \u003cmeting-js auto={{ .Get 0 }}\u003e\u003c/meting-js\u003e 在文章中就可以像下面这样使用，参数为音频网址 audio \"https://y.qq.com/n/yqq/song/000xRG4E4diqXD.html\" ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:11:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"12. 数学公式 文章中使用数学公式也是一种需求，但是Hugo本身不提供对这种语法的支持，KeepIt主题也没有提供这个功能，因此需要自己添加1。 主要方法是在已经生成好的HTML页面中使用JavaScript来渲染LaTex形式的数学公式，因此选择了这方面最流行的库MathJax。 与代码相同，数学公式也有行内(inline)和区块(block)两种，下面展示了这两种写法 When $a \\ne0$, there are two solutions to `\\(ax^2+bx +c =0\\)` and they are: $$x ={-b \\pm\\sqrt{b^2-4ac}\\over2a}$$ Hugo官方其实给了一个解决办法，分为三步： 引入\u003cscript\u003e标签 \u003cscript type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\u003e \u003c/script\u003e 需要确保这段代码嵌入网站所有页面中，因此把它添加到layouts/partials/head.html文件中。 行内公式和特殊字符转义 第一步执行完后行内公式依然无法显示，如下划线_等特殊字符转义也有问题。因此需要继续添加如下代码，仍然是layouts/partials/head.html文件，两段代码前者做了一些配置，后者自动给className加has-jax后缀。 \u003cscript type=\"text/x-mathjax-config\"\u003e MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\\\(','\\\\)']], displayMath: [['$$','$$'], ['\\[','\\]']], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], TeX: { equationNumbers: { autoNumber: \"AMS\" }, extensions: [\"AMSmath.js\", \"AMSsymbols.js\"] } } }); \u003c/script\u003e \u003cscript type=\"text/x-mathjax-config\"\u003e MathJax.Hub.Queue(function() { // Fix \u003ccode\u003e tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for(i = 0; i \u003c all.length; i += 1) { all[i].SourceElement().parentNode.className += ' has-jax'; } }); \u003c/script\u003e CSS调整 最后还需要在CSS中对这种特殊的MathJax进行样式处理，否则行内公式的显示会很奇怪。 code.has-jax { font: inherit; font-size: 100%; background: inherit; border: inherit; color: #515151; } 然后以上方法步骤繁琐最后还不一定起作用，因此采用把所有修改写成一个layouts/partials/mathjax.html文件的方法，把官方提到的三处修改合并成一个partial，然后把MathJax的CDN修改到国内。 \u003cscript type=\"text/javascript\" async src=\"https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\u003e MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\\\(','\\\\)']], displayMath: [['$$','$$'], ['\\[','\\]']], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], TeX: { equationNumbers: { autoNumber: \"AMS\" }, extensions: [\"AMSmath.js\", \"AMSsymbols.js\"] } } }); MathJax.Hub.Queue(function() { // Fix \u003ccode\u003e tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for(i = 0; i \u003c all.length; i += 1) { all[i].SourceElement().parentNode.className += ' has-jax'; } }); \u003c/script\u003e \u003cstyle\u003e code.has-jax { font: inherit; font-size: 100%; background: inherit; border: inherit; color: #515151; } \u003c/style\u003e 最后把以上partial模板添加到head.html模板中 {{ partial \"mathjax.html\" . }} 但直接修改主题中的文件并不合适，因为原作者可能会进行一定的更新（对我这样的半吊子很依赖作者对主题的更新），好在Hugo对文件的寻找是有优先级的，会首先在项目文件中寻找相应的渲染模板，然后才去主题文件夹寻找，因此将layouts/partials/mathjax.html和layouts/partials/head.html这两个修改后的文件复制到Hugo项目的相同位置，此时就可以直接反馈在页面上了。此时在hugo项目根目录查看目录结构如下： $ ls archetypes/ content/ layouts/ static/ config.toml data/ resources/ themes/ $ find layouts -type f | xargs ls -l -rw-r--r-- 1 lylw1 197609 2679 11月 12 15:51 layouts/partials/head.html -rw-r--r-- 1 lylw1 197609 1056 11月 12 15:51 layouts/partials/mathjax.html ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:12:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["爱编程爱技术的孩子"],"content":"待完成 RSS 站内搜索 CDN，可参考为博客添加免费的 CDN (Cloudflare) SEO 菜单栏添加页面 ↩︎ 菜单栏标题排序 ↩︎ Hugo中添加代码高亮支持 ↩︎ ","date":"2019-07-12","objectID":"/2019/hugo-blog-advanced-setup/:13:0","tags":["Hugo"],"title":"hugo搭建个人博客3-进阶设置","uri":"/2019/hugo-blog-advanced-setup/"},{"categories":["平日里的白日梦"],"content":"该部分收集翟天临事件及其它学术不端案例 课程作业，简单的收集翟天临事件和一些其它的学术不端案例，做一些评价。 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:0:0","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"1. 案例 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:1:0","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"1.1 翟天临事件 翟天临事件的发酵始于微博账号@PITD亚洲虐待博士组织在大年初三转发的一个知乎问答：为什么翟天临博士毕业了，但是却没有公开发表的论文。随后经舆论发酵，引起社会广泛关注，最终成为一个全民性的话题和学术不端的典型案例。 该微博账号作为博士相关资讯聚集地，在2018年发现翟天临正在攻读博士后，随即对其关注，并持续追踪其论文及毕业事宜。2019年2月7日，该账号转发了知乎问答：为什么翟天临博士毕业了，但是却没有公开发表的论文。引起网友关注，时值翟天临出演完春晚节目，在2月8日的直播中，某网友问翟天临的博士论文能不能在知网搜到，翟天临回答：“知网是什么东西？”，由此引起强烈反响。 经微博账号@ PITD亚洲虐待博士组织和知乎回答“为什么翟天临博士毕业了，但是却没有公开发表的论文”的持续关注，越来越多的证据被列举出来，最终，学术方面对其质疑归结为以下几点： 翟天临就读于北京电影学院，该学院的博士毕业学位要求中包含：“博士生在学位论文答辩前，应公开发表至少2篇（其中1篇在国内核心刊物）由本人入学后独立撰写的学术论文”。而知乎提问者在知网未搜索到他的论文。随后公布的翟天临可公开检索到的文章包括两篇，其一为《如何用“下意识”让表演更加生动》，发表在综艺报，该报不属于学术期刊。另外一篇名为《谈电视剧〈白鹿原〉中“白孝文”的表演创作》，该文发表在《广电时评》，严格来讲，该刊物同样不属于核心期刊，甚至不属于学术期刊。 《谈电视剧〈白鹿原〉中“白孝文”的表演创作》一文，全文不到3000字，知网查重超过40%，大段内容同黄山学院黄立华教授之前的论文重复，涉嫌严重抄袭。随后，报道显示翟天临的硕士学位论文也涉嫌抄袭。 翟天临博士学历为非定向全日制，然而在翟天临读博期间频繁参加演戏、代言和综艺等社会活动。网友制作的翟天临读博工作日程时间线显示其根本没有时间做学术研究。 2019年2月9日，即翟天临直播回答不知知网为何物次日，四川大学学术诚信与科学探索网将翟天临纳入“学术不端案例”公示栏（现已撤下，但网上有截图）。2019年2月16日，北京大学微博发布《关于招募翟天临为博士后的调查说明》，认定翟天临存在学术不端行为，并对翟天临及其合作导师进行处理。 该事件引起包括北京日报、人民日报和人民网等在内诸多媒体报道关注，并最终引起教育部回应。教育部发言人表示：“调查不仅涉及到翟天临本人是否学术不端，也涉及到工作中的各种环节。教育部对学术不端坚持零容忍态度，绝不允许出现无视学术规矩、破坏学术规范、损害教育公平的行为，对于这件事而言，将坚持发现一起、核实一起、查处一起，绝不姑息。” 事后，受翟天临事件影响，各高校对毕业查重要求提高，各高校本年度毕业生受到进一步影响。 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:1:1","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"1.2 韩春雨事件 2016年5月2日，世界顶级学术刊物《自然·生物技术》刊发了河北科技大学副教授韩春雨相关研究论文。 2016年8月，《自然-生物技术》发表声明称：已有若干研究者联系本刊，表示无法重复这项研究。并按要求令作者提交相关材料。一周后，韩春雨提交了更详细的材料。 2016年10月10日，国内13位知名研究学者声明无法复现韩春雨实验结果。一直到2016年11月底，所有研究都显示无法复现其结果。 2017年1月，韩春雨以该技术为核心的相关专利因材料不足被驳回。 2018年8月31日晚，河北科技大学公布韩春雨团队撤稿论文的调查处理结果称，未发现韩春雨团队有主观造假情况。但认为撤稿论文已不再具备重新发表的基础，按规定已取消了韩春雨所获得的荣誉称号，终止了韩春雨团队承担的科研项目并收回了科研经费，收回了韩春雨团队所获校科研绩效奖励。 该事件全过程韩春雨始终声称无法复现可能是因为实验人员所使用的细胞株被污染等细节问题。但事实依然令我们充满疑虑。 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:1:2","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"1.3 李连生事件 2007年年底，西安交大陈永江等六名教授在同校教授李连生的报奖推荐书中发现大量弄虚作假内容，向校领导口头反映情况。学校要求6人递交书面举报材料。 2008年初，上述教授向学校提交书面意见。此后，他们向西安交大党委、纪委等多部门同时发出公开举报信，举报李连生造假。但遭到校方冷落。其后几位教授甚至被李连生以“侵犯名誉权”告上法庭。 2010年3月，《焦点访谈》栏目以《没有结果的“学术成果”》为题介入对此事的报道，随后，校方做出反应，取消李连生的教授职务，并解除其教师聘用合同。 2011年2月，科技部发布通告，撤销李连生所获2005年国家科学技术进步奖二等奖，收回奖励证书，追回奖金。但据教授们声称：李连生转身又成了合肥通用机械研究院的副总工程师，兼压缩机技术国家重点实验室副主任。这家研究院是压缩机领域很重要的研究机构，很多研究成果都要他们认定。近日听说，行业全国技术会议召开时，他还以副主席的身份坐在主席台上。 而在举报始末教授们录下的校方调解内容也令人深思。“现在高校学术腐败成风，你们不要大惊小怪。”“要不要李连生把一等奖的利益分给你们一些？”“这50多天，你们把校领导搞得日夜不安，你们是始作俑者。如果现在声明退出，还为时未晚。” ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:1:3","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"2.原因分析 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:2:0","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"2.1 外因 首先是相关制度还不够完善和合理。在翟天临事件中，额外引发的一个讨论是关于艺术类博士点设置的问题。一部分人认为，从西方学位体系惯例来看，国外的艺术专业一般硕士就到顶了。而国内则不合理，艺术类专业不仅开办博士点，而且还都是学术型的，翟天临所在北电的教学水平甚至都达不到学术型博士点的水平。实际上，纵观近些年出现的新专业，很多大学往往不顾办学水平盲目申报，最后带来的结果可想而知。另一方面，国内目前高校学生的毕业要求和老师的职称评定要求基本都是论文导向。这种导向可能还需要完善。同时还有一种情况，即某些高管或企业家到高校镀金的情况，这些人往往没有足够的时间和精力在学校进行研修，但偏偏依靠某种资源挂名获得学位和学历，对学术界氛围造成进一步的冲击，加剧了浮躁风气。 部分学校因利益或名誉进行包庇，导致事态发展超出预料，违法学术道德者得不到足够惩罚。比较典型的是西交李连生事件中，学校为了名誉和资金申请对进行举报的六位教授进行压迫，而包庇学术道德违反者李连生，直到《焦点访谈》播出后才进行处理，而且到最后事件当事人李连生都未受到较大影响。公布的录音中展现出的学校管理层的价值观也令人难以置信，说明部分学校内部存在很大的问题。 造假成本低。这两年学术不端事件屡发，每年总要有一两起引起社会关注，2017年韩春雨事件，2018年南京大学教授梁颖撤稿和涉嫌抄袭等行为曝光，2019年翟天临事件，这些都是引起强烈社会反响的事件，被处罚而不为人所知的，甚至未被发现的更多。很多情况下都是由于造假成本低，大家都秉持着那么多人，不一定能查到我的心态。学生为毕业粗制滥造的论文发中文期刊，由于当前学术现状查阅者较少，即使是英文期刊，在影响因子比较低的情况下，几乎不会有人去浪费时间、金钱和精力去复现，偶尔被人质疑，在未引起社会舆论的情况下学校往往淡化处理。作假成本低到难以想象，这也是为什么学术不端事件屡发的一个原因。 还有一个重要的原因是从本科起的学风即不严谨。由于国内教育制度问题，大学之前学习压力较大，在上大学之后，缺少父母的管理，大学辅导员制度又存在一些问题，很多人往往沉迷其它事情，疏于学习。迟到、旷课、作业抄袭和考试抄袭等状况严重，在最重要的毕业设计中，甚至出现在网上买毕设的情况，偶有不愿同流合污者，也往往受到他人耻笑。这种氛围导致了学生往往不以抄袭为耻，养成了一种扭曲的价值观。在升入研究生阶段后，由这种价值观带来的学术不端行为也就不出人意料了。 以上现象的一种本质原因是现在处于一个快节奏、娱乐化的时代，即使大学校园本应是沉心做学术的地方，也难免受到浮躁社会风气的影响，最终导致了研究者的急功近利。而且，学术不端的现象以及这些原因也不是国内独有，世界上各国都存在，国外的学术不端现象爆发也比较频繁。这有待于全人类的共同进步和住房、医疗、教育、养老等基本社会资源问题的妥善解决。也许大家生存压力小一点，浮躁之风能压得住一点。 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:2:1","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"2.2 内因 内因主要是研究者主体修养不高，价值观出现了问题。以金钱、权势、名利等为导向的社会价值观导致了人们普遍急功近利。论语讲，“道之以政，齐之以刑，民免而无耻。道之以德，齐之以礼，有耻且格。”政令与刑罚只能约束人们的行为，使人不敢犯事，何况现有法则还不完善。只有用道德和礼仪来规范，才能使人们从心底认同，从而从根源上避免。现在主要是在道德修养方面的教育不够，大学以前的教育，对这方面的重视程度不够，小学的思想品德和初高中的政治课并不受重视，而家长的受教育程度千差万别，难以引导青少年形成正确的三观。到了大学之后，由于专业的不同，这方面的教育进一步弱化，大学的政治课往往和个人修养方向偏离较远，然而这几年正是学生接触更广阔的世界，三观养成的核心时期，在这方面教育不受重视的情况下，因社会功利主义思潮影响，学生难以养成好的学术品格和修养，导致了进一步深造产生的违反学术规范的行为。 学生对外在的诱惑也难以抵制。随着社会的进步，为了满足人们的精神生活需求，越来越多的产品被生产出来。比如大量的游戏、小说、电视剧等等，在现有科技产品（电脑、手机等）的帮助下，部分学生难以抵御它们的诱惑，从而投入大量时间和精力，导致学业荒废，在面临作业、考试等硬性要求时，匆忙补救，又再次无法抵御抄袭等手段的诱惑，从而走向不归之路。 在科研过程中，沉闷烦躁的文献阅读阶段，迟迟得不到可用数据的实验阶段，往往挑战着研究者的心理承受能力，一念之差，就很有可能做出篡改数据或抄袭的行为。而如果没有严谨踏实的态度，在写作和实验过程中又很有可能无意识地犯下各种错误，因此，行为习惯、态度和心理承受能力也是一个重要的影响因素。 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:2:2","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"3.坚守学术道德 首先应该提高自身道德修养。受学校教育及耳濡目染，我们应养成面对学术不端事件的正确观念，在历来的学术不端事件中，总有人对违规者持支持态度，典型的如“现在社会普遍就是这样，所以这么做没错”，“别人都这么干，我这么干怎么了”这种思想，我们应清晰意识到此类观念的错误之处，养成正确的价值观，因意识对行动具有主观能动性，唯有在意识上保持正确，我们才可能拥有正确的行为。要积极进行个人良好修养的培育，研究生依然处于三观形成的重要时期，我们需要主动的学习中外文化中好的部分，去伪存真，提高个人修养，树立道德底线。中国传统文化中，对个人修养极为看重，士子求学，《大学》是必读经典，何谓大学，即大人之学，“大学之道，在明明德，在亲民，在至于至善。”在由学生向社会，由青年向成人转变的阶段，应明确良好的道德修养是怎样的，要能够弃恶从善，努力达到更高的道德境界，学生需要主动地学习，才能在面临是非时做出正确选择。 其次，要培养细致认真的态度。在实验过程中，认真能够保证不会导致无意识的出错，而把出错的结果作为成果，在论文写作的过程中，认真则能保证文章逻辑的严密和行文的水平。当然，也需要能沉的下心，研究是一个长期的过程，即使短时间拿不出结果，也不应急躁，更不应去寻求旁门左道，从而违反学术道德和规范。而要沉下心就要我们有一个明确的目标，《大学》讲，“知至而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得”，只有有一个明确的目标，才能沉得下心去做事，最终才能得到好的结果。 还需要一些细节的行为，比如，拒绝买论文的行为，拒绝擅自使用别人的成果而不进行标注，大部分行为都由国家或学校进行了规范，我们要注意不要违反。而在一些不完善的地方，比如把别人的程序当作自己写的，孰知开源不等于抄袭，还有不要完全依赖导师，导师有指导的责任，但不能因此完全依赖导师。不能急功近利，研究生阶段培养的是研究的能力，即使短期出不了成果，也不应着急。有时候有学长学姐或导师的先期成果做参考，模仿的过程很容易有很大收获，但要注意尺度，不要无意识地将这些工作当作自己的工作，而且人在看到参考答案后，思维很难跳出这个思路，所以要学会自己仔细认真的思考，而不是一开始就看着“答案”。这种参考有时候还会涉及到导师的工作，比如导师作为评委评阅的别人的工作，往往交由学生阅读提升眼界，而这些工作很多都还处于未发表状态，我们要严格遵守学术准则，不剽窃不泄露他人成果。 另外，对自身的严格要求不代表完全脱离环境，不代表可以帮助别人违反这些要求。在自己“进度良好”或有能力的情况下，不应该为了利益去做如代写论文等程度的写手，这也是违反学术道德的行为。同时，要相互进行监督，在自己的同学流露出这样的想法时，要及时进行劝阻，抑制住思想的苗头，以免出现具体的行动，万不可碍于同学间的“友好关系”，对此思想予以默认，甚至进行怂恿，很有可能会导致对方出现相关违反学术道德的行为。最后，虽然学校的导师都能以身作则，但是由于学生毕业与导师相关，某些不努力的学生很有可能在最后期限都无法拿出足够的工作，这种情况有些导师只能给予援助，一方面，学生要持续努力，学制扩展到三年的情况下，研究时间应该足够得到能够毕业的成果，所以要明确自己的职责，不要直到最后才依赖导师。另一方面，导师也不应对这种行为纵容，否则，也是对其它学生的不公平。 研究生阶段相关的学术道德问题，依赖于学生、导师、学校、同学等各方面的共同努力，研究者追寻真理的道路需要我们尊重知识，需要我们心存敬畏，人类社会的进步依赖的是一代代人孜孜不倦地探索，而不是伪造与抄袭。人皆有向善之心，即使社会浮躁至此，大家还是更向往真善美，所以，还是不要成为自己所讨厌的人吧。 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:3:0","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["平日里的白日梦"],"content":"参考资料 [1] 百度百科. 翟天临学术门 [2] 知乎问答. 为什么翟天临博士毕业了，但是却没有公开发表的论文？ [3] 澎湃新闻. 翟天临事件全记录 [4] 北京大学官方微博. 关于招募翟天临为博士后的调查说明 [5] 百度百科. 韩春雨撤稿事件 [6] 百度百科. 西交大六君子事件 ","date":"2019-07-01","objectID":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/:4:0","tags":["杂谈"],"title":"科学精神与人文素养","uri":"/2019/%E7%A7%91%E5%AD%A6%E7%B2%BE%E7%A5%9E%E4%B8%8E%E4%BA%BA%E6%96%87%E7%B4%A0%E5%85%BB/"},{"categories":["研究生的区块链学习之路"],"content":"Ding, Sheng, et al. “A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT.” IEEE Access 7 (2019): 38431-38441. DOI: 10.1109/ACCESS.2019.2905846 KeyWord: Access control, attribute-based access control, blockchain, consortium blockchain, IoT 注：插图经过重新绘制，照片来自原论文截图。 ","date":"2019-06-03","objectID":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/:0:0","tags":["论文笔记"],"title":"A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT","uri":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1. 摘要 随着智能设备数量的急剧增加，物联网近年来得到越来越多的关注和快速发展。它通过现有的网络基础设施有效地将物理世界与Internet集成在一起，以便在智能设备之间共享数据。然而，其复杂的大规模网络结构给物联网系统带来了新的安全风险和挑战。为了保证数据的安全性，传统的访问控制技术由于其复杂的访问管理和集中性导致可靠性不足，不适合直接用于物联网系统的访问控制。本文提出了一种新的基于属性的用于物联网系统的访问控制方案，大大简化了访问管理。我们使用区块链技术来记录属性的分发，以避免单点故障和数据篡改。访问控制过程也进行了优化，以满足对物联网设备进行高效和轻量化计算的需要。安全性和性能分析表明，该方案能够有效抵御多种攻击，并能在物联网系统中得到有效的实现。 ","date":"2019-06-03","objectID":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/:1:0","tags":["论文笔记"],"title":"A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT","uri":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2. 引言 物联网无疑是最有前途的技术之一，近年来引起了学术界和产业界的广泛关注。物联网是一种新型的架构框架，通过现有的网络基础设施将物理世界与互联网结合起来。它的目标是连接所有的智能设备，包括物理设备、车辆和家用电器，并使它们能够通过互联网自动收集和共享数据。根据Gartner的预测，2017年，全球有超过84亿的联网企业加入了该网络，比2016年增长了31%，到2020年将达到204亿。然而，连接设备数量的急剧增加给物联网系统带来了新的安全风险和挑战。 由于物联网设备分布广泛，因此很难实施严格的安全控制，使其面对恶意实体的各种攻击比较脆弱。有必要保护物联网设备免受未经授权的访问，因为这些设备通常包含许多有价值和敏感的数据，未经授权的访问通常会导致严重的数据泄露。众所周知，访问控制是保证数据安全的重要技术之一。传统的访问控制技术如任意访问控制（DAC）、基于身份的访问控制（IBAC）不适合在物联网系统中实施，因为由于大量未知身份，几乎不可能为物联网系统中的每个人制作访问控制列表（ACL）。另一种常见的技术强制访问控制（MAC）通常由中央管理员执行，这就存在单点故障的问题。由于物联网设备的位置或功能不同，可能属于不同的管理机构，集中访问控制模式不适合物联网系统。 基于属性的访问控制（ABAC）提供了一种灵活、动态和细粒度的访问控制。它将角色或身份抽象为属性权威发布的一组属性。建立在一组属性之上的由布尔公式描述的访问策略用于定义有效和授权的访问。不再需要为系统中的每个角色分配角色或制作访问控制列表。相反，属性权限只需要管理定义在系统中的每个属性，并将它们分发给适当的用户。这样，访问管理就可以有效地简化，因为属性的数量远远小于系统中的用户数量。 区块链是技术巨头和商业界感兴趣的另一个热门话题。它是一种开放、透明和分布式的分类账，能够以可验证和永久的方式有效地记录双方之间的交易。一旦记录，区块链上的数据就不能被篡改，除非达成新的共识。将物联网与区块链技术相结合是一个有前途的趋势，预计将确保物联网系统的信任并减少总体开销。它可以帮助物联网建立一个分散的、可信的、可公开验证的数据库，从而使数以十亿计的连接物通过它实现分布式信任。 本文提出了一种新的基于属性的物联网系统访问控制方案。我们的主要贡献总结如下： 1）针对物联网系统提出了一种新的基于属性的访问控制方案。不再需要为系统中的每个人创建ACL或分配角色。每个设备都可以由一组属性来描述，这些属性在系统中预先定义，并由属性权威根据其身份或能力颁发。除非有足够的属性匹配访问策略，否则不允许任何人访问。 2）我们使用区块链记录属性的分布。属性权威共同维护一个公开和可信的“交易”分类账。一旦被记录，区块中的数据就不能被更改，任何人都可以在需要时随时查询区块链。 3）简化了访问控制协议，双方只需做一些简单的签名和散列操作即可。这样，我们的方案对物联网系统中计算能力和能源供应有限的设备更有效。 论文组织如下：第二节对相关工作进行了总结，第三节对前期工作进行了总结。我们在第4节中提出了利用区块链对物联网系统进行基于属性的访问控制方案的详细构造。第5节和第6节分别是安全性和性能分析。最后，我们将在第7节中得出结论。 ","date":"2019-06-03","objectID":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/:2:0","tags":["论文笔记"],"title":"A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT","uri":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3. 相关工作 为了确保严格的访问控制，身份验证是在共享或交换数据之前确认通信参与者身份的必要机制。沙尔曼等人提出了用于物联网的基于身份的认证方案。在他们的方案中，每个设备都由它所属的网关管理，并且拥有一个由控制器授予的虚拟IPv6地址作为其唯一标识。在与其他人进行身份验证时，授权地址可以用作证书。Porambage等人为分布式物联网应用中的无线传感器网络设计了一种轻量级的认证机制。每个传感器节点将首先从相应的簇头中获得一个凭证，作为将来身份验证的先决条件。针对节点地理分布的差异及其相互关系，讨论了四种通信链路。希夫拉杰等利用一次性密码（OTP）技术，设计了一种基于身份的椭圆曲线密码系统（IBE-ECC）的端到端的轻量级认证方案。由于不需要存储密钥，密钥大小也很小，因此该方案对物联网系统是有效的。参考文献[5]提出了一种分布式基于能力的物联网系统访问控制方案，其中智能事物可以实现轻量级的端到端授权。能力通常是一种可沟通的、不可原谅的权威象征。 许多企业倾向于充当集中的受信任权限，并基于OAuth协议强制授权[6]。该项目连接所有基于IP的智能对象（calipso）实现了一个集中的系统模型，其中智能对象将授权委托给一个名为iot-oas的强大服务器。然而，[7]表明，在资源受限的设备中运行所有OAuth逻辑几乎是不可能的，因为它有很高的通信和计算开销。 基于角色的访问控制（RBAC）[8]是限制授权用户访问权限的常用方法。它根据用户在系统中的角色授予用户特定的权限。然而，它不适合物联网系统，因为这种接入模式不够灵活和可扩展。一旦一个设备被分配给一个角色，它就只能以固定的方式访问数据。与RBAC相比，基于属性的访问控制（ABAC）[9]更加灵活和可扩展，能够提供更细粒度的访问控制。实体可以在属性上定义访问策略以限制有效访问。针对物联网感知层，提出了一种基于ABAC模型的高效访问控制方案。只有在策略中具有满足属性子集的用户才能获得访问授权。张等[11]，[12]提出了两种基于属性的加密方案，以确保细粒度的访问控制和数据安全。 上面提到的大多数访问控制方案都面临着一个共同的问题，即需要一个可靠的中心来确保信任。由于物联网设备分布在世界各地，因此不可能有一个集中的节点来管理所有这些设备。一般来说，每一个都是由附近或其所属的当局管理的。在这些部门之间建立信任是实现分布式管理的基础。因此我们认为使用区块链可以建立一个分布式的一致性信任。它于2008年首次由Nakamoto[13]提出，现在这是数字货币比特币的基础技术。 Ouaddah等人[14]对物联网的不同访问控制方案进行了广泛的审查，结论是传统的访问控制机制不适用于资源受限的环境。Hardjono和Pentland[15]详细描述了基于区块链的访问控制和身份管理的设计。他们在[15]中提出的chainechor系统为系统中的实体提供匿名但可验证的身份。共识节点可以引用匿名成员的公钥列表来强制访问控制。同一实体进行的交易是不可链接的。哈尔特等人[16]系统总结了物联网中区块链的实现。 在Ouaddah[17]中，引入了一个使用名为FairAccess的区块链的分散授权管理框架。它使用新类型的交易来授予或撤销用户的访问权。Novo[18]提出了基于区块链的物联网系统的全分布式访问控制方案。与FairAccess不同，管理系统的策略规则是通过生成单个智能合约来定义的，访问控制策略是通过在[18]中为此智能合约创建交易来定义的。我们使用联盟区块链而不是私有区块链来建立一个更加分散的系统。由属性组成的访问策略由物联网设备根据其安全要求自行定义。要获得访问授权，所涉及的设备必须证明其对满足策略的相应属性的所有权。 ","date":"2019-06-03","objectID":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/:3:0","tags":["论文笔记"],"title":"A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT","uri":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4. 方案 ","date":"2019-06-03","objectID":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/:4:0","tags":["论文笔记"],"title":"A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT","uri":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"A. 系统模型 我们首先介绍了我们使用区块链实施物联网的访问控制方案的系统模型，如图3所示，有两个主要实体，属性权威和物联网设备。属性权威同时充当联盟区块链中的联盟节点和密钥生成中心（KGC）。我们最多允许n个属性权威中的（n-1）/3个是拜占庭节点，因此至少有4个联盟节点。为了便于理解，我们只使用最少数量的联盟节点来构建图3中的系统模型。 1）属性权威 属性权威是区块链的管理者和属性的分发者。为了共同维护分布式账本，他们需要在属性分配上达成共识。属性的授权以交易的形式记录。由某个属性权威授权的属性交易首先放置在自己的交易池中。其他属性权威机构必须在记录到区块链之前验证其有效性。一旦成功记录，任何人都不能篡改区块数据，除非所有联盟节点达成新的共识，并从需要修改的区块生成新的链。考虑地理分布因素，每个属性权威管理不同区域的设备。 同时，当物联网设备向系统注册时，属性权威也充当密钥生成中心（KGC）。每个属性授权机构将使用基于身份的加密技术，根据每个附属设备的身份向其颁发一对公钥和密钥。通过公/私密钥对，通信中涉及的设备可以相互进行身份验证，并就会话密钥达成一致。 2）物联网设备 这些设备负责在物联网系统中收集、处理和共享数据。他们不参与交易验证，只有区块链的读取权限。为了确保有效的访问和数据安全，数据请求者在交换数据之前需要从数据所有者那里获得访问授权。数据请求者使用属性权限分配的属性来证明它们具有相应的权限。只有在有一组符合数据所有者访问策略的属性时，才允许访问。 ","date":"2019-06-03","objectID":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/:4:1","tags":["论文笔记"],"title":"A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT","uri":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"B. 安全模型 在我们的方案中，由于各种恶意攻击成为拜占庭节点，属性权威可能非常容易受到攻击。我们限制拜占庭节点的数量不超过n个节点中的n−1/3个。有了这个限制，属性分配的共识就可以正常地达成。每个属性权限的密钥都是安全的，因此没有人能够伪造每个联盟节点的签名。他们知道彼此的公钥，这样他们就可以验证每个签名的有效性。 这些设备是不可信的，因为它们可能相互勾结，在利益驱动下，当它们中没有一个独立地具有满意的属性集时，它们就与其他设备进行身份验证。恶意设备甚至可能有意篡改区块链或干扰属性权限以达成共识。 ","date":"2019-06-03","objectID":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/:4:2","tags":["论文笔记"],"title":"A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT","uri":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"C.构造 1）系统初始化 设λ为安全参数。系统初始化算法以安全参数λ为输入，输出系统的全局参数。所有系统成员都需要在系统规定的相同椭圆曲线上达成一致。设e为椭圆曲线加群，其中椭圆曲线离散对数问题（ecdlp）是一个难处理的问题。设g为e的一个元素，具有大的素数阶r，然后选择两个安全散列函数h1：0，1→z r，h2：0，1→0，1λ，将任意大小的位串映射成一个新的固定大小的位串。设g为e的一个元素，具有较大的素数r，所有的属性权限共享一个skm∈z r，并将其作为主私钥，相应的主公钥pkm就是skmg。最后，系统参数发布为λ，e，g，pkm，h1，h2。 2）注册 每个设备在系统中都有一个直观的身份ID。注册时，设备所属的属性权威在验证其身份的基础上，根据基于身份的密码学，在安全通道中向其颁发一对公钥和密钥。 3）地址生成 每个设备使用一个地址及其ID来申请一个属性i。为了生成一个地址，它随机选择一个k∈z r作为密钥（sk），因此kg是公钥（pk）。为了生成一个相应的地址，设备可以散列pkkid（k表示这里的连接），并通过base58检查编码对结果进行编码。因此，地址为：address=base58检查[h2（pkkid）]。 4）属性请求 每个属性权威都有一对公钥和密钥。公钥用于生成自己的地址aa，密钥用于签署交易。设备与之交互的属性权威将验证申请人是否能够拥有该属性I。如果设备通过验证，属性权限将生成一个交易：a a i−→address。然后，属性权威用它的密钥sigsk[h1（a a i−→addressktimestamp）]对该交易的散列和时间戳进行签名。 最后，属性权威打包交易、签名和时间戳，并将其放入自己的交易池中。 这些联盟节点将定期选择一个块生成者。其职责是将其交易池中的交易打包成一个块，并将其广播给其他联盟节点，以达成共识。块生成者根据时间戳对交易进行排序，并计算所选交易的merkle根。块头由最后一个块头的散列、生成该块的时间戳和merkle根组成。如图5所示，数据块制造商使用PBFT[5]协议将这个新数据块广播给其他联盟节点。在预准备阶段，其余联盟节点将验证新块的有效性，并以相同的方式向其他节点广播。一旦接收到2F相同的块，他们将在准备阶段向其他人广播确认消息。如果一个节点接收到2F+1确认消息，它会将新块追加到区块链中。 5）访问控制 Alice和Bob之间的访问控制协议如图4所示执行： Alice首先使用她的身份IDA向Bob发起一个通信请求，并使用基于身份的验证和密钥协议（AKA）与Bob生成会话密钥k。使用任意对称密钥算法，k可以保证Alice和Bob之间后续通信的安全性。为了简单起见，我们只描述下面消息交换的过程并忽略每个通信的对称加密。 然后Bob返回一个随机数n和一个访问策略p，表示谁可以与他通信。 Alice选择一个满足策略的子集，并使用其相应地址已被发出匹配属性i的每个密钥对随机数n进行签名。 ","date":"2019-06-03","objectID":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/:4:3","tags":["论文笔记"],"title":"A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT","uri":"/2019/a-novel-attribute-based-access-control-scheme-using-blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Wan J, Li J, Imran M, et al. A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory[J]. IEEE Transactions on Industrial Informatics, 2019. 被引：2次 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:0:0","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 通过IIoT，智能工厂进入了蓬勃发展的时期。但是，随着节点数量和网络规模的扩大，传统的IIoT架构无法再为这样庞大的系统提供有效支持。因此，我们引入了区块链。它是一种用于构建分布式网络的新兴方案，用于重塑传统的IIoT架构。首先，分析了传统IIoT架构的主要问题，总结了现有的改进。其次，我们引入了一个安全和隐私模型来帮助设计基于区块链的架构。在此基础上，我们分解并重新组织原始的IIoT架构，以形成一个新的，多中心，部分分散的架构。然后，我们引入一些相关的安全技术，以改进和优化新架构。之后，我们设计了数据交互过程和架构的算法。最后，我们使用自动生产平台来讨论具体的实现。实验结果表明，与传统架构相比，该架构提供了更好的安全性和隐私保护。因此，所提出的架构代表了原始架构的重大改进，这为IIoT开发提供了新的方向 原因：节点数量和网络规模扩大，传统的IIoT架构无法再为这样庞大的系统提供有效支持。 传统IIoT问题和现有改进（Section I） 设计基于区块链的架构(Section II) 安全与隐私模型(Section III) 设计数据交互过程和算法(Section IV) 使用自动生产平台具体实施(Section V) ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:1:0","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction 随着各种技术的发展，以及大数据，云计算，网络物理系统（CPS）等创新概念的兴起，现代工业已经提升到一个新的水平。因此，以工业物联网（IIoT）为核心，旨在实现智能制造的智能工厂已经出现。通过IIoT，智能工厂中的不同类型的工业设备实现了集群交互，其中数据不再是独立的。通过数据的碰撞和融合，可以促进智能化和网络化制造过程的转型和升级[2] [3]。事实上，当前的行业趋势和举措目的在于利用互联网连接行业中未连接的东西，从而实现第四次工业革命。 得益于各方面的关注和推广，已经有许多成熟的工业物联网平台服务于智能工厂，如西门子MindSphere，施耐德EcoStruxure，GE Predix等[5]。这些工业物联网平台实现了垂直集成，横向集成和端到端集成，打破了设备信息孤岛问题，实现了智能工厂中各种设备的集成。 但是，由于IIoT体系结构的局限性和底层设备的漏洞，大量关键的安全和私有数据非常容易受到攻击。在[6]中展示了在正常物联网环境下攻击数据采集系统的几种情况。另一方面，在[7]中，通过对互联网上各类嵌入式设备的访问，检测和长期监控，发现了大量易受攻击的节点，揭示了设备层面的许多不同漏洞。此外，在[8]中，作者发现恶意软件，恶意脚本等可能很容易潜入应用程序级别的各种设备，这可能会在未经用户许可的情况下侵犯用户的私人数据。这种威胁和攻击不仅会导致敏感数据泄露，还会带来巨大的社会和经济问题，甚至危及国家安全。因此，迫切需要解决当前IIoT架构的安全和隐私缺陷。 2008年，基于区块链技术，Nakamoto提出了一种名为比特币的点对点数字货币系统[9]。直到现在，该系统一直稳定运行。IIoT系统与比特币系统之间存在许多相似之处，例如大量不同的节点，频繁和易变的异构数据交换，高安全性和隐私要求等。因此，将区块链技术应用于IIoT系统，改进底层架构并解决上述缺点是可行的。在[10]中，作者提出了一种基于区块链技术的新的双因素认证方案，以确保数据安全。此外，在[11]中，物联网与开源区块链平台相结合，实现了数据交换，并创建了分布式方法以提高设备级的安全性。基于区块链和智能合约，在[12]中创建了一个名为BPIIoT的点对点IIoT平台，以实现没有可信中介的数据交换。该工作非常具有启发性。讨论和分析了当前IIoT的不足之处，并提出了相应的改进方法。然而，除了高安全性和隐私之外，还需要一个优秀的IIoT架构来提供良好的性能。现有研究有三个主要缺点。首先，区块链技术的引入增加了IIoT架构的传输和计算负担，但是没有深入考虑对工业环境的实时能力的影响。其次，大多数相关研究的范围很小，这意味着没有构建完全独立的系统。最后，由于大多数研究都是基于开源平台，如Multichain，Ethereum，Hyperledger等[13]，与第三方平台的高度耦合可能会导致不可预测的问题。 因此，我们的工作中，目标是实现区块链和IIoT的深度结合。这项工作的新颖性如下：1）我们结合区块链技术并引入比特币设计，为智能工厂构建私有化，轻量级，易于扩展和部分分散的IIoT架构;2）引入安全和隐私模型以帮助分析架构的关键方面;3）在严格的分析和论证的基础上，引入白名单机制，非对称加密机制等方法，提高IIoT体系结构的安全性和隐私性;4）我们根据提出的架构实现了一个自动生产平台，并以平台为例讨论具体的防御措施。 本文的结构如下。在第二节中，介绍了基于区块链技术的改进的IIoT体系结构，列举了关键方面，并讨论了IIoT体系结构的相关关键技术。在第三节中，我们引入了一个模型来帮助分析架构的关键方面并指导防御机制设计;在第四节中，给出了详细的流程图来描述数据流，给出了控制数据交互的具体算法，并分析了所提出的体系结构的防御机制。在第五部分中，我们使用更具体的设置转换自动生产平台，并在实践中分析所提出的架构的安全性和隐私性。最后，第五节提供了一个简短的结论和未来的研究方向。 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:2:0","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"Blockchain-Based IIoT Architecture For Smart Factory 目前，大多数智能工厂都是基于云的制造架构[14]。这样的架构使用户能够随时随地访问共享的制造资源池，并且可以通过最少的工作和第三方交互来实现资源的快速配置和管理[15]。但是，集中式架构非常脆弱。即，只要中心节点损坏，所有服务都将被暂停。因此，我们的目标是建立一个分散的系统，其中节点相互监督。我们提出的用于智能工厂的基于区块链的IIoT架构如图1所示。所提出的架构有五层，传感层，管理中心层，存储层，固件层和应用层。 传感层包括各种类型的传感器和至少一个具有一定计算能力的微计算机，它可以获取关于各种设备的信息，并对所收集的数据进行预处理。一方面，管理中心层解析上传的数据，加密，打包数据以生成块，并将其存储在数据库中。另一方面，管理中心层需要基于生产调度策略来集成和操作不同的设备，并实时响应用户的请求以提供定制的服务。存储层扮演数据中心的角色，保存加密的防篡改数据和区块链记录，这些记录以分布式形式存储并以特定时间间隔同步。为了使传感层，管理中心层和存储层有效互补，我们提出了固件层，它涉及连接每一层的底层实现技术，包括数据采集，分布式算法，数据存储技术等。应用层为用户提供不同类型的服务，如实时监控，故障预测等 传感层：传感器和单片机 收据收集和预处理 管理中心层：计算机 解析传感层数据，加密，存储到数据库，打包数据生成区块 基于生产调度策略集成和操作设备，实时响应用户请求提供定制服务 普通意义上的矿工，PoW的修改版 存储层：管理层计算机的存储设备 保存加密数据，保存区块链数据 固件层：以上三层的底层实现技术 应用层：为用户提供不同类型的服务，如实时监控，故障预测 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:3:0","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"A. 架构划分 所提出的架构分为内联网和外联网。内联网旨在收集和存储数据，而外联网旨在利用数据为不同用户提供不同的服务 内联网由传感层，管理中心层和存储层组成。由于计算能力的限制，不考虑对等（P2P）网络。每个设备节点的数据需要上传到指定的管理中心并由管理中心管理。每个设备节点都需要从管理中心请求对不同操作的许可。 比特币使用UTXO结构来确保良好的匿名性和安全性。由于私有区块链中成员设备节点的数量和权限受到严格限制，我们直接记录传感器的状态，而不是使用UTXO。此外，考虑到IIoT系统[16]的多样性，复杂性等，传感层配备了微型计算机，如STM32，Raspberry Pi等，以预处理数据，有助于有效降低上层系统的开销。 外联网由管理中心层和应用层组成。内联网和外联网之间的主要区别在于内联网面向设备，而外联网面向用户。因此，外联网需要连接到Internet并考虑连接，算法，工具等来利用数据，并创建合理的访问方式来为用户提供服务。这意味着用户可以根据自己的需求定制各种管理中心，并确保高质量的服务（QOS）。 为了确保数据安全性和隐私性，内联网和外联网都具有白名单和动态认证机制来限制节点。在白名单机制中，白名单通常与黑名单一起使用，决定了访问或拒绝的权利。这种机制可以快速验证访问流量并过滤恶意流量，提供快速方便的安全性和隐私[17]。考虑到架构中的设备节点和用户节点，内联网和外联网中的白名单和黑名单应分别创建。此外，动态验证机制也是保证数据安全性和隐私性的有效方法[18]。设备节点和用户节点获取的权限是有时间限制的。达到时间限制后，需要重新验证权限和工作量证明（PoW）。此外，管理中心层和用户层还提供了自运行算法以生成配对的验证码。用户需要提供验证码在重新验证时维持访问权限。 内联网：工厂内私有网络，由前三层组成，旨在收集数据 设备上传数据到管理中心，并从管理中心请求操作许可 直接记录传感器状态，非UTXO结构 外联网：工厂与互联网连接，由管理中心层和应用层组成，旨在利用数据为不同用户提供不同服务 利用数据的合理方式（算法、工具等），合适的访问方式，定制的管理中心 内外联网都使用白名单和动态认证机制，权限有时间限制，超时重新验证 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:3:1","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"B. 管理中心层 在区块链系统中，除了交易节点之外，还有一个负责记录块的特殊节点。在提出的架构中，即构成管理中心层的管理中心。 为了保证管理中心是可信任的，必须将共识算法应用于架构，例如工作量证明（PoW），权益证明（PoS），实用拜占庭容错（PBFT）等。通过奖励解决PoW提出的数学问题的节点，比特币系统鼓励记录节点竞争。奖励保证了记录节点的参与，并且数学问题解决带来的计算成本使得恶意操作成本高昂。但是，这种解决方案不仅浪费了大量的计算资源，而且还带来了可扩展性问题[20]。 在IIoT系统中，我们更注重资源的利用和数据交互的效率。此外，与比特币中的不受信任的系统不同，所提出的系统是私有区块链系统，其中所有节点最初都是受信任的。因此，我们放弃了竞争和奖励机制。智能工厂中的每个车间都配备有一个或多个专门的管理中心用于数据管理。然后，**引入统计过程控制（SPC）[21]或其他比较算法来完成PoW。**对于SPC，根据具体设备，我们首先设置特征值，如控制限值，平均值等。然后，对上传数据进行一些统计分析，将其与设定值进行比较，并对交易进行验证。每次生成新的块记录时，PoW应该执行一次。这种设计可以提高架构的容错性，可扩展性和实时性。 我们考虑使用多个管理中心来形成私有云，而不是设置云，这允许用户连接和访问数据。可以认为管理中心相当于智能边缘网关和云的融合，这是边缘计算架构的简化和改进[22]。虽然传感层和管理中心层是集中式LAN系统，但从全球的角度来看，多个管理集线器构成了部分分散的系统。多个分布式节点可以降低单个中央节点的压力，并避免单个中心节点崩溃导致的系统故障。这种设计是区块链技术与实际工业环境相结合的合适解决方案。 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:3:2","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"C. 私有区块链 我们设计了一个私有的独特区块结构来记录存储层中的数据。如图2所示，该块包含两部分：区块头和区块体。结构化数据存储在区块头中，记录当前块的多个特征值，包括前一个块的哈希值，当前块的时间戳，以及特定算法对收集的数据生成的Merkel根[23]。一般来说，块更像是索引文件。特定设备数据仍然由数据库存储，并且每个节点的访问记录（存储，读取和控制）存储在块中。通过这种设置，每个操作将通过块严格监督，同时可以保持传统数据库的优点。因此，可以跟踪每个节点的各种操作，并且可以高度保护数据交互。 在表1中，给出了区块体中记录的信息的示例，包括请求地址，请求内容，Merkel根和来自管理中心的响应。区块限制了数据记录的数量，这意味着在一定数量的插入之后将生成一个新块。实际上，存储层是管理中心中的物理存储设备，例如SSD，HDD等，其构成分布式存储系统。 为了实现良好的隐私，我们引入了哈希算法和非对称加密算法。对于我们的架构，我们选择SHA256 [24]和椭圆曲线加密（ECC）[25]。通过使用SHA256，我们可以生成Merkle根，它可以有效地压缩数据量以链接每个块。使用加密数据时，用户可以执行相同的哈希计算并比较哈希码以验证数据。**ECC算法用于生成公钥和私钥以加密数据。**数据库中的数据将通过公钥加密为密文。用户应提供私钥以解密加密消息以获得定制服务。这两种算法可以确保良好的数据隐私并防止非法操纵。 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:3:3","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"Data Security and Privacy Model 我们认为架构需要满足三个主要要求：机密性，完整性和可用性（CIA），这可以称为CIA要求[26]。机密性确保只有授权用户才能阅读该消息;完整性确保不会对收到和发送的消息进行任何更改;可用性意味着每个服务和数据都可用[27]。在本节中，我们考虑将Bell-La Padula（BLP）模型与Biba模型[28]结合起来，以满足CIA要求，以帮助完善我们的架构。基于这两个模型，我们进行了一些简化并引入一些属性： $$ S = {s_1,s_2,s_3,…,s_n} \\ O = {o_1,o_2,o_3,…,o_n} \\ μ = {M_1,M_2,M_3,…,M_4} \\ A = {w,r,c} \\ L = {l_1,L_2} $$ S是一组主体。O是一组对象。μ是一组访问矩阵，表示主体对对象的访问权限。A是一组访问属性，其中w代表存储，r代表读取，c代表控制。L表示不同的权限级别，其中w代表存储，r代表读,c代表控制，L代表不同的权限级别，其中l1\u003cl2。在提出的架构中，我们可以轻松地将安全级别与完整性级别相结合，以获得不同主体或对象的权限级别。根据上面的定义，如表2所示，我们设计了一个访问控制列表（ACL）： 可以推断，相同级别的主体具有对象的所有权限，高级别主体具有读取和控制对低级别对象的访问权限，而低级别主体对其自身级别以上的对象没有权限。一方面，数据应限制从低级到高级的流动;另一方面，低级别的数据不能被高级别篡改。这两条规则有助于保持良好的CIA要求。此外，我们认为架构中有三个实体：设备节点，管理中心和用户节点。设备节点和管理集线器应属于𝑙2，而用户节点应属于𝑙1。数据可以从设备节点和管理中心流向用户节点;用户节点无权编写或修改数据。但是，设备节点和管理中心彼此具有所有权限，因此可以实现有效的数据交互。 尽管如此，我们还定义了一个公式来确定当前状态是否安全： $$ 𝑉 = 𝑆 \\times 𝑂 \\times 𝐴 \\times 𝜇 \\times L $$ 在这个公式中，S*O*A表示主体使用某种方法来访问对象;μ表示接入矩阵;L表示权限级别。一旦所有元素都是安全且可信的，就可以确保安全状态。由于我们已经将架构划分为不同的层次并进行了一些定义，这意味着S*O*A和L已经被严格限制和遵守，μ是应该考虑的最后一个元素。因此，如表3所示，我们设计了一些防御机制来帮助控制访问矩阵。 实际上，从表3可以看出，管理中心扮演着数据传输中介的角色。除了严格的层次结构外，还设置了不同的验证方法，以帮助保持架构的安全。与区块链技术一起，它们不仅可以提供有效的方法来控制各种有助于防止恶意攻击的访问,而且还可以增强架构的安全性和隐私性，形成更加成熟稳定的系统。 设备节点对管理中心：白名单，PoW，动态验证，Merkle根 用户节点对管理中心：白名单，动态验证，非对称加密，Merkle根 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:4:0","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"Data Interaction Process Design 然而，实质上，所提出的架构源自物联网。因此，在本节中，我们参考[29]，以温度采集为例，设计架构中的数据交互过程，以防止可能的攻击和威胁：权限泄漏，DoS或DDoS攻击，网络嗅，对攻击和入侵的妥协。我们给出了具体的数字和算法来描述我们的设计，本节的主要概念在表4中给出。 概念 定义 whitelist[1…a] Record trusted ID. There are backups in each management hub mComputer[1…b] Record all microcomputers in the system mHub[1…c] Record all management hubs in the system requestReceived Indicate if data arrives users[1…d] Record all users in the system time Record the running time in the system 所提出的架构应首先实现数据采集，这取决于微型计算机。通常，微计算机可以管理一个或多个传感器并连接到一个管理中心。获取数据后，微型计算机需要注册一个唯一的ID，该ID将被放入连接的管理中心的白名单中。白名单在每个管理中心都有备份。如果一个管理中心崩溃，则连接的微型计算机可以处于待机状态，或者选择更改其网络设置以切换到其他管理中心。流程图如图3所示 在此过程中，我们考虑窃取和滥用节点权限（主要是传感层和管理中心层）的攻击。因此，我们设计了两种防御机制。一方面，在传感层，我们集成了白名单机制，动态验证机制和PoW一致性算法，以防止恶意流量和注入错误数据。另一方面，当创建多中心系统时，在其他管理中心的监督下，可以快速发现，排除和替换被入侵的管理中心。这两种防御机制可以保证底层系统的稳定运行。 设备节点申请存储权限的详细过程如图4所示，可以归结为算法1.通过白名单验证获得权限后，首先将数据放入缓冲池。当达到一定数量的数据时，管理中心将使用内置的比较算法来计算特征值，并将它们与设置值进行比较，通过它们完成PoW。如果满足要求，缓冲池中的数据将被放入数据库中;同时，上传的数据可以直接传输到数据库一段时间，并允许设备节点允许的所有操作;否则，将丢弃缓冲池中收集的数据，并拒绝许可请求。应该注意，所有传输到数据库的数据都需要通过公钥转换为密文。管理中心将为每个权限许可生成区块记录。然后将块记录广播到其他管理中心，这将再次验证块记录并记录它。但是，经过一段时间后，动态验证机制需要重新认证，因此系统需要重复图4中1-6的过程。该流程图是申请存储权限的一个例子，读取和控制请求是一样的。 如上所述，我们在内联网中实现数据交互。如图5所示，外联网交互的流程图类似于内联网的流程图。由于管理中心连接到内联网，Dos攻击或DDoS攻击[30]将非常频繁。因此，为外联网建立了白名单机制，动态验证机制和非对称加密机制。白名单机制和动态验证机制与内联网相同，进行筛选，消除内联网上的恶意流量。另一方面，非对称加密技术是专门为外联网设计，以防止未经授权的访问。该过程归结为算法2 在提出的体系结构中，管理中心也是记录节点。每个块和设备数据在每个管理中心都有一个副本。当块记录达到限制时，具有低开销的管理中心将生成一个块以记录该期间内的所有访问应用。如图6所示，在生成块之后，它将被放置在存储层中并与其他管理中心同步。除了上述防御技术之外，我们还在块记录中引入了双Merkel根来保护数据。第一个应用于块记录中存在的缓冲池中的数据;第二个应用于块头中存在的块体中的数据。这种嵌套保证了数据不被嗅探并且难以实现恶意入侵。 设备节点在管理中心注册 设备节点请求操作，获取权限，进行操作 用户节点注册和用户节点权限管理 数据收集，打包，Merkel防篡改 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:5:0","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"A Case Study: A Blockchain-Based Automatic Production Platform 在[31]中，提出了一种基于云的制造业大数据解决方案，用于主动预防性维护;在[32]中，讨论了上下文感知云机器人及其应用的研究。实际上，对于IIoT，许多研究人员专注于更高的实时能力，更强的计算能力，更智能的应用程序等，其中很少注意到安全性和隐私性。因此，在本节中，我们将使用区块链技术改造自动生产平台，以讨论IIoT应用程序的安全性和隐私性的改进。 如图7和图8所示，实现了根据所提出的架构的自动生产平台。在平台上设计了四个工业机器人来执行不同的任务。然后，我们设置了两个配备Raspberry Pi 3B的传感层来收集数据，如工作温度，工作时间等。最后，我们建立了两个配备Intel I5平台的管理中心，相关的算法和软件将在管理中心进行编程。之后，收集设备数据并通过传感器发送到Raspberry Pis（传感层）。在某些预处理之后，将数据上传到管理中心（管理中心层）以进行进一步处理（存储层和固件层）。用户通过工作区外的独立计算机访问管理中心，以获得不同的服务（应用层）。 我们考虑在图8中构建的系统。四个工业机器人被分成两组，数据将被不同的Raspberry Pis收集和预处理。收集完成后，将上传所有数据进行进一步处理，通常是故障预测，数据可视化等，用户可以要求所需的服务。如图9所示，我们描述了系统中的数据流。N表示体系结构中的任何节点，箭头方向表示受保护的数据的流向。此设置完成数据的收集和处理，并符合我们上面讨论的安全和隐私模型。 实际上，基于传统IIoT系统的背景，在所提出的系统中没有任何验证机制来始终保持传感器可信任。所有传感器都设计为连接到Raspberry Pi或管理中心，这意味着它们是紧密耦合关系。一旦验证在开始时完成，传感器只需要不断上传数据。此问题与用户节点相同。因此，为了防止恶意操作和无效入侵，设置了不同的防御方法。我们将Raspberry Pis和传感器视为设备节点，与用户节点和管理中心一起构建防御措施，如表5所示。 通常，如表5所示，我们以简洁的方式比较了提出的架构和传统的基于云的IIoT架构。通过区块链技术，我们可以看到所有阶段都已经过考虑。由于加密和可验证，可以确保不同服务的数据具有良好的机密性和完整性;良好的可用性因为恶意流量被消除得以保障。更重要的是，系统仍然保持低开销。 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:6:0","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"Conclusions 在本文中，我们提出了一种创新的基于区块链的IIoT架构，以帮助构建更安全可靠的IIoT系统。通过分析现有IIoT架构的缺点和区块链技术的优势，我们引入了一种新的IIoT架构，并对所有架构层进行了详细分析。此外，我们引入BLP模型以及Biba模型来理论上设计安全保证。在此基础上，我们描述了所提出的架构的关键技术，流程和防御机制。最后，我们对现有的自动生产平台进行了改造，以讨论与传统IIoT架构相比的改进。它表明，所提出的架构可以极大地提高CIA的要求。因此，所提出的架构可以在未来实现更多的扩展，例如通过智能合约的集成，实现资源的自动配置;通过分布式系统，可以实现所有设备的在线远程升级。 ","date":"2019-05-24","objectID":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/:7:0","tags":["论文笔记"],"title":"A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory","uri":"/2019/a-blockchain-based-solution-for-enhancing-security-and-privacy-in-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"Fernández-Caramés T M, Fraga-Lamas P. A Review on the Application of Blockchain for the Next Generation of Cybersecure Industry 4.0 Smart Factories[J]. arXiv preprint arXiv:1902.09604, 2019. DOI: 10.1109/ACCESS.2019.2908780 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:0:0","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 工业4.0是一个旨在通过使用一些最新技术改进现代工厂运作方式的概念，例如用于创建工业物联网（IIoT），机器人或大数据应用的技术。其中一种技术是区块链，它能够为不同的工业领域增加信任，安全性和去中心化特性。本文重点分析使用区块链和智能合约开发工业4.0应用时产生的好处和挑战。此外，本文还对工业4.0技术中最相关的基于区块链的应用进行了全面的回顾。因此，其目的是为未来的工业4.0开发人员提供详细指南，以确定区块链如何增强下一代网络工业应用的网络安全。 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:1:0","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction 工业4.0代表了传统工厂向实际智能工厂发展的下一步，这些工厂旨在提高资源管理效率，并高度灵活地适应不断变化的生产要求[1]。工业4.0背后的概念首先由德国政府在2011年定义[2] [3]。虽然工业4.0的想法部分类似于工业物联网（IIoT）[4]，互联网+ [5]或中国制造2025 [6]，但许多行业都在积极拥抱工业4.0。 工业4.0的基础之一在于从价值链的不同部分收集尽可能多的数据。这种数据收集应该以快速有效的方式进行，以便在工厂中使用。数据收集可以通过部署在工厂、供应商或客户处的拥有获取，存储，处理和交换信息功能的系统来执行。 为了提供这种级别的连接，工业4.0范式提出可利用相关支持在工厂和互联网上分布的多个工业设备之间自主通信的技术。此类技术包括3D打印，增强现实（AR），工业网络物理系统（ICPS），IIoT或边缘计算，这些技术和其他相关工业4.0技术都包含在图1中。重要的是要注意工业业4.0范式促进了这些技术的应用，使工厂通信体系结构从当前的云或以Internet服务为中心的体系结构演变为涉及工业流程的所有实体以如点对点网络交换信息的体系结构（图2说明了这种演变）。 图2 通信架构演变：从现代工厂到工业4.0智能工厂 在工业环境中应用最有前景的技术之一是区块链，它源于比特币[7]，允许创建能够跟踪和存储大量用户和设备执行的交易的分布式应用程序（DApps）. 2017年，Gartner预测区块链技术的商业价值将在2025年增长到略高于1760亿，到2030年将增加到3.1万亿。区块链可以为不同领域增加价值并发展现有的互联网，从而实现从互联网信息'到'价值互联网'的转型和创建真正的点对点共享经济[8]。尽管如此，本文的重点是分析区块链处理当前工业场景面临的一些最相关挑战的能力，包括： 分布式应用程序。特别适用于具有中等和大型用户和计算负载的工业4.0应用程序，因为它们依赖于昂贵的集中式服务器，这些服务器的部署和维护成本也很高[9]，[10]。此外，许多工业公司向中间商支付这种集中式解决方案的费用 由于安全问题或上传新软件/固件而更新工业4.0系统（如IIoT设备）非常常见。在某些情况下，更新过程需要在遍布大型工厂的多个设备中手动执行任务。因此，有必要找到一种方法来简化这些繁琐和低效的任务，并将软件更新同时分发给尽可能多的智能设备，同时保持完整性和安全性以避免恶意固件更新。 在大多数行业中，信任收集数据的真实性以及与某些合作伙伴，服务提供商，制造商，供应商甚至政府进行的交易都是必要的。由于这些原因，需要一种提供透明度，验证问责制和增加信任的机制的技术。此外，请注意，由于需要信任收集的值来替换受信任的第三方[11]，因此应实施其他安全机制，尤其是在硬件级别[12]。 与第三方公司交换的数据对于某些企业来说是关键，因此它们应受到保护和匿名化。IIoT设备收集的数据也是如此，这些数据应该得到保护并且对非授权方保密。 许多工业公司也依赖于闭源代码，这增加了信任缺失，因为它实际上对代码的工作方式并不透明。因此，为了提供信任和安全性，必须培养开源方法。尽管如此，应该强调的是，开源代码也可能存在漏洞和攻击，但是，由于许多开发人员已对其进行验证，因此不易受到恶意修改。 提高运营效率和提高竞争力，确保长期可持续性。区块链可能会降低两项关键成本：验证和网络成本。前者与以低成本方式验证交易属性的能力有关，而后者与不需要传统中间人的操作能力相关。 即分布式应用，软件/固件更新，可审计，对第三方的隐私保护，降成本 区块链可以处理大多数先前的挑战，区块链充当存储所有已执行交易的分类账。此类交易经过验证（即，根据区块链政策，它们被视为“合法”，因此它们不是恶意的，不会在用户之间造成不一致），然后通过称为完整节点的计算机添加到区块链中，这些计算机遵循共识协议（即，完整节点就是否将信息添加到区块链达成一致）。 在像比特币这样的加密货币的情况下，验证任务由矿工执行，矿工是充当审计每个交易的会计的计算设备。这样的验证过程是必不可少的，因为它为拜占庭将军问题[13]提供了一个分布式的解决方案，它显示了当实体间缺乏信任时，如何在不同的实体（将军）之间达成协议来做某事（战斗计划）。关于区块链技术内部工作的详细描述超出了本文的范围，但感兴趣的读者可以在[14] - [15] [16]中找到关于区块链基础知识的更多信息。 关于区块链在不同领域的应用，最近有一些综述。例如，在[17]中提供了关于将区块链应用于物联网的基础知识的广泛描述。同样，在[18]中详细介绍了为创建和部署基于区块链的IoT应用程序而执行的体系结构和可能的优化。其他文章的重点是区块链应用于特定的工业4.0技术，如大数据[19]，特定行业[20] - [21] [22]或能源效率等[23]。还值得一提的是[24]和[25]中提出的系统，它们分析了文献中提议使用区块链时所涉及的主题。具体而言，[24]中提出的审查重点是确定是否可以采用区块链和P2P来促进分散和私有设计的物联网，而在[25]中，目标是了解研究主题，挑战和未来方向从技术角度看区块链技术。 与前面提到的综述不同，这项工作提出了区块链的综合方法，以便设想其对工业4.0技术革命的潜在贡献，并应对当今的挑战。本文包括以下文稿，这些文章在撰写时尚未在文献中共同发现。首先，分析区块链的开发，部署和优化所涉及的最相关方面，以及区块链可为工业4.0技术带来的优势和实际限制。其次，研究了影响基于区块链的工业4.0应用优化的基本参数的影响。第三，提供了有关工业4.0应用的区块链技术的最新和最相关研究的综述。最后，本文提供了多项建议，目的是指导未来的研究人员和开发人员在部署下一代工业应用程序之前需要解决的一些问题。 本文的其余部分结构如下。第二部分回顾了与基于区块链的工业4.0应用设计相关的不同方面。第三部分详细介绍了针对各种工业4.0技术的最相关的基于区块链的实用应用。第四部分总结了在工业4.0应用中使用区块链时出现的主要挑战。最后，第五节得出结论。 Introduction部分有用内容不多 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:2:0","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"On the Use of Blockchain for Industry 4.0 Applications ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:3:0","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"A. 评估在工业4.0应用中使用区块链的必要性 区块链可以为多个工业领域带来许多好处，它也可以成为工业4.0应用的一个非常有用的工具。但是，区块链并不总是解决每个问题的最佳选择。例如，在私有网络中，传统数据库对许多应用来讲已经足够快速和强大。此外，已经有其他技术与区块链起到同样的作用（即创建一个解决双花问题的无信任分布式网络），这对许多工业4.0应用来说很方便，特别是对于IIoT应用或小额支付。例如，Tangle是有向无环图（DAG）的实现，可用于对不同类型的信息进行建模。Tangle不使用区块，它不需要矿工，提供没有网络费用的高速交易，并且看似拥有无限的可扩展性。IOTA目前是工业领域中最受欢迎的DAG项目。一旦IOTA交易被广播到网络，该节点的两个先前交易必须被批准，并且网络节点将需要确保批准的交易不冲突。在IOTA系统中，需要少量的工作量证明（PoW）来验证其他两个交易，但它可以忽略不计。IOTA的架构（称为Tangle）使其具有高效，可扩展和轻量级的特点。此外，IOTA还可以与区块链进行通信，从而实现区块链之间的协作。事实上，IOTA项目甚至可以用作完成智能合约的实现。然而，Tangle也有缺点： 该技术不像区块链那样经过验证和测试，因为它没有那么多用户和开发人员。 Tangle无法提供真正的DApp功能或图灵完备的解决方案。 它可能不太安全（例如，与区块链的51％攻击界限相比，它的界限是34％）。 IOTA使用协调节点来解决阻碍分布式的同步问题。 私有网络中为什么需要区块链，相比于分布式数据库，公有区块链，DAG都各有什么优势，这决定了一个确定的场景是否需要使用区块链 因此，在决定是否应使用区块链而不是之前提到的替代技术之前，应确定在工业4.0应用中需要的功能。实际上，一些作者提出了确定何时使用区块链的一般框架[26]，但是有一些特定的工业4.0应用的功能需要详细分析 信任 首先，当在应用程序中需要分布式部署时（即，当通过在计算机的P2P网络上而不是在单个机器上运行来增强这种应用时），区块链可能是有用的。并非每种工业4.0技术都需要分布式，但有些技术可能会从中受益，尤其是当存在不受信任的集中式系统时。在某些对特定提供商，银行甚至政府机构都没有信任的行业中会出现这种情况。如果不同实体之间存在信任，则不需要区块链。 支付 必须付款时需要信任。此外，支付系统的存在可用于使许多系统任务自动化，从而加速各方之间的交易。可以通过传统的支付系统进行支付，但它们通常有两个缺点：它们通常涉及比公共区块链更高的交易费用，并且必须几乎盲目地信任它们，而不质疑它们的安全性，道德或内部策略。 审计 信任和透明度也是创建公共交易日志的原因。这些日志包括可以公开暴露的某些带时间戳的信息（即，它可以被与区块链交互的所有实体仔细检查）。一些工业4.0应用严格遵循这种方法，并存储每个执行的交易，以便能够执行审计，保持准确的可追溯性记录或使用大数据技术或预测分析[27] [28]。值得一提的是，这些功能传统上由数据库提供，其安全性至关重要，特别是当它们通过互联网访问并因此公开暴露于对其可用性或数据隐私的攻击时。 通信 工业4.0应用可能需要的另一个相关特征是需要使用P2P通信来在工业过程中涉及的不同方之间交换数据。这在某些IIoT架构中非常常见，这些架构的节点在它们之间协作以检测特定事件或执行任务[29]。重要的是要强调P2P通信并不总是提供通信的最佳替代方案，并且有一些工业4.0开发人员在分析替代通信方法。例如，在资源约束IIoT节点的情况下，由于其功耗和所需资源量，P2P通信通常不能有效地实现。由于这个原因，这种IIoT节点通常使用非P2P协议（如MQTT [30]）或利用雾[31]或边缘计算基础设施[32]通过网关路由其数据。 健壮性 最后，另一个必需的特性是分布式系统应该是健壮的。由于服务器场或云提供了很好的替代方案，因此必须有其他因素来证明区块链的使用是合理的。最常见的原因是对管理基础架构的组织缺乏信任或客户指定的某些隐私要求[33]。这对于关键基础设施[34]，[35]和防御[36]来说至关重要，由于法律和隐私问题（例如，某些防御数据被认为是战略性的，因此被归类），其数据必须通过以下方式存储：值得信赖的服务提供商，特别是在无法保证数据隐私和安全的国家[37]。 考虑到所有以上因素，图3显示了一个流程图，可用作决定何时适合在工业4.0应用程序中使用区块链技术的一般指南。 区块链在工业4.0中使用考虑的关键因素包括：无信任环境，支付，可审计，可扩展性，健壮性 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:3:1","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"B. 用于工业应用的区块链分类 根据访问规则：公有链，私有链，联盟链 根据权限：许可的区块链和非许可的区块链 根据激励类型：基于代币激励的区块链和不依赖代币激励的区块链 根据操作模式：面向逻辑的区块链（以太坊）和面向交易的区块链（比特币） ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:3:2","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"C. 用于工业4.0工厂的智能合约 由于区块链可以帮助实现涉及多家公司的工业流程的自动化（示例将在后面的第III节中给出），因此定义智能合约的概念非常重要：一个执行至少两方之间建立的协议的计算机程序，使得某些操作在满足一系列特定条件时发生。因此，当出现预设条件时，智能合约自动执行相应的条款。以这种方式，可以通过可执行程序将对物理或数字对象的控制转化为法律术语。 智能合约的触发条件基于依赖外部服务的数据，这些外部服务从现实世界获取数据并将其存储到区块链中（反之亦然）。这种服务被称为oracles。例如，oracle可以检查记录以识别资产是否已到达，并且可以在区块链上写入到达信息。然后，智能合约可以基于读取值触发条件语句并执行代码块。 根据收集的信息类型和与外部世界的交互，有不同类型的oracle：软件oracle，硬件oracle，Inbound和outbound oracle，以及基于共识的oracle： 软件oracles处理可用的在线信息。这种信息可以是存储产品的温度，购买部件的价格或与物流过程相关的卡车位置的可追溯性。数据主要来自网络资源，由oracle软件收集，它提取所需的信息并将其推送到智能合约中。 硬件oracle直接从物理世界中提取信息。例如，RFID传感器。这些硬件的最大挑战是在不牺牲数据安全性的情况下报告读数，并保证这些读数与特定的物理过程相对应。 Inbound oracle将来自外部世界的信息（即，来自不与区块链交互的信息源）插入区块链（例如，资产的价格，当其达到期望价格时可以自动购买）。相反，outbound oracle允许智能合约向外界发送信息（例如，当确认正确接收一组部件时，可以自动释放支付资金）。 基于共识的oracle结合不同的oracle来确定事件的结果。例如，像Augur [52]和Gnosis [53]这样的预测市场利用评级系统来确定未来的结果并避免市场操纵。 软件和硬件oracle实际上是数据存储，Inbound和Outbound是与外界交互 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:3:3","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"D. 使用区块链增强其他工业4.0技术的好处 工业4.0应用与加密货币存在某些共性问题，因为它们涉及可能彼此不信任的许多实体（例如，IIoT节点，运营商，机器，供应商，客户）。尽管如此，这些实体在某些方面仍与加密货币不同，例如使用功率受限的设备（例如，IIoT传感器，AR眼镜，电池供电机械），这些设备必须直接与区块链交互（通过实施低功耗区块链客户端）或间接（通过中间网关）。 尽管存在上述差异，工业4.0仍可以从区块链的使用中受益，以解决他们在部署过程中面临的四个主要挑战[54]： 工业4.0工厂必须部署网络才能垂直连接智能生产系统。在智能工厂中，垂直连接是参与产品价值链的两个实体之间的一种连接。因此，当这种连接变得自动化时，可以从工厂中部署的多个系统自动收集信息并将其发送到价值链的任何相关部分（例如，设计团队或制造操作员）。区块链可以通过提供多个智能工厂实体可以与之交互的公共可信数据或货币兑换点来帮助垂直整合。 工业4.0技术也必须水平集成，这意味着制造商，供应商和客户应该合作。这种集成水平涉及低延迟和灵活通信网络的部署，因此区块链和智能合约可能成为工业4.0流程中涉及的实体的横向集成机制，用于执行经济或简单的数据交易。此外，关于客户与公司之间的通信，主要通过使用IIoT设备（例如，智能车辆，智能机械）和社交网络来实现，其安全性是必不可少的，因此它们也可以通过区块链进行交互。 工业4.0智能工厂还需要在整个价值链中动态集成设计和工程阶段。这种整合的目的是快速反应参与价值链的不同参与者所收到的反馈。因此，智能合约可以加速某些官僚任务，区块链可用于执行上述交互。 整合多种技术。工业4.0促进了不同新技术的使用，这些技术将改变运营商之间以及与工作环境相互作用的方式。区块链可以充当信息交换中心，其技术独立的用户只需要实现适当的区块链客户端功能。 使用区块链实现智能工厂垂直整合与水平集成，充当信息交换平台 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:3:4","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"Blockchain-Based Industry 4.0 Application 工业4.0可以从区块链的使用中受益，但其应用目前也在各个方面提出了挑战。这种情况在图4和图5中示出，其中还可以观察到通过使用区块链可以改进技术的一个特征，但是相同的特征可能仍然是另一个的挑战（例如，区块链的实现可能帮助基于云计算的解决方案为其存储需求提供冗余，同时，由于存储和计算限制，这种本地区块链实现目前很难在IIoT节点中复制。因此，当这些技术在工业4.0应用程序中一起使用时，有必要在区块链的使用及其限制之间寻求权衡。 图4还展示了可以通过使用区块链来改进技术的某些特性，但是其他相关特性可能是挑战。例如，基于区块链的IIoT应用可以增加关于某些方面（即，数据可用性和通信安全性）的安全性，但是其他相关方面仍然是挑战（即，数据隐私，数据完整性，身份认证）。为了澄清所有上述的好处和挑战，下一小节将对它们进行分析，并通过一些最具代表性和实用性的基于区块链的工业4.0开发来说明它们 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:0","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"A. IIoT IIoT一词指的是传统物联网（IoT）技术[55] - [56] [57] [58] [59]在工业环境中的使用。因此，它意味着在感知环境中大规模部署具有遥感/驱动能力的工业传感器，执行器和机器[64] - [61] [62] [63] [64]。 区块链可以帮助IIoT系统在信任框架（例如，共享数据分类帐）内的不同处理阶段期间执行分散的交易和信息交换，其中所有交易都被签名和加时间戳[65]。应用的一个例子是基于信用的支付方案，以支持快速和频繁的安全能源交易[66]。其他作者研究了符合IoT标准的区块链可以带来IEEE P1931.1ROOF标准[67]的性能优势。此外，支持区块链的IIoT开发可以： 提高IIoT安全性。基于区块链的应用允许保证特定IIoT设备发布的信息不会被恶意第三方伪造或更改。 公开或半公开访问IIoT数据。这对某些行业来说非常重要，这些行业的某些参与者（例如政府，监管机构，利益相关者）认为透明度是必不可少的，以便信任公司。 保证数据访问。区块链数据在对等体之间分配，因此一个或多个参与者的通信中断不应影响对数据的访问。 提供一种通信机制，其中多个实体和人员通过智能合约以标准和自动方式（例如，没有任何用户交互）进行交互（关于智能合同如何工作的详细分析超出了本文的范围，但感兴趣的读者可以在[17]中找到描述和一些例子。 尽管如此，必须指出的是，区块链与IIoT设备的使用与某些特定挑战有关： 数据隐私。默认情况下，所有IIoT设备都通过其公钥（或其哈希）进行标识，因此在需要时无法保证其匿名性（例如，为了避免向工业竞争对手泄露关键数据）。混合技术可以提高IIoT数据的隐私性，但在某些情况下，它们可以去匿名化[68] 身份认证。值得注意的是，当组织设置身份提供者以授权访问IIoT设备和IIoT生态系统的其他参与者时，此类提供者通常也能够阻止其访问。为了解决这个问题，一些研究人员提出使用许可的区块链，可以管理多个IIoT节点识别[69]，而其他人建议使用多链[48]（其中只有一部分参与者可以监控区块链活动）。 高安全性。一些IIoT设备由于其有限的计算能力或其功率限制而无法实现复杂的安全机制。基于RSA的加密可能不是最适合某些资源约束的IIoT设备，因此应该研究其他非对称加密机制[70]。此外，由于量子计算在打破传统的非对称加密算法方面的进步，应该考虑量子方法[71]。 数据的完整性。对于IIoT系统来说，保证从IIoT设备收集的信息没有被修改是至关重要的，因为不正确或恶意的数据可能会改变工业系统的基本部分。区块链可以提供完整性服务框架，以避免信任第三方[72]，但是这种系统仍然需要发展。 能源效率。由于某些IIoT设备依靠电池来运行，因此必须最小化功耗。然而，区块链通常是耗电的，主要是由于采矿和P2P通信（例如，当使用低效的P2P算法时，边缘设备必须连续通电并执行计算密集的复杂加密操作[73]，[74]）。此外，必须注意的是，尽管可能的能耗优化，当前的资源约束IIoT节点通常无法处理PoW或挖掘任务，因此它们通常依赖于充当区块链代理的中间网关。在采矿方面，已经提出了不同的共识机制来开发比传统PoW方案更环保的替代方案（例如，股权证明，空间证明[75]），但还需要进一步的研究。例如，一些作者已经提出了像迷你区块链[76]这样的替代方案，这有助于减少对等更新的数量，同时降低整个节点的计算要求。值得一提的是，高效散列算法可以帮助延长IIoT设备的电池寿命：尽管由于比特币，SHA-256可能是最流行的散列算法，但最近的替代品如Scrypt [77]或X11 [78]更快，因此他们可能会减少采矿能耗。 吞吐量限制。IIoT系统通常需要每秒管理大量事务，这可能是某些区块链的问题。例如，比特币的原始区块链每秒最多可达7次交易[79]，尽管它可以进行优化以处理更多交易（例如，增加块大小）[80]。因此，在为IIoT部署选择正确的区块链时，吞吐量是必须考虑的基本参数。 交易延迟。值得注意的是，区块链需要一定的时间来处理交易。例如，比特币交易潜伏期遵循泊松分布，平均值为10分钟[7]，但实际上，建议等待大约一个小时来确认交易（这是因为需要五到六个块才能在确认之前添加到链中）。相反，大多数数据库最多需要几秒钟来确认交易。 区块链大小。随着IIoT设备执行交易，区块链不断增长，这意味着使用更强大的矿工。实际上，传统的资源约束IIoT设备甚至无法管理小块链。因此，区块链压缩技术应该与其他方法一起研究，如迷你区块链[76]，[81]。 额外的IIoT基础设施。区块链需要基础设施来支持分散存储和挖掘。这种基础设施已经可以通过使用现成的硬件来实现，但是可能需要特定的专用设备。例如，在专用专用集成电路（ASIC）[82]的开发之前，采矿硬件在过去几年中发展迅速。 IIoT部分是关键，应该是我们可以做的，其它部分都不太了解 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:1","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"B. 垂直与水平集成系统 垂直整合指智能工厂内部各系统如ERP和MES或工厂部门、上下级的整合；水平则是供应商、工厂、用户等供应链上下游的整合。我们对此缺乏了解，或者说，我们关注的应在作为其支持的物联网技术，而不应该偏上层的应用 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:2","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"C. ICPS 工业网络物理系统是一种能够收集，处理和存储数据和交易以控制物理过程的系统。ICPS的不同组件在整个智能工厂中物理分布，其中一些可能在互联网上，这意味着数据处理和分析是分散的[88] - [89] [90]，能够做出真实的决策时间。 由于ICPS的分散性和对数据冗余的需求，区块链似乎是这种系统的良好补充。事实上，一些研究人员已经提出使用区块链作为不同行业ICPS的支柱。例如，在[91]中详细介绍了PCB制造商基于区块链的CPPS的设计。其他作者专注于通过创建信誉系统来提高CPS的可靠性，并为与系统协作的各种实体提供公平的奖励[92]。 此外，其他研究人员提出通过分散它们然后创建ICPS [93]来改进制造过程，以便监控和控制它们。在这种情况下，研究人员指出，ICPS将受益于使用区块链来协调本地实时流程，尽管它们表明在商业部署之前仍然需要解决问题：交易序列化，这会产生性能瓶颈并影响可伸缩性（更多计算节点不一定能够应对更高的工作负载，因为交易需要连续处理）。此外，重要的是要注意基于区块链的ICPS必须处理另外四个限制： 吞吐量和延迟限制。大多数区块链技术需要一定的时间来达成共识并确认交易，许多ICPS中的问题可能是实际或准实时对收集的数据和事件做出反应。 能源效率。许多用ICPS提供数据的系统实际上是可以电池供电的IIoT设备。因此，有必要研究最小化P2P通信和共识算法功耗的区块链技术。 计算能力限制。其数据由ICPS收集的IIoT设备通常在计算能力方面受到限制，因此它们可能无法利用某些加密机制。 存储要求。区块链需要相关的存储量来保留所有交易，对于将数据发送到ICPS的某些资源约束节点而言可能是个问题。 实质上讲，ICPS也是物联网的一个特例，其面对的挑战和IIoT大同小异 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:3","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"D.大数据和数据分析 理想的工业4.0智能工厂从价值链的许多不同来源（例如，来自工厂，供应商，物流提供商或服务提供商）收集大量数据。如此大量的信息确实值得，但其处理需要使用先进的大数据技术。此外，在预测未来需求或即将出现的问题时，数据分析非常有用。 当面临三个主要问题时，区块链可以增强大数据和数据分析[94]：数据收集，数据可信度和自动可靠的数据流通。首先，必须指出的是，在大数据时代，数据来自许多分散的来源。像区块链这样的技术可以帮助建立一个共同的数据共享界面，所有相关方通过这种界面进行交互[95]。 此外，大数据和数据分析都依赖可靠的数据来做出正确的决策。区块链可以通过在相关实体之间建立信任来提高数据可靠性[96]，保护共享数据并提供数据时间戳[19]。 关于数据流通，它与信息在工业4.0生态系统中不断移动的事实有关，并且这些数据的一部分需要业主和接收者的授权才能传播。在这种情况下，智能合约可以真正有用，因为它们能够标准化和自动化数据流通，使其对第三方透明。 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:4","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"E. 工业AR和VR ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:5","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"F. 机器人和车辆的自动化 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:6","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"G. 云计算和边缘计算 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:7","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"H. 添加制造（3D打印） ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:8","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"I. 网络安全 内部和内部连接是工业4.0应用程序中的关键，因此有必要保护涉及此类连接的系统。此外，安全对于工业关键系统至关重要，这些系统在过去几年中一直受到网络攻击的广泛攻击[145]，影响复杂的工业系统和更简单的物理访问系统[146] - [147] [148]。 正如之前的小节中已经提到的那样，由于大多数区块链技术默认使用安全的公钥密码系统和哈希算法，因此数据安全性相对于可选地提供它的其他解决方案得到了增强。此外，私有和财团区块链可以限制用户访问，减少可能的攻击者数量。此外，由于区块链上的数据是分布式的，尽管一个参与者可能受到攻击，但是信息可以通过其他节点获得，从而保证数据可用性。[149]中描述了一个基于区块链的信息共享框架的例子，该框架旨在应对网络安全挑战。 尽管如此，值得注意的是，与其他类型的分布式系统一样，区块链容易受到Sybil攻击[150]，这可能会改变系统的正常行为。此外，区块链可以被一群矿工在他们成为多数时（在小区块链中不难）抵制，由于经济或意识形态原因能够阻止某些交易。因此，尽管区块链技术可以提高工业4.0应用程序的安全性，但它的使用需要一些应该识别和解决的安全问题[151]。 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:9","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"J.仿真软件 工业4.0工厂收集的信息可用于通过使用模拟软件来模拟生产系统中涉及的所有实体（例如，机器，操作员，产品）的行为。这样的软件可以确定工厂现实中的当前状态（这与Digital Twin [152]的概念有关），然后预测未来事件，建议缓解措施以避免问题，或建议改进以降低成本或提高质量。具体而言，区块链技术可通过以下方式帮助模拟软件： 从分布式存储库中的多个源收集数据，由于使用了不同节点提供的冗余信息，因此可以提高其可用性。 验证数据真实性，从而消除部分不确定性。通过这种方式，对某些参数的预测可能会变得更加准确，并使管理者能够在特定时刻更好地了解工厂的状态。 分配计算任务。区块链能够在不同节点之间分配任务和计算，以加速模拟。事实上，像Gridcoin [153]这样的一些加密货币已经提出了以分布式方式解决数学问题的令牌同伴协作的回报。 提供增强的仿真即服务和分散的协同仿真功能[154]。 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:4:10","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"Main Challenges of the Implementation of Blockchain into Industry 4.0 尽管区块链技术带来了诸多好处，但它们在工业4.0应用中的开发和部署却提出了需要进一步研究的重大挑战： 可扩展性。选择用于支持基于区块链的工业4.0应用的体系结构必须能够承受此类应用程序通常生成的大量流量。对于传统的基于集中式云的架构而言，这样的数量可能是一个问题，在过去的几年中，架构已经发展为倾向于提供接近物理需求的最基本服务的架构，就像雾和雾计算一样。架构[29]。 用于资源约束设备的密码系统。在工业4.0工厂中运行的许多设备（例如，传感器，致动器，工具）具有非常有限的计算资源（即，存储器和处理能力），因此它们与现代安全的公钥加密方案斗争[155]。虽然大多数区块链都使用基于椭圆曲线密码术（ECC）的公钥密码系统，但在相同的安全级别[156]进行比较时，它通常比传统的Rivest-Shamir Addleman（RSA）更轻，这样的密码学仍然是电力很饿。此外，需要保持中长期数据安全的行业应该意识到后量子计算的威胁[157]并寻找节能的量子安全算法。 共识算法选择。由于一致性算法对于区块链的正常工作至关重要，因此必须仔细选择。重要的是要注意，没有必要使用最平等（和理想主义）的共识机制，其中包括在投票时给予所有矿工相同的权重，因为在某些区块链（例如，公共区块链）中，机制将容易受到Sybil攻击，然后单个实体将能够控制整个区块链。除了比特币使用的传统PoW共识算法之外，还有其他类似于利益证明，空间证明，活动证明，实用拜占庭容错（PBFT）[158]，Sieve [159]，烧伤证明或人格证明[160]。此外，值得注意的是挖掘虽然在公共区块链中非常有用，但对于每种情况都不是必不可少的，因此协同算法所消耗的计算量和能量可以大大减少 隐私和安全。正如第III-A部分所述，数据隐私，身份认证和数据完整性仍然是需要妥善解决的问题，尤其是对于资源约束设备。 能效，吞吐量和延迟。这些问题之前已经描述过与IIoT和CPS有关，但它们可以外推到其他区块链应用程序。在能源效率的情况下，使用采矿，低效的P2P协议和计算复杂的加密算法会对每种情况下的能耗产生影响，尽管这些因素在使用电池供电设备时至关重要。关于区块链吞吐量和延迟，它们受到共识算法的工作方式以及如何将区块添加到区块链的影响。实际上，这两个因素通常会增加延迟并且在整个方面显着降低，例如，传统的数据库系统，因此可能难以提供对事件的实时响应。 在以太坊的情况下，目前每个节点都必须处理通过网络的每一个事务[161]。尽管如此，通过开发分析[162]等链式解决方案或Raiden [163]和Plasma [164]等非链式解决方案，以太坊正在向可扩展性方面取得稳步进展。分片允许将节点和事务划分为称为分片的较小分区，这些分区具有自己的状态和事务历史记录。因此，某些节点仅处理某些分片的事务，从而允许更高的吞吐量。 与分片不同，Raiden建议使用离线交易来扩展以太坊网络。它是以太坊的比特币闪电网络版本[165]。它允许一组节点建立双向支付渠道，以促进近乎即时，低费用和可扩展的微交易，而无需直接与以太坊区块链进行交易。最近，该解决方案的简化版本称为μRaiden[166]，可以通过单向支付渠道进行微支付。 另一个离线解决方案是Plasma，这是一个强制执行智能合约的框架。Plasma通过允许创建由其父级强制执行的子区块链，创建遵循树级结构的区块链。有三种主要实现最小可行等离子体（MVP），等离子现金和等离子借记。还提出了不同的替代方案来面对以太坊的问题。这就是EOS的情况，它改善了以太坊的交易费用和可扩展性，但由于其更集中的性质，这仍然存在争议。 所需基础设施区块链技术的使用需要部署特定的硬件基础设施，如额外的存储或采矿硬件。此外，P2P通信产生的预计大量数据流量需要能够支持估计负载的通信基础设施和接口 多链管理。区块链的激增可能需要一些公司同时支持其中几个。例如，公司可以使用比特币处理其金融交易，而智能合约则在依赖以太坊的应用程序上执行。因此，必须设计和实施解决方案以同时使用不同的区块链。 互操作性和标准化。目前，大多数公司开发自己的区块链解决方案，但在许多情况下，它们之间的互操作性是必要的，以实现无缝集成。像IEEE这样的一些实体正致力于制定旨在保证各领域互操作性的特定标准。例如，在编写时，IEEE标准协会[167]就区块链推动了两项相关举措：一项与优化临床试验和加强患者安全建立共识，另一项与推动区块链采用推动合作有关在制药行业。 监管和法律方面。除了前面提到的技术挑战外，还必须关注政府和监管机构正在制定的新法规和法律。例如，欧洲联盟于2018年2月启动了区块链观察站和论坛，其主要目标是绘制关键举措，监测发展情况并在欧盟层面制定共同行动[168]。 这些提到的方面都是我们可以做的事情 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:5:0","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["研究生的区块链学习之路"],"content":"Conclusions 工业4.0是一种通过使用一些最新技术改变工厂运作方式的范例。其中一种技术是区块链，它已经成功地用于加密货币，并且可以通过智能合约增加安全性，信任，不变性，非中介化，分散化和更高程度的自动化来增强工业4.0技术。 本文详细介绍了区块链可以为主要的工业4.0技术带来的好处，以及它们当前的挑战。在提供了一种通用方法来确定区块链的使用是否是实施工业4.0应用程序的适当选择之后，研究了针对每种工业4.0技术的最相关的基于工业区块链的应用程序，以及它们的主要挑战。通过这种方式，本文为未来的工业4.0应用程序开发人员提供了指南，以确定区块链如何增强下一代网络固定工业应用程序。 ","date":"2019-05-23","objectID":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/:6:0","tags":["论文笔记"],"title":"A Review on the Application of Blockchain to the Next Generation","uri":"/2019/a-review-on-the-application-of-blockchain-to-the-next-generation/"},{"categories":["爱编程爱技术的孩子"],"content":"本文是 Hugo 使用记录的第二篇，介绍关于文章写作的一些问题，包括分类管理、排版技巧、特殊语法等，所有语法基于 LoveIt 主题。 Hugo支持的文章格式为.md，即用markdown语言编辑的文章。所有的文章都放在content/posts目录下，支持级联目录，即在posts目录下按分类建立多个子文件夹放置文章，比如本博客的文章按分类放在四个子文件夹下。 $ ls posts 爱编程爱技术的孩子/ 我所热爱的生活啊/ 平日里的白日梦/ 研究生的区块链学习之路/ 下面是三条方便清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 保持图片之类的媒体资源存放在 static 目录, 例如: static/images/screenshot.png ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:0:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 前置参数 Hugo 允许在文章内容前面添加 yaml, toml 或者 json 格式的前置参数，LoveIt 默认文章模板提供的前置参数有 ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"tags:[]categories:[]hiddenFromHomePage:falsefeatured_image:\"\"featured_image_preview:\"\"toc:falseautoCollapsemath:truemapbox:accessToken:\"\"lightStyle:\"\"darkStyle:\"\"navigation:truegeolocate:truescale:truefullscreen:truelightgallery:truelinkToMarkdown:trueshare:enable:truecomment:true--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. tags: 文章的标签. categories: 文章所属的类别. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上, 但是此行为可以在 网站配置 中设置的. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. toc: 如果设为 true, 这篇文章会显示右侧目录. autoCollapseToc: 如果设为 true, 文章目录会自动折叠. math: 如果设为 true, 将自动渲染文章中的数学公式. mapbox: 和 网站配置 中的 params.mapbox 对象相同. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. share: 和 网站配置 中的 params.share 对象相同. comment: 如果设为 true, 将启用评论系统. ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:1:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 标签与分类 标签和分类字段是归档文章最常用的两种形式。为了更好的使用，我们需要弄清楚它们的区别。以生活与健身的韦恩图为例1，饮食与睡眠同时属于这两个分类，当出现这类型文章时，就可以添加标签来管理。 博客文章的存储方式决定了它无法拥有太多的分类，因此，树形逐级检索的方法不适用这种情况，我们应当在将博客分为几个大类的同时，使用标签来管理和检索文章，当同样也要注意不应滥用标签，否则会带来视觉上的混乱和管理的不便。 在每篇文章的元数据(Front-Matter字段)中添加categories字段作为文章分类，添加tags字段作为文章标签，比如本文： tags:[博客写作]categories:[爱编程爱技术的孩子] 标签可以有多个，以逗号分隔，不过即使只有一个标签，外面的中括号也不能省略。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:2:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 排版风格规范 本节内容参考少数派写作排版指南2 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:3:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 空格 行文时在中文与英文、中文与数字、英文与数字之间增加空格。例如： 推荐：苹果公司在 2015 年 9 月 9 日发布了 iPhone 6s。 不推荐：苹果公司在2015年9月9日发布了iPhone 6s。 一段文字中有超链接的部分，在超链接的前后使用空格。例如： 推荐：你可以前往 苹果官网 了解详情。 不推荐：你可以前往苹果官网了解详情。 英文前后接全角标点符号或者表示单位的角标符号时，不需要加空格。例如： 正确：新款屏幕的可视角度为 125°，相比旧款提升了 25%。 错误：新款屏幕的可视角度为 125 °，相比旧款提升了 25 %。 对于有特殊用法的专有名词，如 4K、1080p、iOS 10 等，英文和数字之间是否空格以官方标准为准。 每段文字的开头不需要空两格。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:3:1","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 标点符号 引号使用直角引号「」，而不是弯引号 “”。对于微软拼音输入法可以键入uubd四个字母开启标点符号的选择。 省略号使用 …… 的标准用法，正确输入方法是 shift + 6。不要使用三个句号。。。，也不要使用三个英文句点 …。 不要重复使用标点符号，尤其是在表达强烈情感的时候。例如： 推荐：这个提议真棒！我喜欢。 不推荐：这个提议真棒！！！我喜欢~~~~ 同时，抒发情感的方法有很多，不建议在文中大量使用感叹号等表达强烈情感的符号，也不建议使用波浪号。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:3:2","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 中文和西文符号 一般情况下，一个中文句子中出现了英文部分，仍然使用中文标点，即全角符号。例如： 正确：我常用的电子设备是 Kindle、iPad Pro、iPhone。 错误：我常用的电子设备是 Kindle, iPad Pro, iPhone. 如果引用一段完整的英文句子，或是出现在专有名词中的标点，则不需要更改标点符号。例如： 正确：乔布斯说「Stay hungry, Stay foolish.」 错误：乔布斯说「Stay hungry，Stay foolish。」 正确：我最喜欢的手机游戏是 Lifeline: Silent Night。 错误：我最喜欢的手机游戏是 Lifeline：Silent Night。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:3:3","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 专有名词 所有品牌名称以官方网站写法为准，应用名称遵循 Google Play 或 App Store 的命名。若无官方中文名称，可使用网络上被大家熟知的通用译名，否则请直接使用外文名称，不要自行翻译。 请正确书写常用英文名词的大小写和空格。例如： 正确：iOS 10、macOS、App Store、Android 错误：iOS10、MacOS、AppStore、android 若应用名称过长可在文中自定缩写，但需用括号注明缩写名称，并声明「下同」。 一般情况下，品牌和应用名称不需要使用直角引号「」括起来。 在称呼 app 时，请使用「应用」「应用程序」或「app」，而非「软件」「程序」。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:3:4","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"3.5 样式工具 虽然可以使用加粗、斜体、删除线、引用等样式工具，这些工具的使用也可以增加文章的可读性，但是过度使用则会造成排版混乱，因此建议正确、克制地使用样式工具。 例如，需要着重显示的部分请使用「加粗」功能，不要使用「斜体」，更不要使用「加粗 + 斜体」的组合。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:3:5","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"3.6 注明引用来源 文中有使用外站或外部内容的，务必在引用最后部分注明来源。 文中有使用外站图片，必须在文末标明。来源如果来自外站必须添加链接。例如， 本文部分图片来自 The Verge 题图来自电影《春娇与志明》截图 若文章为全文翻译，必须在文中注明原作者及原文地址，并添加原文链接。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:3:6","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"3.7 写作建议 理清文章结构，动笔之前可以先列一下写作大纲。 用主动语态，不要用被动语态。一般情况下，主动语态比被动语态更有力。 使用具体、明确、展示细节的词汇，能激发想象，使读者自己代入情境。「把硬币放进口袋里，他咧开嘴笑了」，远远强过「他满意地拿走了辛苦挣来的奖赏」。 减少形容词的使用，少用 「的」。 文中涉及到参数规格、数据的部分，要保证严谨性。 文章完成之后通读一遍，记住，不要让读者猜测你在讲什么。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:3:7","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 特殊语法 除Markdown基本语法外，灵活运用Hugo提供的一些功能，可以增加文章的灵活性。 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:4:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:4:1","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 脚注 This is a footnote3 Test all features in development4. ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:4:2","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"4.3 字符注音或注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: [Hugo]^(一个开源的静态网站生成工具) ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:4:3","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"4.4 分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:4:4","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"4.5 数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 你可以在 网站配置 中自定义公式块和行内公式的分割符. Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:4:5","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 扩展shortcode 关于shortcode的说明见附录I，LoveIt提供了一些shortcode的扩展语法，下面介绍可能会用到的几种。其它的（包括link、mapbox等）自行查看主题文档介绍 Bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器，如果视频只有一个部分, 则仅需要视频的 av ID, 例如: https://www.bilibili.com/video/av47027633 一个 bilibili 示例: {{\u003c bilibili 47027633 \u003e}} 或者 {{\u003c bilibili av=47027633 \u003e}} 如果视频包含多个部分, 则除了视频的 av ID之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/av36570401?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili 36570401 3 \u003e}} 或者 {{\u003c bilibili av=36570401 p=3 \u003e}} Music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器，有三种使用方式 自定义音乐 URL music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需]：音乐的链接. type [可选]：音乐的名称. artist [可选]：音乐的创作者. cover [可选]：音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"https://rainymood.com/audio1110/0.m4a\" name=rainymood artist=rainymood cover=\"https://rainymood.com/i/badge.jpg\" \u003e}} 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数)：用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数)：[netease, tencent, kugou, xiami, baidu]，音乐平台. type [必需] (第二个位置参数)：[song, playlist, album, search, artist]，音乐类型. id [必需] (第三个位置参数)：歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme *[可选]*音乐播放器的主题色, 默认值是 #448aff. fixed [可选]：是否开启固定模式, 默认值是 false. mini [可选]：是否开启迷你模式, 默认值是 false. autoplay [可选]：是否自动播放音乐, 默认值是 false. volume [可选]：第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选]：是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选]：[all, one, none]，音乐列表的循环模式, 默认值是 none. order [可选]：[list, random]，音乐列表的播放顺序, 默认值是 list. list-folded [可选]：初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选]：音乐列表的最大高度, 默认值是 340px. Typeit typeit shortcode 基于 TypeIt 提供了打字动画，只需将需要打字动画的内容插入 typeit shortcode 中即可。允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:5:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 写作工具 使用Chrome下的插件诸如stackedit与markdown-here等，不用担心平台受限 在线如CSDN、简书、知乎、Github等都支持Markdown写作，现在越来越多的网站都已经开始支持Markdown格式的文章 客户端软件目前使用Typora，其它如VS code、有道云笔记、为知笔记等都支持markdown写作 ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:6:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"附录I Shortcode Hugo写文章的主要格式是Markdown，但是很多高级的语法默认的渲染引擎是不支持的，需要使用纯HTML代码来编写，这和Markdown的本意是违背的。因此Hugo提供了Shortcodes来提供对这些语法的支持。 短代码的调用方法为将代码放在两个大括号和一个尖括号的包围中，代码本身应与两侧尖括号有一个空格分隔。Hugo本身提供了一些Shortcodes（Build-in），但大部分都由于各种原因不能用，可用的两个分别是 Github Gist 和 Figure figure 的文档，一个 figure 示例: {{\u003c figure src=\"/images/theme-documentation-built-in-shortcodes/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/theme-documentation-built-in-shortcodes/lighthouse.jpg\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e gist 的文档，一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:7:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["爱编程爱技术的孩子"],"content":"附录II 书影音页面 因为添加书籍、电影记录过于繁琐，决定删除该页面，相关的代码放在github gist中 活用标签，提高笔记搜索效率 ↩︎ 少数派写作排版指南 ↩︎ This is a footnote ↩︎ https://www.google.com/ ↩︎ ","date":"2019-05-15","objectID":"/2019/hugo-blog-article-write/:8:0","tags":["Hugo"],"title":"hugo搭建个人博客2-文章写作","uri":"/2019/hugo-blog-article-write/"},{"categories":["研究生的区块链学习之路"],"content":"Zhang Y, Kasahara S, Shen Y, et al. Smart contract-based access control for the internet of things[J]. IEEE Internet of Things Journal, 2018. 被引：35次 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:0:0","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 该论文调查了物联网中的访问控制问题。提出了一个基于智能合约的访问控制框架，该框架包括多个访问控制合约（access control contracts, ACCs），一个判决合约(Judge contract, JC)，一个注册合约（register contract, RC），来实现物联网中分布式和可信任的访问控制。每个ACC为一个subject-object提供一个访问控制方法，并通过检测subject行为实现基于预定义策略的静态访问权验证和动态的访问权验证。JC则通过接收来自ACC的恶意行为汇款，进行行为判决并返回相应的处罚策略，从而实现ACCs的动态验证。RC记录ACC和恶意行为判决方法信息，并提供管理这些方法的相关功能，如注册、更新和删除。最后使用一台台式机，一台笔记本，两台树莓派，基于以太坊智能合约实现了该架构。 Section2介绍该论文考虑的物联网系统 Section4介绍基于智能合约的访问控制框架 Section5介绍该框架实验 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:1:0","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction IoT系统可能遭受入侵，导致相关资源（数据、服务、存储单元、计算单元等）的合法权限被获取，访问控制是阻止未授权实体对资源非法访问的主要方式。传统的IoT访问控制方案主要建立在一些著名的访问控制模型上，如RBAC、ABAC和CapBAC。RBAC方案中，访问控制基于组织中主体的角色，通过为角色关联一组访问权限，并将角色分配给主体，可以建立一个主体和访问权限间的多对多关系。ABAC的访问控制基于策略，该策略结合不同类型的属性，如主体属性、客体（实体或实体持有的资源）属性和环境属性等来表示在什么样的情况下可以授予主体权限。CapBAC中基于权能的概念授予主体访问权限，权能是可转让而不可变的权限令牌，为每个主体描述了一组访问权限。 以上的方案中，验证主体的访问权限一般有中央权威进行，存在单点故障问题。分布式 CapBAC被提出解决这一问题，其中访问权限验证由被请求的IoT对象自己来指向而不是中央权威。然而，IoT对象通常能力不足而会被入侵者轻易控制，所以它们无法作为访问权限验证实体被完全信任，因此，分布式CapBAC模型可能无法解决不可信IoT环境下的访问控制。作者提出使用区块链和智能合约来实现用于IoT的分布式和可信的访问控制，本文的访问控制框架由一个注册合约（RC）、一个判决合约（JC）和多个访问控制合约（ACC）组成，其中每个ACC提供一个subject-object对的访问控制方法，并同时实施基于预定义访问策略的静态权限验证和基于检测subject行为的动态权限验证。ACC还提供添加、更新、删除访问控制策略的功能。一旦ACC被调用，它将被区块链系统的所有参与者验证，确保访问控制的可信。为了实施动态验证，JC提供了错误行为判决方法，它接收来自ACC的关于subject的恶意行为报告，进行判决并返回相应的判决结果。为了管理访问控制和恶意行为判决方法，RC可以注册方法的相关信息，提供注册新方法、更新和删除已有方法的功能。 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:2:0","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"System and Security Model ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:3:0","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"A. 物联网系统结构 服务器。与IoT设备/存储设备链接，为用户提供服务。交互方式包括 从传感器收集环境数据， 向执行器发送命令执行某些操作， 从存储设备查询数据或将数据存到存储设备 存储设备。存储对其它各方有用的数据，包括服务器运行数据，传感器收集的环境数据，用户配置文件等。 用户设备。例如PC，Laptop，smart phone，享受服务器提供的服务，如查询当前温度，并可从存储设备读写数据。 IoT网关。连接大量IoT设备，作为它们的代理 IoT设备。感知环境数据发给server/storage device，执行来自用户的命令 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:3:1","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"B. 安全模型 典型的物联网应用中，每个节点都拥有一些其它节点需要的资源（服务、数据、存储空间等）。因此，资源所有者需要实施访问控制阻止未经授权的访问，例如，服务器需要能阻止未注册用户的访问请求，或已注册用户对未订阅服务的请求。未来阻止对存储空间和数据的非法使用，存储设备必须能限制来自未授权节点查询数据或存储数据的请求。IoT设备也必须能拒绝未授权而对其数据的检索或对执行器的控制。 该论文使用下面论文中的访问控制矩阵抽象了访问控制问题。 R. S. Sandhu and P. Samarati, “Access control: Principle and practice,” sIEEE Commun. Mag., vol. 32, no. 9, pp. 40–48, Sep. 1994. 其中，定义希望访问其它节点资源的subject集合S，持有资源的object集合O。每个属于集合O的object(称为o)，都有资源集R0（例如，文件和程序）。每个属于资源集R0的资源r0都与访问权集合Ar0（如读、写、执行）关联。对于每个subject（称s）和给予它的资源r0，构成映射G(s,r0)，该映射属于访问权集合Ar0。 访问控制矩阵只给了一个抽象的定义，该论文中使用访问控制列表实现，列表中每条包括subject，object的资源，subject执行的操作，以及对操作的许可（allow或deny）。主要目的是基于该模型处理物联网中的访问控制问题。 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:3:2","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Access Control Framework ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:4:0","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"A. 智能合约系统 每个ACC实现一对节点的访问控制，JC进行恶意行为判决，RC存储JC和ACCs信息并提供管理合约的功能。如下图所示。 1. ACC ACC由object部署，这个object想要控制来自subject的访问请求，假设一个subject-object对就访问控制方法达成一致，并且每个访问策略由一个ACC实现，则该subject-object对与多个ACCs关联，但一个ACC仅可以和一个subject-object对关联。框架中，为了控制来自subject的访问请求，每个ACC的实施不只是通过检查预定义策略进行的静态访问权验证，而且检查subject行为进行动态验证。 一个ACC例子如下表，每行都是一个确定的（resource, action）对，Permission字段可用于静态验证，ToLR（Time of Last Request）字段可用于动态验证，如subject短时间发起大量请求的恶意行为。 为了记录subject的恶意行为，ACC还维持一个恶意行为列表如下 Misbehavior字段也可能描述恶意行为的细节，便于JC进行判决。ACC还提供一些函数接口如下以便管理策略和实施访问控制 policyAdd() policyUpdate() policyDelete() accessControl()：接受访问控制请求并返回结果和惩罚。 setJC() deleteACC()：自我销毁 只有ACC创建者可以添加新策略，更新和删除已有策略，设置JC和删除ACC。 2. JC JC接收到ACC发来的恶意行为报告是，基于subject的恶意行为历史来基于惩罚，并将判决结果返回ACC。一个JC示例如下，Object是遭受恶意行为的节点： JC还接收misbehaviorJudge()和deleteJC()两个函数接口进行恶意行为报告和自毁。 3. RC RC管理访问控制和恶意行为判断方法。因此，RC维护一个查找表，该表注册所需信息以查找和执行所有方法，查找表示例如下： JC的subject和object字段留空。依据查找表，RC提供以下函数接口 methodRegister() methodUpdate() methodDelete() getContract()：接收MethodName并返回合约地址和和合约ABIs ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:4:1","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"B. 架构主要功能 包括注册、更新和删除访问控制方法；注册和更新恶意行为方法；添加、更新和删除ACC策略，进行访问控制等。基本都是通过调用相应的合约函数实现。 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:4:2","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Case Study ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:5:0","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"A. 软硬件 两台电脑，两套树莓派。电脑作为用户设备，树莓派作为IoT网关。在树莓派间考虑访问控制，一个作为subject，一个作为object。每个设备上都运行geth，并配置所有设备形成私有区块链网络。两台电脑能力较强所以作为矿工。 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:5:1","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"B. 实现 主要是ACC、JC、RC合约逻辑 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:5:2","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"C. 实验 就是进行各种调用查看结果 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:5:3","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"D. 花费与开销 主要考虑了各操作的gas消耗和执行时间。 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:5:4","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Conclusion 本文研究了物联网中的访问控制问题，为此我们提出了一个基于智能合约的架构来实现分布式和可信赖的访问控制。该框架包括用于系统中多个subject - object对的访问控制的多个ACC，一个用于在访问控制期间判断subject的恶意行为的JC，以及一个用于管理ACC和JC的RC。还为物联网系统中的访问控制提供了案例研究，其中包括一台台式计算机，一台笔记本电脑和两台Raspberry Pi。案例研究证明了所提架构在实现物联网分布式和可信赖访问控制方面的可行性 ","date":"2019-05-14","objectID":"/2019/smart-contract-based-access-control-for-the-internet-of-things/:6:0","tags":["论文笔记"],"title":"Smart Contract-Based Access Control for the Internet of Things","uri":"/2019/smart-contract-based-access-control-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Kim H, Lee E A. Authentication and Authorization for the Internet of Things[J]. IT Professional, 2017, 19(5): 27-33. 核心：locally centralized, globally distributed的认证与授权 引入：由2016年DNS服务商Dyn受到的DDoS攻击说明物联网带来的安全挑战。由2015年乌克兰电网受到的攻击说明物联网遭受攻击的后果更具破坏性。这两者反映的是，物联网设备缺乏相应的访问控制机制，导致面对攻击不够健壮。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:0:0","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"认证和授权 授权是确定实体（设备或用户）是否可以访问资源（如，读取或写入数据、执行程序和控制执行器）的过程。还包括拒绝或撤销访问权限，尤其是针对恶意用户或行为。 认证是识别实体的过程，是授权的前提。认证本质上基于信任，比如身份证是基于对国家的信任。现在的网站使用HTTPS协议，这是建立在SSL/TLS上的HTTP。SSL/TLS使用公钥加密进行信道构建，所以，服务器公钥的真实性至关重要。 证书是用于认证的令牌，其中包含服务器公钥。证书由证书颁发机构（CA）办法并进行数字签名。最初的时候，CA为银行网站颁发证书，该证书被浏览器信任。浏览器使用CA的证书验证银行网站的证书，如果验证成功，就信任该网站。所以，公钥基础设施（PKI）就是用于颁发和管理这些证书的一组角色和策略。 有很多方法来实现计算机系统中用于认证的令牌。密码是验证人类用户最常见的方式，为了提高安全性，密码之外，还经常使用手机（what we have）或指纹(what we are)等辅助验证。而在机器到机器的通信中，加密是最有效的提供安全保证的手段。在加密系统中，加密密钥通常用作认证和授权的令牌，因此，很多情况下，认证和授权问题可以归结为生成和管理加密密钥的问题。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:1:0","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"建立信任的方式 建立信任通常从信任根（root of trust）开始。信任根就是一个特殊的实体，是一定可被信任的，比如PKI中的根证书。然后，基于信任根，可以建立更进一步的信任关系。这种信任关系有两种类型，一种是集中式（如下图b），一种是分布式（如下图c）。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:2:0","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"A. 集中式 集中式方案中的证书颁发机构叫可信第三方，代表是基于SSL/TLS的PKI体系。无线传感器网络(WSNs)也使用这种方式，它们使用具有足够资源的基站和电池供电的传感器节点写作。有时，基站也作为传感器节点的信任根，尤其是作为密钥分发器。一个例子是Sensor Network Encryption Protocol(SNEP)，其中传感器节点和基站共享称为“主密钥”的密钥，所有其它密钥基于主密钥生成，换句话说，基于对基站的信任。 集中式的缺陷是证书颁发机构的错误可能导致整个系统的崩溃，一个例子是2016年中国的CA—WoSign的事故。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:2:1","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"B. 分布式 分布式方案中参与者自主协调建立进一步的信任，从而避免中心化的单点故障。电子邮件加密标准OpenPGps也使用证书，但证书由其它受信任用户签名而不是证书颁发机构。比特币系统同样是由网络中其它节点验证。 The Localized Encryption and Authentication Protocol (LEAP+)是基于分布式安全的WSNs的安全协议，其中基站的作用只限于节点初始化等任务，密钥创建和管理由节点自身和相邻节点协作完成。 分布式的方案往往可扩展性更好，但恶意节点过多也更危险。并且，管理和跟踪整个系统也更困难。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:2:2","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"本地集中，全局分布的架构 引入名为Auth的实体进行本地验证和授权，它可以部署在任意类型的边缘设备中，为本地注册的实体（IoT设备）提供授权服务，同时管理全局范围内与其它Auths的信任关系，称为本地集中，全局分布的架构，如下图。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:3:0","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"A. 本地集中 Auth会在本地保留已注册设备的凭据，因为我们希望本地的管理者可以更好地管理Auth和已注册地设备。这种本地的网络粒度根据网络性质而变化，如可以是PAN或车联网。 Auth将在本地注册的实体的凭据和访问策略存在数据库中，授权过程通过分发会话密钥实现，这种会话密钥只对特定访问操作有效。为了支持异构的物联网环境，Auth还可以支持多种底层通信协议，如Wi-Fi和BLE，并通过将相同的会话密钥分发给两个以上实体来支持安全的一对多通信。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:3:1","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"B. 全局分布 当前使用HTTPS在各Auths间通信，访问其它Auths中的注册实体，需要两个Auths合作授权。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:3:2","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"问题和未来的工作 设备初始化注册过程是繁琐且昂贵的，应尽可能自动化或半自动化。另一个问题是移动设备的授权。 ","date":"2019-05-14","objectID":"/2019/authentication-and-authorization-for-the-internet-of-things/:4:0","tags":["论文笔记"],"title":"Authentication and Authorization for the Internet of Things","uri":"/2019/authentication-and-authorization-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Valentin Rakovic， Jovan Karamachoski，Vladimir Atanasovski，Liljana Gavrilovska Published online: 21 March 2019 Wireless Personal Communications (2019) 106:219–235 https://doi.org/10.1007/s11277-019-06270-9 ","date":"2019-05-13","objectID":"/2019/blockchain-paradigm-and-internet-of-things/:0:0","tags":["论文笔记"],"title":"Blockchain Paradigm and Internet of Things","uri":"/2019/blockchain-paradigm-and-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 区块链是在分布式网络中提供隐私和安全的分布式分类账技术，这使得它适用于具有分布式特性的物联网。然而，区块链需要高计算能力，有高带宽开销和延迟，不适合物联网场景，为了将区块链和物联网结合，许多研究旨在开发针对于特定物联网场景需求的区块链方法。本文详细介绍了物联网区块链集成的相关问题，对当前文献和相关部署测试做了全面调查，指出了当前主要的研究和面临的挑战，并讨论了未来可能的研究领域。 ","date":"2019-05-13","objectID":"/2019/blockchain-paradigm-and-internet-of-things/:1:0","tags":["论文笔记"],"title":"Blockchain Paradigm and Internet of Things","uri":"/2019/blockchain-paradigm-and-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction 物联网需要轻量级、可扩展、分布式的安全和隐私保障，区块链技术可以提供解决方案。本文的目的是提供区块链范式的描述，确定其优缺点，并讨论BC-IoT集成的可能方式。论文结构如下： Section2阐述区块链机制和相关概念，因为比较熟悉，跳过不写。 Section3讨论BC-IoT可能的集成及其好处 Section4概述BC-IoT集成当前的方案 Section5阐述未来可能的研究方向 ","date":"2019-05-13","objectID":"/2019/blockchain-paradigm-and-internet-of-things/:2:0","tags":["论文笔记"],"title":"Blockchain Paradigm and Internet of Things","uri":"/2019/blockchain-paradigm-and-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Blockchain and IoT Integration 物联网和区块链结合是一种解决物联网诸多问题的新思路，它能改进的地方包括： 网络元素间的安全通信 点对点结构和对网络认知算法的支持 数据库冗余 数据交换中最高基本的隐私 自动添加新的物联网设备 两者集成的好处总结如下表 Parameter Conventional IoT+BC Trust model Centralized Decentralized Security/Immutabilityi Low High Openness Low High Privacy High High Identities Non-transferable Transfera ","date":"2019-05-13","objectID":"/2019/blockchain-paradigm-and-internet-of-things/:3:0","tags":["论文笔记"],"title":"Blockchain Paradigm and Internet of Things","uri":"/2019/blockchain-paradigm-and-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Ongoing Activities and Potential Use Cases 几方面的问题： 可扩展性：包括几个方面，如与设备数量相关的可扩展性（寻址相关问题），与网络吞吐量相关的可扩展性（关于交易验证的能力），与数据存储能力相关的可扩展性（物联网设备有限的数据存储），与节点的地理分散有关的可扩展性（与延迟和通过网络遍历数据所需的时间有关的限制）。可扩展性性能取决于用例场景、区块链类型的选择、架构设计、数据存储类型和许多其他参数。 公有还是私有区块链的选择 架构：声称应使用完全分布式的架构，该结论由以下论文得出 Liao, C., Bao, S., Cheng, C., \u0026 Chen, K. (2017). On design issues and architectural styles for blockchain-driven iot services. In 2017 IEEE international conference on consumer electronics-Taiwan (ICCE-TW) (pp. 351–352). https://doi.org/10.1109/ICCE-China.2017.7991140. 数据管理和存储：物联网设备的广泛部署将导致IoT网络中的大规模数据流，对大规模数据存储的需求将决定特定场景的架构方案。 Vo, H. T., Kundu, A., \u0026 Mohania, M. K. (2018). Research directions in blockchain data management sand analytics. In EDBT (pp. 445–448). 上面这篇论文中总结了区块链研究中数据管理的主要研究方向，比较了基于区块链的各数据库的优缺点。 数据管理和数据存储优化必须根据场景完成。显然，主流区块链技术针对小数据块的缓慢和不频繁的交易进行了优化。物联网网络正在以高速和高容量生成重复数据。在下面的论文中可以找到潜在的最优解决方案，其中在设计名为Sapphire的新型区块链解决方案时考虑了物联网网络流量特性。尽管寻址基于位置和类型相关的散列函数，但数据在基于位置和基于类型的基础上进行划分。根据处理和存储能力，定义三种类型的节点以便为网络中的所有参与者提供支持。一个数据分类器管理网络中的数据类型和存储位置。这种架构具有更好的可管理性，在过载节点中的数据平衡以及更容易的数据分析。 Xu, Q., Aung, K. M. M., Zhu, Y., \u0026 Yong, K. L. (2018). A blockchain-based storage system for data analytics in the internet of things (pp. 119–138). Cham: Springer 软件定义：伴随最佳架构选择的，是所部署网络管理的复杂性。集中式的管理很麻烦，尤其是在软件版本和配置版本控制方面。软件定义物联网（SDIoT）的分布式网络设计和实现，使物联网网络具有增强的网络管理方法。公共可用版本控制系统的存在将增强节点的安全性和网络的稳定性。在论文[26-29]中，作者提出了基于区块链技术的软件版本控制机制，它将使物联网网络保持最新。网络的稳定性本质上是基于bug修复和正确的固件更新。此外，软件版本和配置版本在物联网网络中的可验证性将增强SD-IoT网络的安全性。通过定义，软件定义网络提出了两种平面抽象，将流量划分为：数据和控制平面流量。尽管可以利用节点的有效性，但是可以虚拟化由IoT设备生成的数据平面或数据资源。通过区块链技术对SD-IoT进行虚拟资源管理在[30]中进行了描述，并得到了实验结果的支持。Blockchain也被用于尖端的无线概念，如多接入边缘计算（MEC）和分层架构[31] [30] Azzar, A., \u0026 Mottola, L. (2015). Virtual resources for the internet of things. In 2015 IEEE 2nd world forum on internet of things (WF-IoT) (pp. 245–250). https://doi.org/10.1109/WFIoT.2015.7389060. 机器学习方面 访问控制：访问控制，身份认证和授权的过程将从第三方集中式服务器解决方案移至基于自治智能合约的解决方案。从根本上说，调用智能合约可以授予用户访问权限，并授权物联网设备使用网络中的资源。有关使用区块链技术以协调访问管理的解决方案见[36-40]。在论文中，我们可以看到一些成功的概念验证的实验结果。最简单的解决方案是允许资源受限的物联网设备控制所收集或拥有的数据，但对于能够实施分析算法的能力更强的物联网设备，可以增强访问控制机制。在[41]中，作者正在引入风险评估机制进行实时流量分析，以确定潜在的恶意或故障的物联网节点并动态调整访问权限。动态访问控制的过程也可以在[42]中找到。该解决方案可以通过使用在代理节点中实现的机器学习算法来确定安全风险，并相应地动态地修改访问凭证。 安全：除了访问控制之外，还可以通过在物联网网络中集成区块链技术来解决其他与安全和隐私相关的问题。在[43]中，作者介绍了物联网设备安全方面调查的结果。该论文对最有名的物联网攻击进行了扩展分析，并参考了已有文献中提到的最常用的解决方案。此外，在该文中，我们可以初步想到在保护物联网网络的过程中实施区块链技术。作者提议在保护设备间通信的过程中使用区块链技术，增强认证和授权程序，隐私保护以及身份和地址管理。整个物联网网络的保护可以通过防止安全性降低或减轻网络攻击来进一步发挥作用。[44]中提出的解决方案为SDN网络提供了架构，能够在大型网络中的ARP欺骗和DDoS / DoS攻击中实现威胁防御和攻击缓解。除了以前定义的协议之外，在[45]中，作者还提出了使用区块链技术保护物联网网络的过程，并且正在进一步分析某些攻击下的物联网网络状况。物联网网络的安全性和隐私性在许多领域都是必不可少的，以下论文在医疗保健[46-48]，智能家居[49,50]，智能车辆情景[51,52]和智能电网[53]中提供解决方案和概念验证 ","date":"2019-05-13","objectID":"/2019/blockchain-paradigm-and-internet-of-things/:4:0","tags":["论文笔记"],"title":"Blockchain Paradigm and Internet of Things","uri":"/2019/blockchain-paradigm-and-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Open Issues and Future Directions 交易速率：对于许多物联网场景非常重要，例如V2x通信或工业4.0。当前的区块链解决方案依赖于相对冗长的验证周期，导致执行的交易的整体延迟。未来的方向应包括开发新的共识算法，这些算法将提供实时决策，同时仍然保留所需的安全性。一种可能的方案是部署分层区块链结构，这可以提高数据交换率并减少系统中的总体延迟。 能源效率：由于潜在的挖矿过程，大多数当前的区块链解决方案依赖于繁重的计算处理。这最终会导致网络部署具有显着的能耗。然而，物联网需要自我可持续性和高能效，需要引入新的挖矿和共识概念，这些概念更具能量效率并且更适合轻量级操作。 处理（存储）能力：未来的研究应侧重于开发分布式数据存储的新方法，其中每个设备只能存储链中的部分信息。另一种选择是引入具有完全挖矿能力和足够存储容量的可信节点，其中IoT设备将存储数据或将检查交换数据的有效性。在此设置中，IoT设备只能存储最后一个块或存储关于完整链的压缩信息。但是，这些解决方案可能会在延迟，安全性，能源效率等方面对整体网络性能产生影响 人类因素：目前，一小部分专家和工程师完全了解区块链技术是如何运作的。添加异构和多样化的物联网生态系统会导致整个系统架构变得模糊且非常复杂。此外，区块链代表了一种新技术，没有任何法律或合规性代码可以遵循，这对制造商和服务提供商来说是一个严重的问题。仅此问题就会对物联网中区块链的实际实施和部署带来重大限制。标准化和监管机构必须迅速采取行动，为统一的法律和技术框架铺平道路，这将促进新技术的发展并开辟新的商业机会。 ","date":"2019-05-13","objectID":"/2019/blockchain-paradigm-and-internet-of-things/:5:0","tags":["论文笔记"],"title":"Blockchain Paradigm and Internet of Things","uri":"/2019/blockchain-paradigm-and-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Conclusions 区块链技术在物联网领域的潜在整合将促进多个行业的重大转变，促进新的商业模式和机遇。区块链代表了一种引发许多技术挑战的新技术。将其与多功能和复杂的生态系统（如物联网）相结合，会触发许多未解决的问题，这些问题必须在商业推广和部署之前解决。 ","date":"2019-05-13","objectID":"/2019/blockchain-paradigm-and-internet-of-things/:6:0","tags":["论文笔记"],"title":"Blockchain Paradigm and Internet of Things","uri":"/2019/blockchain-paradigm-and-internet-of-things/"},{"categories":["爱编程爱技术的孩子"],"content":"Hugo 是由 Go 语言实现的静态网站生成器，可以快速建立一个静态网站，虽然多数情况下用来搭建个人博客，但也可以用作展示在线书籍、个人简历等。在使用 Hugo 之前，我一直使用 Hexo 搭建个人博客，促使我更换工具的原因主要有两个 文章数量较多时，Hexo 生成速度非常慢，同样的文章数量下，Hugo 渲染文章几乎是即时的； Hexo 依赖于 Node.js，使用需要在电脑里安装 node 和 npm。另外，Hexo 允许开发者提供各种 npm 模块来增强其功能，这种做法虽然使 Hexo 扩展性极高，但在博客的维护、备份和恢复等方面都带来了极大的不便。Hugo 使用 Go 开发，不依赖任何其它模块，只需要按照 Hugo 这一个软件即可。 综上，我选择将博客网站迁移到 Hugo，这个系列的文章用来记录 Hugo 使用种遇到的问题和积累的经验。本文是第一篇，介绍博客网站搭建的过程和一些基础配置。 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:0:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 安装Hugo 详细的安装说明参见官方文档，这里简单介绍 win10 和 Ubuntu18.04 的快速安装。 win10下可自行从官网下载软件包安装，也可以使用 chocolatey 包管理工具快速安装 # 更新chocolatey到最新 \u003e choco upgrade chocolatey # 安装hugo-extended，因为将要使用的主题使用scss \u003e choco install hugo-extended -y # 检查安装 \u003e choco list --local chocolatey 0.10.15 hugo-extended 0.58.3 2 packages installed. Ubuntu下使用 apt-get 会安装低版本 Hugo，因此使用 snap 安装 $ snap install hugo --channel=extended hugo (extended/stable) 0.58.3 from Hugo Authors installed 注意要安装 extended 版本，主要是因为很多主题都需要扩展版的功能，如果确认自己的主题不需要(阅读主题说明)，可以按照正常的版本。 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:1:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 生成博客网站 执行下面的命令在本地生成博客网站项目文件夹，该文件夹是这一系列文章之后所有操作执行的根目录(简称为项目根目录)，我建立的项目文件夹名为 shuzang.github.io （因为之后要使用 Github Pages 托管博客）。 $ hugo new site shuzang.github.io $ cd shuzang.github.io blog 文件夹的目录结构如下所示，其中各文件夹的作用我们将在之后的使用过程中逐步了解 $ ls archetypes/ config.toml content/ data/ layouts/ static/ themes/ ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:2:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 托管到Github 将本地的项目文件夹初始化为 Github 仓库 $ git init $ git add . $ git commit -m \"Initial commit\" 浏览器打开 Github 网站，创建和项目文件夹同名的仓库，该仓库用于存储项目文件夹下所有内容。创建完成后，在本地项目根目录，执行下列命令，将项目文件推送到远程仓库。 $ git remote add origin https://github.com/shuzang/shuzang.github.io.git $ git push -u origin master 关于网页如何托管在Github的详细说明可以参考Host on Github ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:3:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 源码备份 按照 Hugo 的生成规则，执行 hugo 命令后，网站静态文件将会生成在 public 文件夹。但由于我们使用 Github Pages 托管博客网站，该功能启用后 Github 仓库只会从 master branch 或 master branch /docs folder 读取网站源码。 我们解决这一问题的方法是新建 blog 分支将博客源码放在该分支下，利用 Github Action 将 public 目录下的网站文件推送到 master 分支。首先在本地项目根目录下执行下列命令新建并切换到 blog 分支 注：Github Action 的说明见附录I $ git checkout -b blog $ git branch * blog master # 设置本地blog分支追踪远程blog分支 $ git branch --set-upstream blog origin/blog # 查看分支跟踪关系 $ git branch -vv * blog c63526c [origin/blog] Update posts 将本地 blog 分支的内容推送到远程仓库后，在网页端进入shuzang.github.io仓库的设置页面，将默认分支设置为 blog 分支。 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:3:1","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 推送到master分支 首先生成公私钥供 Github Action 使用 ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f blog -N \"\" # You will get 2 files in current file: # blog.pub (public key) # blog (private key) 然后进入 shuzang.github.io 仓库设置页面，在 Deploy Keys 中添加公钥，在 Secrets 中添加私钥，私钥名设置为 ACTIONS_DEPLOY_KEY 接着新建 YAML 配置文件，Github Action 要求配置文件位于 .github/workflows 目录下，新建完成后目录结构如下 $ ls ./.github/workflows main.yml Github Action使用一种模块化的思路，即将很多持续集成的操作写成独立的脚本文件，放到代码仓库，让其它开发者使用。因此进行持续集成时，可以直接引用别人写好的 action，整个持续集成的过程，就是一个 actions 组合的过程。GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 我们的基本思路如下 整个流程在 blog 分支 push 时触发 只有一个job，运行在ubuntu-18.04环境下 使用 official action: checkout 获取仓库源码，注意添加参数clone主题子模块 使用 peaceiris/actions-hugo: GitHub Actions for Hugo 部署 hugo 环境，注意使用 extentded 版本（主题要求） 直接执行 hugo 命令 使用 peaceiris/actions-gh-pages 将当前分支public目录下的内容部署到master分支， 完整的main.yml脚本内容如下 name:hugopushtogithubpageson:push:branches:- blogjobs:build-deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v1with:submodules:true- name:SetupHugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.59.1'extended:true- name:Buildrun:hugo--minify- name:Deployuses:peaceiris/actions-gh-pages@v2env:ACTIONS_DEPLOY_KEY:${{secrets.ACTIONS_DEPLOY_KEY}}PUBLISH_BRANCH:masterPUBLISH_DIR:./public 保存上面的文件后，将本地仓库推送到远程，Github 检测到 .github/workflow 目录和里面的main.yml 文件，就会自动运行，在网页端可以查看运行日志，如果出现错误可以根据日志内容就行修改。 等到workflow运行结束，访问博客页面，就可以看到更新成功了。切换到master分支，也可以看到推送的网页文件，不过因为设置了默认分支为 blog，以后打开网页端该仓库，以及在本地 clone的时候，默认都是 blog 分支。 注：Github Action 在2020年开始正式使用，之前一直使用 Travis CI，配置步骤见 附录II ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:3:2","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 安装主题 Hugo没有默认主题，需要自己从官方的主题列表下载安装。总体来看，Hugo 主题的数量和质量可能都不如 Hexo，比如 Next 这种主题已经形成了庞大的开发社区，有大量的人在使用和维护，Hugo 中就没有这种影响力很大的主题了，但 Hugo 的主题的创意都非常棒。 KeepIt 是其中一个较为简单优雅的主题，基于 LeaveIt 主题二次开发而成，遵循「Less is more」的原则，是我最喜欢的主题。因为主题通常是单独的 Github 仓库，因此将其作为博客项目的子模块进行管理。 # 将主题项目作为子模块添加 $ git submodule add https://github.com/Fastbyte01/KeepIt.git themes/KeepIt # 查看子模块信息 $ git submodule 87c33888f3fa86b8cc096bc3f6d7f2efe9ccba66 themes/KeepIt (v4-53-g87c3388) 复制主题提供的站点配置文件 config.toml 到项目根目录，覆盖 Hugo 本身的站点配置文件（第一次使用可以将exampleSite目录下的内容全部复制过来） $ cp themes/KeepIt/exampleSite/. . 运行hugo server命令，在浏览器键入网址 http://localhost:1313 预览主题效果（首页图片未加载是因为还没有放置头像文件） ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:4:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 网站配置 正式使用前，我们需要编辑站点配置文件从而设置网站的一些内容，通常配置文件或主题文档会进行详细的说明，当前我们对 config.toml 文件做如下配置 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:5:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 基础配置 baseURL = \"https://shuzang.github.io\" languageCode = \"en\" defaultContentLanguage = \"en\" title = \"Shuzang's blog\" theme = \"KeepIt\" paginate = 12 enableEmoji = true enableRobotsTXT = true googleAnalytics = \"\" disqusShortname = \"yourdiscussshortname\" [sitemap] changefreq = \"monthly\" filename = \"sitemap.xml\" priority = 0.5 [blackfriday] hrefTargetBlank = true nofollowLinks = true noreferrerLinks = true [Permalinks] posts = \"/:year/:filename/\" [menu] [[menu.main]] name = \"Blog\" url = \"/posts/\" weight = 1 [[menu.main]] name = \"Categories\" url = \"/categories/\" weight = 3 [[menu.main]] name = \"About\" url = \"/about\" weight = 4 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:5:1","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 头像 新建static/images文件夹，将头像文件存放在这里 $ mkdir static/images # 复制头像文件到images文件夹,复制完成后目录结构如下 $ ls staitc -lR static: total 0 drwxr-xr-x 1 书藏 197610 0 11月 17 14:41 images/ static/images: total 88 -rw-r--r-- 1 书藏 197610 87641 9月 28 18:21 avatar.png 修改站点配置文件params部分的avatar字段值 [params] avatar = \"images/avatar.png\" #comment it to use gravatar 也可以使用自己图床中的头像图片链接，或者如果有gravatar头像，可以在配置文件中寻找相关字段填写账号。 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:5:2","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"5.3 首页社交链接 修改站点配置文件中params.social部分的内容，需要的社交链接取消注释即可启用，比如我只启用了Github和Email，Github只需要填用户名，完整的URL在主题源码中自动生成。 [params.social] GitHub = \"/shuzang\" Email = \"xxxxx@qq.com\" ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:5:3","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"5.4 网站基本资料 编辑站点配置文件的以下内容 title = \"shuzang's blog\" # 网站标题 [params] since = 2018 # 站点建立时间 author = \"shuzang\" # 作者名 subtitle = \"世界钟爱热爱生活的人\" # 子标题 home_mode = \"\" # post or other # post模式会在主页面显示文章 description = \"shuzang的个人博客\" # 网站描述 keywords = \"blog, Golang, Hugo, blockchain \" # 网站关键词 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:5:4","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"5.5 网站图标 使用 favicon generator 生成配套的网站图标，放到 /static 目录下，可以设置网站在各平台的显示图标，包括如下内容 android-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png browserconfig.xml cover.png favicon.ico favicon-16x16.png favicon-32x32.png logo.png mstile-150x150.png safari-pinned-tab.svg site.webmanifest 然后修改站点配置文件中以下内容 [author] name = \"shuzang\" [params.publisher] name = \"shuzang\" [params.publisher.logo] url = \"logo.png\" width = 127 height = 40 [params.logo] url = \"logo.png\" width = 127 height = 40 [params.image] url = \"cover.png\" width = 800 height = 600 更多配置可以参考Mogeko的个人博客 以上所有配置完成后，博客网站首页如下 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:5:5","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 文章发布 在content目录下创建 posts文件夹，写作的文章全部放到该目录下，在每篇文章开头添加元数据字段，可以是YAML或TOML格式，示例如下 title = \"Getting Started with Hugo\" description = \"\" type = [\"posts\",\"post\"] tags = [ \"go\", \"golang\", \"hugo\", \"development\", ] date = \"2014-04-02\" categories = [ \"Development\", \"golang\", ] series = [\"Hugo 101\"] [ author ] name = \"Hugo Authors\" 下面是一篇示例文章 --- title: Markdown说明 date: 2020-04-05 tags: [\"Markdown\"] categories: [\"爱编程爱技术的孩子\"] --- Markdown由Aaron Swartz和John Gruber共同设计 - Aaron Swartz的博客：[http://www.aaronsw.com/](http://www.aaronsw.com/) - John Gruber的博客： [https://daringfireball.net/ ](https://daringfireball.net/ ) 作者中的Aaron Swartz是天才程序员，著名社交网站[Reddit](http://www.reddit.com/)的联合创始人，14岁参与RSS 1.0规格标准的制订，致力于网络信息开放。在2011年7月19日，因被指控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕，2013年1月自杀身亡，年仅26岁。 文章保持后将仓库新增内容推送到远程，几分钟后即可在 https://shuzang.github.io 看的这篇文章 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:6:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 主题迁移 随着使用时间的增加，逐渐意识到某些功能的必不可少，比如目录、数学公式支持等。KeepIt 主题已经停止了更新，好在在KeepIt的基础上重构设计的 LoveIt 主题，解决了大部分我关心的问题。这里借此介绍如何更换主题。 首先删除原来的主题子模块 $ git submodule deinit themes/LoveIt $ git rm themes/LoveIt 然后添加新的主题作为子模块并重新配置 config.toml 文件 $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 具体的配置可以参考主题文档，一个参考配置如下 title = \"Shuzang's Blog\" # 设置网站标题 theme = \"LoveIt\" # 设置主题为LoveIt hasCJKLanguage = true # 启用对中文统计的支持，不启用字数统计会出问题 paginate = 10 # 每页的文章数量设置为10，便于根据页数快速计算总文章数 # 作者名设置 [author] name = \"shuzang\" # 菜单栏新添life页面并调整顺序 [menu] [[menu.main]] identifier = \"posts\" name = \"Posts\" url = \"posts\" weight = 1 [[menu.main]] identifier = \"categories\" name = \"Categories\" url = \"categories\" weight = 2 [[menu.main]] identifier = \"tags\" name = \"Tags\" url = \"tags\" weight = 3 [[menu.main]] identifier = \"life\" name = \"Life\" url = \"life\" weight = 4 [[menu.main]] identifier = \"about\" name = \"About\" url = \"about\" weight = 5 # 基本参数设置，包括网站描述字段、关键词、主页文章显示模式、子标题 [params] description = \"shuzang's personal blog\" # site description keywords = [\"blog\", \"Golang\", \"Hugo\", \"blockchain\", \"go\", \"life\"] # site keywords home_mode = \"other\" # [post, other] home mode subtitle = \"The world loves people who love life\" # subtitle shown in home page #头像、主页社交链接 [params.gravatar] email = \"lylw1996@qq.com\" [params.social] # Social Info in home page GitHub = \"shuzang\" Email = \"lylw1996@qq.com\" Steam = \"76561198343669932\" Skype = \"live:844327696\" # gitalk设置涉及clientId和clientSecret，忽略 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:7:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"附录I Github Action GitHub Actions 是 GitHub 在2018年10月推出的一个持续集成服务，之前一直是试用阶段，去年(2019年)年末刚刚开放，据说比Travis CI 更简单更好用，所以打算把持续集成工具切换到它。同时，之前博客部署使用了两个仓库，一个放源码，一个放生成的网页文件，目前来看可以统一成一个。本篇文章就打算做这两件事。 Github Actions入门可以阅读官方文档或者阮一峰大神的GitHub Actions 入门教程 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:8:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"附录II 使用Travis CI 通过Travis CI做博客的持续集成，可以每次自动渲染生成新的博客网页并推送到shuzang.github.io仓库，从而实现调整域名的目的。但之前尝试了多次持续集成都没有成功，还把博客搞坏了，最终只能重建网站。这一次发现了之前存在的问题，终于成功了。 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:9:0","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"步骤1 申请Token 在GitHub 上申请一个新的 personal access token。 Token description 随便填，只要之后查看的时候知道是博客的就行。勾选所有 repo 列表项目，其它项目不要选。点击 Generate token 生成Token。 之后跳转的页面会显示Token的值，一定要记下来，因为离开这个页面之后这个值就再也无法查看。我因为已经做过一次了，这里就只查看一下。 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:9:1","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"步骤2 设置Travis CI Travis CI是一个持续集成的工具，使用GitHub账号登陆，然后开启 blog 仓库，选择 setting。 在设置页面填写Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 填写完成后点击Add添加 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:9:2","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"步骤3 编写配置文件 在博客根目录下创建并编辑.travis.yml文件，该文件的作用是告诉Travis CI如何部署博客 $ ls -al blog total 30 drwxr-xr-x 1 书葬 197610 0 9月 29 20:28 ./ drwxr-xr-x 1 书葬 197610 0 9月 28 18:20 ../ drwxr-xr-x 1 书葬 197610 0 9月 29 20:28 .git/ -rw-r--r-- 1 书葬 197610 101 9月 28 18:21 .gitmodules -rw-r--r-- 1 书葬 197610 1810 9月 29 20:10 .travis.yml drwxr-xr-x 1 书葬 197610 0 9月 28 18:21 archetypes/ -rw-r--r-- 1 书葬 197610 4946 9月 29 18:27 config.toml drwxr-xr-x 1 书葬 197610 0 9月 28 18:24 content/ drwxr-xr-x 1 书葬 197610 0 9月 29 18:56 docs/ -rw-r--r-- 1 书葬 197610 456 9月 29 20:28 README.md drwxr-xr-x 1 书葬 197610 0 9月 28 18:21 resources/ drwxr-xr-x 1 书葬 197610 0 9月 28 18:21 static/ drwxr-xr-x 1 书葬 197610 0 9月 28 18:21 themes/ 文件内容如下 language:gogo:- \"1.12\"# 指定Golang 1.12dist:bionic# Ubuntu 18.04env:global:# Github Pages- GH_REF:github.com/shuzang/shuzang.github.io# Specify which branches to build using a safelist# 分支白名单限制：只有 master 分支的提交才会触发构建# branches:# only:# - masterbefore_install:# 安装依赖# - wget -q -O libstdc++6.deb http://security.ubuntu.com/ubuntu/pool/main/g/gcc-5/libstdc++6_5.4.0-6ubuntu1~16.04.10_amd64.deb# - sudo dpkg --force-all -i libstdc++6.deb# 删除docs文件夹- rm-rf./docs# 安装 hugo （version: v0.58.0）- wget-q-Ohugo.debhttps://github.com/gohugoio/hugo/releases/download/v0.58.3/hugo_extended_0.58.3_Linux-64bit.deb- sudodpkg-ihugo.debinstall:# 运行hugo命令- hugoscript:- cd./docs- gitinit- gitconfiguser.name\"shuzang\"- gitconfiguser.email\"lylw1996@qq.com\"- gitadd.- gitcommit-m\"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- gitpush--force--quiet\"https://$GITHUB_TOKEN@${GH_REF}\"master:master 大部分都有注释说明，这里要注意的两点是 在运行 hugo 命令前要先删除docs文件夹，是为了清除历史网页文件，这是Hugo官方建议的 注释掉了常规 Github pages 进行持续集成时使用的 deploy 部分，因为我们只需要单纯的把网页文件提交到另一个仓库。只有当普通的项目启用github pages时需要这部分，这里的博客部署不需要，开启deploy部分反而会出现错误，目前不知道原因。 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:9:3","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"步骤4 使用说明 大部分工作都通过Travis CI自动进行了，以后提交只需要在改动之后直接git push到远程仓库，将会触发自动构建，只需要一两分钟，就可以在Travis CI 上查看部署情况。 绿色 代表部署成功 黄色 代表正在部署 红色 代表部署失败 灰色 代表部署被取消 然后访问博客首页，不出意外就可以看到新的改动了。如果部署失败，在网页端的日志记录中找到失败原因，然后修改代码重新提交即可，新的提交通过后，原先失败的提交将会被解决。 ","date":"2019-04-26","objectID":"/2019/hugo-blog-build-personal-blog/:9:4","tags":["Hugo"],"title":"hugo搭建个人博客1-基础建站","uri":"/2019/hugo-blog-build-personal-blog/"},{"categories":["平日里的白日梦"],"content":"一开始看到这本书的时候，我以为这是一本关于梦想的书，就像是《白日梦想家》那样，描述一个人在即将去世前鼓起勇气去完成自己生命清单的事。但是我错了，这本书是一个关于爱的故事，故事的主人公布雷特通过已逝母亲安排的目标，克服心理和生理等方面的困难，找寻爱情、亲情、友情，学着和自然界万物和谐相处，找寻到了真正的自己。 读一本书，体验一段人生。当我读完这本书的时候，蓦然发现已经配布雷特走过来一段多么重要的日子。我还记得布雷特刚经历母亲去世，失去公司，刚得到清单是的颓废和难以接受，记得在舞台上作脱口秀的窘迫，记得在爱情里的挣扎，记得寻找父亲的艰辛，记得从初为老师到游刃有余的过程，记得为了狗寻找房子的过程，记得那个叛逆的男孩彼得，记得寻找同年伙伴卡丽的愧疚与幸福，记得和赛昆塔的一切，记得小小的奥斯汀·伊丽莎白，然后就到了最后，拥有了爱情、亲情、友情，找回了善良的自己，和善的面对世界。也许我都不知道我能列出这么多刻在我脑海深处的事情，两周六个小时的阅读，布雷特一年的旅程，带给我的不只是记忆，还有对爱的理解。 ","date":"2019-04-25","objectID":"/2019/%E7%94%9F%E5%91%BD%E6%B8%85%E5%8D%95/:0:0","tags":["读书笔记"],"title":"生命清单","uri":"/2019/%E7%94%9F%E5%91%BD%E6%B8%85%E5%8D%95/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Guo-Jian Cheng, Li-Ting Liu, Xin-Jian Qiang, Ye Liu Published in：2016 International Conference on Information System and Artificial Intelligence (ISAI) Conference Location：Hong Kong, China Cited times：30 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:0:0","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 过去几年，工业和信息技术领域经历了深刻的变革，进入了工业4.0时代，将从嵌入式系统演变到网络物理系统（CPS）。制造业将通过互联网，整合内部和外部网络，朝着智能化方向发展。本文介绍工业4.0的发展，并以120的智慧信息技术（WIT120）为例介绍网络物理系统，然后通过数字工厂到智能工厂的例子介绍工业4.0在智能制造中的应用。最后分析工业4.0在未来的发展方向，为其在智能制造中的应用提供参考。 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:1:0","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction 互联网和工业的融合，能使制造业拥有对大规模数据收集、传输和处理的能力。工业4.0由德国人提出，实质是“互联网+制造业”，描述了制造业的未来—建立在互联网和基于信息技术的交互平台上，科学地整合越来越多的生产要素，变得更加自动化、网络化和智能化，个性化和定制化的制造将成为新常态。 2015年中国发布“中国制造2025” ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:2:0","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"Industry 4.0 工业4.0实质是基于CPS来实现智能工厂，其核心是生产的动态配置，指在生产之前或生产过程中能随时改变原始设计。在工业4.0的智能工厂中，固定生产线的概念已经消失，而是动态的模块化生产。 工业4.0有几个主要特性：互联、数据、集成和创新。此外，工业4.0的九大支柱技术包括：虚拟现实，人工智能，工业互联网，工业大数据，工业机器人，3D打印，云计算，知识工作自动化和工业网络安全。在未来，这九大支柱将生成大量的商业机会。 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:3:0","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"Cyber Physical System 工业4.0的核心是CPS的深度集成，CPS将虚拟空间和物理现实相连接，集成了计算、通信和存储，可以实时、可靠、安全、稳定和高效地运行。CPS地核心概念是3C，computation, communication和control，为了增加或扩展新功能，提供实时感知、动态控制和信息反馈等，通过计算过程和物理过程交互的反馈循环来实现现实世界和信息世界地协作和实时交互。下图是CPS 3C的协作过程。 CPS的应用非常丰富，通过智能设备获取现实物体的客观信息，对信息分析和智能处理的感知，以及特定应用业务逻辑的通信对象交互。例如，WIT120以“感知、知识、操作”为中心，完成了现实世界和信息世界的实时互操作。基于物联网技术，大量传感器被用于追踪实时的生命体征数据，并通过无线网络技术将其传输到医疗数据中心并建立电子文件。利用大规模的数据存储和处理平台，应用数据挖掘和知识发现理论对医学史数据进行建模和分析。它将通过云服务分析提供给医务人员实时追踪和历史数据作为参考治疗，或者为最终用户直接提供医疗护理计划。它使用CPS的相关技术建立了病人与医疗机构间的桥梁，逐步实现了信息综合。 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:4:0","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"Intelligent Manufacturing in Industry 4.0 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:5:0","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"A. 数字工厂到智能工厂 数字工厂以制造资源，生产运营和产品为核心，利用产品生命周期数据，仿真技术，虚拟现实技术，实验验证技术，使产品在生产台，生产单元，生产线和整个工厂全部的真实活动虚拟化。数字工厂集成了产品，流程和工厂模型数据库，通过先进的可视化，仿真和文档管理，提高了产品质量和生产过程的动态性能。 数字化是智能化的一部分，智能工厂在数字工厂的基础上，利用网络技术和监控技术，加强信息管理服务，提高生产过程的可控性，减少生产线的人工干预。数字工厂是智能工厂的最终结果，智能工厂是工业4.0的基础和立足点。 互联网与工业的融合是制造技术革命的一个突出特点，工业生产的模式将逐步走向智能化。工业4.0提出了基于通信和服务的智能工厂网络建设。物理系统和网络系统通过互联网和移动网络交互，那么工厂将不再仅仅是传统的物理生产车间，它可以通过网络运行和管理设备，实现能耗数据的采集，分析，处理，在线监控等功能。智能工厂通过中间件，云计算和服务连接到庞大的制造网络，基于网络智能物流构建完整的制造系统 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:5:1","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"B. 智能工厂应用示例 以汽车生产为例，目前的汽车生产主要是按照预先设计的工艺生产线生产，虽然也有一些混合生产模式，但在生产过程中，必定由许多机械生产线组成。因此，产品的设计难以实现多样化。由于生产线制造执行管理系统是由大量机械硬件限制的生产线组成，灵活性大大降低，而且它不能发挥更多的作用。同时，不同生产线上的工人位于不同的车间，他们无法掌握整个生产过程，他们只能在特定的固定工作中发挥作用，很难实时满足客户需求。 工业4.0的智能工厂提出了动态配置生产模式，它不再是固定生产线，而是模块化生产，它将它们动态地和有机地结合起来。生产模块可以算是一个CPS，汽车装配时自动穿梭在各生产模块间，接收必要的装配操作。如果它具有生产或零件供应瓶颈，则可以将生产模块安排在其他模型或生产资源的一部分中以继续生产。也就是说，每个模型都是自训练的，以便为动态装配操作选择合适的生产模块。在这种动态配置生产模式中，它可以发挥制造执行管理功能，可以动态管理设计，组装，测试整个生产过程，既保证了生产设备的运行效率，又可以产生广泛的多样化。宝马工厂在冲压，车身，涂层和装配四个主要车间全面实施了工业智能化。车身车间采用智能机器人和工业计算机控制技术，其能效显着提高。实现了节水30％，节能40％，减排20％。 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:5:2","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"C. 智能制造 工业4.0的智能制造在生产过程中通过互联，云计算，大数据实现了系统的垂直整合。整个工厂内部元素相互联系和协作，并进行个性化生产，调整产品生产力，节约资源。特斯拉表示在一定程度上符合工业4.0概念，它自己生产的汽车核心定位不是电动汽车，而是大型移动智能终端，它是人机交互的一种新方式，通过互联网终端使汽车的体验工具包含硬件，软件，内容和服务。特斯拉的成功不仅体现了能源技术的突破，也体现了其对互联网进军汽车制造的思考。这是一个全自动化的设施，除了转向柱和其他需要购买的小零件外，几乎可以完成从原材料到成品的整个生产过程，并且所有剩余部件都是自给自足的。仅在2015年下半年，特斯拉已向弗里蒙特市工厂投资约16亿美元。它的四个制造部门：冲压生产线，车身中心，油漆和装配中心在工作中心拥有150多个机器人。 智能制造的应用非常广泛。智能制造技术的内涵非常深刻。事实上，云计算，大数据分析，电子商务，移动应用，社交网络，企业网络和互联网行业技术都属于智能制造技术或其支持手段，可以说智能制造本身已经包含“互联网+制造业“。 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:5:3","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"Future of Industry 4.0 智能制造的未来表现在四个方面，它们是设备智能化，生产智能化，供应链管理智能化和能源管理智能化。智能工厂的每个生产过程都将清晰可见，高度透明。纵观全球，像之前提到的特斯拉一样，“智能产品+智能生产”企业也不多见，而特斯拉也只是工业4.0时代呼唤的企业原型。目前，工业4.0仍处于概念形成阶段，各国都按照自己的方式试图建立工业4.0标准。在德国，它被称为“i40”。在美国是“物联网”，在中国是“中国制造2025”。但无论名称如何，基本方向都是一致的，即通过新能源技术，物流技术和信息技术提升制造业水平，从而实现从生产到消费的第四次飞跃。在工业4.0的背景下，智能制造的未来不会停留在“智能”的水平，而是要真正实现“智能化”。智能制造系统实现自主学习，自主决策和持续优化。 ","date":"2019-04-15","objectID":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/:6:0","tags":["论文笔记"],"title":"Industry 4.0 Development and Application of Intelligent Manufacturing","uri":"/2019/industry-4.0-development-and-application-of-intelligent-manufacturing/"},{"categories":["研究生的区块链学习之路"],"content":"前言 目的是提取以太坊的区块产生时间形成数据集，初步的思路有两种： 爬取以太坊区块浏览器中的时间数据，然后格式化形成数据集输出 同步以太坊的所有区块（头），利用以太坊本身提供的接口提取每个区块的时间戳信息，然后将时间戳转换为真实的日期格式形成数据集输出，时间戳转换在线工具 查询资料过程中，了解到谷歌已提供以太坊的区块信息数据集1。虽然数据集本身没有时间信息，但可以导出时间戳进行转换，了解到谷歌使用的工具是ethereum-etl，故最终的解决方案是：使用ethereum-etl导出时间戳，编写Python程序转换时间戳并导出数据集。 ","date":"2019-04-05","objectID":"/2019/extract-the-block-generation-time-of-ethereum/:1:0","tags":["区块链"],"title":"提取以太坊的区块产生时间","uri":"/2019/extract-the-block-generation-time-of-ethereum/"},{"categories":["研究生的区块链学习之路"],"content":"区块时间戳信息导出 系统环境为Ubuntu18.04，已安装python环境。安装Ethereum ETL： $ pip3 install ethereum-etl 安装依赖模块 $ pip3 install mythril $ pip3 install pyetherchain 导出区块信息，导出速度和国家有关，国内较慢。 $ ethereumetl export_blocks_and_transactions -s 1 -e 200000 -p https://mainnet.infura.io -b 100 -w 3 --blocks-output blocks.csv 所有的参数使用可以通过-h参数查看，更多信息详见ethereum-etl。 \u003e ethereumetl export_blocks_and_transactions -h Usage: ethereumetl export_blocks_and_transactions [OPTIONS] Export blocks and transactions. Options: -s, --start-block INTEGER Start block -e, --end-block INTEGER End block [required] -b, --batch-size INTEGER The number of blocks to export at a time. -p, --provider-uri TEXT The URI of the web3 provider e.g. file://$HOME/Library/Ethereum/geth.ipc or https://mainnet.infura.io -w, --max-workers INTEGER The maximum number of workers. --blocks-output TEXT The output file for blocks. If not provided blocks will not be exported. Use \"-\" for stdout --transactions-output TEXT The output file for transactions. If not provided transactions will not be exported. Use \"-\" for stdout -h, --help Show this message and exit. 导出的blocks.csv数据集格式如下 Column Type number bigint hash hex_string parent_hash hex_string nonce hex_string sha3_uncles hex_string logs_bloom hex_string transactions_root hex_string state_root hex_string receipts_root hex_string miner address difficulty numeric total_difficulty numeric size bigint extra_data hex_string gas_limit bigint gas_used bigint timestamp bigint transaction_count bigint 打开blocks.csv文件，删除无关项，保留number和timestamp两项。 ","date":"2019-04-05","objectID":"/2019/extract-the-block-generation-time-of-ethereum/:2:0","tags":["区块链"],"title":"提取以太坊的区块产生时间","uri":"/2019/extract-the-block-generation-time-of-ethereum/"},{"categories":["研究生的区块链学习之路"],"content":"时间戳转换及数据集生成 利用csv模块进行数据集逐行读取，利用time模块进行时间戳转换，利用numpy模块进行数据集重新写入，代码如下： import csv,time import numpy filename = 'F:/blocks.csv' with open(filename) as f: reader = csv.reader(f) header_row = next(reader) date = [] rowNumber = 1 for row in reader: date.append(row) rowNumber = rowNumber + 1 i = 0 while i \u003c rowNumber-1: timeStamp = int(date[i][1]) timeArray = time.localtime(timeStamp) otherStyleTime = time.strftime(\"%Y-%m-%d%H:%M:%S\",timeArray) date[i].append(otherStyleTime) print(date[i][2]) i = i + 1 numpy.savetxt('blocks.csv', date, delimiter = ',',fmt = '%s') 生成的数据集格式如下，第一列为区块号，第二列为时间戳，第三列为转换后的时间信息，以逗号分隔，共20万条数据。在第一行手动添加表头。 注：此时的以太坊主链总区块数在750万个左右。 Number,Timestamp,Block generation time 1,1438269988,2015-07-30 23:26:28 2,1438270017,2015-07-30 23:26:57 3,1438270048,2015-07-30 23:27:28 4,1438270077,2015-07-30 23:27:57 5,1438270083,2015-07-30 23:28:03 6,1438270107,2015-07-30 23:28:27 7,1438270110,2015-07-30 23:28:30 8,1438270112,2015-07-30 23:28:32 9,1438270115,2015-07-30 23:28:35 10,1438270128,2015-07-30 23:28:48 11,1438270136,2015-07-30 23:28:56 12,1438270144,2015-07-30 23:29:04 13,1438270158,2015-07-30 23:29:18 14,1438270161,2015-07-30 23:29:21 15,1438270168,2015-07-30 23:29:28 16,1438270174,2015-07-30 23:29:34 也可以直接利用谷歌 BigQuery 获取和分析以太坊数据，见使用谷歌 BigQuery 分析以太坊数据 ","date":"2019-04-05","objectID":"/2019/extract-the-block-generation-time-of-ethereum/:3:0","tags":["区块链"],"title":"提取以太坊的区块产生时间","uri":"/2019/extract-the-block-generation-time-of-ethereum/"},{"categories":["研究生的区块链学习之路"],"content":"参考文献 How to interact with the Ethereum blockchain and create a database with Python and SQL How do you work with Date and time on Ethereum platform Google Cloud-Ethereum in BigQuery Google Cloud数据库操作 Google Cloud文档 How to use Kaggle Kaggle调用BigQuery Kaggle-Beyond Queries: Exploring the BigQuery API Kaggle-Visualizing average Ether costs over time 谷歌宣布其 BigQuery 服务已支持以太坊区块链数据分析 ↩︎ ","date":"2019-04-05","objectID":"/2019/extract-the-block-generation-time-of-ethereum/:4:0","tags":["区块链"],"title":"提取以太坊的区块产生时间","uri":"/2019/extract-the-block-generation-time-of-ethereum/"},{"categories":["研究生的区块链学习之路"],"content":"首先我们就 Ethereum 等九个平台做分析比较，从而确定要用来作为实验平台的区块链。 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:0:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"1. Ethereum ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:1:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于存储 以太坊生态中的一些工具和技术是用来解决大数据量存储问题的，比如Swarm和IPFS。Swarm 是一个去中心化的内容存储和分发服务。 您可以将它视为 CDN，但它并不是在一家公司的服务器上托管的所有 CDN，而是通过互联网在计算机上分发。 就像运行一个以太坊节点一样，来运行一个 Swarm 节点连接到 Swarm 网络。 IPFS在2016年就正式在以太坊分叉（ETH）上推出了它的分布式文件存储网络，在概念上与Swarm完全相似。虽然与以太坊没有直接关联，但可与以太坊集成。 Swarm和ETH的区别见：IPFS\u0026Swarm 在以太坊生态中，智能合约smart contract实现了分布式逻辑，Swarm实现了分布式存储，Whisper实现了分布式消息，整体结构如下所示 参考链接：Swarm文档说明，Swarm内容搜索，Swarm简单入门 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:1:1","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于测试 以太坊官方目前提供两种网络，同时为了测试，也可以自己搭建私有网络 主网络 是产生真正有价值的以太币的网络，目前区块高度超过700万，每个以太币的价值在118美刀左右。优缺点如下表 优点 缺点 全球化的，部署在Internet环境上 任何智能合约执行都会消耗真实的以太币，也就是真实的现金。不适合开发、调试和测试 智能合约的代码，执行，区块的调用，都可以清晰的查看到 所有节点是全球化的，速度较慢 部署在主网络的智能合约，全世界任何应用都可以调用 对于部分商业应用来说，只需要一部分节点，例如分布式部署的10-20台服务器即可，不需要遍布全球的网络 测试网络 以太坊为了方便智能合约的开发、学习和测试，开启了几条全新的区块链，与主网络特性相同，但测试网络中的以太币价值更低，也更容易得到。这样不至于在主网络上开发出现 BUG 造成以太币的损失。主要的以太坊测试网络有： Ropsten Test Network Kovan Test Network Rinkeby Test Network 测试网络的优缺点如下表 优点 缺点 合约执行不消化真实货币 所有节点是全球化的，速度较慢 全球化，部署在Internet环境上 测试网络不能作为商业应用的实际落地环境 智能合约的代码，执行，区块的调用，都可以清晰的查看到 测试网络由官方提供，使用较为直接，对以太坊技术的底层实现，Geth的各种参数接口等理解会差很多 部署在测试环境上的智能合约，全世界任何应用都可以调用 私有网络 除了官方提供的两种网络，用户还可以使用Geth工具创建自己的私有网络，用来开发、学习和测试。基本的说明见官方的github wiki: Private network 私有网络的优点有： 方便开发者深入理解以太坊的技术底层 因为节点相对较少，速度较快 用户可以随时创建，随时销毁，随时重建一个以太坊网络 随意的增加节点数目，或者删除节点， 既可以在服务器上建立，也可以在自己的windows或者Mac机器上建立， 甚至一台机器可以建立多个节点，在一台机器上实现多节点的私有网络 缺点主要是只有在私有网络内的节点才能查看智能合约的执行、调用。目前网上关于如何构建以太坊私有网络的教程很多。但没有实践的情况下，同时也没有在教程中看到如何产生指定的交易类型的方式。 参考链接：一个简单的以太坊私有网络搭建教程 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:1:2","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于智能合约 以太坊是智能合约的主要代表 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:1:3","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"2. Hyperledger Hyperledger是一项旨在推动跨行业开源协作的区块链技术。合作者包括金融，银行，物联网，供应链，制造和技术领域的行业领导者。项目列表 我们从项目列表看到hyperledger的子项目中，总架构有多种，包括：Sawtooth, Iroha, Fabric, Burrow和Indy。但目前最流行的当属Fabric，便以Fabric为焦点。 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:2:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于存储 首先查询了Hyperledger 是否有对IPFS的支持，然后发现有人问过这个问题，以下是回答 Q：Are there plans to integrate hyperledger fabric with IPFS and BigchainDB as an alternative file storage/persistent store? Or perhaps these are already available? Nathan Aw A：There is no intent to integrate ‘directly’ with IPFS or BigchainDB. With the Fabric architecture, blocks are distributed at the node layer, and each node maintains it’s own dedicated data store. This is in contrast to IPFS and BigchainDB, where data is distributed across the data store itself. There are valid design patterns where you can integrate ‘indirectly’ with such distributed/decentralized data stores however. For example in your solution the client application could store data on a distributed/decentralized data store to share data with business partners, and then store a hash (and perhaps a URL to the data) in Fabric as decentralized ‘proof’ of the data. Dave Enyeart 原文地址 显然，Hyperledger不直接的集成IPFS等方式，但可以通过其它间接的手段来完成，这里有一个集成BigchainDB到Hyperledger Fabric的方案：BigchainDB integrates with Hyperledger Fabric 回答中提到Hyperledger自己的存储与IPFS是背道而驰的，所有我们来看以下Hyperledger的存储。fabric网络实际上有三种类型的数据存储，一种是账本本身，也就是区块链数据，是以文件形式存储；第二种是区块数据和历史数据的索引数据库；第三种是状态数据库，即存储我们在chaincode中执行的业务数据。所谓的“each node maintains it’s own dedicated data store\"指的就是第三者状态数据库 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:2:1","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于测试 Hyperledger是联盟链的典型代表，不过联盟链实际上就是一个范围扩大版的私链。所以我们能利用Fabric完成自己的项目。 使用的工具首选Composer，使用Hyperledger Composer完成简单的网络构建和智能合约的编写与运行后，可以继续深入的使用Fabric实际完成项目 重要的是，Composer和Fabric都提供了许多样例场景，可以简化开发 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:2:2","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于智能合约 Hyperledger支持智能合约 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:2:3","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"3. Multichain 号称90秒创建一个私有区块链， 多链(MultiChain)是一个即用型的私有区块链创建平台。隐私与控制的争议是比特币成为行业性金融机构的障碍。而用多链(MultiChain)创建的私有链则克服了这个困难。其特性包括： 各项参数可以完全自定义。多链是一种私链，交易和挖矿都要得到控制者的许可才能进行。 快速部署。二步就可以生成自已的区块链，三步就可以连接上其它区块链。 资产的原生支持。这与彩色币是不同的。 兼容比特币 采用间接的方法集成区块链和分布式的存储如IPFS应是众多链均可实现的，所以我们之后的讨论是描述这些区块链是否原生的支持。显然Multichain（多链）是不支持的。 Multichain在2018.12.19发布了2.0 beta版，有了重大改进，正好有我们需要的功能： Smart Filters. These allow custom rules to be coded for validating transactions or data. Smart Filters are written in JavaScript and run within a deterministic version of the high-performance V8 engine that powers Google Chrome. Click for more on Smart Filters or a comparison with Fabric, Ethereum and Corda. Off-chain data. Any item published in a MultiChain stream can optionally be stored off-chain, in order to save bandwidth and storage space. Off-chain data (up to 1 GB per item) is automatically hashed into the blockchain, with the data itself delivered rapidly over the peer-to-peer network. Click for more about off-chain data. 第一个Smart Filters是对智能合约的支持，只是换了个说法，第二个Off-chain data是解决数据存储的问题。 关于测试的问题，多链本就是为私链而生的，其各项功能显然有利于我们的实验。但这同时带来一个问题，我们虽然在私链环境下测试，因为这有利于我们对链的控制和对结果的分析，但最终的目标显然是要推广到更广的范围的，现在还不清楚Multichain支持的项目体积。 参考链接：Multichain，Multichain blog ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:3:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"4. HydraChain HydraChain是基于以太坊的扩展，用于支持私链和联盟链的构建，100%的兼容以太坊的API和智能合约，唯一大的区别在于共识协议，原文的描述是 it relies on a registered and accountable set of validators which propose and validate the order of transactions. 理论上我们在以太坊部分描述的方式这边能实现，同时，相比于用geth构建私链做实验，这个专门针对私链和联盟链的项目应该拥有更好的特性。唯一的问题正如项目Issue里的第一条：still active github的项目状态处于”Work in Progress”，但最近的版本记录是2016年的。。。很尴尬的情况😂 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:4:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"5. Openchain 项目社区蛮小的，网上的资料也不多，官网描述的用例是这样的 Openchain is a generic register of ownership. It can be modelled to work with an immense number of use cases: Securities like stocks and bonds, commodities like gold and oil, currencies like the Dollar or even Bitcoin. Titles of ownership like land titles, music or software licensing. Gift cards and loyalty points. 看起来适合用于物品所有权领域，不是很适合我们的方案测试。 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:5:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"6. IBM Bluemix Blockchain Bluemix 是一个基于开放标准的云平台，用于构建、运行和管理应用程序和服务。​IBM Blockchain 提供私有区块链基础架构来开发受区块链支持的解决方案。Bluemix Blockchain 服务 是 Hyperledger Fabric 的一种实现。它提供了： 一个由 4 个对等节点组成的区块链网络 一个证书颁发机构服务器 智能合约代码（使用 Golang 开发的链代码） 全球/账本状态，其中包含智能合约数据的当前值（所有事务的历史记录也包含在区块链中） 总的来说应该归到2.hyperledgrer里，以下第三个链接的项目里有一个名为marbles的子项目，好像和Composer的作用类似，还给了例子。 参考链接：IBM Blockchain Platform，IBM Bluemix Blockchain相关说明，IBM Blockchain项目地址 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:6:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"7. Chain 目标指向为金融领域，而且非开源 。官网地址https://chain.com/ ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:7:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"8. IOTA IOTA专为物联网设计，但却不是真正的区块链结构，而是一种基于有向无环图（DAG）的称为Tangle(缠结)的结构。 参考链接：IOTA，IOTA中国 目前来看，IOTA和以太坊两边都有支持者，IOTA的支持者认为它解决物联网中广泛存在的微交易问题，以太坊的支持者则认为IOTA太激进，DAG 区块链还有不少问题，而以太坊则稳扎稳打，采用的技术都足够成熟，长远看更有优势。 但从我们的测试看，IOTA的文档说明很不完善，几乎找不到私人构建的方案教程。再加上DAG 区块链技术相比于传统区块链有较大差异，并不打算使用IOTA。 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:8:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"9. EOS EOS.IO 软件引入一种新的区块链架构设计，它使得去中心化的应用可以横向和纵向的扩展。 这通过构建一个仿操作系统的方式来实现，在它之上可以构建应用程序。 该软件提供帐户、身份验证、数据库、异步通信和跨越数百个 CPU 内核或集群的应用程序调度。 由此产生的技术是一种区块链架构，它可以扩展至每秒处理百万级交易，消除用户的手续费，并且允许快速和轻松的部署去中心化的应用 以上这段话来自EOS.IO 技术白皮书 众多的文章中介绍的EOS的特点包括： 支持大量的用户，可能是上亿级别的用户 消除手续费 超高性能（支持百万级TPS） 对IPFS的天然支持 使用DPoS协议，不会产生硬分叉 以及其它，目前EOS的吞吐量未达到所称的百万级，大概在12000/秒（据某个博客的数据） ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:9:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"结论 综合以上分析，我们初步选定的平台有：Ethereum，Hyperledger，Multichain，EOS。我们的目标是完成IIoT场景下访问控制的一个方案，面对的问题包括物联网设备完成PoW代价过高，实时数据（大数据量）的存储，交易确认的延迟（因为受网络拥堵情况影响，无法判断准确时间，用出块时间代表），物联网场景下并发的设备数量巨大。同时，由于要完成访问控制，还需要智能合约的支持，更由于我们需要对方案进行测试，还需要对所购建的区块链的完全控制能力，即需要选择的平台能支持私链的构建，最后，我们还要考虑该平台的流行度和社区水平，因为这决定了该平台文档的完善程度及遇到问题是否容易解决。对于所有以上所列指标，我们对四个平台总结如下表。 Ethereum Hyperledger Multichain EOS 共识算法 PoW PBET PoW DPoS 大数据量存储支持 Swarm 本身的状态数据库 off-chain IPFS 出块时间 15s 联盟链 私链 0.5s 吞吐量（每秒交易数） 20/s 70-1000/s 12000/s 智能合约支持 支持 支持 支持 支持 私链构建容易程度 中 中 高 中 开发容易程度 中 中 易 难 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:10:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"其它 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:11:0","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于通信 What Makes a Blockchain: Protocols and the Future ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:11:1","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于工具 性能比较与分析这部分内容是 2019.07-2019.08 月关注的问题，这段时期倾向于自行编写一个性能测试平台。 blockBench blockBench 是一个私链的基准测试框架，目前提供的测试包括 Ethereum, Hyperledger, Parity 和 Quorum。 但该项目已经很久没有维护，melhindi/blockbench 是一个 Fort 之后的仓库，相比原项目更新一点。 caliper caliper 也是一个区块链基准测试工具，属于 Hyperledger 官方的项目，因此一直在维护，不过主要针对的也是 Hyperledger 旗下各区块链，包括 Fabric，Sawtooth等等。但因为 Ethereum 的特殊性，也有对该平台的测试。 chainhammer，以太坊及其衍生的各种区块链比如 Quorum 等之间的比较，包含 TPS、blocktime、gas 和 blocksize，会自动绘制一个图表。 ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:11:2","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"关于参考文献 1、Aad van Moorsel. Benchmarks and Models for Blockchain. 2018. 主要介绍区块链基准测试应该测哪些方面 2、Anuj Das Gupta, Andrew Dickson, [Analyzing Performance in Blockchain-Based Systems](https://github.com/stratumn/performance/blob/master/Analyzing Performance in Blockchain-Based Systems.pdf). 2017.11. 介绍区块链性能分析的方法，写的很好，虽然只放在 Github 上，但如果研究这个方向，强烈推荐阅读。 3、Harry Kalodner. et.al. BlockSci: Design and applications of a blockchain analysis paltform. 2018. 声称比其它比较工具好，但没细看。唯一能确认的是，这是该领域直接相关的一篇论文。 4、Medium，Running blockbench for ethereum，见面知意，关于以太坊的一个基准测试的文章，国内需要翻墙。 5、其它几篇论文 Evaluating the Efficiency of Blockchains in IoT with Simulations Untangling Blockchain: A Data Processing View of Blockchain Systems BLOCKBENCH: A Framework for Analyzing Private Blockchains Performance Evaluation of the Quorum Blockchain Platform ","date":"2019-04-01","objectID":"/2019/blockchain-platform-compare-and-select/:11:3","tags":["科研记录"],"title":"研究记录2-区块链平台选择的思考","uri":"/2019/blockchain-platform-compare-and-select/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Gaoqi Liang , Steven R. Weller, Fengji Luo , Junhua Zhao, Zhao Yang Dong Published in：IEEE Transactions on Smart Grid 2018(Early Access) 期刊级别：SCI I区 被引量：19次 keywords：Blockchain, Modern power systems, Cyber-attacks, Distributed network, False data injection attacks ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:0:0","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 现代电力系统的网络安全同时吸引了学术和工业界的关注，许多针对网络攻击的检测和防御手段因此而被提出。本文提出了一种新的基于区块链的分布式保护框架，用于增强现代电力系统应对网络攻击的自抵御能力。我们对区块链技术如何用于增强电网鲁棒性和安全性做了全面的讨论，使用电表作为分布式网络的节点，将电表的测量数据打包为区块。所提出方案的有效性通过基于IEEE-118节点系统的仿真实验来说明。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:1:0","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"I. Introduction 现代电力系统的性能依赖于先进的通信和控制技术，但同时也因此受到网络攻击的威胁。使用分布式网络的区块链技术被视为一个可能的解决方案并开始被研究，与已有的文献不同，本文提出了一个分布式的基于区块链的数据保护框架，主要的贡献包括： 提出的框架增加了现代电力系统应对网络攻击篡改数据的自抵御能力，传统攻击中只要能篡改电表本地测量的数据、信道中传输的数据，以及黑到控制中心，都称为攻击成功。而本文提出的框架中，除非控制了足够的电表或篡改了大部分信道中传输的数据，否则都不算成功。 针对电网环境的特定性质修改共识协议和相关技术细节，使之适用于现代电力系统 section II介绍系统架构，section III介绍工作机制，section IV为性能分析，section V为仿真实验，section VI结论 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:2:0","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"II. System Infrastructure 现代电力系统中，监督控制和数据采集模型（SCADA）有典型的三个基本流程：终端（电表）数据采集，数据传输（到控制中心），控制中心进行的数据存储。当前的数据采集和存储是中心化的机制，有很高的被篡改风险，本文提出的框架通过分布式的信息采集和存储减小了这种风险。但也因此，现有的基础设施需要更新换代来实现这些机制，本节描述该框架需要的基础设施要满足的条件。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:3:0","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"A. 重配置SCADA网络 本文框架中重配置的SCADA网络用于采集、传输和存储数据。电力系统的整体层次与传统相同，不同的是SCADA网络中每个终端电表需要集成数据采集设备、信号发送器、信号接收器和数据处理设备。框架中整个能量管理系统和市场管理系统由物理层收集的信息支持，通信层则独立于网络。 数据采集设备从电表获取实时的测量数据，包括电压、电流、功率、断路器状态等等，地理上分布的电表/传感器形成一个分布式的电表节点网络。我们假设每个不同的节点对都有通信路径相连，只有经电网授权的电表/传感器能执行数据采集操作。这种情况下，电表节点网络是完全独立的，可以被理解和建模为一个私有的区块链网络，更重要的是，网络中节点间的交互是全自动的，这使它区别于现有的区块链平台，如Bitcoin，因为Bitcoin交易由人发起。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:3:1","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"B. 电表关键特性 在电表节点构成的区块链网络中，为了完成彼此的交互，电表需要拥有一些功能，这些功能是现在大规模部署的电表没有的，这些需求的功能列举如下： 每个电表由唯一的地址标识 每个电表装有特殊的支持生成公私钥的软件 每个电表集成RAM，算力硬件，数据收集设备，信号发送器和接收器，数据处理设备等 电表要有能力在彼此间通过无线或有线连接通信 这些特性说明了必须升级现有的电网基础设施。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:3:2","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"III. Working Mechanism 本文的框架中所有收集的数据最终都被收集到区块并存储在区块链中，并分布式的存储于电表RAM中，存储之前还要经过数据广播、数据验证、数据收集到区块、挖矿、区块添加到链末尾、区块同步等流程。主体的流程包括数据的传输、验证和存储，但和基本的PoW机制的区块链技术相似，只把不同之处详细介绍。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:4:0","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"A. 公私钥更新频率设置 为了通信，每个节点都应拥有所有节点的公钥和自己的私钥，如果公私钥被入侵者偷了，那么就无法防止攻击者篡改数据。因此，为了提高安全性，需要定期的更新或替换密钥信息。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:4:1","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"B. 块生成 每个区块必然包含众多测量数据，因此，测量的数据被收集到区块中是一个持续的过程，如果一个块累计过多的测量数据，则可能花费较长的时间，从而对更上层的应用造成不利影响。与之相反，区块中收集的测量数据过少会造成频繁的挖矿操作，从而带来较大的计算负担。本文架构提出两种解决策略： 以固定时间生成区块 以固定规格生成区块：即每个区块大小相同 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:4:2","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"C. 矿工选择 另一个主要的问题是解决工作量证明谜题的矿工节点的选择。因为作为矿工的节点必须拥有足够的计算能力，同时这意味着高资源消耗，我们提出两种策略： 事先指定矿工节点 所有节点算力相同时，随机选择矿工节点 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:4:3","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"D. 周期性的释放电表存储空间 区块链是不断增长的，这同时意味着数据量的不断增长，然而电表节点的存储空间是有限的，所以需要周期性的释放电表的存储空间，当然，释放之前要备份区块数据。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:4:4","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"IV. Performance Analysis 从三个方面做性能分析 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:5:0","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"A. 金融和电力两个领域区块链应用的比较 Item BC in Bitcoin System BC in the Proposed Framework Network Public Private Transaction initiator Human intervention Completely automatic Transaction content Money Collected measurement Transaction relationship Continuously,related Independent,unrelated Checking historical blocks prior to the voting process Required Unnecessary Chain connection speed Approximately 7 transactions per second Much faster Reward to node Yes No Double-spending attack A threat Not exist 51% attack Difficult Difficult but shreshold adjustable ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:5:1","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"B. 缺点和挑战 本文提出的框架利用分布式安全的最新概念，探索了保证现代电力系统安全的新方向，然而，这里还存在一些问题和挑战。主要有三个方面。 1）时机，该方案的实施需要设备的更新换代来支持，这涉及的资金和部门都很多，实际操作不是一朝一夕的事情，所以需要权衡投入和收益来缺点是否进行部署和实现，相比较来看，基于微电网的电力系统可以更快的实验这一方案； 2）安全，该方中地理上分布的传感器增加了攻击者操作传感器/信道篡改数据的攻击难度，然而算力和通信能力等的发展不是单方面的，攻击者的技术也在发展，因此，仍然面临新的安全威胁； 3）冗余，分布式的网络和数据存储造成了大量的冗余数据，攻击者只需要入侵单个的传感器就可以获取整个网络的信息，虽然获取到的测量信息不会直接危害整个系统，但对攻击者监视目标网络、设计有效的攻击测量极为重要，因此需要设计合适的防御策略比如访问许可等。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:5:2","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"C. 新旧电力系统框架面对网络攻击的性能比较 评估新旧两种电力系统框架抵御网络攻击的能力，从三方面评估。第一是传输前的电表阶段，第二是传输过程中，第三是传输后对控制中心的入侵。然后证明了本文的框架比较好 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:5:3","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"V. Case Study 主要是基于IEEE-118节点系统，该系统针对电力系统，所以不多看了。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:6:0","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["研究生的区块链学习之路"],"content":"VI. Conclusion 一个典型的工业场景—智能电网和区块链的结合，抽象了数据采集、数据传输、控制中心的数据存储三个过程，对构建其它工业场景有借鉴意义。首先定义电表拥有足够的算力、存储空间、通信能力等满足区块链节点要求，由众多电表节点构成私有的全自动的区块链网络，采集的数据定期地收集到区块中，随机选择矿工节点做验证和打包，另外还需要周期性地更新密钥列表和释放电表存储空间。整个区块链网络地信息用以支持上层应用，节点间的通信网络和区块链网络是独立的。 ","date":"2019-04-01","objectID":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/:7:0","tags":["论文笔记"],"title":"Distributed Blockchain-Based Data Protection Framework for Modern Power Systems","uri":"/2019/distributed-blockchain-based-data-protection-framework-for-modern-power-systems/"},{"categories":["我所热爱的生活啊"],"content":"2019年3月30日，自上周去过箭馆射箭之后，本周按原定计划前往秦皇求仙入海处及港口博物馆。 秦皇求仙入海处 由31路转8路抵达求仙入海处正门，果然，公交的实际用时总要比地图的预估时间快三分之一，所以到早了一点，景区九点开门。隔壁是边检，正值大风天气，街上行人匆匆，有点现代谍战片场景的感觉。因为是淡季，门票10元/张，网上说游玩H时间估计3小时，但其实1小时都不到，景区内也没什么东西，4A级景区的名头估计有水分，不推荐游玩，算是坑。 求仙入海处周围还有两个地方，一个是港口博物馆，一个是航标展馆，不容易找，而且都需要预约，只拍了张港口博物馆院子的照片。 因为预定的这三处景点都不如人意，全部游览结束时间还早，于是决定干脆将下一次的目标一起逛完，即孟姜女庙。 孟姜女庙 不谈自驾的话，孟姜女庙只能由山海关乘302路车前往，在一个村子里，这个村子叫望夫石村，该村所在的镇子叫孟姜镇，很有意思。孟姜女庙的门票10块。进去之后首先是一个展馆，展馆里有据称是泥人张四代传人的泥塑，描述了从孟姜女一生的系列场景，然后是一片树林，景区别出心裁的在树上挂了大量风铃，正好今天是有风天气，风铃声阵阵，极为悦耳。景点内众多树木树龄都在百年以上，树上都有牌子做记载。主庙中有孟姜女的塑像，还有众多记孟姜女的碑刻，看到了道光皇帝的。有一口钟，撞钟发出的声音可以用余音绕梁的表面意思描述，还有一些其它的地方，但都是最近新建的，不过总体还是比求仙入海处好。 难过的是公交一小时一班，1点15的车我一点17到站牌。随后整整步行了五公里回到山海关才坐车离开。 ","date":"2019-03-30","objectID":"/2019/meng-jiangnu-temple/:0:0","tags":["旅行记录"],"title":"秦皇求仙入海处及孟姜女庙","uri":"/2019/meng-jiangnu-temple/"},{"categories":["研究生的区块链学习之路"],"content":"说实话，swarm的资料比较难找，倒是IPFS的比较多一点。最后只在Medium找到了一些，本篇文章就是在实践其中的一些项目，并通过这样来学习swarm。 参考链接：swarm官网，swarm文档，github项目 还有一些帮助理解的资料： 关于swarm的三个理解上的问题 swarm和ipfs的比较 ","date":"2019-03-28","objectID":"/2019/swarm-storage-network-using/:0:0","tags":["区块链"],"title":"以太坊开发7-swarm存储网络使用","uri":"/2019/swarm-storage-network-using/"},{"categories":["研究生的区块链学习之路"],"content":"1. Ethereum Swarm是什么 Ethereum swarm是一个分布式文件存储系统，开发这个项目是因为区块链中的数据存储是昂贵的，它的不同之处在于它会激励一部分参与者提供他们的存储资源，以此来维持存储网络的稳定运行，当然，目前激励机制还没有上线。 撰写本文时，找到的最新版本是POC3（Proof-of-Concept Release 3)，发布于June 21, 2018。关于该版本和该项目的详细信息见： Announcing Swarm Proof-of-Concept Release 3 Swarm alpha public pilot and the basics of Swarm ","date":"2019-03-28","objectID":"/2019/swarm-storage-network-using/:1:0","tags":["区块链"],"title":"以太坊开发7-swarm存储网络使用","uri":"/2019/swarm-storage-network-using/"},{"categories":["研究生的区块链学习之路"],"content":"2. 安装Swarm 详细的安装方式见这里，这里只介绍在Ubuntu上通过PPA安装，虽然这种方式安装的是stable版本，但版本号同样在0.3，所以就不使用更麻烦的自编译源码安装了。 $ sudo add-apt-repository -y ppa:ethereum/ethereum $ sudo apt-get update $ sudo apt-get install ethereum-swarm 安装完成后查看swarm版本 $ swarm version Swarm Version: 0.3.11-stable Git Commit: c942700427557e3ff6de3aaf6b916e2f056c1ec2 Go Version: go1.10.4 OS: linux ","date":"2019-03-28","objectID":"/2019/swarm-storage-network-using/:2:0","tags":["区块链"],"title":"以太坊开发7-swarm存储网络使用","uri":"/2019/swarm-storage-network-using/"},{"categories":["研究生的区块链学习之路"],"content":"3. 配置Swarm网络 ","date":"2019-03-28","objectID":"/2019/swarm-storage-network-using/:3:0","tags":["区块链"],"title":"以太坊开发7-swarm存储网络使用","uri":"/2019/swarm-storage-network-using/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 第一个swarm节点 运行swarm需要以太坊账户，我们通过geth命令来创建账户，需要已经进行过geth安装。 $ mkdir swarmNode1 $ geth --datadir swarmNode1/ account new $ export BZZKEY1=\"your new account address\" 将返回的账户地址设置为环境变量BZZKEY1，然后启动第一个节点。 $ swarm --bzzaccount $BZZKEY1 --datadir swarmNode1/ --keystore swarmNode1/keystore --ens-api \"\" --bzzport 5000 bzzaccount：设置节点账户地址 datadir：设置swarm节点存储数据的文件目录 keystore：账户密钥所在文件目录，设置该选项后就可以使用密码来解锁账户 ens-api：将此项设置为空，swarm将不会连接到区块链，并在无区块链环境下运行 bzzport：设置用来上传和下载的端口地址 运行单节点的话以上设置已经足够了，但是运行多节点的话还需要其它一些设置，并不能简单的重复第一个节点的配置过程。 ","date":"2019-03-28","objectID":"/2019/swarm-storage-network-using/:3:1","tags":["区块链"],"title":"以太坊开发7-swarm存储网络使用","uri":"/2019/swarm-storage-network-using/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 更多swarm节点 启动多个节点的时候不能仅仅改动--bzzport参数，还需要改动UDP端口号，这一点文档中没有提到，启动第二个节点的示例如下： $ mkdir swarmNode2 $ geth --datadir swarmNode2/ account new $ export BZZKEY2=\"your new account address\" $ swarm --bzzaccount $BZZKEY2 --datadir swarmNode2/ --keystore swarmNode2/keystore --ens-api \"\" --bzzport 5500 --port 9000 ","date":"2019-03-28","objectID":"/2019/swarm-storage-network-using/:3:2","tags":["区块链"],"title":"以太坊开发7-swarm存储网络使用","uri":"/2019/swarm-storage-network-using/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 连接swarm节点 现在节点都已经启动，我们需要把它们连接起来以完成彼此通信。为了完成这一点，我们需要手动地将swarmNode2的引导节点连接到swarmNode1。 首先寻找swarmNode2的引导节点地址，运行如下命令。 $ geth --exec \"console.log(admin.nodeInfo.enode)\" attach swarmNode2/bzzd.ipc enode://4ae5ee37b365e316b1d2b3d07e5cb1f620919ff39b89f5640b461e64bb92cf8a2caa399548a292387c3f31741ff0e886231258a66707ce51ba5f85856790faac@127.0.0.1:9800?discport=0 exec：执行JavaScript语句(只能结合console/attach使用) bzzd.ipc：运行swarmNode2生成的文件，结束运行该文件消失 复制结果并添加到如下命令，连接两个节点 $ geth --exec='admin.addPeer(\"your enode address\")' attach swarmNode1/bzzd.ipc your enode address即我们上面得到的 enode://4ae5ee37b365e316b1d2b3d07e5cb1f620919ff39b89f5640b461e64bb92cf8a2caa399548a292387c3f31741ff0e886231258a66707ce51ba5f85856790faac@127.0.0.1:9800 使用的时候需要去掉?discport=0 ","date":"2019-03-28","objectID":"/2019/swarm-storage-network-using/:3:3","tags":["区块链"],"title":"以太坊开发7-swarm存储网络使用","uri":"/2019/swarm-storage-network-using/"},{"categories":["研究生的区块链学习之路"],"content":"4. 测试网络连接 现在我们来测试两个节点是否已连接。使用如下命令从swarmNode1上传文件fileToUpload.txt，文件内容为test file，上传成功将返回文件哈希 $ swarm --bzzapi \"http://localhost:5000\" up fileToUpload.txt 82c5c438f80dc81730ab9d8aeaa8fc433b3d719590f6729872e42c6c0eed59c5 复制该哈希作为地址从swarmNode2查询 $ curl http://localhost:5500/bzz:/your hash comes here/ 该条命令将返回哈希对应的文件内容test file 可查看swarm文档阅读更多细节 ","date":"2019-03-28","objectID":"/2019/swarm-storage-network-using/:4:0","tags":["区块链"],"title":"以太坊开发7-swarm存储网络使用","uri":"/2019/swarm-storage-network-using/"},{"categories":["爱编程爱技术的孩子"],"content":"前言 本文是创新创业的结课报告，结课报告的题目要求如下： 通过课程学习、课下查阅网络与图文资料，了解和掌握树莓派的功能、扩展性与应用领域（树莓派的典型和非典型应用） 深入分析某一个具体行业或工作的工作特点，找到痛点难点，并分析树莓派的适用性（树莓派的什么特点使其适合用于解决这一问题） 基于树莓派的功能，讨论如何通过增加相应的软硬件（传感器、软件模块、算法库……等），满足所关注的问题 以“开发产品原型并吸引风投”为目标，完成一份创业项目计划书 注：不要求完成实际作品，而是强调基于技术的创意、运用工具和所学知识解决实际问题的能力、分析评价项目商业价值的能力 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:1:0","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"项目简介 随着时代的发展，扫地机器人已走进千家万户，服务于人们的日常生活。然而，与该技术自动化的核心思想相背离，目前的扫地机器人在启动、交互和垃圾倾倒等方面还存在着不少的缺陷。同时，作为一个家庭生活的助手，扫地机器人的工作潜力也远远未开发出来。因此，我们设计了一款自动化程度更高的机器人，将内部的单片机替换为功能和接口更丰富的树莓派，集成智能语音助手，优化交互形式，同时设计了一种机械结构，利用树莓派控制它自动倾倒垃圾，改进了扫地机器人的内部和表面结构，增加了其承重能力，从而使扫地机器人更加的全能与实用。 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:2:0","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"项目背景与意义 自2013年以来，全球扫地机器人市场规模呈逐年增长态势，截止2018年底全球扫地机器人市场规模为23亿美元，而2019年预计将突破30亿美元。从市场占比看，目前美洲、亚洲和欧洲各占三分之一，美国和中国是全球最大的市场。于此同时，国内的市场竞争也极为激烈，扫地机器人品牌达数百家，科沃斯、小米、IRobot是其中的龙头企业，尤其是科沃斯，市场占比近半。 政策方面，国家发改委、工信部和财政部2016年共同制定的《机器人产业发展规划(2016-2020年)》明确支持机器人行业尤其是扫地机器人所在的服务机器人领域快速发展，在政策的引领下，该领域前景广阔。 然而，目前国内市场的主流扫地机器人倾向于在算法和软件方面进行优化，专注于核心的清扫功能和对地面环境的适应能力，未对作为机器人核心思想的自动化做进一步的改进，比如，机器人清扫完毕后仍需要人工处理垃圾，没有实现自动倾倒垃圾的功能；另外，从网络评论来看，扫地机器人在某种程度上已经成为人们的精神慰藉，也偏受家中宠物的喜爱，因此，增加机器人的交互能力和承重能力势在必行。而解决了这三方面痛点的机器人，必将成为市场新的宠儿，促进该领域技术的进一步革新。 另外，我们将机器人起名为大白，目的是希望它能够像《超能陆战队》中的大白一样，成为人们生活的好助手，以及精神的慰藉者。 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:3:0","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"项目总体技术组成 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:4:0","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 系统设计 扫地机器人的核心结构如图1所示，市面上的机器人一般使用普通的单片机作为控制核心，为了更多的功能和扩展，我们将其替换为树莓派。 大白的核心功能同市面上大部分扫地机器人相似，另外添加了我们独有的三个功能，如下表所示。 基本功能 独有功能 自动返回充电 智能语音交互 避障功能，感应障碍，自主脱困 自动倾倒垃圾 多种地形适应，包括木板、瓷砖、地毯等 承重结构设计 下视感应，安全防跌 打扫路径和功能优化，清扫更干净 另外，我们为机器人挑选了极为漂亮的外壳，如图2所示，它可以进一步吸引消费者的青睐。 BC_20190904_ 我们不对基本功能做过多描述，只是令树莓派代替了单片机的作用。下面分模块介绍独有的三种功能设计。 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:4:1","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 自动倾倒垃圾功能 扫地机器人自动倾倒垃圾的功能通过传感器、树莓派、尘盒和相关的机械结构来完成。概念图如图3所示，集成微型称重传感器的尘盒同一根金属杆连接，传感器的数据传回树莓派做处理，树莓派通过控制金属杆的伸缩和转动来倾倒垃圾。 接下来我们描述整个运行过程。通过估计尘盒所能容纳的垃圾重量，我们会事先在树莓派的程序逻辑中设定重量上限，当尘盒中垃圾超过该上限时，机器人启动倾倒垃圾流程，前往垃圾箱的路线可由用户预先自定义设定，机器人到达垃圾箱后，树莓派控制金属杆伸缩将尘盒弹出，然后转动金属杆将尘盒中的垃圾倒入垃圾箱内，最后将尘盒转动复位，收回机器人体内，继续清扫或其它工作。另外，除垃圾重量超过界限会触发倒垃圾操作外，每次清扫完整个家都会进行一次倒垃圾的操作。 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:4:2","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 智能语音交互功能 从“萌蠢”等词我们可以判断出人们已经对扫地机器人倾注了一定的情感，为了强化这一方面的能力，我们决定将智能语音助手与机器人的中枢—树莓派相结合，使其成为人们的精神伴侣，同时，也可以用来控制扫地机器人的工作，免去复杂的APP操作。 硬件层面，我们添加麦克风和扬声器作为语音的输入输出设备。软件层面，我们通过调用科大讯飞的API对录入的语音做识别，然后调用图灵机器人API获得问题答案，再通过科大讯飞的语音合成服务将语音输出，完成整个循环。除此之外，我们还针对扫地机器人的工作指令关键词做特别优化，当识别到这些关键词时，自动调用相关逻辑，实现语音控制机器人完成各种工作的功能。另外，由于整体的工作流程依赖于对各API的调用，所以工作过程需要保持联网，我们通过设置树莓派的WIFI模块使其始终保持和家里无线网络的连接。 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:4:3","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 承重功能 自扫地机器人面世以来，家中以猫和狗为代表的宠物与机器人的斗争就从未停止，不仅仅宠物们极其喜欢站在扫地机器人上面，如图4所示，我们自身也会觉得扫地机器人的外形很合适宠物站在上面。然而目前市场上的扫地机器人设计并没有考虑这一点，其承重能力往往不足以支持宠物的存在，而我们往往在日常生活中对宠物们这样的做法又无可奈何，因此，增加扫地机器人的承重能力刻不容缓。 通过调查得知，幼猫体重一般为70至900克，成年猫则平均为2.5-5.5千克，小型宠物犬和成年猫体重相似。而根据我们找到的资料，如小米的石头扫地机器人承重为2.3千克左右，所以，我们只需要通过一定的结构设计，就能增加足够宠物体重的承重。主要通过内部空隙填充三角形结构，表面做成翻折状来实现，就如同我们将纸不断的折叠来承重一样 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:4:4","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"市场分析 该扫地机器人针对的消费人群主要是： 1）懒癌患者，希望将倒垃圾工作一起自动化的用户； 2）家养宠物人士，能有效防止扫地机器人被宠物破坏； 3）独居人士，做家务的同时完成语音助手的职能，通过聊天来给予客户精神慰藉。 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:5:0","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["爱编程爱技术的孩子"],"content":"风险分析 风险在于树莓派的使用相对于普通单片机来讲，增加了一定的成本，而不论是语音助手、倒垃圾的机械结构还是承重结构都是极易仿制的东西，况且，这些思路都处于初级阶段，改进空间很大。以目前排名前三的扫地机器人厂家的市场占有量，如果在前期我们无法夺取一定的市场，将会面临艰难的竞争。 ","date":"2019-03-26","objectID":"/2019/raspberry-project-sweeping-robot/:6:0","tags":["树莓派"],"title":"树莓派项目构想-扫地机器人","uri":"/2019/raspberry-project-sweeping-robot/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Atin Angrisha, Benjamin Cravera, Mahmud Hasana, Binil Starly Published in：46th SME North American Manufacturing Research Conference, NAMRC 46, Texas, USA 被引量：7次 keywords：blockchain; cyber-physical systems; smart contracts; ethereum; decentralized networks; shareable databases ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:0:0","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 随着产品定制成为新的商机，制造商必须找到在无信任网络中进行协作和实现信息共享的方法。在本文中，我们提出“FabRec”：一种用于处理由各制造商使用区块链技术产生的制造信息的方法。其中，制造机器和计算节点构成去中心化网络来实现制造过程的自动化与透明化，基于对历史记录的审计实现对制造过程的第三方验证，使用智能合约实现参与者之间无纸化合同。同时，系统将与制造相关的信息分类，并使其在P2P网络上可用，以通过可验证的审计跟踪确保透明度和数据来源。我们通过组合制造机器，片上系统（SoC, System on chip）和计算节点来建立测试平台，以展示组成联盟的不同制造商可以通过分布式网络进行通信的机制。我们的测试平台原型展示了驻留在分布式网络上的计算机代码的价值：用于验证区块链的信息以及在物理世界中自动启动操作的方式。本文旨在通过测试平台揭示系统组成，为更大规模的测试做准备，并讨论区块链在制造业的未来潜力。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:1:0","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"I. Introduction 各制造商间及与机器间互联形成的制造网络为产品定制创造了机会。但参与方之间的信任是个问题，传统方式是通过多方的协商签订合同来达成信任。这一过程在产品定制这一生产模式下的经济可行性无法达成。现有的解决方案都在某种场景下存在现在从而无法很好的解决这一问题。 区块链技术是一种很好的解决方案，没有中心化控制，任何得到授权的参与者都可以查看和写入数据，而写入的数据是不可变的，因此建立了可信的数据来源。间接的，通过可公开查看的历史数据，制造商可以建立其区块链保障之外的信誉体系。 当前企业级区块链的实时依赖于Ethereum、EOS、Hyperledger和CoCo等提供的区块链基础设施，以及改进的区块链数据库技术如BigChainDB。驱动制造业应用的核心结构还有待发展。需要开发新技术来验证网络上机器的身份，在区块链中记录的事件在节点间得到验证和协调，定义节点的角色和职责，所有这些设计将支撑智能制造业网络中各级参与者之间的交互。 本文主要内容包括： 一个分布式框架‘FebRec'的提出 一个使用实验室设备（包括计算节点、片上系统、制造机器）组成的测试模型 一组智能合约用来说明机器如何自动交互、事件如何验证、共识机制的实现等。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:2:0","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"II. System Implementation ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:3:0","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 FabRec系统总览 图2.1 FavRec Overview 图2.1中的虚线代表信任域的边界，整个系统能实现跨信任域的受控信息共享，即允许跨信任域边界的数据集成。系统中参与者可能是人类、制造机器、计算节点以及制造商的代理， 每个参与者在网络中都有一个唯一的地址用于验证，经过验证的制造商从世界任何地点都能访问网络； 制造商重要的机器资产也可以被授予访问权限； 机器的构建者也可以是网络的一部分，或者提供数据，或者获得对区块链部分数据的访问权限。诸如寻找制造商的设计者，需要验证制造商的能力或者在网络上提出服务请求； 同样，监管机构、代理商都可以验证制造商的说明，特别是医疗植入物、航空航天部件等受监管的产品。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:3:1","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 区块和交易结构 制造商拥有多台为客户提供服务的机器，每台机器都能唯一标识并拥有向私有区块链（所属制造商加入的那条链）直接写入’事件‘的能力。最终都被收集到区块中，而区块内容（即载荷）取决于： 机器类型 记录的事件类型 记录到区块中的交易数量 因此，一个块可包含与机器操作相关的多个交易。这些交易可包括几种类型： 机器信息，例如安装，服务更新，机器升级，故障，报废，生命周期内的访问日志等，可以包括机器类型、机器功能、机器所有者、服务提供者、操作员列表等的描述; 机器使用情况，包括如整体设备效率（OEE），正常运行时间，维护日志，功耗等的事件记录； 机器能力，如使用的材料，特征的复杂性，原始工件类型等 所有的交易类型都以一种类JSON的文本结构进行记录。 一个示例区块结构如图2.2所示，包含了有关机器信息的交易。 图2.2 example of block structure 随着车间中机器的不断使用，事件也被不断的记录到链中。因此，当客户打算与制造商进行交易时，可以被授予访问历史制造记录的权限，验证数据的真实性和来源。这种信息共享可以提高制造商的信誉并增加赢得新业务的几率。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:3:2","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 智能合约结构 制造业产生的数据时大量的、多样的、动态的和专属的，为了对数据进行操作，设计了三种智能合约结构。 Global Registrar Contract(GRC) 主要功能是建立一个映射列表，将每个参与者（人类、代理商、机器等）同它们的以太坊地址相对应。当映射关系创建或改变时，可通过调用合约添加或修改条目。另外，合约还允许将参与者身份和其历史记录对应起来。 Participant Historical Event Contract(PHEC) 合约功能是允许检索与参与者相关的历史制造数据。还包含特定参与者与链上其它节点间的关系记录。通过检索历史记录可以帮忙建立信誉 Participant Relationship Contract(PRC) 合约当链中参与者和客户建立关系时启动并初始化，PRC中的每个条目都包含参与者间的约束协议和与该关系相关的元数据。有一个状态来只是关系是当前的、无效的还是成功完成的。如果该关系的涉及双方同意，还可以将关系的详细信息向全链参与者公开。PRC维护访问指针，以维护相关的参与者工厂内特定关系的详细数据历史记录。 三种智能合约的结构如图2.3所示。 图2.3 Smart Contract Structure in FabRec 为了说明，一个关于涉及制造商、机器和消费者的智能合约场景如下： 客户需要加工零件，并寻找满足其价格、质量和时间需求的制造商。客户通过发起交易，通过GRC合约搜索符合功能要求的地址列表。然后通过制造商的PHEC合约维护的历史记录进一步过滤选择，一旦客户和制造商通过PRC合约建立关系，客户就可以发送资金到代表机器的智能合约，机器可以根据工作标志和建议资金选择是否接受订单。订单被接受后，机器将作业排队，并把交易收集存储到区块上。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:3:3","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"2.4 FavRec系统节点间的数据交换 设计了FavRec的组件，能够和目前制造企业使用的基础设施集成，假设这些已有的系统值得信任，每个企业拥有自己的内部数据库，记录了零件制造的详细信息。如图2.4，我们引入了四个组件，每个组件都有自己的作用： A Machine’s Virtual Twin Library，The virtual twin library enables machine communication with the digital twin/virtual manufacturing machine built on top of a NoSQL database 以太坊客户端，用于与区块链交互 Nodal Database Sentry through MongoDB，Nodal Sentry可以被认为是执行加密证明的程序， FabRec区块链管理器，以可视化的人类可读的形式追踪区块链上交易，类似于etherscan.io但是用于机器数据。 图2.4 Data Exchange between participants 提供了这些组件的实现，这些组件与MongoDB数据库集成并通过用户界面进行管理。此外，任何数据库后端和用户界面都可以实现即插即用功能，只要它们可以通过API调用区块链上的相关智能合约。 值得注意的是，FabRec并不包括与零件制造相关的详细过程数据，而是只包括一个指针，这些数据存在企业内部数据库，当获得许可时，FabRec能通过指针访问这些数据。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:3:4","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"III. 原型实现与评估 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:4:0","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 测试平台搭建 为了仿真该系统，我们建立了一个包括四个独立计算机的区块链网络，这些计算机作为区块链的参与者，代表不同的制造服务提供商，两个被指定为矿工包含区块链的完整副本。使用以太坊作为区块链平台，一个节点连接到Arduino，通过一个Python脚本与区块链网络相连，该脚本通过对JSON-RPC的API调用保持检查智能合约。交易可以通过geth控制台和python脚本完成，非计算密集型的python脚本允许单板计算机（本实验即Arduino）以低成本读写事件。 机器通过Beaglebone Black中的MachineKit接口（LinuxCNC的修改形式）也连接到网络，成为网络中的节点。在MachineKit OS中编写的脚本将关键事件（例如机器开/关/工作状态）发送到网络，矿工节点验证事件真实性并将其添加到区块链，可以对事件进行批处理以提高数据收集到区块的效率。仿真系统旨在演示智能合约如何处理机器传递的事件，并触发到另一台物理设备的命令，如控制Arduino板上LED的亮灭。并且，设备不必位于同一制造工厂的网络中，即同一信任域内。 图3.1 Physical devices interacting on the FabRec 如图3.1所示，智能合约设置为以交易的形式接受来自不同实体的出价。使用脚本通过API检查所有事件，并查找想要的字符串，查找到字符串后，脚本向Arduino发送信号使LED亮起。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:4:1","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 Proof of Authority(PoA)共识 专用于私链的共识算法，链中有许多预批准的授权节点，有这些节点决定链中新块的添加，这些节点独立的验证区块内容，然后对区块进行投票，最后将区块添加到链中。 以太坊的测试网络可以使用PoA共识 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:4:2","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 结果 为了使用实验室中生成的机器数据测试两种共识算法，利用了以太坊的测试网络Ropsten(PoW)和Kovan(PoA)，分析了两个指标：交易被包含在区块链的区块中所需事件和链延长到一定长度达成不可变所需的时间。两个指标都显示PoA较好。 但这不意味着PoW更差，主要是根据场景来判断。区块链的安全特性是牺牲网络性能换来的，这意味着区块链不是特别适合于实时数据传输和做决策。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:4:3","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"IV. 工业上部署的挑战 区块链的本质要求它是去中心化的，自然而然的，这种情况下如何管理网络上的节点，并且可以信任对外部参与者的恶意攻击的抵御能力。必须设计新的商业模式来激励各制造商利益相关者参与网络，确保没有一组实体控制网络。 对许多制造商而言，共享制造数据是一个敏感话题 由于安全问题和缺乏基础设施，机器缺乏网络连接，阻碍了区块链更大规模的使用 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:5:0","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"V. Conclusion FabRec原型提供了连接计算节点和物理设备（如Arduino / Raspberry PI和基本CNC机器）的概念验证系统，以证明在去中心化的和可互操作的网络上连接这些节点的可行性。我们使用以太坊智能合约，根据物理机器在网络另一部分记录的事件，自动启动给予Arduino系统的命令。展示了三种不同智能合约的数据模型。 ","date":"2019-03-25","objectID":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/:6:0","tags":["论文笔记"],"title":"A Case Study for Blockchain in Manufacturing “FabRec”","uri":"/2019/a-case-study-for-blockchain-in-manufacturing-fabrec/"},{"categories":["研究生的区块链学习之路"],"content":"Author： Yinqiu Liu, Kun Wang, Yun Lin, and Wenyao Xu Published in：IEEE Transactions on Industrial Informatics State：Early Access Index Terms：Blockchain, Industrial Internet of Things, Distributed System, Consensus Mechanism, Data Filter. ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:0:0","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 虽然区块链和IIoT之间的结合得到了广泛的关注，但区块链的高资源需求和IIoT设备的有限性能之间的矛盾还无法较好的解决。一方面，由于公钥结构、默克尔树和PoW等数学概念的引入，部署区块链需要巨大的算力；另一方面，全节点应该能同步大量的区块数据和处理P2P网络中的大量交易。IIoT设备难以承受其对存储容量和带宽的占用。本文中，我们提出了名为LightChain的轻量级区块链使其适用于IIoT场景，提出了一个名为**Synergistic Multiple Proof（SMP）的共识机制来促进IIoT设备间的合作，提出了一种称为LightBlock（LB）**的轻量级数据结构，用于简化广播内容。此外，还设计了一种 **Unrelated Block Offloading Filter (UBOF)**以避免分类帐的无限增长，同时不影响区块链的可追溯性。实验表明，LightChain可以将计算成本降低39.32％，将块生成速度提高74.06％。在存储和网络使用方面，降幅分别为43.35％和90.55％。 ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:1:0","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"一、Introduction IIoT被大量采用，但有如下问题： 拥有大量分散的设备，面对DDoS攻击是脆弱的 中心化的管理结构无法自我认证，会产生隐私泄露问题 LPWAN的发展使大量IIoT设备在地理上是分离的，中心化服务的花费难以承受 最近大家都在研究如何将区块链部署在IIoT来解决上述问题。 基于区块链不可否认和难以篡改的特性，在P2P网络中共同维持工业信息，可以实现数据追溯，并达成在非信任环境中的价值传递 区块链能提供分布式的域名服务，有助于解决当前DNS的漏洞，诸如DDoS攻击和DNS欺骗 已有区块链和IoT/IIoT结合的例子如Ruffchain等。然而，IIoT设备无法满足区块链的高资源需求。有很多方案来优化区块链的资源消耗问题，如： Ehmke[23]，区块链协议PoP，允许不必下载整个区块而验证交易 Dorri[24]，私有不可变分类账，中心化的管理 Li[25]，DAG Zamani[26]，分片（Sharding） Bitcoin-NG，leadership selection Multichain，cross-chain mechanism 但它们都只优化一方面。 将区块链部署在IIoT场景面临的关键问题包括： 打包区块有奖励，所以算力高的节点会持续增加算力，所有节点陷入算力竞争，最后由于马太效应，导致算力集中 为了实现分布式的一致性，区块链需要参与者保存网络中产生的大量数据，所有的数据保存在本地并不断增长而没有减少，会占用大量存储空间 IIoT场景异构网络很常见，在高吞吐量的情况下，资源有限的节点无法支持区块链相关的操作 本文为了解决上述问题，本文提出一种轻量级区块链，资源问题和解决方案如下： 算力—通过新的共识方案SMP 存储空间—检测不相干块（UB），通过一个过滤器（UBOF）过滤它们，减少存储占用 网络资源—广播数据结构LightBlock而不是整个块，减少广播时通信的冗余 ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:2:0","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"二、Proposal ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:3:0","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"1. Framework 整个方案分四层，如图1所示，从上到下依次是：API层，LightChain层，Cache层，Storage层。 图1. Four-layer framework of LightChain 各层功能如下： API层：提供各种操作的请求接口 LightChain层：即普遍意义上的区块链，包括共识机制等部分 Cache层：用了加速对调用操作的响应 Storage层：提供持久化的存储，通常只由资源富裕的节点提供此服务 如图1，以具体的工厂实例来说明，传感器发起的交易请求通过局域网发送到Node1，Node1的API层处理这些请求并发送到区块链（即LightChain层），在LightChain层完成验证。受限于存储问题，将数据存储分为两类，完整的区块链数据会存在云端数据库作为备份，Node1会对数据进行过滤缓存有效数据。 ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:3:1","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"2. LightChain Layer LightChain层的结构如图2， 图2. Architecture of LightChain layer，由Conchain，Webchain和Chainbase三部分组成。类似于C/S架构，Conchain/Webchain是Client端。模块间通信通过本地Socket完成。 Webchain：将API层发送的操作类型和JSON流转换称预定义的信息类型和二进制流 Conchain：在本地挖到新块或接受到块验证请求后，将消息发送到Chainbase 共识机制—减少资源消耗 P2P网络—减少广播冗余 Chainbase：管理本地交易池，验证交易，拥有添加或过滤Cache layer数据缓存的权限 ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:3:2","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"三、Evaluation 构建实验网络时模拟了IIoT的实际场景。主要考虑了IIoT场景的以下特征 网络异构及地理分离 资源限制 复杂的网络拓扑 使用阿里云的10台ECS构建了一个P2P网络，ECSs作为全节点（矿工节点）工作，并且各ECS具有不同的CPU和内存，部署在亚洲多个地点，算力级别在MH/s，符合IIoT设备能力，每个ECS拥有自己的公网IP，同一地点的ECS在同一网段。 开发了一个自动交易生成器，控制几个交易并间隔固定的时间提交随机交易，这里的账户作为P2P网络中的轻量级节点。 每个矿工连接到一个交易生成器，设置两个参数，一个控制账户数量，决定P2P网络的规模；一个用于控制交易生成的间隔。 ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:4:0","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"1. 安全分析 分析对几种攻击的抵御能力： 双花攻击 无厉害关系（PoS中同时在多个fork上投票以获取最大利益） ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:4:1","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"2. 结果分析 共识： CPU使用率：减少 块生成速度：增加 算力消耗：减少 网络：通信冗余减少 存储：过滤区块，存储减少 ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:4:2","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"四、Conclusion 为了使区块链适用于IIoT场景，提出共识算法SMP减少算力消耗，提出数据结构LB减少通信冗余，过滤区块减小存储负担。并通过实验证明了该方案的优越性。 ","date":"2019-03-19","objectID":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/:5:0","tags":["论文笔记"],"title":"LightChain:A Lightweight Blockchain System for Industrial Internet of Things","uri":"/2019/lightchaina-lightweight-blockchain-system-for-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"区块链的本质是一个只增数据库，这就意味着其中存储的数据会随着时间的推移不断增加，而区块链分布式的特性要求节点需要存储区块链的整个副本，因此，区块链对节点存储能力的要求是越来越高的。 因此，我们首先来分析普通的电脑是否能应付区块链不断增长的体积，考虑最流行的比特币和以太坊两个平台。 ","date":"2019-03-16","objectID":"/2019/data-storage-in-blockchain/:0:0","tags":["科研记录"],"title":"研究记录1-区块链的数据存储问题","uri":"/2019/data-storage-in-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"1. 区块链的数据承载能力 以比特币和以太坊为例，但不考虑硬分叉产生的 Bitcoin Cash 和 Ethereum Classic，只考虑比特币和以太坊的主干，到 2019.01.11 15:06 为止，一些数据总结如下表，数据来源为 BitInfoCharts。 Bitcoin Ethereum Transactions last 24h 319853 583335 Transactions avg. per hour 13327 24306 Block Time(出块时间) 9m 28s 15.4s Blocks Count 558038 7046728 Blocks last 24h 151 5586 Blocks avg. per hour 6 233 First Block 2009-01-09 2015-07-30 Blockchain Size 232.51GB 667.10GB 首先，从总体上看。比特币发展十年链上数据共232.51GB，以太坊667.10GB，现有的存储介质，一台普通的电脑即可承受，但是，物联网设备是难以承受的。 从单位时间产生的数据量看区块链的承受能力，数据来源为 区块链浏览器。下面两个图分别展示了到 2019.01.11 15:36 为止 Bitcoin 和 Ethereum 最近的五个区块的情况，图中“大小（KB）”一栏右起第一个逗号实际上是小数点。比如第一个图(Bitcoin)中第一行数值中的1,162,094，实际上是1162.094KB；第二个图中第一行数值中的31,052，实际上是31.052KB 从已掌握的知识以及上面两个图可以看出，每个块中的交易数量是不定的，交易的大小也难以确定，所以数据量的大小我们以区块为最小单位。区块链出块的时间是受到控制的，但是具体到每个区块，出块时间都有不同，区块的大小也不同，而上面两个图中五个数据的样本较小，我们利用上面的表中的“平均每小时区块数”和下图中区块大小的历史变化做一定估计。下图数据来源为 BitInfoCharts，蓝色为比特币区块大小变化，红色为以太坊区块大小变化。 结合已掌握的知识，比特币控制区块大小在 1M 左右，当然，这么长时间的发展，比特币的区块扩容之路非常坎坷，并因此衍生出多条硬分叉。但此次我们只考虑 1M 限制的这种情况。另外，我们还简单的把整个区块的大小作为数据大小，不考虑区块头等固定结构的存在，这种情况下： $$ 比特币每秒处理的数据量 = \\frac {平均每小时区块数 \\times 区块大小}{3600} \\approx 1.71KB $$ 而在以太坊中，理论上对交易大小或区块的大小都没有什么规定，不过这并不意味着交易携带的数据量大小没有上限，因为一个区块可以使用的 gas 是有上限的，叫做 gas limit。截至写这篇文章时，即 2019.01.11 16:40 为止，ethstats 显示的这个值为 8,000,029，约为 800万。因此，理论上，我们通过创建一个交易，让它消耗掉一个区块能用的全部 gas，就能得知一个交易理论上可以包含的最多数据。另外，决定数据大小的另一个因素是数据内容，因为不同的数据消耗的 gas 不同，具体的情况见 以太坊黄皮书 的附录G. Fee Schedule。为了便于计算，我们抽取如下几条： 4gas，paid for every zero byte of data or code for a transaction 68gas，paid for every non-zero byte of data or code for a transaction 21000，paid for every transaction 就假设没有非零字节数据了，这种情况下： $$ 一笔交易的最大数据量 = \\frac {8000029-21000}{68 \\times 1024} \\approx 114.59KB $$ 同时，这大概也是一个区块的数据量上限。虽然实际环境下，根本达不到这么大（使用以太坊钱包Mist尝试过创建），而且在图2中也显示出了区块的大小基本都在 40KB 以下，但我们还是使用这个理论值做接下来的计算。和比特币的计算类似： $$ 以太坊每秒处理的数据量 = \\frac {平均每小时区块数 \\times 区块大小}{3600} \\approx 177.81KB $$ 综上，以太坊平台下，预计物联网设备每秒产生的数据在 177.81KB 以下的话，可以直接将数据存在区块链中，而实际上，这个值已经是各种情况下的最优值了，正常运行能存的数据大小要比这个小的多。 在工业环境下我们经常考虑实时性问题，一开始我以为这实际上是数据量的问题，即使是非实时的数据采集，但当数据量足够大时，也和实时数据的情况无异。但现在明白，实时的含义就是即时的响应，这是区块链的延迟永远无法企及的，只能尽量提高。 ","date":"2019-03-16","objectID":"/2019/data-storage-in-blockchain/:1:0","tags":["科研记录"],"title":"研究记录1-区块链的数据存储问题","uri":"/2019/data-storage-in-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"2. 区块链存储数据的几种选择 考虑数据存储在区块链中时，我们先来考虑这样做是否是值得的，因为，区块链上存数据相比于传统数据库真的是昂贵的 首先考虑目前的去中心化存储的概况，来自 Wulf Kaal在Quora的回答 当前的区块链应用存储数据有如下几种选择： 把一切都存在区块链里 P2P文件系统（Peer to peer file system），比如IPFS 去中心化的云文件存储，如Storj, Sia, Ethereum Swarm等 分布式数据库，如Apache Cassandra, Rethink DB等 巨链数据库 BigChainDB Ties DB 对每一种进行详细分析： 把一切都存在区块链里：最简单粗暴的解决方案。目前，大多数简单的去中心化应用程序都以这种方式工作。然而，这个方法有显著的缺点。首先，区块链交易确认缓慢。对于汇款来说，它似乎很快（每个人都可以等），但是，对于丰富的应用程序数据流来说，它实在是太慢了。因为丰富的应用程序每秒可能有数千次交易。其二，它是不可变的。不可变性是区块链的优势，它给了区块链高稳健性，但是对于数据存储来说却是个弱点。用户可能更改他们的个人资料或者更换照片，但先前的数据将会永远留在区块链中，任何人都能看到。这种不可变性造成了另外一个缺点，就是容量问题。如果所有的应用程序都将数据保存在区块链中，区块链的容量将会飞快增长，超过公开可用的硬盘容量大小。完整节点可能需要特殊硬件。它也许会导致区块链风险的集中化。这就是为什么在区块链中存储数据对于丰富的去中心化应用程序来说，不是个好选择。 P2P文件系统，如IPFS：IPFS 允许在客户端计算机上共享文件，并把它们整合到全局文件系统中。这个技术建立在 BitTorrent 协议和分布式哈希表（Distributed Hash Table）的基础之上。 它确实是对等的或点对点的，分享之前先存放到你自己的计算机上 。任何人只有在需要的时候才会去下载。它是内容可寻址的，因此不可能通过给定地址伪造内容。因为 BitTorrent 协议，才可以飞快地下载热门文件。但是，它也有一些缺点。如果你要分享文件，就得保持在线。至少在有人对你的文件感兴趣，想从你那里下载之前保持在线。它只提供静态文件，一旦上传，它们就不能被修改或删除。当然，你也不能通过其有意义的内容来搜索它们。 在IPFS中，数据被切分成block存储，通过散列表寻找块所在节点，但当数据内容小于1kb时，会直接和散列表放在一起上传给IPFS节点，不用额外再占用一个块。IIoT场景下，小数据量时，数据同样可以以交易形式直接寄存在区块链中。然而这个数据量的大小这个分界线如何判断是最关键的问题。 去中心化的云文件存储：还有一些去中心化云文件存储，它们去掉了 IPFS 的一些限制。从用户的角度来看，这些存储就是像 Dropbox 那样的云存储。区别在于内容是托管在用户的计算机上，而不是在数据中心里，这些用户出租硬盘空间而已。如今，有很多这样的项目。例如，Sia，Storj，Ethereum Swarm。你不再需要保持在线就能分享你的文件。只需上传文件，就可以在云中使用了。这些存储非常可靠，速度快，容量大。但是它们只提供静态文件，也没有内容搜索，还因为它们都是建立在租用的硬件上，所以不是免费的 分布式数据库：因为我们需要存储结构化的数据，并寻求高级查询能力，所以我们可以看一下分布式 noSql 数据库。为什么是 noSql 呢？因为有 CAP 定理的限制，严格的事物性 SQL 数据库不能真正地分布。为了让数据库分布，我们不得不要么牺牲一致性，要么牺牲可用性。NoSQL 数据库选择了可用性而不是一致性，代替一致性的是所谓“最终一致性”，即在网络中所有的数据库节点在一段时间之后会变得一致。这样的数据库有很多成熟的实现，如 MongoDB，Apache Cassandra，RethinkDB 等等。它们非常好——速度快、可扩展、容错、支持丰富的查询语言，但是对我们的应用程序来说有致命缺点。它们不是拜占庭证明（Byzantine-proof）。集群中的所有节点相互之间完全信任。因此，任何一个恶意节点就能毁掉整个数据库。 巨链数据库：另外一个名为巨链数据库的项目声称可以解决数据存储和交易速度问题。它也是区块链，拥有巨大的数据容量和非常快的交易。让我们看看它是怎么做到的。巨链数据库建立于 RethinkDB 集群之上。巨链数据库用它来存储所有的区块和交易。这是它显示出如此高的吞吐量的原因，它是基础 noSQL 数据库中的其中一个。所有的巨链数据库节点（用 BDB 表示）连接到集群，拥有对数据库的完全写访问权限。这里出现了一个问题，整个巨链数据库不是拜占庭证明的！任何恶意的 BDB 节点可以破坏 RethinkDB 集群。巨链数据库团队意识到这个问题，承诺将来会解决这个问题，然而它是这个架构的基石，要改动它几乎是不可能的。无论如何，巨链数据库可能对私有区块链很有用。但是，如果要避免混淆，它应该被叫做巨型私有区块链（BigPrivateBlockchain）。它不是公共存储的选项 Ties DB：这是目前好的公共数据库的可选项。最接近理想的是 noSQL 数据库。它们唯一缺乏的是拜占庭容错（Byzantine fault tolerance）。Ties.Network 数据库：ties.network 是对 Cassandra 数据库的深度修改，提供了一个更好的解决方案：TiesDB 继承了基础 noSQL 数据库的大部分功能，并增加了拜占庭容错和激励。有了这些功能，它可以成为公共数据库，并通过智能合约在 Ethereum 和其他区块链上启用功能丰富的应用程序。任何用户都有数据库写入权限。但是，用户由他们的公钥识别，同时，所有的请求有签名。创建之后，记录记住它的创建者，创建者则成为记录的所有者。之后，记录只能被记录所有者修改。每个人都可以阅读所有的记录，因为数据库是公开的。根据请求和复制检查所有的权限。额外的权限可以通过智能合约管理。 总的来讲，不论使用集中式的存储还是如上任何一种分布式的存储，都取决于应用场景。对于 IoT 数据来将，将数据完全存在区块链里是不值得的，同时也无法实现，理想的存储方式包括 Ties DB，去中心化的云文件存储（如Swarm），P2P文件系统（如IPFS） 当然，还有一篇 How Blockchain Data Storage Can Work for Enterprise Data Management 供参考 ","date":"2019-03-16","objectID":"/2019/data-storage-in-blockchain/:2:0","tags":["科研记录"],"title":"研究记录1-区块链的数据存储问题","uri":"/2019/data-storage-in-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"3. 论文中使用的存储方案 第二节提供了存储数据的几种选择，这一节我们总结一些论文中具体使用的方案和相应的原因。 Román, Victor, and Joaquín Ordieres-Meré. \"[WiP] IoT Blockchain Technologies for Smart Sensors Based on Raspberry Pi.\" 2018 IEEE 11th Conference on Service-Oriented Computing and Applications (SOCA). IEEE, 2018. Román首先考虑了几种可选的经典存储方案，如 InfluxDB，MongoDB和MariaDB。这些方案面临像由数据库引擎本身不可用（关机，维护等）引起的数据丢失问题，同时，一个主要的限制是，这样一个系统中的查询需要共享对不同用户的访问权限，存储的数据能够轻易的暴露给攻击者。作者选用了 BigchainDB 作为存储方案，主要因为其结合了区块链和分布式数据库的优点，如下表： 实际上，如下图，作者选用了不同的存储方案以适应不同的情况。如果数据旨在内部流通，则MariaDB足够；如果利益来自于产品价值链相关的不同组织，则使用BigchainDB；当商业模型中的利益需要公众参与，为了提供合适的透明度等级，应当使用完全公开的架构，即IOTA的Tangle。 Yu, Xiao Liang, Xiwei Xu, and Bin Liu. \"EthDrive: A Peer-to-Peer Data Storage with Provenance.\" *CAiSE-Forum-DC*. 2017. 这篇使用IPFS。传统的云存储是中心化的系统，依赖于可信第三方来提供所有服务。在这样的中心化架构下，首先，云服务商可读、写和删除云中数据。其次，云存储中的数据可用性也存疑，虽然在多个云服务商那里存储数据可以增加数据可用性，但由于供应商锁定，需要大量的工作。 主要是对用户来讲，云服务商如何处理数据不是透明的，数据的完整性和可用性通常不包含在服务内容中，即使保证服务完整性，用户也难以验证，除非做一些额外的工作。只能信任云服务商显然是不利的。 文章提出了分布式存储方案EthDrive，并比较了它和云存储的时间性能，结果显示，当数据规格小于20MB时，分布式方案有更好的性能，当数据规格大于30MB时，云存储有更好的性能。 Liu, Bin, et al. \"Blockchain based data integrity service framework for IoT data.\" *2017 IEEE International Conference on Web Services (ICWS)*. IEEE, 2017. 依然是IPFS，云存储需要保证数据的机密性、完整性和可用性（CIA要求），虽然较为困难，但目前有方案通过加密机制保证数据的完整性。不过，当为不同平台提供动态物联网数据完整性服务时，这种方式缺乏灵活性。另外，我们只考虑了数据所有者需要验证它们在云中存储的数据的完整性的情况，但实际上，共享数据的数据消费者的需求在持续增加，而它们可能并不信任数据所有者所信任的云服务商。 该文提出的分布式数据完整性验证和传统的基于中心化云的完整性验证有如下优点： 更可靠，云无法单方面终止 随着客户端数量增加，数据完整性验证的效率得以增强 支持和数据消费者交易数据，并保证每笔交易的数据完整性 Ayoade, Gbadebo, et al. \"Decentralized iot data management using blockchain and trusted execution environment.\" *2018 IEEE International Conference on Information Reuse and Integration (IRI)*. IEEE, 2018. 使用SGS，由于物联网设备处理能力的限制，通常利用第三方服务商来做数据处理。由于用户将敏感的隐私数据传输给第三方服务商，用户被迫必须信任服务商实施了数据保护并提供了数据隐私保障。遗憾的是，服务商并没有这么做，它们经常违反数据隐私政策，使用从用户那里收集的数据用于未经授权的目的。服务商的这种不正当优势基于集中式架构，其中需要信任第三方系统作为中央权威来管理用户数据。为了消除服务提供商和用户之间数据访问策略执行中的这些不平衡，作者提出了一种基于区块链和智能合约的分布式数据管理系统。 论文使用了Inter的可信执行环境保存数据，其架构如下图： Ozyilmaz, Kazim Rifat, and Arda Yurdakul. \"Designing a Blockchain-Based IoT With Ethereum, Swarm, and LoRa: The Software Solution to Create High Availability With Minimal Security Risks.\" *IEEE Consumer Electronics Magazine* 8.2 (2019): 28-34. 以太坊的Swarm，使用Swarm主要是因为它是一个和以太坊集成的点对点存储方案，它承诺零停机时间，并且具有DDOS抗性，容错性和抗审查性。它是一种类似torrent的服务，内置激励措施，可以保证由于与以太网网络层的高度耦合而导致上传的数据持久性。因此，它是针对物联网的存储服务的强有力候选者 Ali, Saqib, et al. \"Secure Data Provenance in Cloud-Centric Internet of Things via Blockchain Smart Contracts.\" *2018 IEEE SmartWorld, Ubiquitous Intelligence \u0026 Computing, Advanced \u0026 Trusted Computing, Scalable Computing \u0026 Communications, Cloud \u0026 Big Data Computing, Internet of People and Smart City Innovation (SmartWorld/SCALCOM/UIC/ATC/CBDCom/IOP/SCI)*. IEEE, 2018. 使用传统的云存储。云服务通过以低成本为大型网络提供高处理能力，无限存储容量和高可扩展性来增强物联网设备。此外，云为底层异构物联网网络提供有效的管理服务，同时为利用物联网设备产生的数据的应用提供高效灵活的中间层。 云存储可以轻松访问从位于网络不同位置的大量物联网设备收集的数据。因此，使云应用或第三方能够更有效地分析数据以便做出决策。 ","date":"2019-03-16","objectID":"/2019/data-storage-in-blockchain/:3:0","tags":["科研记录"],"title":"研究记录1-区块链的数据存储问题","uri":"/2019/data-storage-in-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"完整梳理 Multichain 虽然针对的是金融领域，但是在 2.0 中推出了一种称之为 off-chain 的结构用来存储大量的数据，减轻区块链负担，在这一特性的描述中，Multichain 对区块链数据存储问题给出了一个非常棒的总结。 文章地址：https://www.multichain.com/blog/2018/06/scaling-blockchains-off-chain-data/ ","date":"2019-03-16","objectID":"/2019/data-storage-in-blockchain/:4:0","tags":["科研记录"],"title":"研究记录1-区块链的数据存储问题","uri":"/2019/data-storage-in-blockchain/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 前言 该工作为课程作业，主要目标为利用树莓派作为服务器，完成wordpress的配置，建立动态博客网站。详细的作业要求如下： 制作raspbian系统的镜像并成功启动树莓派 安装apche2，mariadb，php，phpmyadmin等软件 安装wordpress 登录wordpress后台，发送任一篇技术文章 使用本地计算机完成对博客网站的访问 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:1:0","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 树莓派启动 在官网下载raspbian系统，利用「Win32DiskImager」软件将下载好的镜像写入准备好的SD卡。写入完成后，在boot目录下新建 wpa_supplicant.conf 文件，复制下面的内容到该文件并修改WIFI名和密码，保存该文件，这一步是为了在树莓派启动时令其自动连接到电脑。 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=CN network={ ssid=\"WiFi名\" psk=\"密码\" key_mgmt=WPA-PSK priority=1 } 然后同样在boot目录下新建名为ssh的文件，要注意小写且没有扩展名，从而开启SSH连接。 将配置好的SD卡从电脑卸载并以正确的方式插入树莓派，通电启动，在路由器后台查看新加入的名称中包含raspberry的设备，记录其ip地址，然后使用Putty通过该地址登录树莓派。 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:2:0","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 软件安装 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:3:0","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"apache2 $ sudo apt-get install -y apache2 $ apachectl -v Server version: Apache/2.4.25 (Debian) Server built: 2018-11-03T18:46:19 浏览器地址栏输入localhost，显示It works!界面 查看apache2状态 $ service apache2 status ● apache2.service - The Apache HTTP Server Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: Active: active (running) since Thu 2019-03-14 09:48:04 CST; 2min 31s ago Main PID: 2788 (apache2) Tasks: 55 (limit: 4915) CGroup: /system.slice/apache2.service ├─2788 /usr/sbin/apache2 -k start ├─2869 /usr/sbin/apache2 -k start └─2870 /usr/sbin/apache2 -k start 3月 14 09:47:48 raspberry systemd[1]: Starting The Apache HTTP Server... 3月 14 09:48:04 raspberry apachectl[2709]: AH00558: apache2: Could not reliably d 3月 14 09:48:04 raspberry systemd[1]: Started The Apache HTTP Server. lines 1-13/13 (END) ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:3:1","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"mariadb 以下两条命令没什么区别，安装的软件包数量和名称都一样 $ sudo apt-get install -y mariadb-server # 或下面这条，执行任一句即可 $ sudo apt-get install -y mysql-server mysql-client $ mysql -V mysql Ver 15.1 Distrib 10.1.37-MariaDB, for debian-linux-gnu (i686) using readline 5.2 进入数据库设置密码，新建用户，授予权限 $ sudo mysql -u root -p #按回车键输入密码 \u003e create user 'shuzang'@'localhost' identified by '2427'; #按回车键 \u003e grant all privileges on *.* to 'shuzang'@'localhost'; #给权限 \u003e flush privileges; # 刷新权限 \u003e show grants for 'shuzang'@'localhost'; #查看用户权限 \u003e exit; ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:3:2","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"php $ sudo apt-get install -y php php-mysql php-fpm $ php -v PHP 7.0.33-0+deb9u3 (cli) (built: Mar 8 2019 10:01:24) ( NTS ) 有讲解决PHP无法解析（只显示代码）的问题，需要安装php7.0-mysql和libapache2-mod-php7.0，但是查看上面这条命令安装的软件包你会发现这两个已经装过了，所以不管它，后面也证实了没有出现这个问题。 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:3:3","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"phpmyadmin $ sudo apt-get install -y phpmyadmin 安装时会出现一些选项，选择如下： Web server：apache2 Configure database for phpmyadmin with dbconfig-common?：yes mysql application password for phpmyadmin：xxx (‘xxx'是自己输的密码) 再次输入密码确认 授予执行权限和开启rewrite模块 $ sudo chmod 777 /var/www/html $ sudo a2enmod rewrite 把phpmyadmin软连接到/var/www/html $ sudo ln -s /usr/share/phpmyadmin /var/www/html 重启apache2 $ sudo systemctl restart apache2 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:3:4","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"wordpress $ cd /var/www/html $ sudo wget https://cn.wordpress.org/latest-zh_CN.tar.gz $ sudo tar -zxvf latest-zh_CN.tar.gz $ sudo mv wordpress liuyang $ sudo chmod 777 liuyang ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:3:5","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 建立动态博客 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:4:0","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"新建数据库 浏览器地址栏输入localhost/phpmyadmin，出现界面，输入数据库的用户名密码 进入数据库管理页面，新建数据库，输入数据库名 空数据库就不用管了，不用新建表 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:4:1","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"配置wordpress 浏览器地址栏输入localhost/liuyang，进入五分钟安装过程。 填写博客信息 在最后一步选择「登录」按钮，跳转到登录界面登录 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:4:2","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"主题安装 登录后进入仪表盘，选择侧边栏「外观—\u003e主题」，获取安装主题origami(可以自由选择其它主题) $ cd /var/www/html/liuyang/wp-content/themes $ sudo wgethttps://github.com/syfxlin/origami/releases/download/v1.0.5/Origami-1.0.5.zip $ sudo unzip Origami-1.0.5.zip $ sudo rm -rf Origami-1.0.5.zip 回到主题页面刷新可以看到安装的主题，启用 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:4:3","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"发布文章 点「文章—\u003e写文章」，然后写一篇文章，发布。可以点右上角预览按钮预览，也可以点左上角主页按钮进入博客网站主页。博客页面如下： 在本地计算机访问虚拟机中wordpress时，CSS无法加载，需要在仪表盘设置—\u003e常规更改wordpress地址和站点地址，把两个地址中的localhost都改成虚拟机ip 保存设置，然后在本地计算机使用该地址访问，即可成功显示网站和博客文章 ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:4:4","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"参考资料 [1] 简书-cyzyjin. debian9 LAMP安装. 2018.12. [3] CSDN-霍莉雪特. 外网访问WordPress时无法加载样式表CSS. 2017.06. [4] NEUQ金课行动. 2019创客实战训练营-11树莓派搭建WORDPRESS网站. 2019.01. [5] NEUQ金课行动. 使用虚拟机安装X86版本的raspbian. 2019.03. ","date":"2019-03-13","objectID":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/:5:0","tags":["树莓派"],"title":"利用树莓派作为服务器建立动态博客","uri":"/2019/using-virtual-machine-as-raspberry-pi-server-to-build-dynamic-blog/"},{"categories":["研究生的区块链学习之路"],"content":"在以太坊github的官方项目地址发现其支持Docker启动，同时因为Docker相对于虚拟机的易用性，决定尝试使用Docker搭建以太坊联盟链 Docker安装部分查看自官方说明，搭建过程主要参考简书-使用Docker搭建以太坊私有链并部署合约 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:0:0","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"一、Docker安装 OS环境：Ubuntu 18.04 LTS(bionic) 内核版本：4.18.0-16-generic 处理器架构：amd64 官方的安装说明位于：Get Docker CE for Ubuntu 官方一共提供了三种安装方式，为了简便，我们选择直接下载.deb包安装 前往地址https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/下载安装所需文件，包括以下三个 ├── containerd.io_1.2.4-1_amd64.deb ├── docker-ce_18.09.3_3-0_ubuntu-bionic_amd64.deb └── docker-ce-cli_18.09.3_3-0_ubuntu-bionic_amd64.deb 进入下载文件所在目录，执行下列安装命令 $ sudo dpkg -i docker-ce-cli_18.09.3_3-0_ubuntu-bionic_amd64.deb $ sudo dpkg -i containerd.io_1.2.4-1_amd64.deb $ sudo dpkg -i docker-ce_18.09.3_3-0_ubuntu-bionic_amd64.deb 通过运行hello-world镜像验证安装完成 $ sudo docker run hello-world 该命令会下载一个测试镜像并在容器中运行它，运行时可以从终端看到如下信息说明安装成功，运行结束自动退出。 Hello from Docker! 更新Docker 通过.deb包安装Docker只能再次下载最新的安装包并重复执行安装步骤来更新 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:1:0","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"二、获取geth镜像 docker hub上有现成的geth镜像，使用pull命令直接获取。 $ sudo docker pull ethereum/client-go 默认安装latest版，试运行 $ sudo docker run -it --rm -v /workspace:/workspace --entrypoint /bin/sh ethereum/client-go -i：打开STDIN，用于控制台交互，常与-t一起使用 -t：分配tty设备，支持终端登陆，默认为false，常与-i一起使用 --rm：指定容器停止后自动删除容器（不支持以docker run -d启动的容器 ） -v：给容器挂载存储卷，挂载到容器的某个目录，这里讲本地的/workspace挂载到了容器的/workspace目录，用来在容器和宿主机之间共享文件 --entrypoint：覆盖image的入口点，ubuntu环境下docker默认入口点其实是/bin/bash，修改默认入口点是为了不让节点自动运行，稍后会对节点进行自定义配置使其成为私有链节点 查看本地镜像列表 $ sudo docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ethereum/client-go latest f376688623dc 3 hours ago 42.7MB hello-world latest fce289e99eb9 2 months ago 1.84kB 证实geth镜像获取完成，同时也能看到之前测试docker安装是否完成时获取的hello-world镜像 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:2:0","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"三、创建Docker网络 推荐是创建一个自有网络，然后将需要互联的容器配置到相同的网络中，此处我们创建名为“ethnet\"的网络，该网络配置如下： 子网172.18.0.0/16 IP段172.18.0.0 掩码255.255.0.0 IP范围172.18.0.1~172.18.255.254 IP广播172.18.255.255 使用如下命令创建该网络 $ sudo docker network create -d bridge --subnet=172.18.0.0/16 ethnet -d：指定网络类型 --subnet：指定网段 使用如下命令查看创建的网络 $ sudo docker network ls b88630402852 bridge bridge local 3fb4ed66c9e1 ethnet bridge local 0414b4eff7ae host host local 5668e7baf5ee none null local 其中第二个网络名为\"ethnet”，正是我们创建的，其它三个是默认的网络。关于docker的几种网络的说明见docker中的网络 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:3:0","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"四、配置以太坊网络 运行如下命令进入一个容器 $ sudo docker run -it --rm --network ethnet --ip 172.18.0.50 -v /workspace:/workspace --entrypoint /bin/sh ethereum/client-go --network ethnet指定了该容器加入刚才创建的ethnet网络 --ip 172.18.0.50指定了一个固定IP给该容器 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:4:0","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"1. 创建账户 首先，在容器内的/workspace目录下创建如下目录结构和文件 dapp\\ dapp\\miner\\ dapp\\data\\ dapp\\genesis.json 运行如下命令创建账户 cd /workspace/dapp/miner geth -datadir ./data account new 输入两次password，获得地址，将地址记录备用。重复以上命令可创建多个账户。 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:4:1","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"2. 创建创世区块 编辑刚才创建的文件dapp\\genesis.json内容如下 { \"config\": { \"chainId\": 88, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : { \"0x79b43b2196723fff1485999aba45fda3e8b4df58\": {\"balance\": \"100000000000000000000\"}, \"0x1ae06a8afd157b97f072a97f5c62fa836f5ef597\": {\"balance\": \"1000000000000000000\"}, \"0xa75b4db0c6bfa416d544e3316d47af0fb01eb828\": {\"balance\": \"1000000000000000000\"}, \"0x1a037d8e8e16a4c88e17c3d5f29ee26a9f5b2c85\": {\"balance\": \"1000000000000000000\"} }, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x400\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000000\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } alloc下面列举了4个账户地址，正是是上一步骤创建并记录下来的地址。 balance是创世区块为每个账户分配的初始以太币，单位是wei。1eth=10^18wei。也就是除了第一个账户给了100eth外，其它几个账户分别只拥有1eth。 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:4:2","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"3. 完成以太坊网络配置 此时完成配置可使用exit命令退出容器，由于启动容器时加入了--rm参数，退出后刚才的容器会被删除，但宿主机的/workspace下的文件会被保存下来 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:4:3","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"五、创建以太坊网络 以上已经配置好了一个以太坊私有网络，下面开始正式创建。我们需要一个矿工节点和多个普通节点。 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:5:0","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"1. 创建矿工节点 矿工节点应具有如下特性： 它是一个容器，并且是持久的容器 它会自动读取genesis.json文件，并初始化以太坊网络 它能够连接其它节点（容器） 它能够接受各种rpc调用，并能够部署合约 它已经配置好挖矿账户，可以一键挖矿 按照以上要求我们来创建矿工节点 创建entrypoint脚本 创建文件：/workspace/dapp/init.sh 文件内容如下： #!/bin/sh geth -datadir ~/data/ init /workspace/dapp/genesis.json if [ $# -lt 1 ]; then exec \"/bin/sh\" else exec /bin/sh -c \"$@\" fi 该脚本的功能是让以太坊节点（容器）自动初始化以太坊网络，并且接受一个自动运行脚本作为输入 创建自动运行脚本 创建文件：/workspace/dapp/mine.sh，文件内容如下： #!/bin/sh cp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/ geth -datadir ~/data/ --networkid 88 --rpc --rpcaddr \"172.18.0.50\" --rpcapi admin,eth,miner,web3,personal,net,txpool --unlock \"0x79b43b2196723fff1485999aba45fda3e8b4df58\" --etherbase \"0x79b43b2196723fff1485999aba45fda3e8b4df58\" console 第一行命令是将刚才生成的账户私钥文件拷贝到容器的~/data目录下。因为/workspace是宿主目录挂载的，并不是linux文件系统，直接将datadir指定到该目录会导致geth报错。 第二行命令是启动以太坊节点的命令。 –networkid 88指定了networkid，这个必须与genesis.json内设置保持一致 –rpc –rpcaddr “172.18.0.50” –rpcapi …. 这些参数表示该节点接受rpc，并且指定了rpc的协议 –unlock “0x…” 加入该参数会需要用户输入账户密码。密码校验后会解锁该账户。账户解锁后，该节点就能使用此账户的私钥进行签名加密等动作，用以进行交易、发布合约等。 –etherbase 参数指定了挖矿收益账户 创建容器 因为我们没有授予普通用户直接执行docker的权力，所以这里要先给与执行两个脚本的权力 $ sudo chmod +x init.sh mine.sh 创建容器 $ sudo docker run -it --name=miner --network ethnet --ip 172.18.0.50 --hostname node -v /workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go /workspace/dapp/mine.sh --name=miner指定容器名为miner 该命令会创建一个持久化的容器，容器的entrypoint和自动运行脚本指定为刚刚我们创建的两个脚本 使用ps命令查看容器创建情况 $ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e42f48b1435a ethereum/client-go \"/workspace/dapp/ini…\" 14 hours ago Exited (0) 13 hours ago miner 0384dace397f hello-world \"/hello\" 23 hours ago Exited (0) 23 hours ago clever_cur ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:5:1","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"2. 创建普通节点 我们需要创建更多的节点来形成一个分布式的网络。 创建自动运行脚本 要使容器位于同一个网络，应当使他们利用同一个genesis.json初始化，即共享entrypoint脚本，只需要单独创建自动运行脚本即可 创建普通节点的自动运行脚本：/workspace/dapp/node.sh #!/bin/sh cp -r /workspace/dapp/miner/data/keystore/* ~/data/keystore/ geth -datadir ~/data/ --networkid 88 console 授予执行权限 $ sudo chmod +x node.sh 创建容器 $ sudo docker run -it --name=node1 --network ethnet --ip 172.18.0.51 --hostname node1 -v /workspace:/workspace --entrypoint /workspace/dapp/init.sh ethereum/client-go:v1.8.12 /workspace/dapp/node.sh 这里的容器名指定为node1，查看当前容器创建情况 $ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 23273d430443 ethereum/client-go \"/workspace/dapp/ini…\" 14 hours ago Exited (0) 13 hours ago node1 e42f48b1435a ethereum/client-go \"/workspace/dapp/ini…\" 14 hours ago Exited (0) 13 hours ago miner 0384dace397f hello-world \"/hello\" 23 hours ago Exited (0) 23 hours ago clever_cur ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:5:2","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"3. 节点连接 以上两个容器使用run命令运行后都会自动进入geth的js交互式环境下，等待输入命令 \u003e 查看节点已连接情况 \u003e admin.peers [] 在miner容器交互界面执行下列命令查看miner节点信息 \u003e admin.nodeInfo.enode \"enode://334268de4cb42842bc1957af05bd1df7d6a1ce806279bb6637298e595c4e36794e92e6c59b7090a538120307576eb1791df61c234daa89e7acb541307a3b24da@127.0.0.1:30303\" 在node1容器交互界面执行下列命令动态添加miner节点 \u003e admin.addPeer(\"enode://334268de4cb42842bc1957af05bd1df7d6a1ce806279bb6637298e595c4e36794e92e6c59b7090a538120307576eb1791df61c234daa89e7acb541307a3b24da@172.18.0.50:30303\") true 查看已连接节点数 \u003e net.peerCount 2 查看已连接节点情况 \u003e admin.peers [{ caps: [\"eth/62\", \"eth/63\"], enode: \"enode://334268de4cb42842bc1957af05bd1df7d6a1ce806279bb6637298e595c4e36794e92e6c59b7090a538120307576eb1791df61c234daa89e7acb541307a3b24da@172.18.0.50:30303\", id: \"831e42a7dfb08c648b77aa7396f17033dd103259b30791b87318b08b7ef1e67d\", name: \"Geth/v1.9.0-unstable-7504dbd6/linux-amd64/go1.12\", network: { inbound: false, localAddress: \"172.18.0.51:34858\", remoteAddress: \"172.18.0.50:30303\", static: true, trusted: false }, protocols: { eth: { difficulty: 263168, head: \"0x7e03472bcad02f6e85a3cdb21cfba856da58a4955dd2b6d21e3b8561446ae390\", version: 63 } } }, { caps: [\"eth/62\", \"eth/63\"], enode: \"enode://213e6b175eb2378b42d2564897d32855eae37f7960fe0a378c44f315ca178267bcff076835483274a2385952bf607b1fc1e39eda5be0b03dd1a0ec375ea5b3dc@59.66.19.211:30303\", id: \"86701d83afc9c055c682a3fbe033acf9c5a378c18e0a76c1e13d9e72aa957278\", name: \"Geth/v1.8.22-unstable-dc43ea8d/linux-amd64/go1.11\", network: { inbound: false, localAddress: \"172.18.0.51:45836\", remoteAddress: \"59.66.19.211:30303\", static: false, trusted: false }, protocols: { eth: \"handshake\" } }, { caps: [\"eth/62\", \"eth/63\", \"par/1\", \"par/2\", \"par/3\", \"pip/1\"], enode: \"enode://09f36adecd8110413be39b5bd9dfb9b06f9575d60db1ba9e4ef0796fadee0346fed412f0147136b6a557f725b0a0944dba92a885e0afdd84345fb80d469650f8@35.175.179.140:30303\", id: \"f2b63e1d6dee827ad5bbbc27341223b7463713a67d1a92c1778a5365d6353e67\", name: \"Parity-Ethereum/v2.1.4-beta-bee2cb8-20181028/x86_64-linux-gnu/rustc1.30.0\", network: { inbound: false, localAddress: \"172.18.0.51:46864\", remoteAddress: \"35.175.179.140:30303\", static: false, trusted: false }, protocols: { eth: \"handshake\" } }] 然后就可以完成挖矿、转账、部署合约等其它操作了。 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:5:3","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"4. 退出 使用exit命令会直接退出geth，同时退出容器 \u003e exit INFO [03-13|03:18:52.778] HTTP endpoint closed url=http://172.18.0.50:8545 INFO [03-13|03:18:52.778] IPC endpoint closed url=/root/data/geth.ipc INFO [03-13|03:18:52.778] Writing cached state to disk block=2 hash=7e0347…6ae390 root=741c08…123b78 INFO [03-13|03:18:52.778] Persisted trie from memory database nodes=0 size=0.00B time=7.039µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [03-13|03:18:52.778] Writing cached state to disk block=1 hash=ed8c7f…98bd7c root=b2e71c…818333 INFO [03-13|03:18:52.778] Persisted trie from memory database nodes=0 size=0.00B time=1.037µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [03-13|03:18:52.778] Blockchain manager stopped INFO [03-13|03:18:52.778] Stopping Ethereum protocol INFO [03-13|03:18:52.778] Ethereum protocol stopped INFO [03-13|03:18:52.778] Transaction pool stopped shuzang@ubuntu:~$ 此时使用docker ps命令会发现正在运行的容器列表为空，此时使用start命令可启动关闭的容器 $ sudo docker start -i miner 继续进入miner容器的geth环境，然后使用Ctrl+P+Q快捷键可以退出但不关闭当前容器，此时使用docker ps查看则发现miner容器还在运行列表 然后使用如下命令可进入容器bash环境而不进入geth环境，这种情况下便于我们进行一些需要在容器环境下执行的操作，比如编辑静态节点文件static-nodes.json $ sudo docker exec -it miner /bin/sh 我们之前创建的脚本都是把/keystore拷贝到容器中~/data目录下执行的，现在来查看该目录的路径和有哪些文件 / # cd ~/data ~/data # pwd /root/data ~/data # ls geth geth.ipc history keystore 此时可使用exit命令退出容器，注意，因为我们这次是用exec命令登入的，所以退出时不关闭容器，使用ps命令仍能在运行容器列表中看到miner 当然，也可以使用attach命令而不是exec命令进入，但这样退出会直接退出容器，不会出现在运行列表中 ","date":"2019-03-12","objectID":"/2019/use-docker-to-build-ethereum-private-chain/:5:4","tags":["区块链"],"title":"以太坊开发6-Docker搭建以太坊私链","uri":"/2019/use-docker-to-build-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"文章翻译自：Connecting to the network ","date":"2019-03-12","objectID":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/:0:0","tags":["区块链"],"title":"以太坊开发5-以太坊节点连接到网络的几种方式","uri":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/"},{"categories":["研究生的区块链学习之路"],"content":"如何寻找对等节点 在初始化时，geth会使用一组记录在源码中的bootstrap节点来连接。要指定这些节点，只需使用--bootnodes选项，并使用逗号分隔参数，举例如下： geth --bootnodes enode://pubkey1@ip1:port1,enode://pubkey2@ip2:port2,enode://pubkey3@ip3:port3 使用情况为：第一个节点已启动，并使用admin.nodeInfo.enode获得其地址，在启动第二个节点时，直接加入--bootnodes选项和第一个节点的地址作为参数，可以直接连接两个节点 ","date":"2019-03-12","objectID":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/:1:0","tags":["区块链"],"title":"以太坊开发5-以太坊节点连接到网络的几种方式","uri":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/"},{"categories":["研究生的区块链学习之路"],"content":"常见问题 无法连接的时候，常见的一些原因如下： 本地时钟错误。以太坊连接需要一个准确的时钟，因此，需要检查操作系统的时间并和网络进行同步，不然，即使相差12秒也会造成连接失败。一个时间同步的命令例如： $ sudo ntpdate -s time.nist.gov 防火墙配置错误导致阻止了UDP连接。此时可以使用静态节点进行连接或使用admin.addPeer()手动配置连接 若想使网络不被发现，可以在geth启动时使用--nodiscover选项 ","date":"2019-03-12","objectID":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/:2:0","tags":["区块链"],"title":"以太坊开发5-以太坊节点连接到网络的几种方式","uri":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/"},{"categories":["研究生的区块链学习之路"],"content":"检查连接 为了检查有多少个节点已连接，net模块提供了两个命令来查询已连接节点数量和是否处于监听状态 \u003e net.listening true \u003e net.peerCount 4 若想获取更多关于已连接节点的信息，诸如IP地址和端口号、支持的协议等，可以使用admin.peers命令，会返回最近连接的节点列表。 \u003e admin.peers [{ ID: 'a4de274d3a159e10c2c9a68c326511236381b84c9ec52e72ad732eb0b2b1a2277938f78593cdbe734e6002bf23114d434a085d260514ab336d4acdc312db671b', Name: 'Geth/v0.9.14/linux/go1.4.2', Caps: 'eth/60', RemoteAddress: '5.9.150.40:30301', LocalAddress: '192.168.0.28:39219' }, { ID: 'a979fb575495b8d6db44f750317d0f4622bf4c2aa3365d6af7c284339968eef29b69ad0dce72a4d8db5ebb4968de0e3bec910127f134779fbcb0cb6d3331163c', Name: 'Geth/v0.9.15/linux/go1.4.2', Caps: 'eth/60', RemoteAddress: '52.16.188.185:30303', LocalAddress: '192.168.0.28:50995' }, { ID: 'f6ba1f1d9241d48138136ccf5baa6c2c8b008435a1c2bd009ca52fb8edbbc991eba36376beaee9d45f16d5dcbf2ed0bc23006c505d57ffcf70921bd94aa7a172', Name: 'pyethapp_dd52/v0.9.13/linux2/py2.7.9', Caps: 'eth/60, p2p/3', RemoteAddress: '144.76.62.101:30303', LocalAddress: '192.168.0.28:40454' }, { ID: 'f4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0', Name: '++eth/Zeppelin/Rascal/v0.9.14/Release/Darwin/clang/int', Caps: 'eth/60, shh/2', RemoteAddress: '129.16.191.64:30303', LocalAddress: '192.168.0.28:39705' } ] 要检查geth使用的端口和允许节点的enode URL，如下： \u003e admin.nodeInfo { Name: 'Geth/v0.9.14/darwin/go1.4.2', NodeUrl: 'enode://3414c01c19aa75a34f2dbd2f8d0898dc79d6b219ad77f8155abf1a287ce2ba60f14998a3a98c0cf14915eabfdacf914a92b27a01769de18fa2d049dbf4c17694@[::]:30303', NodeID: '3414c01c19aa75a34f2dbd2f8d0898dc79d6b219ad77f8155abf1a287ce2ba60f14998a3a98c0cf14915eabfdacf914a92b27a01769de18fa2d049dbf4c17694', IP: '::', DiscPort: 30303, TCPPort: 30303, Td: '2044952618444', ListenAddr: '[::]:30303' } ","date":"2019-03-12","objectID":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/:3:0","tags":["区块链"],"title":"以太坊开发5-以太坊节点连接到网络的几种方式","uri":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/"},{"categories":["研究生的区块链学习之路"],"content":"静态节点 Geth还支持一种名为静态节点的特性，如果你有一组确定的节点需要连接，你可以使用静态节点，静态节点在断开连接时会尝试重连。通过配置如下路径的文件来使用。 \u003cdatadir\u003e/geth/static-nodes.json [ \"enode://f4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0@33.4.2.1:30303\", \"enode://pubkey@ip:port\" ] 也可以在Js命令行的运行环境添加静态节点，也就是我们之前所说的手动配置： admin.addPeer(\"enode://f4642fa65af50cfdea8fa7414a5def7bb7991478b768e296f5e4a54e8b995de102e0ceae2e826f293c481b5325f89be6d207b003382e18a8ecba66fbaf6416c0@33.4.2.1:30303\") 目前控制台不支持移除节点、增加节点数量以及增加非静态节点（断开连接时不重连的节点） ","date":"2019-03-12","objectID":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/:4:0","tags":["区块链"],"title":"以太坊开发5-以太坊节点连接到网络的几种方式","uri":"/2019/the-way-to-connect-to-the-network-about-ethereum-node/"},{"categories":["研究生的区块链学习之路"],"content":"Geth Console是一个交互式的JavaScript执行环境，其中\u003e是命令提示符。在这个环境里也内置了一些用来操作以太坊的JavaScript对象，可以直接使用这些对象。这些对象主要包括： eth：包含一些跟操作区块链相关的方法； net：包含一些查看p2p网络状态的方法； admin：包含一些与管理节点相关的方法； miner：包含启动\u0026停止挖矿的一些方法； personal：主要包含一些管理账户的方法； txpool：包含一些查看交易内存池的方法； web3：包含了以上对象，还包含一些单位换算的方法。 ","date":"2019-03-08","objectID":"/2019/geth-console-command/:0:0","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"1. console命令 ","date":"2019-03-08","objectID":"/2019/geth-console-command/:1:0","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 简单启动 最简单的启动方式如下 $ geth console 控制台启动成功后，可以看到\u003e提示符，等待输入控制台命令 \u003e 输入exit退出 \u003e exit ","date":"2019-03-08","objectID":"/2019/geth-console-command/:1:1","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 日志控制 使用geth console启动会在交互界面不时出现日志提示，可以将日志输出到文件 ~/Desktop$ geth console 2\u003e\u003egeth.log 此时geth.log日志文件位于命令执行时的目录下，比如我执行命令在~/Desktop目录，geth.log文件也在这里。可以自己手动打开文件查看日志，当然也可以新开一个终端用tail命令查看日志 $ tail -f geth.log ","date":"2019-03-08","objectID":"/2019/geth-console-command/:1:2","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"1.3 重定向日志 实际上还可以将日志输出到另一个终端，也就是重定向日志。先在2号终端输入： $ tty dev/pts/1 获取得到终端编号，然后在1号终端输入如下命令，就可以将日志输出到2号终端 $ geth console 2\u003e\u003e /dev/pts/1 不想看到日志的话也可以选择将日志输出到空的终端 $ geth console 2\u003e\u003e /dev/null 正常的不输出日志的方式实际上并不是使用如上命令，而是使用--verbosity来控制日志级别，此时不输出日志的命令如下 $ geth --verbosity 0 console ","date":"2019-03-08","objectID":"/2019/geth-console-command/:1:3","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"2. attach命令 另一个启动geth交互式JavaScript环境的方法是连接到一个geth节点 geth attach ipc:{ipc_file_path} # geth.ipc 文件路径 geth attach http://191.168.1.1:8545 # JSONRPC 的地址 geth attach ws://191.168.1.1:8546 注意，要连接到的节点在启动时必须开启ipc服务，不然不会产生geth.ipc文件。产生的geth.ipc文件位于存放链数据的data文件下，即datadir命令后面跟的文件目录，和keystort文件以及geth文件位于同一级目录。 $ tree ~/Desktop -L 2 /home/shuzang/Desktop ├── data │ ├── geth │ ├── geth.ipc │ ├── history │ └── keystore ├── genesis.json └── geth.log 3 directories, 4 files ","date":"2019-03-08","objectID":"/2019/geth-console-command/:2:0","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"3. Management API 该部分翻译自：management API 除官方 DApp APIs 接口外，go-ethereum还支持额外的一些Management API。与DApp API类似，这些也是使用JSON-RPC提供的，并遵循完全相同的规范。这些API正是应用在Geth提供的控制台中。 除了官方公布的DApp API（如eth，shh，web3）之外，额外的Management API列表如下： admin: Geth node management debug: Geth node debugging miner: Miner and DAG management personal: Account management txpool: Transaction pool inspection admin debug miner personal txpool addPeer backtraceAt setExtra ecRecover content datadir blockProfile setGasPrice importRawKey inspect nodeInfo cpuProfile start listAccounts status peers dumpBlock stop lockAccount setSolc gcStats getHashrate newAccount startRPC getBlockRlp setEtherbase unlockAccount startWS goTrace sendTransaction stopRPC memStats sign stopWS seedHashsign setBlockProfileRate setHead stacks startCPUProfile startGoTrace stopCPUProfile stopGoTrace traceBlock traceBlockByNumber traceBlockByHash traceBlockFromFile traceTransaction verbosity vmodule writeBlockProfile writeMemProfile ","date":"2019-03-08","objectID":"/2019/geth-console-command/:3:0","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 Admin adminAPI给了我们几种非标准的RPC方法，允许我们对Geth实例进行细粒度的控制，包括但不限于网络节点和RPC的端点管理。 admin.addPeer(url) 该方法请求添加一个新的远程节点到跟踪的静态节点列表中，节点将始终尝试保持与这些节点的连接，如果远程节点断开，则每隔一段时间尝试重连一次。 \u003e admin.addPeer(\"enode://a979fb575495b8d6db44f750317d0f4622bf4c2aa3365d6af7c284339968eef29b69ad0dce72a4d8db5ebb4968de0e3bec910127f134779fbcb0cb6d3331163c@52.16.188.185:30303\") true admin.datadir 用于查找正在运行的Geth节点当前用于存储的数据库的绝对路径 \u003e admin.datadir \"/home/Karalabe/.ethereum\" admin.nodeInfo 查询当前网络正在运行的Geth节点的所有已知信息，包括节点作为P2P网络参与者的本身的信息和它自己运行的应用协议（e.g. eth,les,shh,bzz）的专有信息。 \u003e admin.nodeInfo { enode: \"enode://44826a5d6a55f88a18298bca4773fca5749cdc3a5c9f308aa7d810e9b31123f3e7c5fba0b1d70aac5308426f47df2a128a6747040a3815cc7dd7167d03be320d@[::]:30303\", id: \"44826a5d6a55f88a18298bca4773fca5749cdc3a5c9f308aa7d810e9b31123f3e7c5fba0b1d70aac5308426f47df2a128a6747040a3815cc7dd7167d03be320d\", ip: \"::\", listenAddr: \"[::]:30303\", name: \"Geth/v1.5.0-unstable/linux/go1.6\", ports: { discovery: 30303, listener: 30303 }, protocols: { eth: { difficulty: 17334254859343145000, genesis: \"0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\", head: \"0xb83f73fbe6220c111136aefd27b160bf4a34085c65ba89f24246b3162257c36a\", network: 1 } } } admin.peers 和admin.nodeInfo相似，但查询的是所有连接的远程节点的信息 \u003e admin.peers [{ caps: [\"eth/61\", \"eth/62\", \"eth/63\"], id: \"08a6b39263470c78d3e4f58e3c997cd2e7af623afce64656cfc56480babcea7a9138f3d09d7b9879344c2d2e457679e3655d4b56eaff5fd4fd7f147bdb045124\", name: \"Geth/v1.5.0-unstable/linux/go1.5.1\", network: { localAddress: \"192.168.0.104:51068\", remoteAddress: \"71.62.31.72:30303\" }, protocols: { eth: { difficulty: 17334052235346465000, head: \"5794b768dae6c6ee5366e6ca7662bdff2882576e09609bf778633e470e0e7852\", version: 63 } } }, /* ... */ { caps: [\"eth/61\", \"eth/62\", \"eth/63\"], id: \"fcad9f6d3faf89a0908a11ddae9d4be3a1039108263b06c96171eb3b0f3ba85a7095a03bb65198c35a04829032d198759edfca9b63a8b69dc47a205d94fce7cc\", name: \"Geth/v1.3.5-506c9277/linux/go1.4.2\", network: { localAddress: \"192.168.0.104:55968\", remoteAddress: \"121.196.232.205:30303\" }, protocols: { eth: { difficulty: 17335165914080772000, head: \"5794b768dae6c6ee5366e6ca7662bdff2882576e09609bf778633e470e0e7852\", version: 63 } } }] admin.setSolc(path) 当调用eth_compileSolidityRPC方法时用来设置Solidity编译器路径，不设置的话，默认路径是/usr/bin/solc \u003e admin.setSolc(\"/usr/bin/solc\") \"solc, the solidity compiler commandline interface Version: 0.3.2-0/Release-Linux/g++/Interpreter path: /usr/bin/solc\" admin.startRPC(host, port, cors, apis) 开启一个基于JSON RPC的HTTP Webserver来处理客户端请求，参数含义如下： host: network interface to open the listener socket on (默认\"localhost\") port: network port to open the listener socket on (默认8545) cors: cross-origin resource sharing header to use (默认 \"\") apis:通过此接口提供的API模块 (默认 \"eth,net,web3\") 返回一个布尔值表示HTTP RPC监听是否打开，任何时候只允许一个HTTP端点保持活动 \u003e admin.startRPC(\"127.0.0.1\",8545) true admin.startWS(host, port, cors, apis) 和RPC相似，不同的是开启的是WebSocket Websever。Example \u003e admin.startWS(\"127.0.0.1\", 8546) true admin.stopRPC() 和RPC开启对应，关闭HTTP Webserver \u003e admin.stopRPC() true admin.stopWS() 和WebSocket开启对应，关闭WebSocket Webserver \u003e admin.stopWS() true Q：HTTP和WebSocket有啥区别 A：HTTP协议和WebSocket协议（一）, HTTP协议和WebSocket协议（二） ","date":"2019-03-08","objectID":"/2019/geth-console-command/:3:1","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 Debug 提供一些非标准的RPC方法，运行我们在运行时检查、调试和设置某些调试标志 这部分的话从上面表格也看出来了，方法比较多，而且是调试用，就不细列了，用的时候查就行了。 ","date":"2019-03-08","objectID":"/2019/geth-console-command/:3:2","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 Miner 允许我们远程控制节点的挖矿操作并进行各种挖矿相关的设置 miner.setExtra(string)：设置一个矿工挖矿时可以包含的额外数据，最大32字节 miner.setGasPrice(number)：设置挖矿时接受的最低Gas价格，低于此价格的交易不会被收集到区块 miner.start(number)：以给定数量的线程启动CPU挖矿进程，如果需要生成新的DAG miner.stop()：停止CPU挖矿操作 miner.setEtherbase(address)：设置挖矿奖励账户地址 ","date":"2019-03-08","objectID":"/2019/geth-console-command/:3:3","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"3.4 Personal 管理私钥 personal.listAccounts 返回密钥库中所有密钥对应的以太坊账户地址 \u003e personal.listAccounts [\"0x5e97870f263700f46aa00d967821199b9bc5a120\", \"0x3d80b31a78c30fc628f20b2c89d7ddbf6e53cedc\"] personal.newAccount() 生成新的私钥并将其存储在密钥库目录中。密钥文件使用给定的密码加密。返回新帐户的地址。未提供参数时，会在控制台提示输入密码。 \u003e personal.newAccount() Passphrase: Repeat passphrase: \"0x5e97870f263700f46aa00d967821199b9bc5a120\" 也可以直接提供参数作为密码 \u003e personal.newAccount(\"h4ck3r\") \"0x3d80b31a78c30fc628f20b2c89d7ddbf6e53cedc\" personal.unlockAccount(address, passphrase, duration) 使用密码解密密钥库中某个地址对应的账户。使用JavaScript控制台时，密码短语和解锁持续时间都是可选的。如果密码短语未作为参数提供，控制台将以交互方式提示输入密码短语。 解锁持续时间默认为300秒，geth退出持续时间也会结束。帐户解锁时可以与eth_sign和eth_sendTransaction一起使用。 \u003e personal.unlockAccount(\"0x5e97870f263700f46aa00d967821199b9bc5a120\") Unlock account 0x5e97870f263700f46aa00d967821199b9bc5a120 Passphrase: true 提供密码字段和持续时间作为参数 \u003e personal.unlockAccount(\"0x5e97870f263700f46aa00d967821199b9bc5a120\", \"foo\", 30) true 如果不想将密码字段作为参数显式输入，但又想设置持续时间，如下 \u003e personal.unlockAccount(\"0x5e97870f263700f46aa00d967821199b9bc5a120\", null, 30) Unlock account 0x5e97870f263700f46aa00d967821199b9bc5a120 Passphrase: true personal.sendTransaction(tx, passphrase) 验证给定的密码短语并提交交易。该交易与eth_sendTransaction的参数相同，并包含from地址。如果验证了密码短语可以用来解锁tx.from的账户，签名并发送到网络上。该帐户未在节点中全局解锁，不能在其他RPC调用中使用。 \u003e var tx = {from: \"0x391694e7e0b0cce554cb130d723a9d27458f9298\", to: \"0xafa3f8684e54059998bc3a7b0d2b0da075154d66\", value: web3.toWei(1.23, \"ether\")} undefined \u003e personal.sendTransaction(tx, \"passphrase\") 0x8474441674cdd47b35b875fd1a530b800b51a5264b9975fb21129eeb8c18582f personal.sign(message, account, [password]) \u003e personal.sign(\"0xdeadbeaf\", \"0x9b2055d370f73ec7d8a03e965129118dc8f5bf83\", \"\") \"0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b\" personal.ecRecover(message, signature) 返回与某个私钥相关联的地址，该私钥用于personal.sign中计算签名 \u003e personal.sign(\"0xdeadbeaf\", \"0x9b2055d370f73ec7d8a03e965129118dc8f5bf83\", \"\") \"0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b\" \u003e personal.ecRecover(\"0xdeadbeaf\", \"0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b\") \"0x9b2055d370f73ec7d8a03e965129118dc8f5bf83\" personal.lockAccount(address) 从内存中删除具有给定地址的私钥。该帐户不能再用于发送交易。 personal.importRawKey(keydata, passphrase) 将给定的未加密私钥（十六进制字符串）导入密钥存储区，并使用密码短语对其进行加密。返回新帐户的地址 ","date":"2019-03-08","objectID":"/2019/geth-console-command/:3:4","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"3.5 Txpool 给我们访问交易池和排队队列中待处理交易的权限，交易池中是所有挂起的交易 txpool.content 返回交易池和待处理交易队列中的内容 \u003e txpool.content { pending: { 0x0216d5032f356960cd3749c31ab34eeff21b3395: { 806: [{ blockHash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", blockNumber: null, from: \"0x0216d5032f356960cd3749c31ab34eeff21b3395\", gas: \"0x5208\", gasPrice: \"0xba43b7400\", hash: \"0xaf953a2d01f55cfe080c0c94150a60105e8ac3d51153058a1f03dd239dd08586\", input: \"0x\", nonce: \"0x326\", to: \"0x7f69a91a3cf4be60020fb58b893b7cbb65376db8\", transactionIndex: null, value: \"0x19a99f0cf456000\" }] }, 0x24d407e5a0b506e1cb2fae163100b5de01f5193c: { 34: [{ blockHash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", blockNumber: null, from: \"0x24d407e5a0b506e1cb2fae163100b5de01f5193c\", gas: \"0x44c72\", gasPrice: \"0x4a817c800\", hash: \"0xb5b8b853af32226755a65ba0602f7ed0e8be2211516153b75e9ed640a7d359fe\", input: \"0xb61d27f600000000000000000000000024d407e5a0b506e1cb2fae163100b5de01f5193c00000000000000000000000000000000000000000000000053444835ec580000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", nonce: \"0x22\", to: \"0x7320785200f74861b69c49e4ab32399a71b34f1a\", transactionIndex: null, value: \"0x0\" }] } }, queued: { 0x976a3fc5d6f7d259ebfb4cc2ae75115475e9867c: { 3: [{ blockHash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", blockNumber: null, from: \"0x976a3fc5d6f7d259ebfb4cc2ae75115475e9867c\", gas: \"0x15f90\", gasPrice: \"0x4a817c800\", hash: \"0x57b30c59fc39a50e1cba90e3099286dfa5aaf60294a629240b5bbec6e2e66576\", input: \"0x\", nonce: \"0x3\", to: \"0x346fb27de7e7370008f5da379f74dd49f5f2f80f\", transactionIndex: null, value: \"0x1f161421c8e0000\" }] }, 0x9b11bf0459b0c4b2f87f8cebca4cfc26f294b63a: { 2: [{ blockHash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", blockNumber: null, from: \"0x9b11bf0459b0c4b2f87f8cebca4cfc26f294b63a\", gas: \"0x15f90\", gasPrice: \"0xba43b7400\", hash: \"0x3a3c0698552eec2455ed3190eac3996feccc806970a4a056106deaf6ceb1e5e3\", input: \"0x\", nonce: \"0x2\", to: \"0x24a461f25ee6a318bdef7f33de634a67bb67ac9d\", transactionIndex: null, value: \"0xebec21ee1da40000\" }], 6: [{ blockHash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", blockNumber: null, from: \"0x9b11bf0459b0c4b2f87f8cebca4cfc26f294b63a\", gas: \"0x15f90\", gasPrice: \"0x4a817c800\", hash: \"0xbbcd1e45eae3b859203a04be7d6e1d7b03b222ec1d66dfcc8011dd39794b147e\", input: \"0x\", nonce: \"0x6\", to: \"0x6368f3f8c2b42435d6c136757382e4a59436a681\", transactionIndex: null, value: \"0xf9a951af55470000\" }, { blockHash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", blockNumber: null, from: \"0x9b11bf0459b0c4b2f87f8cebca4cfc26f294b63a\", gas: \"0x15f90\", gasPrice: \"0x4a817c800\", hash: \"0x60803251d43f072904dc3a2d6a084701cd35b4985790baaf8a8f76696041b272\", input: \"0x\", nonce: \"0x6\", to: \"0x8db7b4e0ecb095fbd01dffa62010801296a9ac78\", transactionIndex: null, value: \"0xebe866f5f0a06000\" }], } } } txpool.inspect 和txpool.content相似，不同的是只列出所有交易摘要，而txpool.content是列出前几个交易的详细内容 \u003e txpool.inspect { pending: { 0x26588a9301b0428d95e6fc3a5024fce8bec12d51: { 31813: [\"0x3375ee30428b2a71c428afa5e89e427905f95f7e: 0 wei + 500000 × 20000000000 gas\"] }, 0x2a65aca4d5fc5b5c859090a6c34d164135398226: { 563662: [\"0x958c1fa64b34db746925c6f8a3dd81128e40355e: 1051546810000000000 wei + 90000 × 20000000000 gas\"], 563663: [\"0x77517b1491a0299a44d668473411676f94e97e34: 1051190740000000000 wei + 90000 × 20000000000 gas\"], 563664: [\"0x3e2a7fe169c8f8eee251bb00d9fb6d304ce07d3a: 1050828950000000000 wei + 90000 × 20000000000 gas\"], 563665: [\"0xaf6c4695da477f8c663ea2d8b768ad82cb6a8522: 1050544770000000000 wei + 90000 × 20000000000 gas\"], 563666: [\"0x139b148094c50f4d20b01caf21b85edb711574db: 1048598530000000000 wei + 90000 × 20000000000 gas\"], 563667: [\"0x48b3bd66770b0d1eecefce090dafee36257538ae: 1048367260000000000 wei + 90000 × 20000000000","date":"2019-03-08","objectID":"/2019/geth-console-command/:3:5","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"3.6 net和web3 这两个也有使用，但是没找到Javascript控制台下命令格式的具体说明 ","date":"2019-03-08","objectID":"/2019/geth-console-command/:3:6","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"四、常用命令 personal.newAccount()：创建账户； personal.unlockAccount()：解锁账户； eth.accounts：枚举系统中的账户； eth.getBalance()：查看账户余额，返回值的单位是 Wei（Wei 是以太坊中最小货币面额单位，类似比特币中的聪，1 ether = 10^18 Wei）； eth.blockNumber：列出区块总数； eth.getTransaction()：获取交易； eth.getBlock()：获取区块； miner.start()：开始挖矿； miner.stop()：停止挖矿； web3.fromWei()：Wei 换算成以太币； web3.toWei()：以太币换算成 Wei； txpool.status：交易池中的状态； admin.addPeer()：连接到其他节点； ","date":"2019-03-08","objectID":"/2019/geth-console-command/:4:0","tags":["区块链"],"title":"以太坊开发4-geth console命令","uri":"/2019/geth-console-command/"},{"categories":["研究生的区块链学习之路"],"content":"Geth是以太坊智能合约开发工具，是一个命令行工具，所以熟悉其命令参数有助于提高开发效率。本文是geth help的翻译，基于geth 1.8.11-stable版本。 github的项目wiki也有一份命令说明：Command Line Options ","date":"2019-03-08","objectID":"/2019/geth-client-use/:0:0","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"参数详解 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:0","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"命令用法 geth [选项] 命令 [命令选项] [参数…] ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:1","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"版本： 1.8.11-stable ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:2","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"命令: 即“命令用法”部分命令字段的内容，是geth的主体功能 account 管理账户 attach 启动交互式JavaScript环境（连接到节点） bug 上报bug Issues console 启动交互式JavaScript环境 copydb 从文件夹创建本地链 dump Dump（分析）一个特定的块存储 dumpconfig 显示配置值 export 导出区块链到文件 import 导入一个区块链文件 init 启动并初始化一个新的创世纪块 js 执行指定的JavaScript文件(多个) license 显示许可信息 makecache 生成ethash验证缓存(用于测试) makedag 生成ethash 挖矿DAG(用于测试) monitor 监控和可视化节点指标 removedb 删除区块链和状态数据库 version 打印版本号 wallet 管理Ethereum预售钱包 help,h 显示一个命令或帮助一个命令列表 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:3","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"ETHEREUM选项: 即”命令用法“部分[选项]字段的内容 --config value TOML 配置文件 --datadir “xxx” 数据库和keystore密钥的数据目录 --keystore keystore存放目录(默认在datadir内) --nousb 禁用监控和管理USB硬件钱包 --networkid value 网络标识符(整型, 1=Frontier, 2=Morden (弃用), 3=Ropsten, 4=Rinkeby) (默认: 1) --testnet Ropsten网络:预先配置的POW(proof-of-work)测试网络 --rinkeby Rinkeby网络: 预先配置的POA(proof-of-authority)测试网络 --syncmode \"fast\" 同步模式 (\"fast\", \"full\", or \"light\") --ethstats value 上报ethstats service URL (nodename:secret@host:port) --identity value 自定义节点名 --lightserv value 允许LES请求时间最大百分比(0 – 90)(默认值:0) --lightpeers value 最大LES client peers数量(默认值:20) --lightkdf 在KDF强度消费时降低key-derivation RAM\u0026CPU使用 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:4","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"开发者（模式）选项: 本节及以下到”版权“部分为止，均是”命令用法“部分[命令选项]字段的内容 --dev 使用POA共识网络，默认预分配一个开发者账户并且会自动开启挖矿。 --dev.period value 开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0) ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:5","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"ETHASH 选项: --ethash.cachedir ethash验证缓存目录(默认 = datadir目录内) --ethash.cachesinmem value 在内存保存的最近的ethash缓存个数 (每个缓存16MB ) (默认: 2) --ethash.cachesondisk value 在磁盘保存的最近的ethash缓存个数 (每个缓存16MB) (默认: 3) --ethash.dagdir \"\" 存ethash DAGs目录 (默认 = 用户hom目录) --ethash.dagsinmem value 在内存保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 1) --ethash.dagsondisk value 在磁盘保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 2) ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:6","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"交易池选项: --txpool.nolocals 为本地提交交易禁用价格豁免 --txpool.journal value 本地交易的磁盘日志：用于节点重启 (默认: \"transactions.rlp\") --txpool.rejournal value 重新生成本地交易日志的时间间隔 (默认: 1小时) --txpool.pricelimit value 加入交易池的最小的gas价格限制(默认: 1) --txpool.pricebump value 价格波动百分比（相对之前已有交易） (默认: 10) --txpool.accountslots value 每个帐户保证可执行的最少交易槽数量 (默认: 16) --txpool.globalslots value 所有帐户可执行的最大交易槽数量 (默认: 4096) --txpool.accountqueue value 每个帐户允许的最多非可执行交易槽数量 (默认: 64) --txpool.globalqueue value 所有帐户非可执行交易最大槽数量 (默认: 1024) --txpool.lifetime value 非可执行交易最大入队时间(默认: 3小时) ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:7","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"性能调优的选项: --cache value 分配给内部缓存的内存MB数量，缓存值(最低16 mb /数据库强制要求)(默认:128) --trie-cache-gens value 保持在内存中产生的trie node数量(默认:120) ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:8","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"帐户选项: --unlock value 需解锁账户用逗号分隔 --password value 用于非交互式密码输入的密码文件 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:9","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"API和控制台选项: --rpc 启用HTTP-RPC服务器 --rpcaddr value HTTP-RPC服务器接口地址(默认值:“localhost”) --rpcport value HTTP-RPC服务器监听端口(默认值:8545) --rpcapi value 基于HTTP-RPC接口提供的API --ws 启用WS-RPC服务器 --wsaddr value WS-RPC服务器监听接口地址(默认值:“localhost”) --wsport value WS-RPC服务器监听端口(默认值:8546) --wsapi value 基于WS-RPC的接口提供的API --wsorigins value websockets请求允许的源 --ipcdisable 禁用IPC-RPC服务器 --ipcpath 包含在datadir里的IPC socket/pipe文件名(转义过的显式路径) --rpccorsdomain value 允许跨域请求的域名列表(逗号分隔)(浏览器强制) --jspath loadScript JavaScript加载脚本的根路径(默认值:“.”) --exec value 执行JavaScript语句(只能结合console/attach使用) --preload value 预加载到控制台的JavaScript文件列表(逗号分隔) --rpcaddr有几种不同的用法，如下所示，参考自Geth –rpcaddr doubt --rpcaddr 127.0.0.1 在本地网络开启一个JSON RPC，并且只能从本地主机连到geth服务器 --rpcaddr 0.0.0.0 开启一个JSON RPC，任何人都可以连到geth服务器 如果想只允许本地网络的主机连接，使用 127.0.0.1，如果想只允许自己的主机连接，应该使用自己的网络ip，一般是192.169.1.1，如果使用0.0.0.0，任何人都能连接 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:10","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"网络选项: --bootnodes value 用于P2P发现引导的enode urls(逗号分隔)(对于light servers用v4+v5代替) --bootnodesv4 value 用于P2P v4发现引导的enode urls(逗号分隔) (light server, 全节点) --bootnodesv5 value 用于P2P v5发现引导的enode urls(逗号分隔) (light server, 轻节点) --port value 网卡监听端口(默认值:30303) --maxpeers value 最大的网络节点数量(如果设置为0，网络将被禁用)(默认值:25) --maxpendpeers value 最大尝试连接的数量(如果设置为0，则将使用默认值)(默认值:0) --nat value NAT端口映射机制 (any|none|upnp|pmp|extip:\u003cIP\u003e) (默认: “any”) --nodiscover 禁用节点发现机制(手动添加节点) --v5disc 启用实验性的RLPx V5(Topic发现)机制 --nodekey value P2P节点密钥文件 --nodekeyhex value 十六进制的P2P节点密钥(用于测试) ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:11","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"矿工选项: --mine 打开挖矿 --minerthreads value 挖矿使用的CPU线程数量(默认值:8) --etherbase value 挖矿奖励地址(默认=第一个创建的帐户)(默认值:“0”) --targetgaslimit value 目标gas限制：设置最低gas限制（低于这个不会被挖？） (默认值:“4712388”) --gasprice value 挖矿接受交易的最低gas价格 --extradata value 矿工设置的额外块数据(默认=client version) ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:12","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"GAS价格选项: --gpoblocks value 用于检查gas价格的最近块的个数 (默认: 10) --gpopercentile value 建议gas价参考最近交易的gas价的百分位数，(默认: 50) ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:13","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"虚拟机的选项: --vmdebug 记录VM及合约调试信息 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:14","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"日志和调试选项: --metrics 启用metrics收集和报告 --fakepow 禁用proof-of-work验证 --verbosity value 日志详细度:0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3) --vmodule value 每个模块详细度:以 \u003cpattern\u003e=\u003clevel\u003e的逗号分隔列表 (比如 eth/*=6,p2p=5) --backtrace value 请求特定日志记录堆栈跟踪 (比如 “block.go:271”) --debug 突出显示调用位置日志(文件名及行号) --pprof 启用pprof HTTP服务器 --pprofaddr value pprof HTTP服务器监听接口(默认值:127.0.0.1) --pprofport value pprof HTTP服务器监听端口(默认值:6060) --memprofilerate value 按指定频率打开memory profiling (默认:524288) --blockprofilerate value 按指定频率打开block profiling (默认值:0) --cpuprofile value 将CPU profile写入指定文件 --trace value 将execution trace写入指定文件 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:15","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"WHISPER实验选项: --shh 启用Whisper --shh.maxmessagesize value 可接受的最大的消息大小 (默认值: 1048576) --shh.pow value 可接受的最小的POW (默认值: 0.2) ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:16","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"弃用选项： --fast 开启快速同步 --light 启用轻客户端模式 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:17","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"其他选项: 该部分和”命令“部分的help是不同的，用于查询[命令选项]字段命令的使用说明 –help, -h 显示帮助 ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:18","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"版权： Copyright 2013-2017 The go-ethereum Authors ","date":"2019-03-08","objectID":"/2019/geth-client-use/:1:19","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"命令示例 创建账户 $ geth --datadir data/ account new 创建节点 $ geth --datadir data/ init genesis.json 启动geth $ geth --datadir data/ --networkid 72 --nodiscover --port 30306 --etherbase 0x4c283287839fd441b8c8d18771321bc06a81edae --mine --minerthreads 1 console 同步节点 $ geth --syncmode \"fast\" --cache 512 查询account命令的说明及参数 $ geth account -h 返回结果如下： NAME: geth account - Manage accounts, list all existing accounts, import a private key into a new account, create a new account or update an existing account. It supports interactive mode, when you are prompted for password as well as non-interactive mode where passwords are supplied via a given password file. Non-interactive mode is only meant for scripted use on test networks or known safe environments. Make sure you remember the password you gave when creating a new account (with either new or import). Without it you are not able to unlock your account. Note that exporting your key in unencrypted format is NOT supported. Keys are stored under \u003cDATADIR\u003e/keystore. It is safe to transfer the entire directory or the individual keys therein between ethereum nodes by simply copying. Make sure you backup your keys regularly. USAGE: geth account command [command options] [arguments...] COMMANDS: list Print summary of existing accounts new Create a new account update Update an existing account import Import a private key into a new account OPTIONS: --help, -h show help ","date":"2019-03-08","objectID":"/2019/geth-client-use/:2:0","tags":["区块链"],"title":"以太坊开发3-geth客户端命令","uri":"/2019/geth-client-use/"},{"categories":["研究生的区块链学习之路"],"content":"文件说明 关于genesis.json的官方说明位于两处 Private network Connecting to the network 每条区块链都以创世区块开头，而genesis.json正是创世区块的配置文件，它是区块链最重要的识别标志之一。实际上，每条区块链的创世区块文件都是唯一的，如果两条机器启动Geth时所选用的创世区块文件不同，就无法被识别为同一条区块链的成员。因此，同一条联盟链/私链中的所有节点必须使用同一份创世区块文件进行初始化配置。 ","date":"2019-03-07","objectID":"/2019/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BC%80%E5%8F%912-%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97%E6%96%87%E4%BB%B6genesis.json/:1:0","tags":["区块链"],"title":"以太坊开发2-创世区块文件genesis.json","uri":"/2019/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BC%80%E5%8F%912-%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97%E6%96%87%E4%BB%B6genesis.json/"},{"categories":["研究生的区块链学习之路"],"content":"标准示例 一个创世区块文件genesis.json的标准示例如下： { \"config\": { \"chainId\": 15, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"nonce\": \"0x000000000000002a\", \"difficulty\": \"0x020000\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x\", \"gasLimit\": \"0x2fefd8\" \"alloc\": { \"7df9a875a174b3bc565e6424a0050ebc1b2d1d82\": { \"balance\": \"300000\" }, \"f41c74c9ae680c1aa78f42e5647a62f353b7bdde\": { \"balance\": \"400000\" } } } ##　参数说明 关于示例文件中各参数说明如下。首先config中的内容是区块链相关的基本配置参数。 ChainId - identifies the current chain and is used for replay protection. You should set it to a unique value for your private chain. homesteadBlock - your chain won’t be undergoing the switch to Homestead, so leave this as 0. eip155Block - your chain won’t be hard-forking for these changes, so leave as 0. eip158Block - your chain won’t be hard-forking for these changes, so leave as 0. 最重要的是链编号ChainId，用于标识区块链，关于它更详细的说明见EIP-155，Ethereum Improvement Proposals (EIPs)是以太坊改进建议，描述了以太坊平台的标准，包括核心协议规范，客户端API和智能合约标准。 mixhash - 一个 256 位的哈希证明，与 nonce 结合使用，证明已经对该块进行了足够的计算：工作量证明（PoW）。 nonce 和 mixhash 的组合必须满足黄皮书 4.3.4 Block Header Validity，(44)中描述的数学条件。它允许验证块确实已经加密地挖掘，因此，从这方面来说，它是有效的。 nonce - 一个64位的哈希证明，与mixhash结合使用，证明在该块上进行了足够的计算：工作量证明（PoW）。 nonce 和 mixhash 的组合必须满足黄皮书 4.3.4 Block Header Validity，(44)中描述的数学条件。它允许验证块确实已经加密地挖掘，因此，从这方面来说，它是有效的。 nonce 是加密安全的挖掘工作证明，证明在确定该令牌值时已经花费了特定量的计算。 （黄皮书, 11.5. Mining Proof-of-Work )。 difficulty -初始挖矿难度，可以根据前一个块的难度和时间戳来调整。难度越高，Miner 必须执行更多计算才能发现有效块。此值用于控制区块链的区块生成时间，将块生成频率保持在目标范围内。在测试网络上，我们将此值保持为较低的值以避免在测试期间等待，因为在区块链上执行交易需要发现有效区块。 alloc - 以太坊账户信息，可以留空，等待部署完成后再启动以太坊创建账户；也可以预先配置好以太坊账户及其余额。这里的账户余额以wei为单位。 coinbase - 挖矿收益账户，是一个160 位地址。它们是采矿奖励本身和合约交易执行退款的总和。通常在规范中命名为 “beneficiary”，有时在在线文档中称为 “etherbase”。可以设置为零地址，留待运行以太坊挖矿之前再设置。 timestamp - 标量值等于此块开始时 Unix time（） 函数的合理输出。该机制在块之间的时间方面强制实施稳态。最后两个块之间的较小周期导致难度级别的增加，从而导致找到下一个有效块所需的额外计算。如果周期太大，则减少了难度和到下一个块的预期时间。时间戳还允许验证链内的块顺序（黄皮书，4.3.4。（43））。 parentHash - 整个父块头的 Keccak 256 位哈希（包括其 nonce 和 mixhash）。指向父块的指针，从而有效地构建块链。创世区块中其值为0，实际上创世区块没有这个参数也可以。 extraData - 可选字段，但最多 32 字节，to conserve smart things for ethernity。 gasLimit - 每个区块所消耗的gas限制。自己做测试时需要设置的高一点，以避免在测试期间受到此阈值的限制。注意：这并不表示我们不应该关注合约的汽gas消耗量。 原始的英文说明如下： mixhash A 256-bit hash which proves, combined with the nonce, that a sufficient amount of computation has been carried out on this block: the Proof-of-Work (PoW). The combination of nonceand mixhash must satisfy a mathematical condition described in the Yellowpaper, 4.3.4. Block Header Validity, (44). It allows to verify that the Block has really been cryptographically mined, thus, from this aspect, is valid. nonce A 64-bit hash, which proves, combined with the mix-hash, that a sufficient amount of computation has been carried out on this block: the Proof-of-Work (PoW). The combination of nonceand mixhash must satisfy a mathematical condition described in the Yellowpaper, 4.3.4. Block Header Validity, (44), and allows to verify that the Block has really been cryptographically mined and thus, from this aspect, is valid. The nonce is the cryptographically secure mining proof-of-work that proves beyond reasonable doubt that a particular amount of computation has been expended in the determination of this token value. (Yellowpager, 11.5. Mining Proof-of-Work). difficulty A scalar value corresponding to the difficulty level applied during the nonce discovering of this block. It defines the mining Target, which can be calculated from the previous block’s difficulty level and the timestamp. The higher the difficulty, the statistically more calculations a Miner must perform to discover a valid block. This value is used to control the Block generation time of a Blockchain, keeping the Block generation frequency within a target range. On the test network, we keep this value low to avoid waiting during tests, since the discovery o","date":"2019-03-07","objectID":"/2019/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BC%80%E5%8F%912-%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97%E6%96%87%E4%BB%B6genesis.json/:2:0","tags":["区块链"],"title":"以太坊开发2-创世区块文件genesis.json","uri":"/2019/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BC%80%E5%8F%912-%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97%E6%96%87%E4%BB%B6genesis.json/"},{"categories":["研究生的区块链学习之路"],"content":"一、单虚拟机 最简单的方式是使用一个虚拟机，这也是在条件有限的情况下的最好选择。方法是在一台虚拟机上启用多个终端，每个终端使用不同的端口通信。步骤如下 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:1:0","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"1. 创建节点文件 在~Desktop路径下创建NodeA、NodeB和NodeC三个文件夹，代表三个节点。在三个文件夹中分别创建genesis.json文件 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:1:1","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"2. 初始化创世区块 分别执行geth init命令初始化创世区块 $ geth --datadir ~/Desktop/NodeA/dataA init genesis.json $ geth --datadir ~/Desktop/NodeB/dataB init genesis.json $ geth --datadir ~/Desktip/NodeC/dataC init genesis.json ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:1:2","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"3. 分别启动三个节点 启动NodeA $ geth --datadir ~/Desktop/NodeA/dataA --networkid 22 --nodiscover console 默认的端口是30303，因为三个节点在同一个操作系统中，所以接下来启动其它两个节点时我们要指定使用其它的接口 $ geth --datadir ~/Desktop/NodeA/dataB --port 30304 --networkid 22 --nodiscover console $ geth --datadir ~/Desktop/NodeA/dataC --port 30305 --networkid 22 --nodiscover console ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:1:3","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"4. 连接各节点 这里就使用admin.addPeers连接各节点就可以了。 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:1:4","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"二、多虚拟机快速搭建 最理想的方式是使用多台电脑，但是一般情况下实验条件不足，不过在电脑性能足够的情况下，可以开启多台虚拟机模拟这样的环境，这里的示例使用三台Ubuntu18.04 LTS系统的虚拟机。 在走了一遍完整搭建流程后，精简不需要的步骤，将快速搭建的过程总结如下，如果想要查看详细的步骤和描述信息，请看第三部分。省略的步骤包括 更新软件源 配置主机名 配置地址解析 同步时间 配置Golang环境 下载编译以太坊源码 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:2:0","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"正式搭建过程 安装网络工具 $ sudo apt-get install -y net-tools 安装geth $ sudo add-apt-repository -y ppa:ethereum/ethereum $ sudo apt-get update $ sudo apt-get install ethereum $ geth --help 详细过程可以查看Installing Go Ethereum 创建创世区块文件 $ mkdir ~/nodeA $ cd ~/nodeA $ touch genesis.json 编辑genesis.json文件内容如下 { \"config\": { \"chainId\": 72, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x40\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000000\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" :\"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } 之后克隆得到三个虚拟机，作为区块链的三个节点 创建data文件夹供存储区块链数据 $ mkdir ~/nodeA/data \u0026 cd ~/nodeA 初始化创世区块 geth --datadir data/ init genesis.json 启动网络 $ geth --datadir data/ --networkid 72 --nodiscover console ... Welcome to the Geth JavaScript console! 获取节点信息 \u003e admin.nodeInfo.enode 分别在三个节点执行上述命令，得到的三个节点的信息为： NodeA: \"enode://d0d6a32cacb349c8f8c92372dc3a1e118384720636519a46c14067a3b62f6cfa8549a8766ade0f91790ebdadfb44341e03c50a171b714070527be96ed037707e@[::]:30303?discport=0\" NodeB: \"enode://d9fc148c9808fbfee7954bd3324bfdff42777de7d2545ac3c2357f05939dbd8ee153cd32320a05f4dbf18138007f743f3a2097b62e71c3c47bb3cf1559dd1328@[::]:30303?discport=0\" NodeC: \"enode://246782d2429f4697e18009505989ed82c2c0a664aab96ed80b96e28be42b6d9e2d11b27806ea43e46fddfcb3e9a41e9df4889636f51e3dadc0c937b0735d0bdc@[::]:30303?discport=0\" 在NodeA执行下列命令，将NodeB加入网络，NodeC同理 \u003eadmin.addPeer(\"enode://d9fc148c9808fbfee7954bd3324bfdff42777de7d2545ac3c2357f05939dbd8ee153cd32320a05f4dbf18138007f743f3a2097b62e71c3c47bb3cf1559dd1328@[::]:30303\") 将 [::] 修改为正确节点的 IP 地址，是之前用ifconfig命令查询并记录的本地地址，不支持DNS解析的域名地址，只支持点分十进制格式的IP地址。删除` ?discport=0 查看节点连接信息 \u003e admin.peers 节点关机后，会自动被删除，节点重新启动后，会自动加入节点集群, 但是如果所有节点全部断掉，则需要重新添加。 转账和挖矿测试查看下面的详细搭建过程 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:2:1","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"补充说明 genesis.json文件的相关说明可参见以太坊-创世区块文件genesis.json geth命令的参数说明参见以太坊-geth命令参数说明 本文后半部分以\u003e开头的命令是控制台命令，这是一个以太坊提供的交互式的JavaScript环境，可以在该环境中进行命令或者代码的执行操作，具体内容参见以太坊-Geth Console命令详解 本文使用了admin.addPeer()命令进行节点连接，但实际上还有其它方式，具体每种方式的使用参见以太坊-节点连接到网络的几种方式 geth命令和控制台命令有时候能实现同样的功能，比如 $ geth --datadir data/ account new \u003e personal.newAccount() 两条命令均是实现创建新账户的功能 第4条所述节点连接方式中有一种是实现创建static-nodes.json文件用于之后的节点识别，但该方式需要账户地址，故只能使用geth命令创建新账户，而本文所述方式可以在节点连接后，再在控制台下创建账户用于转账和挖矿的操作。 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:2:2","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"三、多虚拟机详细过程 主要内容来自 https://blog.51cto.com/clovemfong/2280872 使用了多个虚拟机搭建，每个虚拟机代表一个区块链节点。自编译了以太坊源码，并且由于区块链的特性，对Linux的时间做了一定的配置，同时为了多个节点间的连接，对IP地址做了配置处理。以上这些不是必须的，但能让我们思路清晰，明白构建一个区块链应该保证什么条件。 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:3:0","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"1. 配置操作系统环境 本文的操作环境是在虚拟机上完成，共计三台虚拟机 (配置尽量高上去，如下这个配置挖矿太耗时，这里的配置主要指内存和CPU的核，因为以太坊的挖矿算法Ethash主要和内存有关，而CPU的核多一点挖矿时可以多开几个线程) 主机名 IP 地址 操作系统 内存 / GB CPU / 核 nodeA.shuzang.com 172.16.222.189 Ubuntu18.04 LTS 2 2 nodeB.shuzang.com 172.16.222.190 Ubuntu18.04 LTS 2 2 nodeC.shuzang.com 172.16.222.191 Ubuntu18.04 LTS 2 2 Q：linux下设置主机名的时候，为什么都要求设置成：name.domain.com这种域名的样式. A：因为linux等类unix系统都是为网络应用而开发的，主机的性能可以不需要很强大，只需要能够登录到服务器（也就是加入某个域），就可以利用服务器的资源，因此安装系统时如果主机是在某个域里，设置域名就表明该主机是这个域里的一员，通过合法的帐号和密码就可以连接登录到域服务器。如果是单机或者个人家庭网络，域名就可以随便设置了 注1：以 nodeA 为例进行相关配置，其他节点配置操作相同 注2：IP地址一栏应在虚拟机创建好后用ifconfig命令查看并记录 1.1 更新软件源 根据自己需要选择是否需要更换软件源，此处用的是原生的即可。 $ sudo apt-get update 1.2 安装相关工具 sudo apt-get install vim openssh-server ntp ntpdate make gcc net-tools -y 1.3 配置主机名 $ sudo hostname nodeA.shuzang.com 1.4 配置地址解析 $ vim /etc/hosts 127.0.0.1 localhost 172.16.222.189 nodeA.shuzang.com 172.16.222.190 nodeB.shuzang.com 172.16.222.191 nodeC.shuzang.com hostname –fqdn 验证 $ hostname -f nodeA.shuzang.com 1.5 同步时间 修改时区 $ sudo timedatectl set-timezone \"Asia/Shanghai\" 手动同步 $ sudo ntpdate time1.aliyun.com 同步硬件时间 $ sudo hwclock -w # 系统时间同步至硬件 手动设置完毕后，再通过如下方式进行 ntp 服务的配置，可以选择现有或者自建的时间服务器 测试连通性 $ ntpdate -q time1.aliyun.com server 203.107.6.88, stratum 2, offset 0.050751, delay 0.06232 22 Sep 21:04:36 ntpdate[8082]: adjust time server 203.107.6.88 offset 0.050751 sec 修改配置文件 $ sudo cp /etc/ntp.conf /etc/ntp.conf_shuzang_201809231208 #备份配置文件 $ sudo vim /etc/ntp.conf //修改配置文件 修改信息如下 # Use servers from the NTP Pool Project. Approved by Ubuntu Technical Board # on 2011-02-08 (LP: #104525). See http://www.pool.ntp.org/join.html for # more information. #pool 0.ubuntu.pool.ntp.org iburst #pool 1.ubuntu.pool.ntp.org iburst #pool 2.ubuntu.pool.ntp.org iburst #pool 3.ubuntu.pool.ntp.org iburst server time1.aliyun.com server time2.aliyun.com server time3.aliyun.com server time4.aliyun.com server time5.aliyun.com server time6.aliyun.com server time7.aliyun.com 启动 ntp 服务 $ sudo systemctl restart ntp #启动ntp服务 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:3:1","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"2. 配置 Golang 环境 下载 go 安装包 $ mkdir ethereum ;cd ethereum $ wget https://dl.google.com/go/go1.11.linux-amd64.tar.gz 解压安装包 $ sudo tar zxvf go1.11.linux-amd64.tar.gz -C /usr/local/ 配置环境变量 $ mkdir -p ~/workspace/{src,pkg,bin} $ sudo cp /etc/profile /etc/profile_shuzang_201809231354 $ sudo vim /etc/profile # 配置文件中添加如下信息 export GOROOT=\"/usr/local/go\" export GOPATH=\"/home/ubuntu/workspace\" export GOBIN=$GOPATH/bin export PATH=$PATH:$GOROOT/bin 检查配置 $ source /etc/profile $ go env GOARCH=\"amd64\" GOBIN=\"/home/ubuntu/workspace/bin\" GOCACHE=\"/home/ubuntu/.cache/go-build\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"linux\" GOOS=\"linux\" GOPATH=\"/home/ubuntu/workspace\" GOPROXY=\"\" ...... ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:3:2","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"3. 安装部署 3.1 获取源代码 以太坊的源码文件网址如下 https://github.com/ethereum/go-ethereum 可以选择通过git clone或者下载zip包的方式进行源代码的获取, 为了方便起见，本文直接下载 zip 包上传至三台节点进行解压部署。 下载源码包 $ cd /home/ubuntu/ethereum $ wget https://github.com/ethereum/go-ethereum/archive/master.zip 解压源码包 $ unzip master.zip $ mkdir ~/workspace/github.com/ $ mv go-ethereum-master/ ~/workspace/github.com/go-ethereum $ cd ~/workspace/github.com/go-ethereum ; make geth #编译安装 添加环境变量 $ sudo vim /etc/profile # 添加及修改如下信息 export GETH=\"$GOPATH/github.com/go-ethereum/build\" export PATH=$PATH:$GOROOT/bin:$GETH/bin 测试生效 $ source /etc/profile $ geth --help 至此环境配置完成，可以完成后进行虚拟机复制，得到三个虚拟机，然后再对主机名等进行修改，也可以等genesis.json文件创建完成后在进行虚拟机复制，然后修改相关名称。这样可以免去重复的环境配置工作，节省大量时间。 3.2 创建创世区块 创建数据存储目录 $ mkdir -p /home/ubuntu/nodeA/data0 $ cd /home/ubuntu/nodeA 创世区块配置文件genesis.json { \"config\": { \"chainId\": 66, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" :\"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } 难度\"difficulty\"可以设置小一点，比如\"0x40”，这样挖矿会容易一点，不然配置不好就只能死等。 初始化创世区块 $ geth --datadir data0/ init genesis.json 3.3 启动服务 $ geth --datadir data0/ --networkid 66 --nodiscover console ... Welcome to the Geth JavaScript console! nodiscover : 设置为不自动发现，用于控制联盟链的节点加入 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:3:3","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"4. 节点通信 4.1 查看集群节点 \u003e admin.peers [] 目前为空状态，表明未于其他节点进行通信。 4.2 获取节点信息 \u003e admin.nodeInfo.enode 分别在三个节点的 console 上执行命令，显示如下: NodeA \"enode://d0d6a32cacb349c8f8c92372dc3a1e118384720636519a46c14067a3b62f6cfa8549a8766ade0f91790ebdadfb44341e03c50a171b714070527be96ed037707e@[::]:30303?discport=0\" NodeB \"enode://d9fc148c9808fbfee7954bd3324bfdff42777de7d2545ac3c2357f05939dbd8ee153cd32320a05f4dbf18138007f743f3a2097b62e71c3c47bb3cf1559dd1328@[::]:30303?discport=0\" NodeC \"enode://246782d2429f4697e18009505989ed82c2c0a664aab96ed80b96e28be42b6d9e2d11b27806ea43e46fddfcb3e9a41e9df4889636f51e3dadc0c937b0735d0bdc@[::]:30303?discport=0\" 4.3 将 NodeB 加入 NodeA 在 NodeA 节点上执行如下命令 \u003eadmin.addPeer(\"enode://d9fc148c9808fbfee7954bd3324bfdff42777de7d2545ac3c2357f05939dbd8ee153cd32320a05f4dbf18138007f743f3a2097b62e71c3c47bb3cf1559dd1328@172.16.222.190:30303\") 返回true表示加入成功，注意 将 [::] 修改为正确节点的 IP 地址，是之前用ifconfig命令查询并记录的本地地址，不支持DNS解析的域名地址，只支持点分十进制格式的IP地址 删除 ?discport=0 4.4 查看新加入的节点 \u003e admin.peers 在 NodeA 节点上执行如下命令 通过查看 localAddress 跟 remoteAddress 查看节点关联信息。 在 NodeB 节点上执行如下命令 在 NodeC 节点上执行如下命令 \u003e admin.peers [] 4.5 将 NodeC 加入 NodeA 与 NodeB 在 NodeA 节点上执行如下命令 \u003eadmin.addPeer(\"enode://246782d2429f4697e18009505989ed82c2c0a664aab96ed80b96e28be42b6d9e2d11b27806ea43e46fddfcb3e9a41e9df4889636f51e3dadc0c937b0735d0bdc@172.16.222.191:30303\") 在 NodeB 节点上执行如下命令 \u003eadmin.addPeer(\"enode://246782d2429f4697e18009505989ed82c2c0a664aab96ed80b96e28be42b6d9e2d11b27806ea43e46fddfcb3e9a41e9df4889636f51e3dadc0c937b0735d0bdc@172.16.222.191:30303\") 4.6 查看节点加入信息 在 NodeA 节点上执行如下命令 在 NodeB 节点上执行如下命令 在 NodeC 节点上执行如下命令 注意: 节点关机后，会自动被删除，节点重新启动后，会自动加入节点集群, 但是如果所有节点全部断掉，则需要重新添加。 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:3:4","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"5. 测试 5.1 转账测试 查看当前节点上的账户 \u003e personal.listAccounts # 或者 \u003e eth.accounts 创建新账户 \u003e personal.newAccount(\"shuzang1996\") \"0xcd3d95c64394452313b539a1f2de54eab2b80eed\" \u003e personal.newAccount(\"shuzang1997\") \"0xc4f132a71da05257a71ae5872beabd12c50dbb81\" 查看创建的账户 \u003e personal.listAccounts [\"0xcd3d95c64394452313b539a1f2de54eab2b80eed\", \"0xc4f132a71da05257a71ae5872beabd12c50dbb81\"] 查看账户地址 \u003e personal.listWallets 查看挖矿账户 \u003e eth.coinbase INFO [09-23|18:17:20.246] Etherbase automatically configured address=0xcD3d95c64394452313b539a1f2dE54Eab2B80eEd \"0xcd3d95c64394452313b539a1f2de54eab2b80eed\" 默认情况下，平台会选择创建的第一个账户作为挖矿账户 (coinbase)，可以通过 miner.setEthbase() 进行 coinbase 账户的设置。 5.2 挖矿测试 注意：在执行挖矿命令之前，务必在节点上面设置挖矿账户 (coinbase)，否则会报错Error: etherbase missing: etherbase must be explicitly specified 当前账户信息为 NodeA:[\"0xcd3d95c64394452313b539a1f2de54eab2b80eed\",\"0xc4f132a71da05257a71ae5872beabd12c50dbb81\"] NodeB：[\"0x22160d844b4016ed8f45ce63c405de72b1946696\",\"0x23e80b2f1f74fc6da4bcb015d17ed642bcc98c06\"] NodeC: [\"0xa37539c0f41fea23c81f65b196df825202bc3bb5\",\"0x3c9cdb2f29606a0b35ae95b51521a41bb5b48e27\"] 启动挖矿 \u003e miner.start() INFO [09-23|18:57:41.223] Updated mining threads threads=6 INFO [09-23|18:57:41.223] Transaction pool price threshold updated price=1000000000 null \u003e INFO [09-23|18:57:41.225] Commit new mining work number=1 sealhash=b16ebe…9b0094 uncles=0 txs=0 gas=0 fees=0 elapsed=794.985µs \u003e INFO [09-23|18:57:52.671] Successfully sealed new block number=1 sealhash=b16ebe…9b0094 hash=082473…eb94b6 elapsed=11.446s INFO [09-23|18:57:52.671] ined potential block number=1 hash=082473…eb94b6 INFO [09-23|18:57:52.672] Commit new mining work number=2 sealhash=7a67a7…3c98aa uncles=0 txs=0 gas=0 fees=0 elapsed=1.062ms INFO [09-23|18:57:55.115] Successfully sealed new block number=2 sealhash=7a67a7…3c98aa hash=c5cd53…c3e66b elapsed=2.443s INFO [09-23|18:57:55.115] ined potential block number=2 hash=c5cd53…c3e66b INFO [09-23|18:57:55.116] Commit new mining work number=3 sealhash=cc1414…f36ad7 uncles=0 txs=0 gas=0 fees=0 elapsed=343.53µs INFO [09-23|18:57:55.166] Successfully sealed new block number=3 sealhash=cc1414…f36ad7 hash=765d41…03ce17 elapsed=50.270ms INFO [09-23|18:57:55.166] ined potential block number=3 hash=765d41…03ce17 INFO [09-23|18:57:55.167] Commit new mining work number=4 sealhash=cb5122…e36b2c uncles=0 txs=0 gas=0 fees=0 elapsed=718.996µs INFO [09-23|18:57:58.048] Successfully sealed new block number=4 sealhash=cb5122…e36b2c hash=ab1e6d…03b40b elapsed=2.881s INFO [09-23|18:57:58.048] ined potential block number=4 hash=ab1e6d…03b40b INFO [09-23|18:57:58.049] Commit new mining work number=5 sealhash=0dd5ab…5d47d9 uncles=0 txs=0 gas=0 fees=0 elapsed=159. 注意: 尽量将虚拟机的配置调高一点，否则会出现以下这些信息，耗时非常久。 INFO [09-23|18:48:45.223] Updated mining threads threads=2 INFO [09-23|18:48:45.229] Transaction pool price threshold updated price=1000000000 INFO [09-23|18:48:45.230] Etherbase automatically configured address=0x22160D844B4016eD8f45cE63C405DE72B1946696 null \u003e INFO [09-23|18:48:45.236] Commit new mining work number=1 sealhash=88e805…da6df6 uncles=0 txs=0 gas=0 fees=0 elapsed=4.290ms INFO [09-23|18:48:48.930] Generating DAG in progress epoch=0 percentage=0 elapsed=2.961s INFO [09-23|18:48:51.895] Generating DAG in progress epoch=0 percentage=1 elapsed=5.926s INFO [09-23|18:48:54.739] Generating DAG in progress epoch=0 percentage=2 elapsed=8.770s ..........无尽的等待......... INFO [09-23|18:53:50.638] Generated ethash verification cache epoch=0 elapsed=5m4.669s INFO [09-23|18:54:08.357] Generating DAG in progress epoch=1 percentage=0 elapsed=15.480s INFO [09-23|18:54:19.874] Generating DAG in progress epoch=1 percentage=1 elapsed=26.997s INFO [09-23|18:54:29.911] Generating DAG in progress epoch=1 percentage=2 elapsed=37.034s ..........无尽的等待......... WARN [09-23|18:57:57.836] Discarded bad propagated block number=1 hash=082473…eb94b6 INFO [09-23|18:57:58.398] Block synchronisation started INFO [09-23|18:57:58.404] Mining aborted due to sync INFO [09-23|18:57:58.611] Imported new stat","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:3:5","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"附录 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:4:0","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"1. 创世区块配置文件参数说明 参数名 说明 chainId 指定独立的区块链网络 ID，1-4 为保留 ID，其中 1 为主网 ID，其余为测试网 alloc 用来设置账号以及账号的以太币数量，私有链可以不进行设置 coinbase 用于获取挖矿奖励的矿工账号 difficulty 设置挖矿的难度系数 extraData 附加信息，自定义即可 gasLimit 设置对 gas 的消耗总量的限制, 私有链中可以填写任意数值 (大数值) nonce 用于进行挖矿的随机数 mixhash 与 nonce 配合使用，用于挖矿 parentHash 上一个区块的 Hash 值，由于该区块为创世区块，所以父 Hash 值为 0 timestamp 时间戳 data0 目录中的相关文件列表 chaindata : 存储区块数据 keystore: 存储账户数据 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:4:1","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"2. 私链服务启动常见参数说明 参数名 说明 identity 用于标识区块链的名称 init 用于指定创世区块的位置，并且创建创世区块以及相关目录结构 datadir 设置当前区块链网络数据存放的位置 port 区块链启动的监听端口，默认为 30303 rpc 启用 RPC 服务，可以用于智能合约的部署与调试，默认监听 127.0.0.1, 端口为 8545 rpcapi 设置 RPC 提供的 API 接口类型，一般为 db,eth.net.web3 networkid 设置当前区块链的网络 ID nodiscover 设置节点不被自动发现，用于控制节点的加入 console 启用命令行模式，用于执行命令 help 帮助命令，所有参数的汇总 ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:4:2","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"3. 控制台命令说明 以太坊提供了一个交互式的 JavaScript 环境，可以在该环境中进行命令或者代码的执行操作，其中一些常用的以太坊 JavaScript 对象可以直接被调用。 对象名 说明 eth 操作区块链相关的方法 eth.accounts 查看当前系统中的所有账户地址 eth.getBalance() 查询账户余额，返回单位为 Wei(1 ether=10^18Wei) eth.blockNumber 列出区块总数 eth.getTransaction() 获取指定交易的状态信息 eth.getBlock() 获取指定区块的信息 net 用于查看 p2p 网络状态 admin 管理节点相关的方法 admin.peers 查看通讯的节点信息 admin.addPeer() 添加通讯 P2P 节点 miner 启动 / 停止挖矿相关方法 personal 用于管理账户 personal.newAccount() 创建账户 personal.unlockAccount() 解锁账户 txpool 查看交易池信息, txpool.status() web3 包含了以上对象以及单位换算等方法 web3.fromWei() Wei 换算成 ether 或者其他单位 web3.toWei() 将 ether 或者其他单位换算成 Wei ","date":"2019-03-07","objectID":"/2019/use-virtual-machine-builds-ethereum-private-chain/:4:3","tags":["区块链"],"title":"以太坊开发1-虚拟机搭建以太坊私链","uri":"/2019/use-virtual-machine-builds-ethereum-private-chain/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Nikolay Teslya; Igor Ryabchikov Published in：2017 21st Conference of Open Innovations Association(FRUCT) Date of Conference: 6-10 Nov. 2017 会议举办地：Helsinki, Finland 被引量：11次 ","date":"2019-02-28","objectID":"/2019/blockchain-based-platform-architecture-for-industrial-iot/:0:0","tags":["论文笔记"],"title":"Blockchain-Based Platform Architecture for Industrial IoT","uri":"/2019/blockchain-based-platform-architecture-for-industrial-iot/"},{"categories":["研究生的区块链学习之路"],"content":"摘要 机器人技术，物联网概念，大数据处理技术，自动化和分布式数字分类账技术的发展引发了第四次工业革命。新工业的主要问题之一是基于物联网的智能工厂内部组件以及工厂之间的互操作。这种互操作应该提供物联网参与者之间的信任;控制资源的分配（如维护时间，能源等）和成品。本文描述了集成物联网和区块链技术以解决这些问题的可能方法之一。为此，开发了一种结合了Smart-M3信息共享平台和区块链平台的架构。所提出的体系结构的一个主要特征是使用智能合约来处理和存储与智能空间组件之间的交互相关的信息。 文章有用的地方并不多，引言部分和Blockchain Platforms Overview for Industrial IoT purpose有部分重复，其它基本无用，文章主体内容-结合Smart-M3和区块链的架构并不是很适合，主要是其重点在于智能合约，并且两个平台的结合依靠中间件，由此会带来各种开销，Multichain的说明文档中对此有过分析，所以，有珠玉在前，不再细看这个架构了，下面只是把文章中一些可用的资料摘录出来。 ","date":"2019-02-28","objectID":"/2019/blockchain-based-platform-architecture-for-industrial-iot/:1:0","tags":["论文笔记"],"title":"Blockchain-Based Platform Architecture for Industrial IoT","uri":"/2019/blockchain-based-platform-architecture-for-industrial-iot/"},{"categories":["研究生的区块链学习之路"],"content":"IIoT概念的应用场景 按需生产。接受并自动完成买方订单，可生产高度定制化的商品（例如3D打印或计算机数字控制）。工厂将通过区块链网络跟踪订单。 通过供应链跟踪商品。将商品数字化并存储其信息，包括生产细节，谁以及何时拥有该商品，维修记录等。通过这些信息我们可以追踪商品在供应链中的位置，从一批缺陷产品中识别商品，确认商品许可等。 生产产品的机器间的自动交互。将产品准备信息交付下一生产阶段，不同的企业完成不同的生产阶段。 ","date":"2019-02-28","objectID":"/2019/blockchain-based-platform-architecture-for-industrial-iot/:2:0","tags":["论文笔记"],"title":"Blockchain-Based Platform Architecture for Industrial IoT","uri":"/2019/blockchain-based-platform-architecture-for-industrial-iot/"},{"categories":["研究生的区块链学习之路"],"content":"IIoT对平台的需求 安全。保证参与者能完整的发布他想发布的信息，不被别人中途篡改。 容错。参与者信息系统的中断应当只影响其自身的进程。别人的进程不受影响。 持久。一旦发布，所有参与者都可访问这些信息。 公共访问的可能性。一些信息应当被所有参与者平地的看到。 共识的可能性。指的是智能合约。 考虑IIoT的情况，还可能提出如下附加要求： 能够过滤作者所要求的信息。在IIoT中，共同智能空间的参与者可以是独立的企业，它们必须在其中共存并拥有发布信息的平等权利。例如，每个人都有可能说：“莫斯科正在下雨”，但在某些情况下，对于某些问题并非所有发言都可信。因此，智能空间的要求之一是能够过滤作者所请求的信息。例如，根据州气象服务，“现在莫斯科的天气怎么样？” 将信息标记为不相关并在查询中对其进行过滤。在智能空间中发布的信息可能失去相关性（例如，关于产品的当前所有者的信息），但不应基于耐久性要求移除信息。因此，需要一种机制/协议，根据该机制/协议可以将信息标记为不相关，以及在查询中过滤此类信息的机制，允许指定诸如“谁是该产品的当前所有者？”之类的表达。 ","date":"2019-02-28","objectID":"/2019/blockchain-based-platform-architecture-for-industrial-iot/:3:0","tags":["论文笔记"],"title":"Blockchain-Based Platform Architecture for Industrial IoT","uri":"/2019/blockchain-based-platform-architecture-for-industrial-iot/"},{"categories":["研究生的区块链学习之路"],"content":"一些讨论 区块的不可变和交易记录的存储不仅仅是优点，也是一种缺点。不断增长的区块链需要较大的存储，但这很难由物联网中的简单设备提供。假设该问题可由更强大的设备来处理，那么弱能力设备可以通过区块链将它们的信息和功能委托给智能空间中的其它设备。 另一个问题是输入信息的延迟，区块的形成和验证都需要时间。这个问题可通过选择和配置环境来解决，使得形成新块的时间尽可能短。 ","date":"2019-02-28","objectID":"/2019/blockchain-based-platform-architecture-for-industrial-iot/:4:0","tags":["论文笔记"],"title":"Blockchain-Based Platform Architecture for Industrial IoT","uri":"/2019/blockchain-based-platform-architecture-for-industrial-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Nikolay Teslya; Igor Ryabchikov Published in：2018 22nd Conference of Open Innovations Association(FRUCT) Date of Conference: 15-18 May 2018 会议举办地：Jyvaskyla, Finland 被引量：1次 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:0:0","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 如今已有很多可用区块链平台存在。但要集成到工业物联网的智能空间中，区块链平台不仅应支持代币交易，还应支持智能合约、容错共识机制，以及参与者创建和实施新区块和智能合约的地位的平等。本文分析了最常用的共识机制，公共（无权限）和私有（有权限）区块链的具体特征。还描述了满足IIoT平台开发要求的区块链平台。通过分析所得结果，可选择平台和特定模块来实现用于IIoT平台的区块链。 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:1:0","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"I. Introduction 智能工厂的内部组件之间以及和其它工厂之间的交互是工业4.0的主要问题之一。到目前为止，已有许多基于物联网的解决方案，允许将多个组件组合成单一的信息空间并在它们之间提供信息交换。工业上这种联合体正是工业物联网（IIoT，Industrial Internet of Things）的概念，即物联网用于物理、虚拟和社会工业组件在单一信息空间（也称为智能空间）中的交互。然而，生产变得越来越去中心化，一些问题随之出现，其中有几个需要强调：需要在智能空间内组件之间以及和其它智能空间之间提供互操作性；信息空间参与者之间的信任；资源（如维护时间，能源等）和成品分发的控制。 为了提供智能空间中组件间的互操作性，可以使用本体和本体匹配机制（称为ontology and ontology matching mechanism）,这种机制已在众多项目中做了广泛描述和使用[2-3]。组件间的信任问题由于参与者的异构变得复杂，可通过数字签名和访问控制机制解决，需要一个中心化实体来为IIoT的所有组件提供信任和访问控制。资源和成品分发的控制可以使用一个所有组件都可访问的数据库完成。这些解决方案都相当复杂并且需要复杂的基础架构才能提供容错、性能和可用性。与此同时，区块链技术的活跃发展为以上提到的问题提供了更简单的解决方案。 [2]. A. Smirnov A. Kashevnik A. Ponomarev N. Shilov M. Shchekotov N. Teslya “Smart space-based intelligent mobile tourist guide: Service-based implementation” Conference of Open Innovation Association FRUCT pp. 126-134 2014. [3]. A. Smirnov A. Kashevnik N. Shilov S. Balandin I. Oliver S. Boldyrev “On-the-fly ontology matching in smart spaces: A multi-model approach” Lect. Notes Comput. Sci. (including Subser. Lect. Notes Artif. Intell. Lect. Notes Bioinformatics) vol. 6294 pp. 72-83 2010. 以上解决方案都较复杂并且需要复杂的基础架构才能提供容错、性能和可用性。与此同时，正在活跃的区块链技术为此提供了一种更简单的解决方案。 这里有两段区块链的介绍，跳过 本文的目的是分析可用的区块链解决方案，以便在工业4.0案例中实施。分析的主要问题是共识机制的实施、网络的公开性、智能合约的支持和用于在IIoT平台上提供所有这些功能的平台。这些因素可能会彼此依赖，比如，共识机制依赖于网络公开性。为了适用于IIoT平台，区块链应当支持智能合约，支持没有挖矿程序的区块生成，共识机制应当能够以少量节点运行。 本文剩余部分结构如下，Section 2描述一些关于区块链实施的进展，Section 3描述共识机制，Section 4描述公私链网络的实现以及它们的优缺点，Section 5描述一些可用于区块链和IIoT集成的区块链平台和模块 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:2:0","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"II. State of the Art 目前已有许多区块链技术的实现，搜索显示至少存在20个平台。它们的不同主要在于共识机制、交易验证机制（可靠性和一致性的保证）和功能（例如，仅支持货币交易还是能创建智能合约的通用目的的区块链）。通用目的的区块链（支持智能合约）的情况下，可用的状态存储结构，以及限制智能合约性能的机会仍有不同。 由于区块链技术不久前才流行起来，许多项目还处于早期阶段，因此它们没有定性地描述算法来支持所声称的保证，因此不适用于实际项目的实施。已有的区块链技术的实现，尤其是共识机制的实现在[6]中得到总结。本文基本上研究了[6]中的所有共识和共识机制之外他们工作的特点，并和具体项目的需求相关联。下一部分将详细描述这些共识机制。 [6] C. Cachin M. Vukolic Blockchain Consensus Protocols in the Wild Jul. 2017. ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:3:0","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"III. Consensus Mechanisms 以下是几种最流行的共识机制 Proof-of-work (PoW) ; Proot-of-elapsed-time (PoET)) ; Proof-of-stake (PoS) ; Byzantine Fault Tolerance (BFT) ; Federated Byzantine Agreement (FBA) ; Various combinations of the above algorithms. PoW和PoS不再细述，其它几种简单机翻 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:4:0","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"A. PoET PoET类似于PoW，但对于随机块创建，解决方案不是基于资源密集型任务，而是基于特殊硬件（特别是在Hyperledger Sawtooth中）它使用称为Intel Software Guard Extensions（SGX）的特定Intel CPU指令集，允许应用程序在受保护的环境中运行可信代码。它允许等待一段随机时间，并且由于加密签名，可以证明用户已经做出了期望。此解决方案允许降低块创建的成本（不需要花费资源来计算数学问题），但它有一个明显的缺点 - 网络的性能取决于硬件或虚拟环境性能。如果硬件被黑客入侵，网络将失去效率（这足以提醒英特尔处理器的最后两个漏洞 - 幽灵和熔化，由于补丁导致系统性能下降到2-11％）和操作机制变得众所周知。此外，更不用说硬件开发商和制造商将有可能通过硬件架构中的后门来影响网络。此外，由于块生成的可能性取决于参与者拥有的英特尔处理器的数量，因此仍存在资金投入影响的问题。该协议在Hyperledger Sawtooth区块链网络中实现 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:4:1","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"B. BFT 拜占庭容错是信息系统容忍一个或多个组件故障的属性。它起源于拜占庭将军问题，该问题假定需要在三位将军之间达成共识，这是其中一人可能向其他人发送冲突信息的条件。基于BFT的共识机制用于私链网络（在其成员彼此已知的网络中）。在区块链网络中，当少于三分之一的节点出现故障时，该机制允许在条件下达成共识，包括干扰整体目标的恶意节点。违反条件可能导致缺乏进度或分支（例如，如果超过三分之二的节点是恶意协同工作的节点）。与之前描述的协议相比，该协议的特点是它不允许回滚状态 - 接受的有效块是最终的并且不能被替换。但这也有一个缺点 - 只有部分节点的性能才能实现进展，而上述机制即使只运行一个节点也能运行。在将数量条件（超过2/3）应用于参与者权重之和而不是其数量的意义上，存在将该机制与利益证明相结合的实施方式。此机制在许可节点中最受欢迎。该机制用于各种私有区块链网络实现 - Hyperledger Fabric [17]，Tendermint [18]，Corda [19]，Exonum [20]等。 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:4:2","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"C. FBA 类似于BFT，但允许每个参与者在达成共识时指出他们自己的可信参与者列表，而不是共享共同的假设。这种机制在Ripple 和Stellar 项目中实现 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:4:3","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"IV. Permissioned and Permissionless Blockchain Platforms 可以将区块链分为公链和私链，两种网络的对比如表1所示 表1. 除了共识机制外，区块链平台之间的另一个区别是功能。许多实现仅针对参与者之间的资产（货币或对象）的审计和转移，包括MultiChain，Chain Core等。为了开发共同的智能空间，有必要实现一个通用目的的区块链平台（支持智能合约）。 区块链和IIoT集成的架构在[1]中提出，它允许通过共享信息空间（智能空间）将小型和弱能力设备（如传感器）和强大的计算单元联合起来，并通过将签名的共享信息记录到区块链中来提供它们之间的信任。在目前的研究状态下，传感器仅用于提供信息而无需自己进行签名。此外，由于较弱的计算能力，IIoT的这些部分不能参与共识。总结以上，IIoT和区块链技术的整合应基于许可链技术进行实施，从而提供每秒超过2500次交易的高性能，并允许为小组参与者的工作创建私人智能空间。 [1] N. Teslya I. Ryabchikov “Blockchain-Based Platform Architecture for Industrial IoT” Proceeding of the 21st conference of FRUCT Association pp. 321-329 2017. ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:5:0","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"V. Blockchain Platforms and Modules for Integration with Industrial IoT ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:6:0","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"A. Platforms 作者把范围缩小到了Corda, Hyperledger Fabric, Tendermint和Symbiont四种平台。然后详细的讨论了Corda和Hyperledger。 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:6:1","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"B. Modules 除了使用现有的区块链平台，还可以使用现有的共识机制创建自己的区块链平台。可以通过一组库实现。这里介绍两个：BFT-SMaRt和Tendermint。然后就是详细的介绍。 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:6:2","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"Conclusion 本文提供的分析表明，区块链平台有很多种实现方式。它们的区别在于很多因素，最重要的是块创建协议，块添加的共识，智能合约的支持（环境，编程语言，功能）。要在工业物联网和区块链平台之间建立连接，需要创建将IoT和区块链功能联合起来的模块。该模块将允许在IIoT的智能空间中存储信息，并在区块链中使用签名事务复制它。此外，还可以创建可在适当条件下自动处理的合约。这种集成的最佳平台是Hyperledger Fabric / Burrow。它们提供容错共识机制以及用于创建和处理智能合约的内置基础架构。可以使用这些平台创建两种类型的区块链网络 - 私有和公共。 此外，通过在IIoT基础设施上创建自己的区块链网络，可以深入集成IIoT和区块链。为此目的，本文提供了用于创建自己的区块链功能的库列表。这些库为各种共识机制提供了现成的解决方案，但开发人员应该为智能合约创建自己的基础架构，例如通过容器技术。 未来的工作将集中在第一个案例上，开发IIoT模块和私有区块链集成。此外，第二种情况将部分用于实现共识机制的深度集成，以便在所有参与者之间提供更高的块添加和共享速度。 总结： 区块链用于IIoT目的包括三点，1）工厂内各组件间，工厂间的交互；2）组件间的信任；3）资源和成品分发 主要研究问题为：共识的比较与选择，区块链类型选择，是否支持智能合约，平台比较选择 结论为应选择私链平台，并且使用私链的共识，平台应支持智能合约 ","date":"2019-02-27","objectID":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/:7:0","tags":["论文笔记"],"title":"Blockchain Platforms Overview for Industrial IoT Purpose","uri":"/2019/blockchain-platforms-overview-for-industrial-iot-purpose/"},{"categories":["研究生的区块链学习之路"],"content":"Zyskind G, Nathan O, Pentland A, et al. Decentralizing Privacy: Using Blockchain to Protect Personal Data[C]. ieee symposium on security and privacy, 2015: 180-184. DOI: 10.1109/SPW.2015.27 KeyWord: Protocols, Privacy, Data privacy, Online banking, Encryption, Compounds. 注：部分插图经过重新绘制，部分来自原论文截图。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:0:0","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"摘要 当前的商业模式下，第三方收集和控制了大量的个人隐私，损害了用户权益，越来愈多的安全事件使得这一模式开始受到质疑。比特币证明了通过一个分布式的公有分类账在金融领域进行可信和可审计的计算是可行的。因此，本文提出了一种基于区块链的分布式个人数据管理系统，用于保证用户对个人数据的所有权和控制权。与比特币不同的是，本文提出的系统中，区块链交易不是金融交易，而是用于携带指令，如存储、查询和共享数据等，在文章的最后也会讨论区块链未来可能的发展。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:1:0","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引言 世界上的数据量正在迅速增加，其中大量的数据被人为的收集，例如，Facebook自成立以来收集了300PB的个人数据，是国会图书馆200多年来收集的数百倍。商业公司和组织利用收集的数据来提供个性化的服务，并通过大数据分析等技术优化公司决策过程、预测未来趋势等，数据已成为一种宝贵的资产。虽然我们都从数据驱动的社会中获益，但隐私问题也越来越受到人们的关注，公共与私人组织收集了大量隐私与敏感信息，经常在没有明确通知的情况下随意使用这些数据，个人很难或根本无法控制自己的数据是否被收集或如何被使用。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:2:0","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 Related Work 当前已有很多尝试解决隐私问题的努力，不论是从立法的角度还是技术的角度都有。比如一个最近开发的框架Open-PDS，它提供了一个PDS自主部署模型，返回计算后的结果而不是原始数据本身，从而避免原始数据被滥用，虽然行业中现在普遍使用基于OAuth的认证。 研究人员开发了各种针对个人数据隐私问题的技术。数据匿名化方法试图保护个人身份信息，如k-匿名（k-anonymity）中匿名数据集要求每个记录的敏感信息至少与其它k-1个记录可区分，它确保敏感数据由足够多的可能值表示。差异隐私（differential privacy）是在共享数据之前扰乱数据或将噪声添加到计算过程的技术。同态加密则允许在加密数据上运行计算和查询，比如完全同态加密（FHE）方案允许在加密数据上执行任何计算，但目前效率太低而无法在实践中广泛使用。 近些年出现的区块链技术正在被大规模应用，并向我们展示了如何服务于需要可信计算和可审计性功能的项目。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:2:1","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 贡献与全文结构 本文专注于移动平台中用户使用第三方服务时面临的隐私问题，提供第三方服务的应用程序不断收集用户的隐私和敏感信息。我们假设这些应用遵循某种协议，在此基础上本文提出的系统可以解决以下隐私问题： 数据所有权：确保用户对自己的个人数据的所有权和控制权，系统将用户识别为数据所有者，服务作为宾客被授予权限。 数据透明性和可审计性：用户知晓自己哪些数据被收集以及这些数据以怎样的方式被访问。 细粒度的访问控制：现有移动应用程序中，用户注册时授予应用一组权限，这些权限是无限期的，更改协议的唯一方法是退出。本文系统中，用户可以随身更改或撤销先前授予的访问权限，注意表现形式是权限对话框，虽然用户界面可能不变，但访问控制策略实际上更安全地存储在了区块链中。 因此，本文的注意贡献如下： 区块链和链下存储相结合，构建了一个专注于隐私的个人数据管理平台。 通过对提出的平台和未来技术改进的讨论说明了区块链如何成为可信计算的重要资源。 本文的工作也可以用于其它场景下的数据隐私问题，例如患者共享其医疗数据用于科学研究，这时用户用于监督自己数据被如何使用和随时退出的能力。 论文其余部分组织如下，第二节讨论了解决的隐私问题，第三节概述了平台，第四节介绍了技术实施细节，第五节讨论了区块链的未来发展，第六节是结论。本篇论文笔记组织结构略有不同，接下来将直接介绍论文提出的方案，然后总结作者给出的分析，最后自己进行论文总结并记录相关想法和灵感。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:2:2","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"2. 方案 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:3:0","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 总体架构 总体架构如下图所示，系统由三部分构成： （智能手机的）用户：users，下载和使用应用程序； 服务：services，应用程序的提供者，出于操作和业务相关的原因（例如，有针对性的广告，个性化服务），需要处理个人数据； 节点：nodes，维护区块链和一个分布式的私有键值对形式的数据库以换取奖励。 需要注意的是，虽然系统中的用户因为区块链的关系通常保持（伪）匿名，但我们可以在区块链上存储服务配置文件验证其身份。 区块链接受两种新的交易类型：Taccess用于访问控制管理，Tdata用于数据存储和检索。相关的操作封装到一个移动软件开发工具包（SDK）中，提供接口供程序开发使用。 举个例子：用户安装的应用程序使用本文提出的系统保护其隐私，当用户注册时，生成一个新的共享（用户，服务）身份，并使用Taccess交易将这个身份与相关联的权限一起发送到区块链。在手机上收集的数据（例如，传感器数据，位置等）使用一个共享加密密钥加密，并使用Tdata交易发送到区块链，这些数据随后将被路由到链下以键值方式存储，仅保留一个指向数据的指针存在区块链上（指针是数据的SHA-256哈希值）。 现在，服务和用户都可以使用Tdata交易（关联了数据指针）查询数据。区块链会验证数字签名属于用户还是服务，如果是服务，还会检查其访问数据的权限。最后，用户可以通过发布具有新权限的Taccess交易来随时更改授予服务的权限，包括撤销对先前存储的数据的访问权。 链下的键值存储是分布式哈希表（或DHT）的一个实现，使用 LevelDB 并维持一个到区块链的接口。DHT由节点网络（可能不是区块链网络节点）维护，完成授权的读/写交易。数据在节点之间充分随机化并复制以确保高可用性。值得注意的是，可以考虑使用其它的链下存储方案如集中式的云，虽然这需要信任第三方，但在可伸缩性和已部署方面有一定优势。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:3:1","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 细节描述 我们现在描述底层协议的细节，系统使用标准加密构建区块：由3元组（Genc，Eenc，Denc）定义对称加密方案，分别是生成器，加密和解密算法；由3元组（Gsig，Ssig，Vsig）描述数字签名方案（DSS），分别是生成器，签名和验证算法；加密散列函数H由SHA-256实现。 A. 身份 区块链使用伪身份机制。为了增加隐私，每个用户都可以根据自己的需要生成尽可能多的伪身份（实质是一个公钥）。我们现在引入复合身份，复合身份是两方或多方的共享身份，其中一些方（至少一方）是「所有者」，拥有所有权限，其余方是「访客」，被限制访问。协议1说明了单个所有者（用户）和单个访客（服务）的实现。 如协议所示，身份包括用于所有者和访客的签名密钥对，以及用于数据加密（和解密）的对称密钥，以便保护数据免受系统中的所有其他参与者的影响。形式上，复合身份在外部（如网络中）看来是一个二元组： $$ Compound_{u, s}^{(public)}=(pk_{sig}^{u, s},pk_{sig}^{s, u}) $$ 整个身份（包括私钥）是如下五元组： $$ Compound_{u, s}=(pk_{sig}^{u, s},sk_{sig}^{u, s}, pk_{sig}^{s, u},sk_{sig}^{s, u},sk_{enc}^{u, s}) $$ B. 区块链存储空间 我们让L代表区块链存储空间，表示为哈希表 L：{0,1} 256→{0,1} N，其中N»256并且可以存储足够大的文档。我们假设这个存储在比特币和其他区块链中使用的相同对抗模型下是防篡改的。为了直观地解释为什么这种可信数据存储可以在任何区块链（包括比特币）上实现，请考虑以下简化的，虽然效率低下的实现：区块链是一系列带时间戳的交易，其中每个交易包括可变数量的输出地址（每个地址是160位的值）。然后L可以按如下方式实现：交易中的前两个输出哈希为256位存储地址指针（其实就是哈希值），以及一些辅助元数据。其余的输出构成了序列化文档。查找 L[k]时，仅返回最近的交易，除了插入之外，还允许更新和删除操作。 C. 策略和辅助功能 用户u授予服务s的一组权限，由POLICYu，s表示。例如，如果u安装了需要访问用户位置和联系人的移动应用程序，那么POLICYu，s = { location，contacts }。值得注意的是，假设服务不会破坏协议并错误地标记数据，任何类型的数据都可以通过这种方式安全存储。可以在移动SDK中引入部分防止这种情况的保护措施，但无论如何，用户可以轻松检测到作弊的服务，因为他可以看到所有更改。 Parse（x）并行化发送到交易的消息，消息包含参数。协议2中说明的CheckPolicy（pkksig，xp）验证发起者是否具有适当的权限 D. 核心协议 包括两种：访问控制和存储数据。当接收到Taccess交易时，协议3由网络中的节点执行，类似地，对Tdata交易执行协议4。 如本文前面所述，Taccess交易允许用户通过发送POLICYu，s来更改授予服务的权限集。发送空集会撤消先前授予的所有访问权限。使用新的复合身份发送Taccess交易将被解释为用户首次注册服务。 类似地，Tdata交易控制读/写操作。在Check Policy的帮助下，只有用户（总是）或服务（如果允许）才能访问数据。请注意，在协议4的第9行和第16行中，我们使用简写符号来访问DHT，就像普通的哈希表一样。实际上，这些指令产生发送到DHT的链下的网络消息（读或写）。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:3:2","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"3. 相关分析 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:4:0","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 隐私与安全 我们依赖于区块链是无篡改的，这种假设需要一个足够大的不受信任的对等网络。此外，我们假设用户以安全的方式管理其密钥，例如使用安全的集中式钱包服务。我们现在展示我们的系统如何防止攻击者破坏系统中的节点。目前，我们不太关心改变协议或记录先前读取数据的恶意服务，因为它们很可能是有信誉的，但我们在第V-A节中提供了这种行为的可能解决方案。 鉴于此模型，只有用户可以控制他的数据。区块链分布式的特性与数字签名交易相结合，确保对手无法冒充用户或破坏网络，因为这意味着对手伪造了数字签名，或者控制了大部分网络资源。同样，攻击者无法从区块链中学到任何东西，因为只有哈希指针存在链里。 控制一个或多个DHT节点的对手无法得到有关原始数据的任何信息，因为它是使用没有任何节点拥有的密钥加密的。请注意，虽然每个节点都不能确保数据完整性，因为单个节点可以篡改其本地副本或以拜占庭方式操作，但我们仍然可以通过充分切分和复制数据来最小化风险。 最后，为每个用户 - 服务对生成新的复合身份可确保在攻击者获得签名和加密密钥的情况下，只有一小部分数据受到危害。如果攻击者只获得其中一个键值，那么数据仍然是安全的。请注意，在实践中，我们可以进一步分割身份，以限制单个复合身份的暴露。例如，我们可以为每100条记录存储生成新密钥。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:4:1","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 未来发展 在本节中，我们稍微讨论一下区块链未来的发展。与当前最先进的系统相比，这些可以在塑造更成熟的分布式可信计算平台方面发挥重要作用。更具体地说，它们将大大增加先前提出的平台的实用性。 A. 从存储到处理 到目前为止，我们的分析侧重于存储指向加密数据的指针。虽然这种方法适用于存储和随机查询，但它对处理数据的效率不高。更重要的是，一旦服务查询到一段原始数据，它就可以存储它以供将来分析。 更好的方法可能是永远不要让服务获取原始数据，而是允许它直接在网络上运行计算并获得最终结果。如果我们split data into shares（例如，使用Shamir’s Secret Sharing），而不是加密它们，我们就可以使用安全的多方计算（MPC）来安全地评估任何功能。 在下图中，我们说明了MPC如何与区块链结合使用，特别是在我们的框架中。考虑一个简单的例子，其中一个城市举行选举并希望允许在线秘密投票。它开发了一个投票的移动应用程序并使用了我们的系统，现在增加了MPC的功能。在线选举结束后，该市随后提交其后端数据以汇总结果。网络随机选择节点子集，解释器将数据转换为安全的MPC协议。最后，结果存储在区块链中，以防止篡改。结果，没有人知道个人投了什么票，但每个人都可以看到选举的结果。 B. Trust and Decision-Making in Blockchains 比特币或一般的区块链假设所有节点都是同等不受信任的，并且它们在集体决策过程中的比例完全基于它们的计算资源（称为工作量证明算法）。换句话说 - 对于每个节点，资源（概率地）决定节点在投票中的权重。这会导致不利影响，最显著的是对sybil攻击的脆弱性，过度的能量消耗和高延迟。 直观上，工作量证明体系中将更多资源投入系统中的节点更不可能作弊。相似的，我们可以定义一种基于节点行为的新的信任的动态度量，比如遵循协议的行为会得到奖励。具体来说，我们可以将每个节点的信任度设置为其未来表现良好的预期值。同样，由于我们处理的是二进制随机变量，因此期望值只是概率p。逼近这种概率的一种简单方法是计算节点所采取的好的和坏的动作的数量，然后使用sigmoid函数将其压缩成概率。在实践中，每个块i我们都应该以公式(3)重新评估每个节点的信任分数 $$ trust_{n}^{(i)}= \\frac{1}{1+e^{-\\alpha(\\# good-\\# bad)}}\\qquad $$ 其中α 只是步长 基于这种度量，网络可以为可信节点提供更多权重并更有效的计算区块，因为这些节点花费了时间在系统中获取信任。它应当能抵抗sybil攻击。这种机制可能会吸引其他类型的攻击，例如节点增加其信用只是为了以后恶意行为。这可以通过随机选择几个节点来缓解，这些节点按其信任加权，对每个块进行投票，然后进行同等加权的多数投票。这可以防止单个参与者受到太多影响，无论他们的信任级别如何。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:4:2","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"4. 总结与启发 个人数据和一般敏感数据的存储不应该信任第三方，因为第三方容易受到攻击和滥用数据。相反，用户应该拥有并控制他们的数据，而不影响安全性或限制公司和权威机构提供个性化服务的能力。我们的平台通过将区块链和链下存储解决方案相结合来实现这一目标。用户不需要信任任何第三方，并且始终知道正在收集的有关他们的数据及其使用方式。此外，区块链将用户识别为其个人数据的所有者。反过来，公司可以专注于利用数据而不过度担心正确保护和划分数据。 此外，通过分布式的平台，制定关于收集，存储和共享敏感数据的法律和监管决策应该更加简单。此外，法律法规可以编入区块链本身，以便自动执行。在其他情况下，分类帐可以作为访问（或存储）数据的合法证据，因为它是（计算上）防篡改的。 ","date":"2019-02-14","objectID":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/:5:0","tags":["论文笔记"],"title":"Decentralizing Privacy：Using Blockchain to Protect Personal Data","uri":"/2019/decentralizing-privacyusing-blockchain-to-protect-personal-data/"},{"categories":["研究生的区块链学习之路"],"content":"随着物联网的高速发展，越来越多的智能设备接入到了人们的日常生活和工业生产当中。尤其在智能工厂领域，物联网设备的使用大幅提高了工厂自动化程度，并提供了更高的容错能力。然而，现有的集中式云存储与管理方式面临很大的安全隐患和性能瓶颈。学术与工业界目前致力于将区块链技术应用于车联网、能量网络和供应链方向，而忽视了智能工厂与区块链的结合。本文从区块链和物联网的可结合性出发，具体分析了智能工厂场景区块链技术的适用性。对现有的共识算法进行分类，总结分析在智能工厂场景中可做的改进。研究工厂实时数据的存储解决方案。列举了可能面临的安全问题和攻击方式，并提出使用智能合约来完善安全机制。从而为之后的实验研究奠定了基础。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:0:0","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引言 物联网是互联网概念的扩展，通过将具有独立功能的实体互联互通，可以为我们的生产生活带来巨大便利。自从物联网的概念提出以来，迅速应用到了智能家居、农业、医疗和工业等诸多领域，物联网在工业中的应用称为工业物联网。工业物联网是工业4.0的重要一部分，然而，随着终端设备数量的迅速增长，传统的基于云的中心化架构面临的部署和维护成本，向第三方支付的服务费用，以及性能、安全和隐私问题都迫切需要解决。同时，由于设备和生产过程的深度融合，恶意攻击所带来的危害也远远超出普通的互联网，甚至可能对人们的生命财产造成威胁。 区块链是解决中心化带来的单点瓶颈和安全问题的有效手段。这项技术起源于2008年中本聪提出的比特币1，它分布式的结构能有效避免单点问题，共识和链式结构带来的不可篡改性和通过智能合约实现的访问控制又能为物联网带来良好的安全与隐私保护。另外，智能合约还能便于设备进行一定的自动化交互。目前，许多人正在研究将其应用于物联网234。然而，要实现这一目的还需解决一些问题： 效率和安全：区块链的核心是共识算法，工作量证明(Proof of Work, PoW)则是使用最广泛的一种，它需要节点具有较高的算力，而物联网设备的相关性能往往是极为有限的。虽然消除对算力的需求可使区块链适用于物联网，但同时也失去了它带来的安全性。 隐私：区块链虽然具有匿名特性，但采用如链接攻击等方式可以将行为与用户地址关联起来，从而破解用户真实身份，由于存储在区块链中的数据是公开可见的，一旦身份被获知，数据将完全泄露；物联网涉及大量的隐私数据，需要更加良好的隐私保护方案。 吞吐量和数据存储：区块链共识采用洪泛的通信方式，因此具有一定的延迟，从而导致吞吐量较低。另外，网络中每个节点都要保存整个区块链的副本，由于区块链不断增长的链式结构，并不适合大量数据的存储。然而，物联网通常会产生大量实时数据，具有较高的存储和吞吐量需求。 目前很多研究者都致力于解决以上问题，但在工业领域，大量研究集中在车联网56、能量网络78和供应链9[^tian2016agrifood]方面，而较少分析和关注区块链在制造工厂内的适用性和解决方案。事实上，智能工厂作为工业4.0重要的一部分，区块链不仅在原材料和产品分销，个性化产品定制等方面可提供一定帮助，在提高工厂生产效率和数据安全方面，也是一种良好的解决方案。首先，区块链配合分布式存储系统消除对中心化的云服务商的依赖，在性能、安全和隐私方面得到改进；其次，借助智能合约，可以完成对工厂大量物联网终端设备的访问控制；并且实现对生产的动态调整，完成一定的自动化与智能化。 区块链和制造工厂结合的相关研究1011，和智能家居场景121314具有一定的相似性。这两个场景的研究通常集中于细粒度的访问控制和安全框架，然而，大部分并不深入，只是区块链和分布式存储技术的简单结合。另外，工业物联网同普通的物联网在诸多方面有着区别，如设备的自动化，低时延高可靠性的要求。但是，两者都更适合使用私有区块链而非公有区块链。 本文旨在总结物联网和区块链结合的众多已有方案，分析它们的优势与不足，并在制造工厂场景下，分析各方面可做的改进，存储方案的选择和访问控制方案的设计。从而提高工厂的生产效率，降低其成本，为下一步的概念验证和实际的大规模实施做理论准备。 本文其余部分安排如下。第二部分介绍相关共识方案并分析工厂场景下共识可做的优化。第三部分介绍待选的存储方案，并比较它们在工厂场景的适用性。第四部分详述可能可能面临的攻击和访问控制的方案，同时包括对隐私问题的讨论。第五部分讨论其它的补充机制。总结在最后的第六部分。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:1:0","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"2. 共识 区块链技术的核心是共识，广义上讲，它是一组参与各方能达成一致所需遵守的规则。在区块链中，共识确保了节点和交易的可信，并解决了双花问题。迄今为止，已提出了种类繁多的共识协议，它们达成一致的速度有快有慢，有的同时适用于公有和私有区块链，有的则只适用于私有区块链 ,有些是通用类型的共识，有些只针对特定的需求和场景。以下我们先介绍各种不同类型的共识，然后再根据工厂场景进行挑选，并提出可做的改进。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:2:0","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 共识分类 自区块链第一次出现[1]以来，使用最广泛的共识机制一直是工作量证明，代表性的应用有比特币、以太坊和莱特币等。PoW中，为了添加新块，节点必须证明自己做了一定的工作，这一工作一般是大量的哈希运算，无论是计算依赖（Bitcoin PoW）还是存储依赖（Ethash），都需要消耗电力资源，带来资源浪费和高成本，但却可以在无信任网络中实施。PoW共识中的交易速度较慢，另外，还需要激励机制来鼓励矿工参与维护网络。 与PoW不同，权益证明（Proof-of-Stake, PoS）的核心是在网络中拥有更多权益的人具有更小的攻击可能性，这个权益指节点持有的代币数量及持有代币的时间。PoS消除了对算力的需求，但可能出现最富者支配记账权的情况，同时，还存在“无厉害关系(nothing at stake)”问题，即在出现分叉的情况下，权益持有者有动机在分叉形成的两条链上都下赌注，更有可能出现双花问题。PoS的代表性应用主要是Cardano、NXT、Tezos和未来的以太坊。 委托权益证明(Delegate Proof of Stake, DPoS)会选举一定数量的节点进行交易验证和区块添加，投票的权重取决于节点的权益大小，并且，投票选举的验证者出现“作恶”情况也可以通过重新投票随时进行替换。DPoS能以更高的速度形成区块，并且在单位时间处理大量的交易，共识运行的效率更高。Daniel Larimer在2014年设计了它，并在BitShares中首次使用，后来又在Steemit和EOS项目中使用该共识，其它如TRON也使用DPoS方案。以上三种共识是公有区块链中最常使用的共识，但它们也适用于私有区块链。 在私有区块链中，由于部分节点可以相互信任，参与验证的节点数减少，从而交易和区块生成的速度可以加快。拜占庭容错(Byzantine Fault Tolerance, BFT)正是针对这种场景提出的共识。BFT可以容忍小于1/3个恶意或无效节点的存在。事实上，BFT是一个大的分类，许多共识都可以划归到BFT的范围内，主要包括授权拜占庭容错(Delegated Byzantine Fault Tolerance, DBFT)，实用拜占庭容错(Practical Byzantine Fault Tolerance, PBFT)，联邦拜占庭协议(Federated Byzantine Agreement, FBA)和其它的一些共识协议。我们将它们适用的区块链类型和主要应用案例总结如表3.1所示。 表2.1 BFT类共识 公有/私有区块链 私有区块链 DBFT：NEO, TON FBA：Stellar, Ripple PBFT：Hyperledger, Chain SIEVE：Hyperledger beta Round Robin：Multichain, Tendermint Loopchain Fault Tolerance(LFT)：ICON Cross-Fault Tolerance(XFT)：Hyperledger beta 除以上几种主流的共识外，还有众多用于特定任务或特定场景的共识如Proof-of-Activiy(PoA)，Proof-of-Elapsed-Time(PoET)，Proof-of-Authority(PoA)和Proof-of-Burn等。以上共识建立的区块链都是链式结构，实际上，为了改善吞吐量等问题，人们还提出了图状结构的“区块链”，如IOTA的DAG区块链和HashGraph。而无论是链式还是图状的区块链共识，都消除或部分消除了PoW对算力的依赖问题，并且在吞吐量、扩展性等方面进行了相关的改进，使其适用于特定的或更广泛的领域。同时，由于技术的飞速发展，提出时间较晚的共识往往具有更多更好的特性。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:2:1","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 共识需求及改进 目前已存在不少专门针对物联网开发的区块链平台，市场占有率较高的几位分别是：使用DAG结构的IOTA；使用PoS协议的量子链QTUM；使用DPoS的EOS；使用PoW和PoS混合的沃尔顿链Waltonchain以及使用权威证明(Proof of Authority, PoA)的VeChain。这些平台的市场占有情况说明了它们所使用的共识都是一定程度上适用于物联网的，基于这些协议的特性，以及制造工厂的相关背景，我们总结单个制造工厂中的共识需要的改进： 资源限制：尽可能减少对资源的依赖是首要需求，这方面可做的改进主要包括1）共识本身。消除PoW共识对算力的严重依赖，实际上，PoW之后的共识普遍都达成了这一点。但除这种办法外，有一些研究者仍然在PoW上做努力15，他们引入了“银行“的思想，使资源有限的设备可以向附近算力较强的设备“借”算力，从而完成挖矿操作。这种方案虽然消除了物联网设备的资源限制问题，但没有解决电力浪费问题，在工业领域，这种电力浪费带来的成本是不想要的。2）加密算法。为了安全性进行签名使用的加密算法也需要进行哈希运算，从而带来对算力的一定需求，所以选择加密算法时应在安全性的基础上选择算力需求较低的算法。16中，研究者认为RSA和ECC（椭圆曲线加密）都具有一定的不足，而AES(Advanced Encryption Standard)是更好的选择，建议使用Simon、Scrypt或X11这样的新算法，但是对IoT设备使用的哈希算法还应做进一步的分析。3）P2P通信，P2P通信是共识过程不可缺少的一部分，但需要对终端设备持续供电，这一机制在一定程度上是与物联网的节能策略相背离的，对资源造成了一定的浪费，故需要对通信机制进行一定的优化。可以通过广播精简的数据结构而不是整个区块来减少广播时的通信冗余。 可扩展性：可扩展性主要包括两方面，1）物联网终端设备的巨大数目及其不断增长的趋势，要求共识必须具有良好的可扩展性，能够支持设备动态的加入退出。17中通过分离物联网网络和区块链，只将访问控制相关的交易记载在链中的方式，提供了较高的可扩展性；2）小型的交易可能会增加与通信相关的能耗，而载荷过大的交易物联网设备将可能无法处理，故交易和区块的大小需要能根据物联网网络的带宽限制进行调整。鉴于此，在区块链中普遍应用的全节点和轻节点方案基础上，Slock.it又提出了两种节点类型，从而填补了该方面的空缺。 吞吐量（TPS）：TPS即每秒处理的交易数，是区块链的吞吐量单位，物联网由于其巨大的设备数目和复杂的运行环境，需要较高的TPS，比特币中TPS值为7，以太坊为15，都难以满足要求，采用BFT共识的区块链这一参数值普遍较高，可以达到10000。区块链平台EOS据称可以达到百万级。而采用DAG的IOTA则是实时的。实际上，大多数的平台都在致力于吞吐量的提高，比较著名的例子是以太坊的分片方案，比特币的扩容方案，以及闪电网络、雷电网络等链下解决方案。 吞吐量的问题一部分是共识过程的复杂性带来的，主要是通信及交易确认的延迟，所以使用速度较快的哈希算法如scrypt而不是SHA-256能带来一定的优化，另一部分原因是任务的单进程处理，分片方案的实质就是提高并发程度。 激励机制：比特币和以太坊等公链场景下，由于要鼓励矿工进行挖矿，不断地添加新块到区块链中，需要激励机制的存在。在车联网、能量网络等工业领域，激励机制也有某种程度的适用性，然而在单个工厂场景中，运行节点的成本由工厂负责，即使没有激励机制，也能得到很好的运行。在这种情况下，可以考虑取消激励机制的存在，或者将基于货币的激励机制更改为基于信誉积分的激励机制。 从以上几方面进行优化的共识一定程度能更适应单个工厂场景，然而，如TCP/IP协议的出现一般，并不是最完善的技术最适合，以太坊、EOS、IOTA等平台的方案已经对物联网具有极好的适应性，首要和初步的考虑仍然是使用它们来进行方案的设计与实验，只有进行到方案优化阶段，我们才考虑从上述提到的诸多方面做改进。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:2:2","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"3. 存储 区块链本身面临着存储问题。随着时间的推移，新的区块不断的添加到区块链的末尾，这使得区块链的体积不断增长，带来的问题是参与共识的矿工初始需要同步更多的内容，致使节点参与挖矿的门槛不断提高。目前采用的轻节点是一种解决方案，但这种情况下区块链无法缺少一定量的全节点，从而会导致某种程度的中心化，另一种选择是使用mini-blockchain1819，这种方式只有新用户添加到区块链时，区块链才会增长。最后如20等人在研究的区块链压缩方案也是一种思路。 而对物联网来说，要和区块链结合，必须解决不断产生的庞大数据的存储问题。因为虽然区块链可以防止数据篡改和单点故障，但使用区块链直接存储物联网数据，会面临机密性和可扩展性问题。 机密性：数据不可变性是区块链的优势，它给了区块链高稳健性，但不是所有的数据都需要不可变的存储，如用户的个人资料，更改后先前的数据仍会永远留在区块链中，任何人都能看到。同样，许多场景中数据最好只对一部分节点可见。解决办法是对原始数据进行加密再存储，在物联网场景下，也可以使用智能合约进行访问控制，从而把数据访问权只开放给授权节点。 可扩展性：如前所述，区块链的数据在不断增长，增加了节点参与的难度。在物联网场景将加剧这一问题，一种解决办法是数据仍然进行传统的中心化存储，而把数据哈希存储在区块链中21，这样可以保证数据的完整性，但缺失了解决单点问题的初衷。更合适的办法是采用分布式存储，Wulf Kaal将其划分为六种情况22，我们认为其划分有部分重复和缺失，故重新总结如下： 传统的分布式存储：由于关系数据库对大数据存储的支持不是很好，故大数据的存储一般使用NoSQL数据库，23对市场上出现的大数据存储技术做了全面的调查，关注点主要在于分布式存储技术，大部分都以NoSQL的格式进行存储，包括Google File System(GFS)，Hadoop Distributed File System(HDFS)，BigTable，HBase，MongoDB等，它们速度快、可扩展、容错、支持丰富的查询语言，但它们声称的容错指的是分布式本身带来的容错性能，一个节点被毁，因为副本数据的存在并不会对整个系统造成影响，而缺乏对恶意攻击的抵御性能，集群中的所有节点相互之间完全信任，任何一个恶意节点都能毁掉整个数据库。 IPFS：建立在BitTorrent协议和分布式哈希表（Distributed Hash Table）基础之上的内容寻址服务，它成功的解决了大数据量的问题，但作为一个目标是下一代Web的系统，上传的所有数据将无法得到控制，这是企业及工厂所有者们不想看到的。 去中心化的云文件存储：将存储系统托管在用户的计算机上，而不是在云端的服务器，由节点用户出租和购买存储空间来维持该系统。这样的项目包括Sia，Storj，PPIO，Ethereum Swarm。不需要保持在线就能分享文件。上传的文件能得到很好的安全保护，存储可靠，速度快，容量大。解决了传统物联网中心化存储单点故障问题，但在费用上是不可预知的，并且，在维持区块链的同时维持该存储系统，需要一些中间件来维持，显得有些笨拙和不方便。 Ties DB： TiesDB 继承了传统 NoSQL 分布式数据库的大部分功能，并增加了拜占庭容错和激励。有了这些功能，它可以成为公共数据库，并通过智能合约在 Ethereum 和其他区块链上启用功能丰富的应用程序。任何用户都有数据库写入权限，但被其账户地址唯一识别，所有的请求都进行签名。记录创建之后，创建者则成为记录的所有者一起被记录。之后，记录只能被记录所有者修改。每个人都可以阅读所有的记录，因为数据库是公开的。根据请求和复制检查所有的权限。额外的权限可以通过智能合约管理。 巨链数据库BigChainDB：BigChainDB 的目标是将NoSQL数据库的主要优点与区块链技术的优点结合起来，如表3.124所示 ，实际上，结合的正是MongoDB和Tendermint(一种BFT)共识 表3.1 Bitcoin，分布式数据库，BigchianDB特性比较 比特币区块链 分布式数据库 BigchianDB 不可变性 Yes Yes 去中心化 Yes Yes 网络上的资产 Yes Yes 高吞吐量 Yes Yes 低延迟 Yes Yes 丰富的权限 Yes Yes 查询功能 Yes Yes 物联网和区块链结合的实验系统中，IPFS2526、SGS27、BigchainDB28和Swarm29都有研究者使用过，其结合方式均为将物联网产生的原始数据存入这些存储系统，再将数据哈希存入区块链，这一方案会面临一个新的问题，即需要维持区块链和存储两套P2P系统，然后利用中间件进行交互，这种结构是复杂的不易维护且笨重的，Multichain中的off-chain结构通过将存储节点和区块链节点合并，解决了这一问题。另外，在工厂场景中，我们需要的是一个可以在本地部署的存储系统，如Storj这种分布式的云是不适用的，但Ethereum Swarm例外，它是一个分布式的云文件系统，但也可以在本地部署。 综上所述，在单个工厂场景中，我们需要一个分布式的，可在本地部署的文件系统，同时，因为和区块链主体的分离，存储系统本身也需要高吞吐量、低延迟、不可变的安全特性等，多级权限不需要由存储系统提供，而由区块链的访问控制实现，最后，还需要支持在异构的物联网终端设备上运行。传统的分布式存储缺乏不可变特性和相关安全机制，IPFS和去中心化的云存储除Swarm外无法在本地部署，Multichain不支持并且在可预期的未来也不会支持在各种异构设备上运行，因此，我们需要将BigchainDB、TiesDB或Swarm与区块链深度结合，在保证原有特性的同时，减小双系统部署的复杂性，并提供异构系统的支持，从而为区块链和工厂进一步结合铺平道路。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:3:0","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"4. 安全和隐私 区块链的价值与安全性随着用户数量的增加而增加，而物联网多数节点为自动化的终端设备，少数节点为人工控制，因此需要单独考虑。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:4:0","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 常见安全问题 同互联网面对种种安全和隐私威胁相似，物联网面临同样的问题，并且随着物联网渐渐融入生活的方方面面，设备遭到安全攻击或用户隐私泄露带来的危害也更大。原因有很多方面，包括：（1）大多数通信都是无线的，这使得系统更容易受到攻击如身份欺骗，消息窃听，消息篡改和其他安全问题，以及（2）多种类型的设备在能量，内存和处理能力方面的资源有限，这阻碍了它们实施高级安全解决方案。 区块链与物联网的结合解决了诸如数据完整性方面的问题，但仍存在未解决的安全问题，并且区块链也带来了一些其本身面临的安全问题。下面介绍这些安全问题和可能面对的攻击。 管理者：区块链中交易和区块的添加依赖于矿工的工作，矿工伪造交易会被发现，但其拒绝添加交易的行为却可能带来严重后果。相似的，与物联网结合时，终端设备身份需要在链中验证和确认，如果身份提供者负责授权，那么它也可以阻止，30使用非对称密钥提供了一种解决方案。31提出了一种基于云的物联网应用的数据完整性框架 女巫攻击(Sybil attack)：节点通过伪造多个身份来进行攻击，骗取权限或数据等，可以通过身份认证解决，即每个物联网设备的唯一标识和不可替代，这一点一般通过密钥分发完成。 欺骗性攻击(spoofing attack)：伪装成合法用户以利用其权限 消息替换(message substitution)：在信息传输过程中对其进行替换，而不被接收者发现。 DoS(Denial of Service)或DDoS(Distributed DoS)攻击：短时间发起大量请求，使网络拥塞，Ali的方案中用CH控制密钥列表来识别消息，避免DDoS带来的问题 重放攻击(Message Replay Attack)：用户请求被攻击者获取，然后重新发给服务器，从而达到认证通过的目的，加密解决不了该问题，一般通过时间戳或随机数解决。 日蚀攻击：区块链中通过隔离节点伪造安全的通信环境 工厂场景与比特币系统或其它的系统相反，节点的身份（即匿名性）是不被需要的，反而应该被验证；而数据的隐私通过完整的访问控制来实现，确保什么人什么时间可以访问什么数据。 但当多个工厂间或与用户通过跨链等技术连接时，需要考虑更多隐私方面的问题，但这不是我们现在需要考虑的。32中提出的环签名方案保证只有交易双方知道身份。同态加密和零知识证明可以解决交易隐私问题，但解决方法都是资源密集型的，在资源受限的IoT设备上适用性有限。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:4:1","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 访问控制 论文33 中提出，认证和访问控制是解决物联网中安全与隐私问题的主要手段，而任何有效的访问控制系统都应满足三个安全需求：机密性、完整性和可用性。机密性确保只有授权用户才能获得数据。完整性确保数据未经修改，物联网的场景中，将完整性分为两方面：1) 交易完整性：在网络传输过程中，交易信息不得被修改，核心是通信过程。2) 数据完整性：数据在整个生命周期内保持一致性和可信赖性。确保只有授权用户才能修改存储的数据。可用性意味着合法用户需要时可以访问数据。 完整的访问控制包括认证、授权和问责。[34]提供了关于授权的参考模型，将其分为目标、模型、架构、机制四层，从而提供一个完整的构思和实现思路。 物联网和区块链结合拥有了区块链的安全特性，机密性通过访问控制和加密技术实现，完整性由数字签名和区块链的不可变特性带来，可用性则基于分布式系统的基本特性，少量节点的受损不会导致数据的损坏不可访问。 工厂场景中提到访问控制的含义有两层，一是对存储的数据的权限的访问控制，这一部分在上面提到的多数方式中都能得到良好的实现，而对数据存入存储网络还是直接存入区块链可由矿工节点执行，存入区块链的数据由智能合约进行合适的存储；二是对设备权限的访问控制，如前所述，我们需要对更下层的，包括物联网网关甚至传感器的控制。 关于区块链和物联网结合，现有的访问控制的实现方式有两种，一种是利用提出的区块链架构实现访问控制，Ali在[4]中提出的架构中，通过簇头（Cluster Head）对节点进行分组管理，维护密钥列表，从而实现访问控制；一种是利用智能合约实现访问控制。[7]中使用名为Energy aggregators(EAG)的中间实体管理与能源交易有关的事件，并为IIoT节点提供无线通信服务，通过一定程度的中心化实现访问控制；Oscar在[18]中将物联网系统与区块链系统分离，只将访问控制策略定义在区块链中，通过Managers来注册设备和访问策略定义等，从而实现设备管理和访问控制；34定义了一种基于区块链的多级机制来改进访问管理，该机制将指定功能，访问列表和访问权限。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:4:2","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"5. 其它 最后，区块链网络可能需要以下机制来补充其功能，并且这些机制也应是分布式的。 指向区块链中资源的DNS服务，用于查找相应的区块 安全的通信和文件交换，区块链中的消息通信是公开的，如果需要两个节点间专用的通信，需要telehash, Whisper之类的协议，不同工厂的区块链的交互需要跨链机制的支持，另一方面，传感器数据的存储可能使用私有区块链，而货币和服务的流通可能使用比特币或以太坊。 ","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:5:0","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["研究生的区块链学习之路"],"content":"6. 总结 我们讨论了单个工厂内使用区块链的可能性，以及为了提高工厂生产效率和安全，在共识、存储、安全和隐私的各个方面可以做的种种改进，从而为下一步的研究做准备。 Nakamoto S. Bitcoin: A peer-to-peer electronic cash system[J]. 2008. ↩︎ Christidis K, Devetsikiotis M. Blockchains and smart contracts for the internet of things[J]. Ieee Access, 2016, 4: 2292-2303. ↩︎ Özyılma K R, Yurdakul A. Work-in-Progress: Integrating low-power IoT devices to a blockchain-based infrastructure[C]. Proceeding of the Thirteenth ACM International Conference on Embedded Software. 2017. ↩︎ Dorri A, Kanhere S S, Jurdak R, et al. Blockchain for IoT security and privacy: The case study of a smart home[C]. 2017 IEEE international conference on pervasive computing and communications workshops (PerCom workshops). IEEE, 2017: 618-623. ↩︎ Dorri A, Steger M, Kanhere S S, et al. Blockchain: A distributed solution to automotive security and privacy[J]. IEEE Communications Magazine, 2017, 55(12): 119-125. ↩︎ Huang X, Xu C, Wang P, et al. LNSC: A security model for electric vehicle and charging pile management based on blockchain ecosystem[J]. IEEE Access, 2018, 6: 13565-13574. ↩︎ Li Z, Kang J, Yu R, et al. Consortium blockchain for secure energy trading in industrial internet of things[J]. IEEE transactions on industrial informatics, 2018, 14(8): 3690-3700. ↩︎ Liang G, Weller S R, Luo F, et al. Distributed blockchain-based data protection framework for modern power systems against cyber attacks[J]. IEEE Transactions on Smart Grid, 2018. ↩︎ Korpela K, Hallikas J, Dahlberg T. Digital supply chain transformation toward blockchain integration[C]//proceedings of the 50th Hawaii international conference on system sciences. 2017. ↩︎ Lin C, He D, Huang X, et al. BSeIn: A blockchain-based secure mutual authentication with fine-grained access control system for industry 4.0[J]. Journal of Network and Computer Applications, 2018, 116: 42-52. ↩︎ Kapitonov A, Berman I, Bulatov V, et al. Robonomics Based on Blockchain as a Principle of Creating Smart Factories[C]//2018 Fifth International Conference on Internet of Things: Systems, Management and Security. IEEE, 2018: 78-85. ↩︎ Xue J, Xu C, Zhang Y. Private Blockchain-Based Secure Access Control for Smart Home Systems[J]. KSII Transactions on Internet \u0026 Information Systems, 2018, 12(12). ↩︎ Qu C, Tao M, Yuan R. A hypergraph-based blockchain model and application in Internet of Things-enabled smart homes[J]. Sensors, 2018, 18(9): 2784. ↩︎ Xu Q, He Z, Li Z, et al. Building an Ethereum-Based Decentralized Smart Home System[C]//2018 IEEE 24th International Conference on Parallel and Distributed Systems (ICPADS). IEEE, 2018: 1004-1009. ↩︎ Xiong Z, Zhang Y, Niyato D, et al. When mobile blockchain meets edge computing[J]. IEEE Communications Magazine, 2018, 56(8): 33-39. ↩︎ Fernández-Caramés T M, Fraga-Lamas P. A Review on the Use of Blockchain for the Internet of Things[J]. IEEE Access, 2018, 6: 32979-33001. ↩︎ Novo O. Blockchain meets IoT: An architecture for scalable access management in IoT[J]. IEEE Internet of Things Journal, 2018, 5(2): 1184-1195. ↩︎ Bruce J D. The mini-blockchain scheme[J]. White paper, 2014. ↩︎ França B F. Homomorphic mini-blockchain scheme[J]. 2015. ↩︎ Kim T, Noh J, Cho S. SCC: Storage Compression Consensus for Blockchain in Lightweight IoT Network[C]//2019 IEEE International Conference on Consumer Electronics (ICCE). IEEE, 2019: 1-4. ↩︎ Ali S, Wang G, Bhuiyan M Z A, et al. Secure Data Provenance in Cloud-Centric Internet of Things via Blockchain Smart Contracts[C]//2018 IEEE SmartWorld, Ubiquitous Intelligence \u0026 Computing, Advanced \u0026 Trusted Computing, Scalable Computing \u0026 Communications, Cloud \u0026 Big Data Computing, Internet of People and Smart City Innovation (SmartWorld/SCALCOM/UIC/ATC/CBDCom/IOP/SCI). IEEE, 2018: 991-998. ↩︎ Wulf Kaal. How can blockchain be used as a database to store data[Online]. https://www.quora.com/How-can-blockchain-be-used-as-a-database-to-store-data. 2017. ↩︎ Siddiqa A, Karim A, Gani A. Big data storage technologies: a survey[J]. Frontiers of Information Techn","date":"2019-02-05","objectID":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/:6:0","tags":["科研记录"],"title":"文献综述-区块链用于 IoT/IIoT：智能工厂案例","uri":"/2019/blockchain-for-iot/iiota-smart-factory-case-study/"},{"categories":["平日里的白日梦"],"content":"大学章句 右经一章，盖孔子之言，而曾子述之。其传十章，则曾子之意而门人记之也。旧本颇有错简，今因程子所定，而更考经文，别为序次如左。 《大学》之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始，知所先后，则近道矣。古之欲明明德于天下者，先治其国；欲治其国者，先齐其家；欲齐其家者，先修其身；欲修其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知；致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。自天子以至于庶人，壹是皆以修身为本。其本乱而末治者，否矣，其所厚者薄，而其所薄者厚，未之有也！ 右传之首章，释明明德。《康诰》曰：“克明德。”《大甲》曰：“顾諟天之明命。”《帝典》曰：“克明峻德。”皆自明也。 右传之二章，释新民。汤之《盘铭》曰：“苟日新，日日新，又日新。”《康诰》曰：“作新民。”《诗》曰：“周虽旧邦，其命惟新。”是故君子无所不用其极。　右传之三章，释止于至善。《诗》云：“邦畿千里，惟民所止。”《诗》云：“缗蛮黄鸟，止于丘隅。”子曰：“于止，知其所止，可以人而不如鸟乎！”《诗》云：“穆穆文王，于缉熙敬止！”为人君，止于仁；为人臣，止于敬；为人子，止于孝；为人父，止于慈；与国人交，止于信。《诗》云：“瞻彼淇澳，菉竹猗猗。有斐君子，如切如磋，如琢如磨。瑟兮僩兮，赫兮喧兮。有斐君子，终不可諠兮！”如切如磋者，道学也；如琢如磨者，自修也；瑟兮僩兮者，恂栗也；赫兮喧兮者，威仪也；有斐君子，终不可諠兮者，道盛德至善，民之不能忘也。《诗》云：“于戏，前王不忘！”君子贤其贤而亲其亲，小人乐其乐而利其利，此以没世不忘也。 右传之四章，释本末。子曰：“听讼，吾犹人也，必也使无讼乎！”无情者不得尽其辞。大畏民志，此谓知本。 此谓知本，此谓知之至也。 右传之五章，盖释格物、致知之义，而今亡矣。闲尝窃取程子之意以补之曰：“所谓致知在格物者，言欲致吾之知，在即物而穷其理也。盖人心之灵莫不有知，而天下之物莫不有理，惟于理有未穷，故其知有不尽也。是以大学始教，必使学者即凡天下之物，莫不因其已知之理而益穷之，以求至乎其极。至于用力之久，而一旦豁然贯通焉，则众物之表里精粗无不到，而吾心之全体大用无不明矣。此谓物格，此谓知之至也。”　右传之六章，释诚意。所谓诚其意者：毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也！小人闲居为不善，无所不至，见君子而后厌然，掩其不善，而著其善。人之视己，如见其肺肝然，则何益矣。此谓诚于中，形于外，故君子必慎其独也。曾子曰：“十目所视，十手所指，其严乎！”富润屋，德润身，心广体胖，故君子必诚其意。 右传之八章，释修身齐家。所谓修身在正其心者，身有所忿懥，则不得其正；有所恐惧，则不得其正；有所好乐，则不得其正；有所忧患，则不得其正。心不在焉，视而不见，听而不闻，食而不知其味。此谓修身在正其心。 所谓齐其家在修其身者：人之其所亲爱而辟焉，之其所贱恶而辟焉，之其所畏敬而辟焉，之其所哀矜而辟焉，之其所敖惰而辟焉。故好而知其恶，恶而知其美者，天下鲜矣！故谚有之曰：“人莫知其子之恶（è），莫知其苗之硕。”此谓身不修不可以齐其家。 右传之九章，释齐家治国。所谓治国必先齐其家者，其家不可教而能教人者，无之。故君子不出家而成教于国：孝者，所以事君也；弟者，所以事长也；慈者，所以使众也。《康诰》曰：“如保赤子”，心诚求之，虽不中不远矣。未有学养子而后嫁者也！一家仁，一国兴仁；一家让，一国兴让；一人贪戾，一国作乱；其机如此。此谓一言偾事，一人定国。尧舜帅天下以仁，而民从之；桀纣帅天下以暴，而民从之；其所令反其所好，而民不从。是故君子有诸己而后求诸人，无诸己而后非诸人。所藏乎身不恕，而能喻诸人者，未之有也。故治国在齐其家。《诗》云：“桃之夭夭，其叶蓁蓁；之子于归，宜其家人。”宜其家人，而后可以教国人。《诗》云：“宜兄宜弟。”宜兄宜弟，而后可以教国人。《诗》云：“其仪不忒，正是四国。”其为父子兄弟足法，而后民法之也。此谓治国在齐其家。 右传之十章，释治国平天下。所谓平天下在治其国者：上老老而民兴孝，上长长而民兴弟，上恤孤而民不倍，是以君子有絜（xié）矩之道也。所恶于上，毋以使下；所恶于下，毋以事上；所恶于前，毋以先后；所恶于后，毋以从前；所恶于右，毋以交于左；所恶于左，毋以交于右：此之谓絜矩之道。《诗》云：“乐只君子，民之父母。”民之所好好之，民之所恶恶之，此之谓民之父母。《诗》云：“节彼南山，维石岩岩，赫赫师尹，民具尔瞻。”有国者不可以不慎，辟则为天下僇矣。《诗》云：“殷之未丧师，克配上帝；仪监于殷，峻命不易。”道得众则得国，失众则失国。是故君子先慎乎德。有德此有人，有人此有土，有土此有财，有财此有用。外本内末，争民施夺。是故财聚则民散，财散则民聚。是故言悖而出者，亦悖而入；货悖而入者，亦悖而出。《康诰》曰：“惟命不于常！”道善则得之，不善则失之矣。《楚书》曰：“楚国无以为宝，惟善以为宝。”舅犯曰：“亡人无以为宝，仁亲以为宝。”《秦誓》曰：“若有一?臣，断断兮无他技，其心休休焉，其如有容焉。人之有技，若己有之，人之彦圣，其心好之，不啻（chì）若自其口出，实能容之，以能保我子孙黎民，尚亦有利哉。人之有技，媢疾以恶之，人之彦圣，而违之俾（bǐ）不通，实不能容，以不能保我子孙黎民，亦曰殆哉。”唯仁人放流之，迸诸四夷，不与同中国。此谓唯仁人为能爱人，能恶人。见贤而不能举，举而不能先，命也；见不善而不能退，退而不能远，过也。好人之所恶，恶人之所好，是谓拂人之性，菑必逮夫身。是故君子有大道，必忠信以得之，骄泰以失之。生财有大道，生之者众，食之者寡，为之者疾，用之者舒，则财恒足矣。仁者以财发身，不仁者以身发财。未有上好仁而下不好义者也，未有好义其事不终者也，未有府库财非其财者也。孟献子曰：“畜马乘不察于鸡豚，伐冰之家不畜牛羊，百乘之家不畜聚敛之臣，与其有聚敛之臣，宁有盗臣。”此谓国不以利为利，以义为利也。长国家而务财用者，必自小人矣。彼为善之，小人之使为国家，菑害并至。虽有善者，亦无如之何矣！此谓国不以利为利，以义为利也。 凡传十章：前四章统论纲领指趣，后六章细论条目功夫。其第五章乃明善之要，第六章乃诚身之本，在初学尤为当务之急，读者不可以其近而忽之也。 ","date":"2019-01-22","objectID":"/2019/the-great-learning/:0:0","tags":["读书笔记"],"title":"大学全文","uri":"/2019/the-great-learning/"},{"categories":["平日里的白日梦"],"content":"人生最贵重的，就是通过不断地学习，将你经历过的事、遇到过的人、读过的书、走过的路，揉碎吸收之后，用这些养分供养你，成就一个只属于你自己的人生，然后，让你不断超越昨天的你。 ","date":"2019-01-21","objectID":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/:0:0","tags":["读书笔记"],"title":"越简单越美好","uri":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/"},{"categories":["平日里的白日梦"],"content":"关于生活 简约不等于清贫，而是懂得取舍 如果18℃能让我们保暖，我们为什么一定要21℃的奢侈呢？ 我们吃的、住的，原本是为了让我们生活得更舒适，但有一天这些东西打扰到你的清净，分散你的精力，让你花时间保养它们，不得不时常打扫它们，保持房子的清洁。稍有不慎，甚至会让你受到伤害。那时我就考虑：我的生活里，真的需要这么多东西吗？ 拒收礼物，每一件未经计划来到我身边的东西都是多余的。 有时候，让人累的不是有计划的生活，而是没有计划的生活！别人一个电话你就到，或者随便地应约，又随便地爽约，这样你在朋友那里是得不到尊重的。随心所欲的生活看似自由，其实极大地消耗着人地时间和精力，你连自己每天要做什么都不清楚，每天上班不敢拒绝加班，下班后懒懒的往沙发上一躺。你以为你为生活少奋斗了，其实你没有。那些看似严谨约束地计划里，实则藏着你想要地自由与梦想！只有当你有能力掌控你的生活之后，你的生活，才是你的！ 一心不能二用，一次只做一件事。 既然你选择了与众不同的生活，就不要在意别人对你与众不同的评论。 在大是大非面前，必须有一个清晰而明确的判断结果。 如果你连莲的中通外直都做不到，连破茧成蝶的勇气都没有，既不能是非分明地对待生活，又不能像庄周梦蝶那样快意人生，还谈什么潇洒飘逸地佛道系？ 常年阅读的智慧和优雅，坚持不懈的锻炼之后地线条与健康，常处于同理心的爱和善良，以及不断学习带来的无论是生活还是工作中的独立和自信，正是生活和生命的审美核心。 ","date":"2019-01-21","objectID":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/:0:1","tags":["读书笔记"],"title":"越简单越美好","uri":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/"},{"categories":["平日里的白日梦"],"content":"关于伴侣 北欧人伴侣之间的关系值得学习。 同居不表示自私，不想为家庭担责。每月发工资后，双方都会拿出一部分用于家庭运转。一个人负责一家大小吃饭穿衣旅行，一个人负责每月房租、汽油费及其它花销。两人生活中矛盾不可避免，但可以尽量降到最低。除了公共花费承担的那一部分，应很少过问对方的经济花销。婚姻是绵绵无尽的信任、尊重和珍惜。在一起爱就是爱，不是为了束缚，也不是为了要改变对方什么。在一起而又没有自由的羁绊，反而更照顾对方的情绪，更为对方、为这个家着想！因为这是一份完全纯粹的以爱为前提的长情的陪伴！ 爱娃所言不虚，每次去她家里做客，安德士从来不会像地主家的二少爷一样，拿张报纸在沙发上一坐，家务活都让妻子干。孩子们最喜欢酸甜口味的食物，妈妈爱娃和爸爸安德士独家研制了番茄酱芸豆炖牛肉。安德士负责洋葱、牛肉、芸豆等所有主料配料的洗切泡，艾娃负责将所有食材按口味优化的先后顺序加不同佐料下锅料理。煮成，芳香四溢，孩子们一边捏着就近面包店买来的现烤面包，蘸着浓厚的牛肉汤吃得小肚儿圆圆，一边高呼“爱妈妈，爱爸爸”！ 经济的高度独立和对生活品质极致的追求，又决定了两个本是陌生的男女，因情生爱而组建起来的家庭，绝不会是因为物质、孩子，或者老人等这样的因素而存在。 爱意味着什么？那就是看两人能够分享独处时领悟到的生活真谛，比如人生观、价值观、孩子的成长、一本好书、一部电影、一次旅行，或者一句话等等。 即使两个人在一起，独处的时间也很重要。大家需要时间来完成日积月累的自我精神体系的构筑。一个有精神内涵的人，常常自我探索与反省的人，才有控制自我情绪的能力、专注做事的能力、成熟地爱一个人地能力，以及对整个家庭和社会负责任的能力。 素简生活不是吃苦，也不是固守清贫，而是那些经历过奋斗，付出过不懈努力，读过很多书，走过很多路，对生活有深刻品味，对生活的信念一直保有纯真，拜托了物质欲望的束缚之后，对精神层次修炼有需求的人，想拥有的生活方式。富翁和渔人在海边晒太阳的故事，即使两人做的事是一样的，但心态却不一样，渔人仍要面临生存，富翁却可安心享受美景。 如果结了婚反而过的不如单身，那么结婚的意义何在？ ","date":"2019-01-21","objectID":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/:0:2","tags":["读书笔记"],"title":"越简单越美好","uri":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/"},{"categories":["平日里的白日梦"],"content":"关于孩子 成年人是孩子的一面镜子。与其将劝告和警示挂在墙上，不如以身作则，做出表率。 孩子应更像朋友，胆怯的时候受到鼓励，做错事要承担责任，没人会说：算了，他还是个孩子。熊父母必须为熊孩子买单，孩子也应从小就要懂得为自己的行为负责。 不管日子多忙碌，一定把1/5的时间留给自己和孩子。 关于这部分可参考的还有很多，具体的观念大部分位于“活在当下的从容”后两个小节 ","date":"2019-01-21","objectID":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/:0:3","tags":["读书笔记"],"title":"越简单越美好","uri":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/"},{"categories":["平日里的白日梦"],"content":"关于女权 强势不代表着蔑视男性，蔑视男权。也不应该抛开身为女性的优势，去干一些体能上明显男人更有优势的工作，比如伐木、建筑和机器维修。选择工作时，应更好的发挥女人柔美的优势，比如老师、护士、医生、设计师等更贴近生活发明创造的领域。、 因为强势不体现在能不能像男人那样发力，而体现在能否将上天赋予的身为女人的柔和优雅舒展之美用到极致。是否在内心里，有着强大的身为女人的独立自信和自豪感。 和“关于伴侣”一节相联系，拥有自己独处的时光，和伴侣共同承担家庭责任，从家务中解脱出来，使内心真正强大，才不会只得到表面的尊重。 女权的实质是直指人性的两性关怀。如果在性别上的最起码的互相尊重都做不到，那么所谓的由自尊获得的幸福感只是妄谈。 ","date":"2019-01-21","objectID":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/:0:4","tags":["读书笔记"],"title":"越简单越美好","uri":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/"},{"categories":["平日里的白日梦"],"content":"关于相处 以正直、善良、自律、不惊扰别人、不危害社会为出发点，别人如何生活，都是别人自己选择的生活方式，我们无权干涉。要永远乐意去理解甚至尝试接受那些不一样的人，不一样的事，不一样的思想，不一样的见解。 ","date":"2019-01-21","objectID":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/:0:5","tags":["读书笔记"],"title":"越简单越美好","uri":"/2019/%E8%B6%8A%E7%AE%80%E5%8D%95%E8%B6%8A%E7%BE%8E%E5%A5%BD/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Mayra Samaniego, Ralph Deters Published in：2017 IEEE International Conference on Cognitive Computing (ICCC) Date of Conference: 25-30 June 2017 会议级别：不知道 被引量：11次 keywords：IoT; Management; Blockchain; Multichain;Smart Things; Autonomy;Self-inferencing; Self-monitoring;Fog; Edge. ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:0","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"摘要 构成物联网的大量异构设备需要有效的资源管理。随着雾计算的出现，一些管理任务可以下移到物联网的边缘，更靠近物理设备。建立在雾网络上的区块链可以处理一些物联网的管理任务，如通信、存储和身份验证。这种情况下，以及超越了原来对物联网中Things的定义，可以称之为“Smart Things”。Smart Things提供基于CLIPS编程语言的人工智能（AI）功能，以实现自我推理和自我监控。这项工作使用私链构建工具Multichain通过读写块中信息来达成Smart Things之间的通信。本文评估了Edison Arduino板上部署的Smart Things以及雾网络上部署的的Multichain网络。 ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:1","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"I. 引言 物联网设备从现实世界感知和捕获数据，然而，它们缺乏足够的计算资源来处理和分析这些数据，只能把它们发送到云。如今，典型的IoT系统是一个以云为中心的架构，包括Things, Services, Applications三层，其中Things的作用仅仅是一个数据收集器。云的稳健性和灵活性使得数据处理高效且可靠，然而数据流到达云端的时间可能影响建立在数据之上的决策的准确性。 云结构的显著缺点是是传感器的单一作用和数据流的传输延迟，若要构建更为先进和高级的物联网系统，就需要在Things层使物联网设备具有一定的处理能力，因此引入了物联网中自治的概念。 物联网设备计算能力的提高使得执行自治任务成为可能。实现这一目的通过在Things层创建能够自我推理和自我监督的Smart Things来实现。 物联网系统中，管理地理上分布的设备必须是低延迟的，而云存储无法处理由终端设备产生的实时数据流。使用雾计算，把管理任务下移到物联网的边缘可以提升效率和减少延迟。一些研究提出了部署在雾网络上的虚拟解决方案，如虚拟传感器和网关。然而，这些方案都偏向于虚拟化独立的组件来避免物联网设备间的实时通信。但雾计算系统中设备间实时通信的需求是恒定存在的。本文通过建立在雾网络上的区块链，实现了Smart Things的实时通信的管理，实现的能力包括： 去中心化的通信管理 低延迟通信 实时通信 Time-effective event management 以下，Section II讨论物联网中的自治，Section III介绍物联网中的专家系统，Section IV讨论区块链协议，Section V解释Smart Things架构，Section VI给出实验结果和评估。最后一部分做总结。 ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:2","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"II. 自治 自治指的是计算机能够监督和管理自己，系统应能够在没有人参与的情况下对未知事件做出反应。根据Kephart和Chess的研究，自治系统应满足如下原则 自我配置与重配置 自我优化 自我修复 自我保护 传统互联网背景下已经有一些关于自治系统的研究。IBM有一种分层的自治计算框架。但在物联网背景下，自治系统还需要解决一些问题： 设备间异构 大量设备 计算能力限制 能耗限制 地理上分布 实时操作 更多的，根据场景的不同，物联网中的自治概念可以侧重于解决以上某种特定的问题。IBM的结构是不少研究的基础，总的来说，物联网终端设备是资源，相关的中间件是管理者，它监督设备并根据当前状态执行操作。 ADEPT PoC是物联网自治系统的另一个方案。和IBM的架构不同，它是混合和去中心化的，ADEPT使用Telehash用于点对点通信，使用BitTorrent用于分布式文件共享，使用Ethereum区块链用于自治设备的协作比如存储设备配置和身份认证。 ADEPT PoC：The Autonomous Decentralized Peer-to-Peer Telemetry Proof of Concept ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:3","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"III. 专家系统 专家系统的概念都熟悉。这里主要是介绍CLIPS是一种开发专家系统的编程语言，由NASA开发，用C编写完成，多平台支持。 CLIPS：The C’ Language Integrated Production System ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:4","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"IV. 区块链 熟悉，略过 ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:5","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"V. Smart Things 架构 使用ADEPT PoC方案构建的自治系统由两部分组成：Smart Things和区块链协议。 Smart Things 一个Smart Things是一个软件定义的物联网设备，能够分析当前状态，监视可能的改变和推断知识。主要目标是通过直接在物联网设备上开发人工智能（AI）功能，在Things层中保持监控和决策。一个Smart Thing由三部分组成： Reader 作用是从环境中感知数据，然后发给Self-C. resource Self-Inferencing resource 集成了基于CLIPS的专家系统，在开始时会声明一组初始规则和事实(fact)，之后基于这些预先配置的规则进行AI推理。接收到的数据会转换为事实然后插入到系统的事实列表，系统分析这些事实并执行操作，最后把分析结果发给Self-monitoring resource. Self-Monitoring Resource 从Self-Inferencing resource接收结果并评估。根据专家系统的规则和推理过程决定是否把数据发送到区块链从而分发到Things层。 以上三部分都使用Go语言编程。使用RESTful微服务进行通信。 私链构建工具Multichain 使用Multichain管理Smart Things间的通信，因为是私链，所以只有预先注册的成员能访问区块链。Multichain执行的共识算法是轮询（Round Robin, RR）调度算法。每个块必须有创建者签名。块的创建者必须等一个固定的时间才能创建新块。 Multichain部署在雾网络中，靠近Things层。和Smart Thing中的Self-Monitoring Resource交互。它接收并存储数据，并扩散到整个网络的所有节点，所以节点能够实时的获知决策结果。 ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:6","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"VI. 实验与评估 评估Smart Things和Multichain区块链 评估Smart Things 使用Edison Arduino开发板评估Smart Things的性能。在该板上运行Smart Thing的三部分组件。从环境中获取温度值1000并发送到专家系统。 每个请求都会使用AES进行加密，由专家系统解密数据，把数据转化成fact，插入face列表，推理，分析，最后把结果发给Self-Monitoring resource。 在实验中加入不同的延迟间隔来测试不同请求级别下的Smart Things性能。这个延迟间隔指的是数据发送的延迟。结果表明，不同的延迟并不会影响Smart Things的性能。Smart Things的平均响应时间是1.7ms，所有的实验中，响应时间都大于1.2ms。加密和解密时间包含在内，这也说明了该系统中提出的Smart Things的良好性能。 评估Multichain 评估部署在雾网络中的Multichain的性能，实验中的Multichain有三个节点。开发板中的Smart Things做完推理分析后，发送1000个结果给区块链，每个请求都包含成员的身份验证信息，消息使用AES加密，同样，加密和解密的时间包含在实验结果中。 Multichain的平均响应时间是389ms。延迟不影响性能。这说明了区块链能够存储数据并分发到所有节点。同时，Multichain对请求处理成功的概率是98.47%。 ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:7","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"结论和未来工作 自治由Smart Things完成，Smart Things间的实时通信由区块链完成。总的来说，这项研究对物联网系统做了如下贡献： 设计开发Smart Things，可实时完成自我推理和自我监督 在CLIPS上设计和开发专家系统，来执行数据分析和自我推理 设计并实现了集成区块链的雾网络，可与Smart Things实时通信，并将管理任务分配到Things层的边缘。 未来的工作侧重于评估不同开发板的Smart Things😳 ","date":"2019-01-17","objectID":"/2019/internet-of-smart-things-iost/:0:8","tags":["论文笔记"],"title":"Internet of Smart Things-IoST","uri":"/2019/internet-of-smart-things-iost/"},{"categories":["研究生的区块链学习之路"],"content":"最近ETC遭受疑似51%攻击的影响很大，虽然最后的结果还没出来，仍不确定是真的遭受了51%攻击，还是之前官方所称的ASIC矿机测试带来的问题。但我们现在默认以前一种情况分析。 有文章分析称造成该攻击的直接原因是“ETC市值下降，网络算力萎缩，使攻击者能较容易地通过租赁算力的方式发起攻击”。同时究其本质是PoW共识算法面临的风险。给出的建议包括： 立刻抛弃PoW，改为PoS 构建于其它网络之上（ERC20） 使用Interchain linking 所以我们还就算力问题来看这件事。首先需要明白ETC并不是以太坊，而是“以太坊经典”，ETH才是以太坊，两者的区别在于 ETH是Ethereum，正式的以太坊，市值第二大币种 ETC是Ethereum Classic，以太坊经典，The DAO事件后以太坊硬分叉的产物 ","date":"2019-01-16","objectID":"/2019/ethereum-and-ethereum-classic/:0:0","tags":["区块链"],"title":"区块链学习5-ETC和ETH","uri":"/2019/ethereum-and-ethereum-classic/"},{"categories":["研究生的区块链学习之路"],"content":"The DAO事件 DAO全称是Decentralized Autonomous Organization，即“去中心化的自治组织”, 本质就是众筹。而 The DAO则是其中最大的一个，被誉为“DAO之母”，The DAO筹集到了1170万以太币（价值约2.45亿美元），并创造了众筹历史之最。 2016年4月30日，The DAO上线开始为期28天的全球众筹； 2016年5月10日，10天时间融得以太币的价值已达到3400万美元； 2016年5月15日，众筹金额超过1亿美元； 2016年5月28日，众筹结束，融得超过1150万个以太币，相当于超过1.5亿美元价值，成为全球历史上最大金额众筹项目。同日，The DAO开始在各大数字货币交易所进行开放交易； 2016年6月9日，以太坊开发人员Peter Vessenes指出The DAO存在递归调用漏洞； 2016年6月14日，修复方案被提交，等到The DAO成员的审核； 2016年6月16日，递归调用问题再次被提及； 2016年6月17日，黑客发起针对The DAO智能合约多个漏洞的攻击，其中也包含了递归调用漏洞，并向一个匿名地址转移了3600万个以太币，几乎占据了The DAO众筹总量1150个的三分之一。受制于The DAO的28天锁定期原则，黑客需要等到7月14日才能对这部分资金进行转移。当天以太坊停止了对所有交易的验证，此行为被社区诟病为“中心化”干涉，违背区块链本意；同时以太币币价大跌，一举从145元人民币跌落至68元人民币。 2016年6月18日，开放交易验证后，社区号召大家通过发送大量垃圾交易阻塞交易验证的形式减缓黑客的继续偷盗；同时白帽通过使用与黑客同样的方法将剩余2/3未被盗取资金转移到安全账户； 2016年6月24日，以太坊社区提交了软分叉提案，希望通过阻止所有人从The DAO中提取资金，为找回被盗资金争取时间； 2016年6月28日，Felix Lange指出软分叉提案存在DoS攻击风险，能够让黑客伪造gas，并通过广播大量无效却标有高价gas的智能合约，吸引矿工验证它们，从而驱使整个区块不能处理真实有效的交易；以太币币价从逐渐回升到的96元人民币再次下跌至76元，并进入下跌通道。 2016年6月30日，以太坊创始人Vitalik Buterin提出硬分叉设想； 2016年7月15日，具体硬分叉方案公布，建立退币合约，但7月21日之后黑客将可以进一步通过分离创造子The DAO，造成所盗取资金不被退币合约影响。因此7月21日将成为硬分叉执行的最终期限。 2016年7月21日，超过85%的算力支持硬分叉，以太坊硬分叉成功。 ","date":"2019-01-16","objectID":"/2019/ethereum-and-ethereum-classic/:0:1","tags":["区块链"],"title":"区块链学习5-ETC和ETH","uri":"/2019/ethereum-and-ethereum-classic/"},{"categories":["研究生的区块链学习之路"],"content":"ETC的诞生 关于The DAO事件，有人认为 被盗是因为这个项目存在漏洞的原因，根本就不是以太币的事，甚至跟以太币压根就没什么关系。可是这个项目（THE DAO）是以太坊基金会和 V 神这些核心人员参与的，他们自己的币被盗了当然不能就这样算了，所以搞了一个硬分叉，把被盗的币找了回来并且宣布硬分叉之后的 ETH 才是真正的以太币，分叉之前的那些币都不算数了，那么挖矿的矿工们也需要使用升级后的挖矿程序在崭新的一条链上挖矿。 不管这种想法如何，最终的结果都是ETC成了被抛弃者，但它为什么没有消失呢？ 从经济效益上看，矿工在旧链上挖出的 “旧版” 以太币几乎没有任何价值，不仅在交易所里无法交易，而且因为旧链生死未卜，没有人愿意担风险买入旧版币。矿工没有了经济来源，旧链消失也只是时间问题了。 之前在其他的区块链上也出现过硬分叉的情况，当时绝大多数矿工都切换到新链上，旧链也就自动消亡了。可这次以太坊硬分叉却不同，由于存在分歧，有一部分矿工还继续维持着旧链（在旧链、旧的挖矿程序上维持算力），因此旧链并未即刻消失，还在顽强地活着。 这些人拥有坚定信仰、他们认为不能为了一己私利就随意的篡改代码（指硬分叉事件），代码既是法律、一旦生效任何人（包括创始人和以太坊基金会）也没有权利去更改它。 这些人自称是坚定的去中心化实践者，宁可影响收益、也不愿意违背自己的信仰。 就在旧链风雨飘摇之际，全球最大的以太坊交易平台 Poloniex(P 网)率先地宣布开始交易旧版以太币。为和新版以太币 ETH 区别，旧币代号为 ETC(EthereumClassic，经典以太坊)。ETC 由此具有了流通价值，因为价格极低，有愿意冒险的投资 (机) 人买入，矿工们的生计得以为继。后来，相继有更多的交易所开始支持ETC的交易。 ETC（以太经典）从此顽强的活了下来。 ","date":"2019-01-16","objectID":"/2019/ethereum-and-ethereum-classic/:0:2","tags":["区块链"],"title":"区块链学习5-ETC和ETH","uri":"/2019/ethereum-and-ethereum-classic/"},{"categories":["研究生的区块链学习之路"],"content":"ETC的问题 因为 ETC 本身就是勉强活下来的，上交易所之后价格也是非常低的，拥有 ETH 的人也同时拥有同等的 ETC，而支持 ETH 的人（手里拥有大量 ETH，比如以太坊基金会）却不断的抛售自己的 ETC，来维护 ETH 的地位。 而另一部分人始终认为 ETC 才是真正的去中心化产物，所以坚持购买 ETC，所以就造成了如今拥有两个以太币（以太坊和以太经典）的这种局面。由于以太币的创始人 V 神是坚定支持 ETH 的，并且 ETH 团队有很多强力的合作伙伴，而 ETC 虽然代码和 ETH 相同、但是由于没有一个强力的团队（也可以说没有强大的背后组织）去做技术推广、以及各种宣传，种种原因导致目前 ETH 和 ETC 差价很大。 以太坊最终的目标一直都是PoS，PoW只是过渡，作为如今的以太坊的ETH自然是朝着这个目标迈进。而 ETC 则表明，永远是 POW 机制，永远都是由矿机挖矿产生，这样来说更加公平、不会造成较大的贫富差距。并且创始人自己也需要去挖矿才能得到币。 目前使用 ETH 当智能合约平台的项目非常多（这也是 ETH 价格高的原因之一），背后的技术团队支持让整个系统更加稳定，拥有众多的用户和合作伙伴组成庞大的生态圈。而目前使用 ETC 的项目则寥寥无几。 以太坊初期就确定了通过四个阶段，即 Frontier（前沿）、Homestead（家园）、Metropolis（大都会）和Serenity（宁静）达到PoS，目前处于第三阶段大都会。基于大都会的重要性（切换到最终的宁静之前的最后一个阶段），拥有庞大的更新数量和大量特性，以太坊核心社区决定分两阶段实现，即“拜占庭”和“君士坦丁堡”。2019年1月11号，以太坊发布了君士坦丁堡升级公告，定于2019年1月16号进行升级，但由于发现的漏洞，今天，即2019年1月16日，进行了安全警告，推迟了君士坦丁堡升级。 尽管困难重重，ETH仍在坚定的向前迈进，而ETC则在坚持着自己的PoW的理念。不过目前人们普遍认为的物联网领域的区块链竞争者，包括ETC，EOS，IOTA。主要是基于它们在微交易方面的优势，但具体的适用性还不是很清楚。 ","date":"2019-01-16","objectID":"/2019/ethereum-and-ethereum-classic/:0:3","tags":["区块链"],"title":"区块链学习5-ETC和ETH","uri":"/2019/ethereum-and-ethereum-classic/"},{"categories":["研究生的区块链学习之路"],"content":"攻击事件分析 事实上，发展到矿池挖矿阶段后，比特币也曾面临过某个矿池接近50%算力的情况，当时是部分矿工发现这个问题然后自行离开该矿池从而解决的。 关于本次核心的算力问题。 Ethereum目前兑换比例为1 ETH=$120.97 USD，算力大小为187.875 Thash/s，预计24小时内增长1.08% Ethereum Classic目前兑换比例为1 ETC=$4.22 USD，算力大小为8.832 Thash/s，预计24小时内降低1.92% 两者的历史算力变化如下图 PoW需要挖矿，挖矿的本质是哈希运算，而每秒能做多少次哈希运算，即hash/s，就是算力的单位。算力每隔千位划为一个单位，最小单位 H=1次 1000H = 1K 1000K = 1G 1000G = 1T 1000T = 1P 1000P=1E 比特币目前的算力在E级别，ETC和ETH都在T级别。 ","date":"2019-01-16","objectID":"/2019/ethereum-and-ethereum-classic/:0:4","tags":["区块链"],"title":"区块链学习5-ETC和ETH","uri":"/2019/ethereum-and-ethereum-classic/"},{"categories":["研究生的区块链学习之路"],"content":"结论 所以，当前ETH的价格在ETC的30倍，算力大概在ETC的20倍，如果直接原因是算力萎缩的话，暂时不用担心ETH的问题，甚至，由于ETC和ETH的特殊关系，从ETC撤出来的算力很大概率会投入ETH。 从价格上看，ETH虽然最近有所下落，但基于其历史表现，应仍能源源不断地刺激新的算力加入，拥有强大的生命力。 技术方面，致力于稳步升级的ETH，拥有完善的社区和开发团队，我仍然对其充满信心。 ","date":"2019-01-16","objectID":"/2019/ethereum-and-ethereum-classic/:0:5","tags":["区块链"],"title":"区块链学习5-ETC和ETH","uri":"/2019/ethereum-and-ethereum-classic/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 智能车辆互联提供了一系列先进的服务，这有益于车主、运输当局、车辆制造商和其它服务提供者。但这也可能把智能汽车暴露在一系列安全和隐私威胁之下，如位置追踪或远程劫持车辆。论文谈论了区块链技术，这是解决上述问题的可能方案。论文提出了一个基于区块链的架构来保护用户隐私和增加车辆自治系统的安全性。无线远程软件更新和其他新兴服务（例如动态车辆保险费）用于说明所提出的安全架构的功效。最后还定性地论证了该架构对常见安全攻击的弹性。 ","date":"2019-01-15","objectID":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/:0:1","tags":["论文笔记"],"title":"BlockChain：A Distributed Solution to Automotive Security and Privacy","uri":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction 智能汽车越来越多的联网或连到其它系统从而使它面临许多安全问题，不仅仅是对智能车辆本身还对路上行人有威胁。人们能通过无线接口远程控制智能车辆核心功能，关于隐私数据的存储和交换也使其面临新的隐私问题。 同时，旧的安全手段因为下面的问题不能用于该系统。 中心化 当前架构依赖于中心服务器，面临性能瓶颈和单点失效问题。 隐私缺失 当前通信架构基本不考虑用户隐私，不经用户运行获取所有车辆数据并提供广告这些不想要的东西。 安全威胁 自动车辆的自动化功能越来越多，由安全漏洞导致的故障就可能威胁驾驶者和行人 区块链因为它拥有它的安全性，数据不可变性和隐私性等特性成为解决智能车辆问题的一个可行方案。提到了以太坊平台和使用比特币作为底层支付手段保证隐私的电动车辆充电平台BlockCharge。也能通过以太坊区块链设计一个用于车辆属主和服务提供者之间安全和隐私的智能合约。作者之前还写了一篇文章介绍了一个用于物联网的优化的区块链实例叫轻量级可扩展区块链（LSB） 本文提出了一个基于区块链的安全和隐私架构，用于智能车辆自治系统。智能车辆、原始设备制造商和服务提供者一起形成一个彼此之间可以相互通信的覆盖网络。这一架构建立在LSB之上，覆盖网络中的节点是成簇的，只有簇首（CH）可以管理区块链和执行核心功能，被命名为overlay block managers(OBMs)。交易的广播和验证都由它完成，从而取代了中心服务器的作用。为了保护隐私，每个智能车辆还配备了车内存储用于存隐私敏感的数据，车辆属主可以定义哪些数据提供给第三方换取更方便的服务，哪些只能存在本地。 覆盖网络中的智能车辆是移动的，与OBM的距离增加会增加延迟，所以提出使用软切换的方式保证智能车辆始终连到离他最近的OBM。 覆盖网络中的通信使用非对称加密，从而保证安全性。 ","date":"2019-01-15","objectID":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/:0:2","tags":["论文笔记"],"title":"BlockChain：A Distributed Solution to Automotive Security and Privacy","uri":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/"},{"categories":["研究生的区块链学习之路"],"content":"LSB概述 传统区块链网络面临a)全网广播的高负载和高开销，b)因为要全网广播，节点增加，数据包也增加，不能无限扩展，c)吞吐量的限制三个问题，于是提出了LSB LSB主要是用一个序列的块生成过程取代了计算密集的工作量难题，每个节点在特定时间间隔只被允许存一个块，并且对网络节点进行簇划分，只由簇首对区块链管理，从而解决扩展性问题，然后用distributed throughput management（DTM）动态调整吞吐量。使用一个分布式可信算法减少块验证时间。 列举了两类型交易，只有发送者的单签名和同时有发送者接收者的多签名。交易广播到覆盖网络里，被OBM验证有效后被打包的block里，多签名的会被OBM和它维护的整个簇的公钥列表做匹配，匹配到的话直接交付，没匹配给其它OBM。 ","date":"2019-01-15","objectID":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/:0:3","tags":["论文笔记"],"title":"BlockChain：A Distributed Solution to Automotive Security and Privacy","uri":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/"},{"categories":["研究生的区块链学习之路"],"content":"基于区块链的架构 这部分描述这个用于智能车辆安全隐私的架构的细节。架构主体是覆盖网络，其中公链被节点管理，节点包括智能车辆、原始车辆制造商、汽车装配线、软件提供者、云存储提供者和用户的移动设备。整个架构如图4。 每个车辆有无线接口和车内存储，无线接口用来连到覆盖网络，车内存储用来存隐私数据。车辆以预定义的时间间隔生成单签名交易，其中包含车内存储的哈希值。这个交易发送到车辆关联的OBM并被存到链里。车内存储的哈希值用于以后验证存储未被改变，同时由于车内存储的容量限制，可以考虑把备份存在属主智能家庭里。备份数据周期性的发送智能家庭的存储里，备份数据的哈希指也被存到链里。 交易被OBM验证和广播，不仅验证当前块的有效，还验证前一个块是否还在链里。每次交易都改变公钥提供了高隐私性，但有些时候却需要确认公钥的属主是不是某个实体，比如设备制造商提供服务时需要确认提供者是制造商。然后这里又引入了第三方证书机构。。。 智能车辆在覆盖网络中的行为通过OBM完成，当它移动时造成的延迟通过软切换完成（好巧，刚在新一代网络这门课里学了软切换）。车辆到新位置时通过测量和相邻的所有OBM的延迟，选一个延迟最小的OBM，然后更新新OBM的公钥列表以便别的节点能找到它，之后断开和旧OBM的连接，并清除在旧OBM公钥列表里的它自己。如果车辆找不到新OBM，因为可能各簇间太分散了，这时维持旧OBM。 ","date":"2019-01-15","objectID":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/:0:4","tags":["论文笔记"],"title":"BlockChain：A Distributed Solution to Automotive Security and Privacy","uri":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/"},{"categories":["研究生的区块链学习之路"],"content":"Application 讨论这个架构的一些应用 远程软件更新 车辆控制系统的软件更新或bug修复通过一种叫wireless remote software update (WRSU)的机制完成。这一机制在车辆开发、组装、车辆服务中心、自己家都有执行，这一机制的安全性是个大问题，因为它需要对车辆的完全控制。当前的安全架构是中心化的，就比如特斯拉用一个VPN完成远程软件更新，但车辆数多时，这一个架构的扩展性是个问题，并且前面提到的隐私问题这一架构也没办法解决。 但本文的架构能解决这个问题。OEM（原始设备制造商）把软件更新放在云里，然后为每个车辆在云里建一个账户，分配公私钥对，用于车辆进行软件更新的授权和验证。 服务提供者把新版本存在云里，然后建一个多签名交易，自己的公钥和新版本软件的哈希值都存在交易里，车辆可以通过验证哈希值确认软件未被篡改，把OEM公钥放进去然后发给OBM。OBM广播并按流程交付OEM，OEM收到后验证，验证无误广播给所有OBM，所有OBM通知各自管理的簇成员有新更新了。智能车辆通过验证相应OEM的公钥字段做验证，然后通过公私钥对从云下载更新，最后通过哈希值判断新版本软件的完整性。 保险 现在的车险很灵活，他们会收集数据评估驾驶行为。本文架构可以用在这个。保险公司在云端建一个存储库，给用户开个账户然后分配公私钥对，用户将相关数据存在保险公司的云里，保险公司凭这个评估用户驾驶行为。用户凭借自己对车内存储的隐私数据的控制决定哪些给保险公司看，同时，保险公司也可以通过公链中车内存储的哈希值判断用户没擅自改数据。 用户可能不再用保险公司的服务或卖车了，这时保险公司把用户账户和数据从云移除。 电动汽车和智能充电服务 和保险类似，电动汽车多了，充电桩跟不上，通过收集用户数据可以调整充电时间使之最适合用户。本文架构用于只开放需要的隐私数据给服务提供者换取想要的服务。这些服务提供者可以作为节点加入覆盖网络。 共享汽车 这一领域中车辆位置、车解锁使用、支付这些过程通过新架构给一个安全保证。 ","date":"2019-01-15","objectID":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/:0:5","tags":["论文笔记"],"title":"BlockChain：A Distributed Solution to Automotive Security and Privacy","uri":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/"},{"categories":["研究生的区块链学习之路"],"content":"安全和隐私分析 是新架构可能遇到的一些安全和隐私问题 隐私 通过把地址和用户行为相关联可能推断出用户身份。可以通过每次交易变化密钥避免这一问题。 安全 数据哈希值的使用保证了数据完整性。 加密手段的使用保证了保密性。 OBM管理簇成员避免了流量攻击。 数字签名确认了数据来源可靠。 ","date":"2019-01-15","objectID":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/:0:6","tags":["论文笔记"],"title":"BlockChain：A Distributed Solution to Automotive Security and Privacy","uri":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/"},{"categories":["研究生的区块链学习之路"],"content":"未来研究方向 密钥管理：因为架构里涉及很多密钥对 数据缓存：车辆从云下载数据造成开销与延迟，OBM缓存可以解决这一问题，和Decentralized Caching for Content Delivery Based on Blockchain这篇结合食用更佳 应用：这一架构适合更多的应用 移动：软切换其实并不是最好方式，可以想想其它办法。 ","date":"2019-01-15","objectID":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/:0:7","tags":["论文笔记"],"title":"BlockChain：A Distributed Solution to Automotive Security and Privacy","uri":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/"},{"categories":["研究生的区块链学习之路"],"content":"结论 提出一个基于区块链的架构，用于智能车辆安全与隐私。并分析了其在一些场景中的应用。 ","date":"2019-01-15","objectID":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/:0:8","tags":["论文笔记"],"title":"BlockChain：A Distributed Solution to Automotive Security and Privacy","uri":"/2019/blockchaina-distributed-solution-to-automotive-security-and-privacy/"},{"categories":["研究生的区块链学习之路"],"content":"1. 背景 传统工厂向智能工厂转变是为了提高生产和管理效率，并高度灵活地适应不断变化的生产要求1。这一目的的达成部分依赖于大量来自于制造设备，工业生产流程，工厂运行等过程的数据收集。为了完成这样的收集过程，工厂中部署的终端设备节点数量和网络规模不断扩大，各种新兴技术如 3D打印，AR/VR，CPS，IoT 和边缘计算等不断集成。传统的中心化架构无法再为这样庞大的系统提供有效支持，工厂的通信体系结构因此需要转变为涉及工业流程所有实体的分布式体系结构。区块链技术是可选的解决方案之一，其优点包括： 分布式应用。具有较大计算负载的工业应用依赖于昂贵的集中式服务器，采用区块链技术，可以利用去中心化应用(dapp)分担计算负载，有效减少运维成本，提升用户体验。 软/固件更新。由于安全问题更新工厂中的 IIoT 设备十分常见，通常情况下，更新过程需要在遍布工厂的众多设备中手动执行。使用区块链可以简化这一繁琐而低效的更新流程，将软件更新同时分发给尽可能多的智能设备，并同时保证完整性和安全性。 信任关系。工厂运行过程中，与合作伙伴、设备制造商、原材料提供商、服务提供商甚至政府之间的交互都是必不可少的，这些交互往往基于对所收集数据真实性的信任。区块链的不可篡改特性，可以提供一种验证问责机制，从而增加信任。 信息平台。智能工厂还往往涉及附加制造、大数据、云或边缘计算、IIoT、CPS、集成系统、机器人、网络安全等诸多技术的集成使用，这些技术可以从作为一个统一的信息交换平台的区块链的部署中受益。 垂直与水平集成。智能工厂内部各系统如 ERP 和 MES，或工厂各部门和上下级之间的垂直整合，以及供应商、工厂、用户等供应链上下游的水平整合，是工业4.0的核心之一。区块链能为这两种整合提供良好的解决方案。首先，在垂直整合中，工厂中部署的多个系统自动收集信息并将其发送到价值链的任何相关部分（例如设计团队或操作工人）。区块链可以通过提供一个公共可信的数据及货币平台帮助垂直整合。水平整合即供应链，区块链可辅助达成制造商、供应商、客户等供应链涉及实体间的信任，确保产品安全可靠。 访问控制。随着终端设备数量的增加，访问控制同样是一个必须解决的问题。传统的访问控制方式往往存在各种各样的不足。区块链是一种良好的解决方案。 问题1：智能工厂涉及的设备数量其实并没有大到无法承受，传统中心化的云为什么不使用？ 区块链固有的解决信任问题的优势，厂商对云服务提供商的不信任等。 问题2：为什么不用替代性的分布式架构，如分布式数据库技术？ 区块链就是一种分布式数据库。 问题3：区块链出现之前，这一方向对基于云的中心化架构的替代方案是什么？ ","date":"2019-01-15","objectID":"/2019/blockchain-for-smart-factory/:1:0","tags":["科研记录"],"title":"背景调查4-区块链与智能工厂","uri":"/2019/blockchain-for-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"2. 需解决的问题 这些问题主要包括三个方面： 性能上：能源效率，算力，延迟，吞吐量 数据管理：存储 安全上：数据隐私，身份认证，数据完整性 具体每部分总结如下： 数据隐私： 包括1）节点身份的隐私；2）区块链中交易数据的隐私。节点身份可以通过诸如链接攻击获取，而区块链中的数据本身就是透明的。但是，在工业场景中，为了避免向竞争对手泄露关键数据，匿名的需求确实存在。对节点身份的链接攻击现在主要依靠密码学上的混淆技术抵御。另外，BSeIn中通过基于属性的数字签名（ABS）也实现了匿名。交易数据的隐私可以简单的通过发起交易前先加密保证，或者通过访问控制机制保证实体对区块链数据的访问和写入权限。 身份认证：认证是访问控制的前提，实际上，认证和访问控制是解决 IIoT 中安全和隐私问题的主要手段。传统方式中，认证通过证书颁发机构完成，访问控制也通过指定节点负责授权允许访问相关设备和资源实现。但是这些中心化的机构具有较大的安全隐患，信任度与区块链方案相比有较大差距。区块链中访问控制方案通常利用智能合约完成，有些也会使用区块结果或共识过程等。 总而言之，隐私和安全问题的解决，很大程度依赖于认证和访问控制的方案。 数据完整性：对于 IIoT 系统来讲，保证从 IIoT 设备收集的信息没有被修改是至关重要的，因为不正确或恶意的数据可能会影响工业系统的运行。区块链的不可篡改性实际上可以保证数据完整性，另外，由于区块链存储的高花费，采用其它中心化或分布式的存储方案时，保存数据的哈希是一种常用的保证数据完整性的方式。 存储：随着 IIoT 设备执行交易，区块链不断增长，传统的资源约束 IIoT 设备甚至无法管理区块链的一小部分。需研究区块链压缩技术或其它技术。另外，IIoT 设备收集的大量数据也不应存储在区块链中，使用什么样的存储方案值得研究。关于存储的问题有过详细的研究和总结。 能源效率：由于某些 IIoT 设备依靠电池来运行，因此必须最小化功耗。然而，区块链通常是耗电的，主要是由于采矿和 P2P 通信。边缘设备也必须连续通电并执行计算密集的复杂加密操作。此外，必须注意的是，尽管进行了可能的能耗优化，当前的资源约束 IIoT 节点通常还是无法处理挖矿任务，因此它们通常依赖于充当区块链代理的中间网关。在采矿方面，已经提出了不同的共识机制来开发比传统 PoW 方案更环保的替代方案，但还需要进一步的研究。另外，一些作者已经提出了像迷你区块链这样的替代方案，这有助于降低节点的计算要求。值得一提的是，高效哈希算法可以帮助延长IIoT设备的电池寿命：尽管由于比特币，SHA-256 可能是最流行的哈希算法，但最近的替代品如 Scrypt 或 X11更快，因此他们可能可以减少采矿能耗。 算力：一些 IIoT 设备由于其有限的计算能力或其功率限制而无法实现复杂的安全机制。基于 RSA 的加密可能不是最适合资源约束的 IIoT 设备，因此应该研究其他非对称加密机制。此外，由于量子计算在打破传统的非对称加密算法方面的进步，应该考虑量子方法。 交易延迟：区块链需要一定的时间来处理交易。例如，比特币交易潜伏期遵循泊松分布，平均值为10分钟，但实际上，建议等待大约一个小时来确认交易。相反，大多数数据库最多需要几秒钟来确认交易。智能工厂中许多情况下需要实时地对收集的数据和相应地事件做出反应。 吞吐量：IIoT 系统通常每秒处理大量交易，这可能是某些区块链的缺陷。例如，比特币每秒最多处理7次交易，尽管它可以进行优化以处理更多交易（例如，增加块大小）。因此，在为 IIoT 部署选择正确的区块链时，吞吐量是必须考虑的基本参数。实际上，大多数的平台都在致力于吞吐量的提高，比较著名的例子是以太坊的分片方案，比特币的扩容方案，以及闪电网络、雷电网络等链下解决方案。 吞吐量的问题一部分是共识过程的复杂性带来的，主要是通信及交易确认的延迟，所以使用速度较快的哈希算法如 scrypt 而不是 SHA-256 能带来一定的优化，另一部分原因是任务的单进程处理，分片方案的实质就是提高并发程度。 吞吐量和延迟或许可以归结到同一个问题，因为吞吐量很大部分是由延迟造成的。 可扩展性：基于区块链的工业4.0应用使用地体系结构必须能够承受此类应用产生的大量流量。可扩展性主要包括两方面，1）物联网终端设备的巨大数目及其不断增长的趋势，要求架构必须具有良好的可扩展性，能够支持大批量设备动态的加入退出，支持规模庞大地设备地同时运行；2）小型的交易可能会增加与通信相关的能耗，而载荷过大的交易物联网设备将可能无法处理，故交易和区块的大小需要能根据物联网网络的带宽限制进行调整。鉴于此，在区块链中普遍应用的全节点和轻节点方案基础上，Slock.it 又提出了两种节点类型，从而填补了该方面的空缺。 还有几个问题是后期需要考虑的： 多链管理。区块链的激增可能需要一些公司同时支持其中几个。例如，公司可以使用比特币处理其金融交易，而智能合约则在依赖以太坊的应用程序上执行。因此，必须设计和实施解决方案以同时使用不同的区块链。 互操作性和标准化。目前，大多数公司开发自己的区块链解决方案，但在许多情况下，它们之间的互操作性是必要的，以实现无缝集成。像IEEE这样的一些实体正致力于制定旨在保证各领域互操作性的特定标准。 问题1：激励机制是否还有存在的必要？ 没有存在的必要，为了谋取利益，工厂有自发运行共识的动力，无需激励机制。但是基于代币的激励机制可以转化为基于信誉积分的激励机制，用于权限节点的选举、惩罚机制的执行等等操作。 问题2：该场景中适合使用什么类型的区块链？ 从智能合约的角度，需要支持智能合约运行的区块链，而非加密数字货币类型的。 从访问规则的角度，需要私有链或联盟链。公链在交易处理速度、可访问性、数据公开等方面不满足场景需要。 问题3：该场景中适合使用什么样的共识？ 非资源需求型的共识，吞吐量较高的共识。 问题4：用什么样的存储方案？IPFS，Swarm或其它，分布式的还是集中式的？ 数据的集中式存放必然面临单点故障问题，传统的分布式方案在安全和防篡改方面不足。这里还存在一个问题，之前所提区块链的使用是中心化架构的不满足，一般指的就是数据，但这里突然存储方案并不用区块链，那之前的说法就存在问题。 ","date":"2019-01-15","objectID":"/2019/blockchain-for-smart-factory/:2:0","tags":["科研记录"],"title":"背景调查4-区块链与智能工厂","uri":"/2019/blockchain-for-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"3. 访问控制方案具体应该是什么样的 我们决定使用Ouaddah提出的OM-AM四层模型，即目标、模型、架构、机制。 ","date":"2019-01-15","objectID":"/2019/blockchain-for-smart-factory/:3:0","tags":["科研记录"],"title":"背景调查4-区块链与智能工厂","uri":"/2019/blockchain-for-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 目标 目标阶段主要是研究所在场景，提取主要的隐私和安全需求，这些需求基于对文献的广泛阅读。 隐私：隐私是指一个实体拥有的决定是否、何时以及向谁发布或披露自己的个人信息的能力。隐私的范围包括用户数据和个人信息。我们通过与隐私相关的几个关键因素量化了该目标：1）透明性：用户应当知道他们有哪些隐私数据，这些数据是否被获取，由谁获取，用来做什么和获取时间等信息；2）用户驱动：用户是数据的主人，拥有对他们在云或网络中数据的完整权限，能够在无需第三方的情况下使用这些数据，并能保证这些数据在没有用户许可的情况下无法被使用，最后，能保证可以将数据直接与授权节点共享，不受第三方控制；3）匿名：不直接使用用户真实身份作为标识符，同时，也不应当通过用户的行为可以分析出其真实身份； 技术限制：1）灵活性：主客体的身份不应是静态的或预定义的，设备可以同时扮演资源请求者和资源拥有者的角色，同时，两者间的对应关系也是多对多的。2）可扩展性：由于设备和用户数量可能是无限的，访问控制机制应在大小、结构、用户和资源数量等方面可扩展；3）轻量：物联网设备的电源、内存、计算能力等较低，引入的安全机制涉及应确保计算和通信开销尽可能小，故应是轻量的；4）异构：应同时支持多种通信技术、不同的设备和生态系统。 机密性和完整性：机密性意味着数据和信息没有未授权的泄露，完整性意味着不会被篡改。更多的，访问控制系统应拥有以下特性1）细粒度：用于指定访问控制规则的语法足够灵活，能支持描述更多的信息，因此支持细粒度的访问控制；2）撤销：能够撤销对资源的访问权限，并确保被撤销权限的用户无法再访问资源；3）委托：一个主体可向另一个主体授予访问权限或部分授予访问权限，由于许多事物由其用户永久或临时拥有，并可能属于同一个组，因此有必要考虑委托机制设计。 可靠性和可用性：物联网环境下，这两个属性描述为1）离线模式：即使决策者（可能是资源所有者）不在或没有连接，也可以进行决策。2）短期可用：物联网资源必须以合理的响应时间提供给授权用户，因为过程或数据可能有时间限制。3）长期可用：法规规定某些数据必须保存很长时间（如病历拥有规定的保存年限），只有有权限的用户才能删除数据，并且只能在相应的时间段过期之后。4）访问控制应易于管理、表达和修改，因为授权活动的参与者专业知识可能存在差异。 物联网环境中，设备无法自行执行所有授权功能，应选择一种集中式的方法，即为设备定义统一的授权管理中心。同时，系统中应存在对恶意行为的处罚。 ","date":"2019-01-15","objectID":"/2019/blockchain-for-smart-factory/:3:1","tags":["科研记录"],"title":"背景调查4-区块链与智能工厂","uri":"/2019/blockchain-for-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 模型 授权模型是用来清晰明确地表示安全策略的一组符号规则（通常是数学的），帮助抽象和理解安全策略，并用于验证策略的完整性和一致性。常用的授权模型包括自主访问控制 DAC，强制访问控制 MAC，基于角色的访问控制 RBAC，以及基于属性的访问控制 ABAC。我们使用的授权模型是基于加密机制生成的设备身份的授权。 定义 $subject$ 集合 $S$，这是希望访问其它节点资源的节点集合；$object$ 集合 $O$，这是持有资源的节点集合。每个属于 $O$ 的目标 $o$ 都有一组资源 $R_0$（数据或功能），每个属于资源集 $R_0$ 的资源 $r_0$ 都与一组访问权限集合 $A_{r_0}$（读，写或执行）相关联。对每个主体 $s$ 和资源 $r_0$ 都定义了一个属于权限集的映射，说明对该资源的相关权限授予该主体。为了满足离线模式下的可用性，定义 $L$ 为不同的权限级别，相同级别的主体拥有对对象的所有权限，高级别的主体拥有对低级别对象的读取和控制权限，低级别主体对高级别对象没有权限。该设计限制了数据由低级向高级的流动，并且保证了低级别的数据不能被高级别篡改。 ","date":"2019-01-15","objectID":"/2019/blockchain-for-smart-factory/:3:2","tags":["科研记录"],"title":"背景调查4-区块链与智能工厂","uri":"/2019/blockchain-for-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 架构 目前，大多数智能工厂都是基于云的集中式制造架构[1]。这样的架构使用户能够随时随地访问共享的制造资源池，并且可以通过最少的工作和第三方交互来实现资源的快速配置和管理[2]。但是，一方面，集中式架构非常脆弱。只要中心节点损坏，所有服务都将被暂停。同时，集中式服务器的部署与维护费用也很高，工厂还需要向中间商支付这种集中式解决方案的费用。另一方面，工业4.0的发展意味着工业网络物理系统（ICPS），增强/虚拟显示（AR/VR），IIoT和边缘计算等众多技术手段的集成和应用，从而要求工厂的架构体系从当前基于云的中心式架构向涉及工业流程所有实体的分布式架构转变。因此，我们的目标是建立一个分布式的节点相互监督的系统。我们提出的用于智能工厂的基于区块链的IIoT架构如图1所示。所提出的架构主体包括三部分：物理资源，区块链网络和存储网络。 Physical Resources：即位于工业网络最边缘的设备节点，主要指各种收集数据的设备如传感器，各种参与制造过程的设备如机械臂和制造设备，以及工作环境下的打印机、扫描仪等等其它物理设备。由于设备节点在功耗、性能、存储等方面的限制，其作用仅仅是将收集的大量数据交付给区块链网络中的网关节点。 Blockchain Network：区块链网络的成员包括三种节点。网关节点是与各类传感器相连的单片机或与其它设备节点相连的网关设备，它们接收来自设备节点的各种数据，经过简单处理和加密后，上传到存储网络。然后将数据哈希存入区块链中。同时，它们也需要执行来自区块链网络的由其它节点发起的控制命令并返回结果。网关节点的性能同样也是有限的，因此，它在区块链网络中作为轻节点而不是全节点存在。管理节点是工厂中普遍存在的工控电脑和普通计算机。负责验证交易，打包数据生成区块，广播区块以及将区块添加到区块链等一系列操作。用户节点是移动PC，智能手机和手持终端等设备，用来由用户操作向区块链发出数据查询请求或发出向设备的控制命令。 这里节点的作用其实还取决于共识的选择，类 PoW 的资源型共识只能由管理节点参与区块生成和添加，其它共识网关节点也可以参与。 Storage Network：由于区块链在存储上的困难，我们将收集的数据及日志存储在单独的存储网络中，同时为了避免单点故障和安全隐私问题，存储网络也同样适用分布式的架构。我们选择了 Ethereum 的 Swarm 作为本系统的存储网络。存储网络接收来自网关节点的数据，并返回数据的哈希。同时依赖用户节点发出的查询请求，根据数据哈希返回相应的数据。存储网络的节点与区块链网络的管理节点是部分重合的，它将中心化的云存储分散到了工厂所有的各独立的计算机中。 [1] [14] D. Wu, D. W. Rosen, L. Wang, and D. Schaefer, “Cloud-based design and manufacturing: A new paradigm in digital manufacturing and design innovation,” Computer-Aided Design, vol. 59, pp. 1-14, 2015. [2] A. W. Colombo, T. Bangemann, S. Karnouskos, J. Delsing, P. Stluka, R. Harrison, F. Jammes, and J. Lastra, “Industrial cloud-based cyber-physical systems: The IMC-AESOP approach,” Springer Ebooks, pp. 15-16, 2014. 3.3.1 架构划分 与论文[3]相似，我们也将所提出的架构分为内联网和外联网。内联网旨在收集和存储数据，而外联网旨在利用数据为不同用户提供不同的服务 内联网由设备节点，区块链中的管理节点和存储网络组成。由于计算能力的限制，设备节点完全由与之相连的管理节点控制，数据上传到管理节点由其进一步处理，收到的控制命令也由管理节点发出。管理节点在转发控制命令前需要对请求发起者的权限做验证。另外，由于设备节点完全受管理节点支配，其身份需要得到验证，从而保证安全性。 外联网由管理节点，用户节点和存储网络组成。内联网和外联网之间的主要区别在于内联网面向设备，而外联网面向用户。传统的系统中，外联网连接到Internet并通过集中式服务器或云来为用户提供服务。本文的系统中，这一机制通过区块链网络和存储网络完成。用户节点发起请求后，区块链网络将根据定义在智能合约中的合理的访问控制策略来判断是否有相应的操作权限。请求通过时，对数据的查询请求将返回存储网络中相应数据的哈希，用户节点再通过哈希值调取数据，这样做能减轻区块链网络的存储和处理负担，加快响应时间。对设备的控制请求在被目标网关节点收到后，网关节点从区块链中查询其权限，确认权限后将控制命令转发给设备节点。 为了确保数据安全性和隐私性，区块链网络通过智能合约定义了相应的访问控制机制。决定了决定了访问或拒绝的权利。这种机制可以快速验证访问流量并过滤恶意流量，提供快速方便的安全性和隐私。同时，架构中的设备节点和用户节点的直接交互被隔离，数据请求和控制请求都先由智能合约处理，确认权限后才会进行下一步操作。另外，设备节点和用户节点获取的权限是有时间限制的。达到时间限制后，需要重新验证权限。 [3] Wan J, Li J, Imran M, et al. A Blockchain-Based Solution for Enhancing Security and Privacy in Smart Factory[J]. IEEE Transactions on Industrial Informatics, 2019. [4] Lin C, He D, Huang X, et al. BSeIn: A blockchain-based secure mutual authentication with fine-grained access control system for industry 4.0[J]. Journal of Network and Computer Applications, 2018, 116: 42-52. [5] Zhang Y, Kasahara S, Shen Y, et al. Smart contract-based access control for the internet of things[J]. IEEE Internet of Things Journal, 2018 ","date":"2019-01-15","objectID":"/2019/blockchain-for-smart-factory/:3:3","tags":["科研记录"],"title":"背景调查4-区块链与智能工厂","uri":"/2019/blockchain-for-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"3.3.2 共识 与公有区块链的不受信任的系统不同，所提出的系统是私有区块链系统，其中所有节点最初都是受信任的。因此，我们放弃了竞争和奖励机制。采用了 PoA (其实还不确定)共识算法。这种设计可以提高架构的容错性，可扩展性和实时性。 ","date":"2019-01-15","objectID":"/2019/blockchain-for-smart-factory/:3:4","tags":["科研记录"],"title":"背景调查4-区块链与智能工厂","uri":"/2019/blockchain-for-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"3.4 机制 在[3] [4] [5]三篇论文中，分别实现了自己的访问控制合约，现将它们的优势和不足分析如下 优点 缺点 [3] - 访问控制权限有时间限制 - 数据存到分布式云中时数据哈希使用Merkle根形式获得 注册阶段使用固定IP，容易泄露身份 [4] - 节点真实身份通过属性得以隐藏- 使用一次性密钥用于消息加密，密钥使用CL-MRE通过交易发送 注册使用的是区块链账户地址，易泄露 [5] - 实现了恶意行为判决和处罚- 定义策略的合约与其它合约分离，便于销毁- 访问控制权限有时间限制（对时间的判定即文中声称的动态验证） - 三种合约分离，甚至每个访问控制策略都是一个合约，存储空间浪费严重 - 策略查询通过发起交易来调用合约实现，延迟较大 在我们的方案实现中，摒弃了以上方案的缺点，集合了它们的优点，如 对访问控制策略进行时间限制 添加对节点恶意行为的判决和处罚 尽量在一个合约中实现，避免空间浪费 数据在链下的存储不是单纯的计算数据哈希，而是使用 Merkle 根形式计算 另外，我们还采用了一些新的方法克服它们的缺点 采用ECC生成公/私钥对，公钥作为节点身份来注册，定期更新，从而保证用户身份 策略查询通过对节点中的区块链副本查询完成，不上链交易，节省时间。只有发起操作请求才会发起交易 3.4.1 合约设计 主体包括数据存储合约和访问控制两个合约 3.4.2 交互流程 注册。区块链中的网关设备和用户设备使用其公钥进行注册，终端无连接的物联网设备在其网关设备控制下生成对应公钥，然后进行注册。将区块链账户地址与身份公钥分离，身份公钥加密传输，可以保持隐私。 初始化应定义网关设备对终端物联网设备的所有权限。 E. Munera, J. Poza-Lujan, J. Posadas-Yagüe, J. Simo, J. F. Blanes, and P. Albertos, ‘‘Control kernel in smart factory environments: Smart resources integration,’’ in Proc. IEEE Int. Conf. Cyber Technol. Automat., Control, Intell. Syst. (CYBER), Shenyang, China, Jun. 2015, pp. 2002–2005. ↩︎ ","date":"2019-01-15","objectID":"/2019/blockchain-for-smart-factory/:4:0","tags":["科研记录"],"title":"背景调查4-区块链与智能工厂","uri":"/2019/blockchain-for-smart-factory/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Ali Dorri, Salil S. Kanhere, and Raja Jurdak arXiv预印（非正式发表） 2016.08 ","date":"2019-01-09","objectID":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/:0:0","tags":["论文笔记"],"title":"Blockchain in Internet of Things:Challenges and Solutions","uri":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 物联网产业在快速发展，但安全和隐私的问题始终没有解决。由于物联网分布式的拓扑结构和资源有限的设备，传统的安全和隐私方法不适用于物联网。区块链能用于保证和物联网具有相同拓扑的P2P网络的安全与隐私，因此应也能用于物联网，然后，BC是计算密集型的，需要较高带宽且延迟较高，并不适合物联网。本文提出一种基于BC技术的安全、私有和轻量级的架构，去除了BC的缺点，同时保留了其安全和隐私特性，使其适用于物联网。利用智能家居场景为例做了描述，整个架构分为智能家居层、覆盖网络层、云存储层三层。在各层使用了不同类型的BC，并对常见的安全威胁做了定性分析，证明了其保证物联网安全与隐私的有效性。 ","date":"2019-01-09","objectID":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/:0:1","tags":["论文笔记"],"title":"Blockchain in Internet of Things:Challenges and Solutions","uri":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/"},{"categories":["研究生的区块链学习之路"],"content":"I. Introduction 物联网设备收集的信息一方面为我们提供了实用的个性化的服务，一方面也被算法分析从而揭示了我们的行为和生活方式，一定意义上泄露了隐私。另外，不成熟情况下出厂使用的第一代物联网设备安全和隐私风险更加严重。现有的一些方案存在各种问题，比如提升了安全性但隐私风险增加等等。 本文致力于用BC技术解决区块链的安全和隐私问题。是因为BC技术具有以下特性： 去中心化：通过使用所有已参与节点的资源并消除多对一的流量，去除中心化的控制，提高了架构可扩展性和鲁棒性，减少延迟并克服了单点故障问题 匿名：区块链中参与者固有的匿名特性适用于物联网 安全：BC能达成没有信任基础的各方之间的信任，这在异构设备普遍的物联网中很适用 然而，BC技术并不能直接用于物联网，还需要解决一些问题： 挖矿是计算密集型的行为，而多数物联网设备资源有限 挖矿耗费时间，而物联网要求低延迟 随着节点数量的增加，BC的可扩展性慢慢变差，但物联网的设备数量超乎想象 BC的通信协议开销显然很大，物联网设备的带宽有限 本文提出的架构消除了BC的缺点，保留了其安全和隐私特性，使其适用于物联网，并用智能家居场景为例做描述，并声明了该架构是场景无关的，可以用于各种物联网场景。 ","date":"2019-01-09","objectID":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/:0:2","tags":["论文笔记"],"title":"Blockchain in Internet of Things:Challenges and Solutions","uri":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/"},{"categories":["研究生的区块链学习之路"],"content":"II. Block-based IoT Architecture 以一个典型的智能家居场景为例，屋主为Alice，屋内设备有智能恒温器，智能灯泡，IP摄像头，一些传感器。整个架构分三层：智能家居层（也即本地网络层），覆盖网络层，云存储层。如图1所示 考虑两个情况： 数据访问：Alice远程访问其卧室的当前温度 数据存储：智能设备能将数据存起来供第三方使用以提供某些服务，如智能恒温器供应商 先介绍各层 A. Smart Home 由以下几部分组成 设备：屋里的智能设备 本地BC：一个部署在本地的私链，由一个或多个具有足够计算资源的设备（比如家里的计算机）维持，总是在线。不像比特币管理是分布式的，本地BC的管理由其属主完成。与特定设备相关的所有交易都链在一起，所以新设备的添加实际上就是由属主创建一个起始交易从而创建该设备的链，设备的删除也就是把该设备的这条链删掉。本地BC拥有一个策略头，被属主用来控制屋里发生的所有交易。设备间通信只有当属主为它们分配了共享密钥才能完成。BC中所有的块都有策略头，但最新的块中的策略头是特殊的，因为它用于检查策略是否有更改，当然，策略的更改也是通过修改最新的策略头实现。和比特币相同，交易被聚集在一起放到块里，但与比特币不同的是，没有求解PoW谜题的过程，矿工直接将指针添加到前一个块，并把前一个块的策略头复制到新块，从而将块链到BC上。另一个不同是，比特币中交易需要随块被全网验证才能生效，但该方案中交易只要被打包的块里就生效了，无论块是否上链。 本地存储：可选的，用于在本地存数据 除上述三部分，miner还拥有一个公钥列表用于授权访问屋里设备的数据。 B. Overlay Network 覆盖网络和比特币的P2P网络相似，其节点可以是智能家居的矿工，其它屋里的高资源设备，用户智能手机或个人电脑。每个节点通过洋葱路由器连到覆盖网络，以此提供额外的匿名性。可能多个节点属于同一个人，这样网络开销和延迟就是不必要的，所以可以把多个节点聚集成簇，然后选个簇头CH，节点可以根据延迟大小自由切换所属的簇。同样，簇中节点也可以随时选举一个新的CH。每个CH维持下列三个列表： 请求者公钥列表 被请求者公钥列表 转发列表：为网络中其它CH转发的交易列表 overlay BC由所有CH维护，包含访问交易和云存储发送的多签名交易。与比特币不同，每个CH根据与收到的交易的参与者的通信，独立决定是保留新块还是丢弃它，这会导致每个CH中存储的BC版本不同，因为不比协调CH中的BC版本，减少了同步开销，但在某些情况下寻找一个特定的块或交易则会拥有更高的延迟。用户拥有多个家庭并希望一起管理时，可以将多个家庭的高资源设备组成一个共享覆盖，使用共享的矿工和共享的存储。每个设备的起始交易都链到它自己所在家庭的起始交易上，这样就可能造成共享BC的分叉。比特币中分叉不允许存在，但我们的方案中可以。当一个共享覆盖存在时，其成员维护一个表，该表包含最新交易的块号和数据的哈希值。 C. Cloud Storage 某些情况下，智能家庭里的设备可能希望把数据存在云里（比如恒温器），这样第三方SP就可以访问这些数据并依此提供服务（比如智能温度调节）。云存储会把数据打包放在以块号为唯一识别的相同的块中。块号和存的数据的哈希值被用户用来认证。来自用户的数据和数据的哈希值在块中以FIFO顺序存储。存完后，新块块号用共享密钥加密，确保拥有密钥的人是唯一知道块号的人。从而保证除真正用户外任何人都不能访问它的数据，也不能将新数据链到现有的分类账。另外，用户是给自己的所有设备各建一个分类账还是共用一个分类账是自由的。如果用户想提供数据的访问权限给SP，这种格式很合适。 ","date":"2019-01-09","objectID":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/:0:3","tags":["论文笔记"],"title":"Blockchain in Internet of Things:Challenges and Solutions","uri":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/"},{"categories":["研究生的区块链学习之路"],"content":"III. Transaction Handling 讨论架构拓扑，把注意力放在交易如何处理上 A. storing 基于已定义的策略，每个设备都可以将其数据存在本地存储、共享存储和云存储。以恒温器数据送到云存储为例，如图2 图2. 共享存储和本地存储的过程要简单很多 B. Accessing SP可能访问确定时间段内的数据或确定设备的数据。为例访问信息，SP会生成一个SP和智能家庭矿工一起签名的交易，也就是请求者和被请求者一起签名。交易发给SP自己所在簇的CH。CH检查所维护的公钥列表，请求者列表或被请求者列表匹配，就广播到自己的簇，否则转发到别的簇，并且请求者公钥放到转发列表中（这里没明白为什么两个签名任一个匹配就可以）。当智能家庭矿工收到交易时，检查策略头看SP是否有访问权限，这个权限必须在请求发送前由用户授予。如果有权限，矿工从存储里拿数据，然后用请求者公钥加密，发给请求者，如图3所示。发给请求者之前可能会设置安全问题或添加噪声等来增加隐私性。发完数据后，矿工要把双方签名的这个交易存在本地BC。然后送给覆盖网络其它一些随机的CH存储。 该方案中，通信涉及的所有CH都要存该交易。 C. Monitoring 用户可能想访问自己屋里一些实时信息，比如向恒温器请求当前温度。为这种操作设立了Monitoring交易 ","date":"2019-01-09","objectID":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/:0:4","tags":["论文笔记"],"title":"Blockchain in Internet of Things:Challenges and Solutions","uri":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/"},{"categories":["研究生的区块链学习之路"],"content":"IV. Distributed Trust 现在来讨论覆盖网络中保证分布式信任的机制。覆盖网络中每个CH维持一个对别的CH的信用评分。这个评分基于一个依赖某些直接或间接证据的信用系统。架构中，如果CH A验证了块由CH B挖掘，则拥有一个CH B的直接证据，如果是从C收到的B的块，则拥有一个B的间接证据。当一个CH生成一个新块，它应创建一个多签名的交易用于评估信用，然后把新块和交易一起发给相邻CH。当一个CH收到了一个块，它就会验证与之相关的交易，如果它对块矿工或签署了多重事务的其他CH有直接的证据，那么它会通过检查他们的签名来随机验证块中的部分事务。CH的验证交易数量取决于其拥有的块矿工的直接证据的程度及其对提供间接证据的CH的信任评估，其中更可信赖的证据需要更少的随机交易进行检查。如果CH对块生成者或那些签名了块的参与者没有直接证据，那么它会检查所有事务。 很明显，本文架构和比特币的BC有差异，总结如表1 表1. ","date":"2019-01-09","objectID":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/:0:5","tags":["论文笔记"],"title":"Blockchain in Internet of Things:Challenges and Solutions","uri":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/"},{"categories":["研究生的区块链学习之路"],"content":"V. Evalution 分析开销、性能和常见安全和隐私威胁下的表现，攻击可能来自CH，家庭中的设备，覆盖网络中的节点以及存储。攻击方可能欺骗通信，丢弃交易，创建错误交易和区块，改变或删除存储中的数据，通过分析用户交易得到用户身份，或签名虚假交易使串通节点合法化。然而它们无法破解加密，主要的威胁类别有： 可访问性：攻击方目标是阻止合法用户访问数据或获取服务 匿名性：攻击方目标是通过分析匿名交易和其它可见信息找到用户真实身份 身份验证和访问控制：为了能访问数据，攻击方尝试将自己的身份合法化 考虑下列攻击可威胁可访问性： DoS Attack：CH会匹配公钥，从而阻止这种攻击，但攻击者使用不同的公钥，DoS攻击可以达成 Modification Attack：攻击者更改或删除云中特定用户的数据，用户可以检测到改变，识别攻击，但无法恢复数据 Dropping Attack：攻击者控制超过一个CH，丢弃收到的所有请求，但这种情况会被设备检测到，如果一直没收到请求，这种情况同一个簇中的设备会重新选择CH Mining Attack：即多个CH协作构造一个假块，但架构中的信用系统会对块中交易进行验证，即使一个CH无法识别假块，其它CH也会检测到，只要有一个检测到，就会广播给全体。 为了避免攻击者分析可见信息找到用户真实身份，允许用户将任意交易发到覆盖网络，并且每个交易的ID和公钥都可变。 最后一类威胁是针对身份验证和访问控制，其中攻击者可以攻击家中的现有设备。这是可由用户检测到的，因为所有交易都在本地BC中开采。另一种可能性是对手试图在智能家居中添加新设备。这种攻击是不可能的，因为所有设备都应该由用户预先定义，并且应该在本地BC中挖掘起始交易。攻击者可以将其作为SP。然后，当它从user接收到块号和哈希值时，它可以使用这两个参数来验证自己是存储和操作存储的真实用户，使得用户不再能够访问它。在提议的架构中，存储中的每个块可以链接到另一个块。在给出这两个参数之前，矿工存储一些数据，甚至是一个空的块，并指向一个将被提供给请求者的数据。通过这样做，请求者无法将其数据链接到用户的数据，因为给定的块已经被链接 总之，所提出的方案通过适当的方法在每层中都确保了安全和隐私。表二简单的总结了它们。 表2. 表3评估了各种交易及操作在各方面的性能度量 表3. 实际上，即使最坏情况，交易数量也只和簇的数量成正比，而不是和节点数量。 ","date":"2019-01-09","objectID":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/:0:6","tags":["论文笔记"],"title":"Blockchain in Internet of Things:Challenges and Solutions","uri":"/2019/blockchain-in-internet-of-thingschallenges-and-solutions/"},{"categories":["研究生的区块链学习之路"],"content":"Dorri, Ali \u0026 Kanhere, Salil \u0026 Jurdak, Raja \u0026 Gauravaram, Praveen. (2017). Blockchain for IoT Security and Privacy: The Case Study of a Smart Home. 10.1109/PERCOMW.2017.7917634. ","date":"2019-01-07","objectID":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/:0:0","tags":["论文笔记"],"title":"Blockchain for IoT Security and Privacy:The Case Study of a Smart Home","uri":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 由于物联网网络大规模和分布式的特性，物联网（IoT）安全和隐私仍然是一个主要的挑战。基于区块链的方法可以提供分布式的安全性和隐私性，但会带来显著的能量、延迟和计算开销，不适合大多数资源受限的IoT设备。在我们之前的工作中，我们通过去除PoW（Proof of Work, 工作量证明）和货币（coins）的概念，提出了一个适用于物联网的BC（Blockchain, 区块链）的轻量级实例。我们的方法在智能家居环境中进行了验证，主要包括三层：云存储，overlay和智能家居。在本文中，我们深入研究并概述了智能家居层的各种核心组件和功能。每个智能家居都配备了一个永远在线的高资源设备，称为“miner”，负责处理家庭内外的所有通信。该miner还维护一个私有BC，用于控制和审计通信。我们通过彻底分析其在机密性，完整性和可用性的基本安全目标，表明我们提出的基于BC的智能家居框架是安全的。最后，我们利用仿真结果证明我们的方法引入的开销（在流量，处理时间和能耗方面）相对于其安全性和隐私性增益而言是微不足道的。 ","date":"2019-01-07","objectID":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/:0:1","tags":["论文笔记"],"title":"Blockchain for IoT Security and Privacy:The Case Study of a Smart Home","uri":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/"},{"categories":["研究生的区块链学习之路"],"content":"I. Introduction 物联网设备生成，处理和交换大量与安全相关的关键数据以及隐私敏感信息，因此很容易遭受各种网络攻击。许多构成物联网的新型可联网设备能耗低，重量轻。但这些设备必须将大部分可用的能量和计算资源用于执行核心应用程序，从而使得经济地处理安全和隐私问题变得困难。在能耗和处理开销方面，传统安全方法对于物联网而言往往是高花费的。此外，许多最先进的安全框架都是高度集中式的，并且由于其规模的巨大，多对一流量，单点故障等问题，不一定适合物联网。为了保护用户隐私，现有方法通常会显示噪声数据或不完整数据，这可能会阻碍某些IoT应用程序提供个性化服务。因此，物联网需要轻量级，可扩展且分布式的安全性和隐私保护方法。BC技术有可能解决上述问题。 在之前的工作中，我们认为在物联网环境中无法直接使用BC，需要解决几个问题，例如：求解PoW难题的高资源需求，由广播交易和区块到整个网络造成的交易确认的高延迟以及低可扩展性。我们通过去除PoW的概念和对货币的需求，提出了一个框架。该框架依赖于层次结构和分布式信任来维护BC安全性和隐私性，同时使其更适合IoT的特定要求。我们以智能家居场景为例说明了整个框架，但框架是与场景无关的，可以用于其他物联网场景中。该设计包括三个核心层：智能家居，云存储和overlay。智能设备位于智能家居层内，由miner集中管理。智能家居与服务提供商（SP）、云存储、用户的智能手机或个人计算机一起构成overlay，如图1所示。overlay类似于比特币中的对等网络，将分布式特性引入我们的架构。为了减少网络开销和延迟，overlay中的节点被分组为簇，每个簇选举一个CH（簇头，Cluster Head）。overlay中的众多CH和两个密钥列表一起维护公共BC。这两个密钥列表是： requester(请求者)密钥列表，它是被允许访问连接到该簇的智能家居的数据的overlay用户的公钥列表; requestee(被请求者)密钥列表，它是连接到此簇的允许访问的智能家居的公钥列表。 智能家居设备使用云存储来存储和共享数据。我们在之前的工作中讨论了overlay和云存储的细节。 本文的贡献是全面描述了我们的设计中智能家居层的细节。首先概述如何初始化IoT设备，然后解释如何处理交易。使用部署在本地的私有BC用来为IoT设备及其数据提供安全的访问控制。此外，BC生成一个不可变的按时间排序的交易历史记录，该历史记录可链接到其他层以提供特定服务。设计安全性来自多种特性，包括 间接可访问的设备 智能家居和overlay中的不同交易结构 为了实现轻量级安全性，智能家居设备采用对称加密。我们提供定性论证来证明智能家居层实现了机密性，完整性和可用性，并讨论如何阻止诸如linking攻击和DDOS等安全攻击。最后，我们使用仿真提供了一个定量结果，证明我们的框架引起的开销相对较小。本文后面的部分按以下顺序介绍 Section II：设计的主要组件 Section III：深入讨论基于BC的智能家居 Section IV：仿真结果和安全分析 Section V：总结相关工作 Section VI：结论 ","date":"2019-01-07","objectID":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/:0:2","tags":["论文笔记"],"title":"Blockchain for IoT Security and Privacy:The Case Study of a Smart Home","uri":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/"},{"categories":["研究生的区块链学习之路"],"content":"II. Core Components 介绍图2中智能家居层的主要组成部分。 A. Transactions 本地设备或overlay节点间的通信称为transactions。方案里设计了几种不同的交易用于特定的功能。Store交易由设备发起，用于存数据。access交易由SP或房主发起用于访问云存储。monitor交易由SP或房主发起用于周期性的监测设备信息。genesis交易用于添加新设备到智能家居层，remove交易则用于删掉一个设备。所有以上交易使用一个共享密钥用于安全通信。一个轻量级哈希用于检测交易内容的改变。所有的交易（不管是smart home发出的还是接收的）都存在一个本地的私有BC中。 B. Local BC 在每个智能家居中，都有一个本地私有BC，它跟踪交易并具有一个策略头来强制执行用户对传入和传出交易的策略。从genesis交易开始，每个设备的交易被链接在一起作为BC中的不可变分类帐。本地BC中的每个区块包含两个头：区块头和策略头，如图2顶部所示。区块头包含前一个区块的哈希值以保持BC不可变。策略头用于对设备授权并在其家中强制执行所有者的控制策略。如图2右上角所示，策略头有四个参数。“请求者”参数指的是接收到的overlay交易中的请求者公钥。对于本地设备，此字段等于“设备ID”，比如图2中示例策略头的第四行。策略头中的第二列表示交易中请求的操作，可以是store（在本地存储数据），store cloud(在云存储上存储数据)，access(访问存储的设备数据)，monitor(访问特定设备的实时数据)。策略头中的第三列是智能家居中设备的ID，最后一列说明是否应该通过对第二列的请求。 除了区块头和策略头之外，每个区块都包含许多交易。本地BC的每个交易都会存储五个参数，如图2的左上角所示。前两个参数用于将同一个设备的交易链接在一起并且在BC中唯一地标识每个交易。交易的相应设备ID写入第三个参数列。“交易类型”是指可以是genesis,access,store 或monitor。如果交易来自overlay，则交易存储在第五个参数列，否则，该参数列为空。本地BC由本地miner维持和管理 C. Home Miner 智能家居miner是一种集中处理来往智能家居的传入和传出交易的设备。miner可以与家里的外网网关或独立设备集成。与现有的中心化的安全设备类似，miner对交易进行身份验证，授权和审核。此外，miner还完成以下附加功能：生成创世交易，分发和更新密钥，更改交易结构，以及形成和管理簇。miner将所有交易收集到一个区块中，并将完整区块附加到BC。为了提供额外的容量，miner管理本地存储 D. Local Storage 本地存储是一种存储设备，例如在本地用来备份数据的硬盘。本地存储可以与miner集成为一个设备，也可以是单独的设备。存储使用FIFO方法，并将每个设备的数据存储为一条链，所以这里是一个设备一条链，不是所有的设备共用一条链。 ","date":"2019-01-07","objectID":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/:0:3","tags":["论文笔记"],"title":"Blockchain for IoT Security and Privacy:The Case Study of a Smart Home","uri":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/"},{"categories":["研究生的区块链学习之路"],"content":"III. The BC-Based Smart Home 讨论Initialization，Transaction Handing，shared overlay A. Initialization 描述添加设备和策略头到本地BC的过程。首先，miner通过生成genesis交易与设备共享密钥。该共享密钥存在genesis交易里。然后定义策略头，房主根据之前所述的图2中的策略结构生成自己的策略，并把策略头添加到第一个区块中。miner在最新的区块中使用该策略头，因此，要更新策略，房主应更新最新的区块中的策略头。 B. Transactions Handling 智能设备可能会彼此直接通信或者与智能家居外部的实体通信。家里的每个设备可以请求另一个家里设备的数据以提供某些服务，例如，当有人进入家中时，灯泡从运动传感器请求数据以自动打开灯。为了实现用户对智能家庭交易的控制，miner应该将共享密钥分配给需要彼此直接通信的设备。要分配密钥，miner检查策略头或向所有者请求许可，然后在设备之间分配共享密钥。收到密钥后，只要密钥有效，设备就会直接通信。要拒绝授予权限，miner通过向设备发送控制消息将分布式密钥标记为无效。这种方法的好处是双重的：一方面，miner（以及所有者）有一个共享数据的设备列表，另一方面，设备之间的通信用共享密钥保护 在本地存储上存储数据是家中可能出现的另一种交易形式。要在本地存储数据，需要使用共享密钥对存储进行身份验证。要授予密钥，设备需要发送对miner的请求，如果它具有存储权限，则miner生成共享密钥并为设备和存储发送密钥。通过接收密钥，本地存储器生成包含共享密钥的起始点。使用共享密钥，设备可以将数据直接存储在本地存储中。 设备可能要求将数据存储在云存储上。在云中存储数据是一个匿名过程，在[6]中讨论过。要存储数据，请求者需要一个起始点，该起始点包含用于匿名身份验证的区块号和哈希值。云存储可以由SP拥有和管理（例如Nest恒温器），或者由房主（例如Dropbox）支付和管理。在前一种情况下，miner通过使用设备密钥生成签名交易来请求起始点。在后一种情况下，付款是通过比特币完成的。在任一存储类型中，在收到请求后，存储会创建一个起始点并将其发送给miner。当设备需要在云存储上存储数据时，它会将数据和请求发送给miner。通过接收请求，miner授权设备在云存储上存储数据。如果设备已被授权，则miner从本地BC中提取最后的区块编号和散列，并创建store交易并将其与数据一起发送到存储器。在存储数据之后，云存储将新的区块号返回给用于进一步存储交易的miner。 其他可能的交易是访问和监视交易。这些交易主要由房主在外面监控房屋时产生，或由SP来处理设备的个人服务数据。通过从overlay中的节点接收access交易，miner检查所请求的数据是在本地还是云存储上。如果数据存储在本地存储中，则miner从本地存储请求数据并将其发送给请求者。另一方面，如果数据存储在云中，则miner要么从云存储请求数据并将其发送给请求者，要么将最后的区块号和散列发送给请求者。后一种情况使请求者能够读取设备在云存储中存储的整个数据，并且当存储的数据用于唯一设备时是合适的。否则，用户的隐私可能会受到链接攻击的威胁，这将在后面的第IV节中讨论。 通过接收monitor交易，miner将请求的设备的当前数据发送给请求者。如果允许请求者在一段时间内接收数据，则miner定期发送数据，直到请求者向miner发送关闭请求并废除交易。monitor交易使房主能够观看发送定期数据的摄像机或其他设备。为了避免开销或可能的攻击，所有者应该以分钟为单位定义周期性数据的阈值。如果miner为请求者发送数据的时间达到阈值，则miner终止连接。 C. Shared Overlay 当一个人有多套房子，他需要为每套房子都部署miner和存储。为了降低这种情况下的花费和管理开销。定义了一个shared overlay。shared overlay由至少两个智能家庭组成，但由一个共同的miner管理，逻辑上可以视作一个家庭。但有些地方和一个家庭的情况还是有区别的，比如即使是shared overlay的情况，其中每个家庭也都有一个自己的创世交易，所有设备的创世交易都链到它们家庭的创世交易上。又比如设备间通信，同一个家庭内的设备间通信自然没有什么区别，但不同的家庭间设备的通信则通过VPN完成，数据包从一个家庭的miner路由到另一个家庭的miner。 ","date":"2019-01-07","objectID":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/:0:4","tags":["论文笔记"],"title":"Blockchain for IoT Security and Privacy:The Case Study of a Smart Home","uri":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/"},{"categories":["研究生的区块链学习之路"],"content":"IV. Evaluation and Anlysis 讨论安全性、隐私和方案性能 A. 安全分析 任一设计都应保证三个安全需求：机密性、完整性和可用性。机密性确保只有授权用户才能阅读该消息。完整性确保目标接收到未经修改的消息，可用性意味着用户需要时每个服务或数据都是可用的。前两个需求的实现第III部分以及说清楚了。为了增加智能家居可用性，使设备可以免受恶意请求的影响，可以通过将接受的交易限制为每个设备已与其建立共享密钥的那些实体来实现的。从overlay接收的交易在将它们转发到设备之前由miner授权。此外，我们方案还带来了一些处理上的延迟，但这些延迟并不会影响可用性。表一总结了我们的方案如何实现上述需求 表1. 需求 保证方法 机密性 通过对称加密实现 完整性 通过哈希实现 可用性 通过限制设备和miner可接受的交易实现 用户控制 通过在本地BC中记录交易实现 身份鉴别 通过使用策略头和共享密钥实现 接下来分析该方案应对DDoS攻击和Linking攻击的有效性 DDoS Attack 首先，攻击者不可能直接在智能家居设备上安装恶意软件，因为所有的交易都由miner检查，所有的设备都无法直接访问。 其次，假设设备被感染，称为恶意节点，由于所有传入传出的请求都由miner通过检查策略头授权，构成DDoS攻击流量的请求是不会被授权的。 Linking Attack 为了防止这种攻击，每个设备的数据由唯一密钥共享和存储。miner使用不同的公钥为每个设备在云存储中创建唯一的数据分类帐。从overlay的角度来看，miner应该为每个交易使用唯一的密钥。 B. 性能分析 本文架构为了提供改进的安全性和隐私性，引入了额外的计算和分组开销。通过使用Cooja仿真器仿真智能家居场景，和没有使用加密，哈希和区块链的场景做对比，结果如下： Packet 开销：显著增大 时间开销：由于额外的加密和哈希操作，需要更多的时间，但引入的额外时间最多不超过20ms，可以接收。 能量开销：能耗几乎增加了一倍。 作者认为相比于该方案带来的安全性和隐私性，额外引入的这些开销是可以接受的。 ","date":"2019-01-07","objectID":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/:0:5","tags":["论文笔记"],"title":"Blockchain for IoT Security and Privacy:The Case Study of a Smart Home","uri":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/"},{"categories":["研究生的区块链学习之路"],"content":"V. Related Works 首先是两篇论文说明了现有的智能家居场景确认有效的安全防御手段 S. Notra M. Siddiqi H. H. Gharakheili V. Sivaraman R. Boreli “An experimental study of security and privacy risks with emerging household appliances” Communications and Network Security (CNS) 2014 IEEE Conference on pp. 79-84 2014. V. Sivaraman D. Chan D. Earl R. Boreli “Smart-phones attacking smart-homes” Proceedings of the 9th ACM Conference on Security \u0026 Privacy in Wireless and Mobile Networks pp. 195-200 2016. 以及一个现有的处理智能家居场景安全和隐私的方案，通过使用两个数据集保证真实用户对数据的访问权，但对服务提供商无法提供有效的隐私保证。 A. Chakravorty T. Wlodarczyk C. Rong “Privacy preserving data analytics for smart homes” Security and Privacy Workshops (SPW) 2013 IEEE pp. 23-27 2013. ","date":"2019-01-07","objectID":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/:0:6","tags":["论文笔记"],"title":"Blockchain for IoT Security and Privacy:The Case Study of a Smart Home","uri":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/"},{"categories":["研究生的区块链学习之路"],"content":"VI. Conclusion 如今，物联网安全正受到学术界和工业界的广泛关注。由于高能耗和处理开销，现有的安全解决方案不适合物联网。我们提出的方法通过利用BC来解决这些挑战。使用智能家居场景为例研究讨论了这个想法。在本文中，我们概述了智能家居层的各核心组件，并讨论了与之相关的各种交易和程序。我们还提供了有关其安全性和隐私的全面分析。我们的仿真结果表明，对于低资源IoT设备，我们的方法产生的开销很低且易于管理。我们认为，鉴于提供的安全性和隐私优势，引入的开销是值得的。 ","date":"2019-01-07","objectID":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/:0:7","tags":["论文笔记"],"title":"Blockchain for IoT Security and Privacy:The Case Study of a Smart Home","uri":"/2019/blockchain-for-iot-security-and-privacythe-case-study-of-a-smart-home/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Mohamed Tahar Hammi, Badis Hammi, Patrick Bellot, Ahmed Serhrouchni Published in: Computers \u0026 Security(2018.6) SCI期刊分区：3区 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:0","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Abstract 我们使用的许多东西都配备了电子设备和协议，以使它们互连和连接到互联网。在物联网中，事物处理和交换数据而无需人为干预。因此，由于这种完全自治，这些实体需要相互识别和认证，并确保其交换数据的完整性。否则，它们将成为恶意用户和恶意使用的目标。由于物联网的规模和其他特性，几乎不可能创建有效的集中式身份验证系统。为了弥补这一限制，在本文中，我们提出了一种称为bubbles of trust的分布式系统确保设备的可靠识别和认证。此外，它还可以保护数据的完整性和可用性。为了实现这一目标，我们的方法依赖于区块链提供的安全优势，并用于创建安全的虚拟区域（bubbles），在这些区域内，事物可以相互识别和信任。我们还使用C ++语言和以太坊区块链提供了我们机制的真实实现。所得结果证明了其满足物联网安全要求，效率和低成本的能力。 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:1","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction and problem statement 前三段讲如今物联网和我们的生活息息相关，并且用在很多领域。 物联网及其不同应用背后的理念是各种各样的事物无处不在，它们能够相互交流和合作，以提供广泛的服务。因此，将包括大量设备。因此每个物理或虚拟设备都应是可达的，并产生可以由用户检索的内容，而不管其位置如何。但是，只有经过身份验证和授权的用户才能使用该系统，这一点非常重要。否则，它将容易出现许多安全风险，例如信息窃取，数据更改和身份篡改。实际上，安全问题仍然是物联网大规模采用和部署的主要障碍，因为它极易受到攻击，原因有很多：（1）大多数通信都是无线的，这使得系统更容易受到攻击如身份欺骗，消息窃听，消息篡改和其他安全问题，以及（2）多种类型的设备在能量，内存和处理能力方面的资源有限，这阻碍了它们实施高级安全解决方案。 许多研究人员将IoT定义为system-of-systems，其中多个用例场景要求只有受信任的用户才能使用提供的服务。因此，诸如认证，机密性和数据完整性之类的传统安全要求对于这些生态系统的每个部分都是至关重要的，包括事物，网络和软件应用程序。但是，由于设备资源的局限性和异构性，现有的安全解决方案并未完全适应这种生态系统。此外，通常需要多种安全技术和解决方案的组合，这导致了高花费。更多的，有效的安全解决方案通常是中心化的，如Public Key Infrastructure（PKI），它可能在由数千个节点组成的环境中引起巨大的可伸缩性问题。最后，每个用例都应用不同的安全方法，体系结构和部署，这会在新服务和方案的集成中造成多个困难。因此，有必要为整个系统系统提出新的安全解决方案。后者必须：（1）允许轻松集成新设备和新服务;（2）完全适应物联网的要求和需求;（3）不依赖于设备的类型，也不依赖于用例架构和设计 我们相信，区块链代表了一种非常有前途的技术，可以满足物联网环境中的安全要求。在这项工作中，我们提出了一种称为bubbles of trust的高效分布式认证机制。该机制在以太坊上实施，旨在创建安全的虚拟区域，设备可以安全地进行通信。其评估显示了其满足物联网安全要求的能力。此外，我们还对可构成物联网生态系统的不同类型设备的计算和能源影响以及财务成本进行了广泛的研究。最后，将这些成本与一些现有的物联网认证方案进行比较。 第二节介绍了区块链 第三节分析安全要求并介绍我们的威胁模型。 第四节描述了将区块链和物联网结合的现有工作。 第五节描述了我们基于区块链的方法。 第六节讨论和分析我们的评估活动。 第七节描述了方法的公开问题。 第八节总结了论文并介绍了我们未来的工作。 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:2","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Background 介绍区块链及其中的一些重要概念，略过。 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:3","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Security Requirements and threat model A. 安全需求 物联网计划必须满足众多安全要求，以确保生态系统的可持续性和弹性。因此，在本节中，我们将描述主要的安全目标，并介绍评估认证方案是否适合保护物联网用例所需的标准。 完整性：完整性是每个方案都必须保证的一个关键需求，本文将完整性分为两方面 消息（交易/通信）完整性：在网络传输过程中，不得更改或修改交换的消息。 数据完整性：涉及在数据的整个生命周期内保持其一致性和可信赖性。因此，只有授权用户才能修改存储的数据。 可用性：可用性意味着合法用户必须可以按需访问资源。因此，系统必须能够抵御拒绝服务攻击，特别是那些以身份验证服务为目标的攻击 可扩展性：可扩展性代表着系统规模对其性能没有影响。 不可否认性：它指的是确保实体不能拒绝执行特定操作的能力，例如：设备不能拒绝发送消息。 识别：识别代表了大多数物联网用例的主要要求。它代表了确保任何实体都可以在确保对所有系统实体匿名的情况下使用系统的匿名性的反面。例如，在智能停车场景中，当停车位的传感器发送通知时，管理系统必须确切地知道哪个传感器正在通信，以便准确地更新停车位的状态。另一个例子是环境监测，其中传感器监测湖泊的水位。当该传感器向监控平台发送信息时，后者必须确切知道哪个传感器正在通信，以便决定要提供的操作。 相互认证：认证是证明身份的机制。相互认证表示两个通信方相互认证的要求。这个要求是使系统免受欺骗的必要条件。 B. 威胁模型 网络模型：身份验证方案的总体目的是允许多个节点通过非可信网络以可信赖的方式进行通信。在这项工作中，我们考虑一个在集中式或分布式架构中提供和使用不同物联网服务的网络。每个IoT设备都和大量其它设备通信。交换的消息通过不可靠且可能有损失的通信网络，例如Internet。我们还假设所有参与者都不可信任。实际上，网络中的大量智能物品会增加风险。此外，现有设备是异构类型的，并且不属于相同的用例。网络功能仅包括转发数据包，不提供任何安全保证，如完整性或身份验证。因此，恶意用户可以读取，修改，丢弃或注入网络消息。 攻击者模型：我们假设攻击者或恶意用户可以完全控制使用过的网络，即他可以选择性地嗅探，丢弃，重放，重新排序，注入，延迟和修改消息，延迟可以忽略不计。但是，设备可以接收未经更改的消息。尽管如此，没有对改变的消息的速率做出假设。此外，攻击者可以从比实现的设备更大的计算能力和存储中受益。 不考虑对设备的物理攻击，及属主拥有对设备的完全控制权，不可能让攻击者在现实里碰到设备。 攻击：攻击者可以有多个目标，例如发送错误的信息以误导系统的决策或拒绝系统的服务。因此，它可以进行多次攻击 Sybil attack spoofing attack：与sybil攻击相反，攻击者试图创建大量虚假或虚拟身份，在欺骗攻击中，攻击者试图欺骗合法用户的身份以利用其权限。 message substitution：在替换攻击中，攻击者在传输过程中截获有效消息，对其进行更改，使伪造消息就好像它们是由原始发件人发送的一样。 Denial of Service Message Replay Attack：重放 本文方案的考虑的主要安全需求和攻击如下表1 评估标准 结果 相互认证 √ 数据完整性 √ 通信消息完整性 √ 可用性 √ 可扩展性 √ 不可否认性 √ 匿名 X 机密性 X Sybil保护 √ spoofing保护 √ 消息替换保护 √ 重放保护 √ 消息删除保护 X 认证机制的DoS/DDoS保护 √ 服务的DoS/DDoS保护 X ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:4","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Related Works 很多人试图把区块链和物联网结合，但只有少数人关注如何使用区块链满足物联网的安全需求。 总结了很多文章，最后还列了一张表，是讲很多人的方案用公链的安全机制，这样每个人都可以加入，包括恶意节点，没有认证机制。而且不少人的方案只是理论，没有实现，连个仿真实现都没有。 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:5","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Proposed Approach 方案的主要目标是在物联网环境中创建一个安全的虚拟区域，每个设备都只和本信任域的设备通信，并认为其它设备是恶意的。这个信任域叫bubbles of trust。方案使用公链，因为私链用户是预定义的，可扩展性和灵活性都不如公链。 系统中的通信作为链中交易，需要验证。一个设备的完整过程如下所述。 A. 初始化阶段 我们的方法可以应用于大量的物联网用例，不需要特殊的硬件。但是，它需要一个初始化阶段。初始化阶段中，一个设备被设计为bubble的Master（它拥有私钥/公钥对），可以认为它类似于证书颁发机构。任何给定的设备都可以是Master。此外，bubble中除Master之外的其它设备称为Follower。每个Follower生成椭圆曲线（EC）私钥/公钥对。然后，每个Follower由一个名为ticket的结构识别，该结构表示64字节的轻量级证书，其中包含：（1）groupID（grpID），表示设备所属bubble，（2）objectID（objID），代表bubble中的Follower标识符，（3）pubAddr，代表Follower的公共地址。它代表了Follower公钥的Keccak（SHA-3）哈希的前20个字节。（4）一个Signature结构，它使用bubble的Master的私钥表示椭圆曲线数字签名算法（ECDSA）签名。与传统的签名算法相比，例如Rivest Shamir Adleman（RSA），ECDSA具有多种优势，特别是关于密钥大小和签名时间，更适合物联网。Signature涵盖了groupID，objcetID和pubAddr的串联的Keccack哈希。结构如下： GroupID：XX ObjectID：YY PubAddr：@@ Signature（keccakhash（XX || YY || @@）） B. System’s functioning 整个结构完整描述，不过是以图示的方式，可以看原文。 C. Summary Master，Follower和一些它们都需要注意的规则。 使用公链而不是私链或联盟链的好处 为什么用以太坊 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:6","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Evaluation an Discussion A. Context and use case scenarios 该方案的优点在于其适用性，所以以下提出几个场景，分别评估在不同场景下执行时间、能耗和经济上的花费。 Smart house：这里的案例里包括如下几个设备。1）具有存储购物清单并按照某个已编程的时间表在线订购的功能的设备，2）智能冰箱，通过编程来保持食物，如果食物坏了，就发消息把它添加到购物清单里，3）智能洗衣机，监控洗衣粉的水平。如果水平达到某个阈值，则洗衣机发送消息以将其添加到购物清单。4）远程浇水系统，可由智能手机控制。（4）remote vacuum，也可以由智能手机控制 Waste management：废物管理是城市生活中日益严重的问题。其中一个已知问题是垃圾车路线。实际上，垃圾车需要拿起所有垃圾桶，即使它们是空的，这会导致燃料和时间损失，以及二氧化碳增加。如果我们考虑通过塑料，纸张，玻璃或其他特殊材料收集的卡车，这些问题可能会更加昂贵，垃圾桶大部分都在地下，并且有一个非常复杂的程序来清空它们，这在许多情况下会造成交通拥堵，产生更多污染，时间和金钱损失。幸运的是，物联网可以带来多种解决方案。通过在垃圾桶内使用物联网设备，这些设备将连接到管理应用程序，在那里他们发送有关垃圾桶填充状态的信息。基于该信息，服务器决定是否将垃圾桶添加到要清空的垃圾桶列表中。接下来，管理应用程序使用图论技术来定义垃圾车的更便宜的路径。 Smart factory：智能工厂的特点是自组织的多代理系统，辅以基于大数据的反馈和协调。换句话说，在智能工厂中，有许多自动化机器，例如机器人手臂，机器人和自动无人驾驶车辆，它们配备有通信设备，以便在它们之间以及它们与外部世界（客户，合作伙伴，其他生产现场）之间进行通信。为了提供更好的组织和生产安排。 Smart road radar：智能道路雷达，是一种可以远程控制和设置的道路雷达，以避免人为干预。其主要功能是衡量道路使用者的速度。如果它检测到速度违规者，它会向管理系统发送包含其拍摄的牌照及其测量速度的消息。 在所有描述的场景中，在网络中发送多个敏感消息和信息。如果恶意用户伪造，修改或重放（在某些情况下）这些消息，后果将是灾难性的。因此，这些消息的认证和完整性是至关重要的。 B. Evaluation framework 为了评估方案的时间和功耗，用了三个终端，两个相同的笔记本电脑，一个树莓派。一个笔记本作为Master，一个作为Followers。其中的应用程序用C++开发。 区块链用了以太坊，智能合约用solidity写。还写了一个接口做消息转换。测量以下指标： 准备关联请求所需的时间 准备数据消息所需的时间 准备关联请求的CPU功耗 准备数据消息的CPU功耗 发送关联（发送请求+接收响应）的网络接口控制器（NIC）功耗 发送数据消息（发送消息+接收收据）网卡功耗 只关注Follower的各项指标，因为Master除了创建bubble，之后完全和Follower没什么两样。 C. Evaluation results 安全需求评估：针对前面提到的各安全需求分析该方案是否满足。 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:7","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Open Issue 不适用于实时应用 我们的方法依赖于公链。根据共识协议，交易（块）在某个预定义的时间段（共识所需时间）中被验证，例如，以太坊14秒。因此，设备发送的事务（消息）将仅在此期间之后进行验证。有许多物联网方案，不允许这段时间。但是，如果使用私有区块链，则可以解决此问题。 需要一个初始化阶段 我们的方法需要初始化阶段。可以在新设备或旧设备上实现。在这两种情况下，都需要服务供应商（发起人）的干预。尽管如此，任何用户都可以创建自己的bubble，只要他将自己定义为Master 加密货币汇率的演变 我们的方法依赖于公链，其涉及的成本取决于区块链系统使用的加密货币。尽管如此，我们认为所提供的每项安全服务都需要成本，只要它仍然低于潜在的损害赔偿金。此外，根据一些研究，加密货币汇率的演变将随着时间的推移变得更加稳定。更好的是，以太坊开发者和社区正致力于调节和稳定与智能合约使用相关的费用。 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:8","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Conclusion and Future works 在本文中，我们提出了一种方案，创建了一个信任域，其中设备可以以完全安全的方式进行通信。该方案可以应用于众多物联网场景。它依赖于公链，因此，它受益于其所有安全属性。此外，我们还定义了物联网认证方案必须确保并构建威胁模型的安全要求。对我们方法的评估表明其能够满足所请求的安全要求及其对攻击的弹性。此外，我们对其时间和能量消耗进行了广泛的研究，我们评估了不同的设备。对于未来的工作，我们计划（1）改进系统，以便允许一组选定的bubble之间的受控通信;（2）为受损设备实施撤销机制;（3）研究和设计一个协议，旨在优化定义系统中矿工的数量，以及如何放置选定的矿工 ","date":"2019-01-03","objectID":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/:0:9","tags":["论文笔记"],"title":"Bubbles of Trust：a decentralized Blockchain-based authentication system for IoT","uri":"/2019/bubbles-of-trusta-decentralized-blockchain-based-authentication-system-for-iot/"},{"categories":["平日里的白日梦"],"content":"凡心所向，素履以往，生如逆旅，一苇以航。 三月桃花，四月欢唱，两人一马，明日故乡。 流浪陌路，暖然绯凉，写意人生，相识一场。 不关此世，不负己心，我自倾杯，且君随意。 ","date":"2019-01-02","objectID":"/2019/%E5%87%A1%E5%BF%83%E6%89%80%E5%90%91%E7%B4%A0%E5%B1%A5%E4%BB%A5%E5%BE%80/:0:0","tags":["文摘"],"title":"凡心所向，素履以往","uri":"/2019/%E5%87%A1%E5%BF%83%E6%89%80%E5%90%91%E7%B4%A0%E5%B1%A5%E4%BB%A5%E5%BE%80/"},{"categories":["研究生的区块链学习之路"],"content":"Novo O. Blockchain Meets IoT: An Architecture for Scalable Access Management in IoT[J]. IEEE Internet of Things Journal, 2018, 5(2): 1184-1195. DOI: 10.1109/JIOT.2018.2812239 keywords: Access control, Blockchain, IoT, smart contracts ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:0:0","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"摘要 物联网所面临的一个问题是部署在全球的数十亿的设备如何去管理，现有的访问管理技术是基于一个中心化的模型。这篇论文提出了一种在物联网中用于仲裁角色和权限的新的架构。这种新架构是基于区块链技术的全分布式的访问控制系统。该体系结构由概念验证的实现支持，并在实际的物联网方案中进行评估。结果表明，区块链技术可以用作特定可扩展物联网场景中的访问管理技术。 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:1:0","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1. 引言 IoT设备数量迅速增长并逐渐对许多关键领域产生重要影响，可预见的是，许多物联网服务将建立在数百万IoT设备的互联互通基础上，而限于IoT设备本身的能力限制和现有的中心化访问控制系统，实际应用依然面临许多挑战。 传统的互联网场景下，设备位于同一信任域内，因此需要中心化的访问管理结构。但相比于传统场景，一些物联网场景是动态的，这句话主要含义有两个 IoT设备可能是移动的，在生命周期中可能属于不同的管理实体， IoT设备可以同时由多个管理实体管理。 此外，许多IoT设备和管理实体在CPU，内存和电池等方面能力都有限，无法支持当前管理系统的正常运行。另外，在访问控制查询和更新请求频繁时，中心化结构中的访问控制服务器可能成为性能瓶颈，因此需要新的方法来解决问题。 这篇论文提出了一种用于管理IoT设备的新架构，建立了一个能将位于不同地点的传感器网络连接起来的分布式访问控制系统。这一解决方案基于区块链技术，访问控制策略则由区块链强制执行，通过采用区块链，能替代原来的中心化管理方式。与传统中心化结构相比，这篇论文的方案有如下优点： 灵活性（Mobility）：该架构可用于相互隔离的管理域。因此，每个管理域都有自己的自由来管理物联网设备，而访问控制策略仍然由区块链中的规则强制执行。 可访问性：一些物联网设备拥有休眠模式，这使得持续的访问是不可行的。这种解决方案则使访问控制规则随时可用。此外，某些管理服务器中的故障不会破坏对信息的访问，所有访问控制信息都是分布式的。 并发：同一物联网设备可能同时拥有多个manager，并且这些manager能同时访问或修改访问控制策略 轻量：现有的IoT设备无需任何改动即可采用该方案，另外，管理实体和IoT设备间的通信通过区块链实现，可以实现跨平台的通信。 可扩展性：管理实体可以使用该方案操纵多个IoT设备，因为设备对访问控制信息的读取是通过区块链完成的，不直接访问管理实体。另外，该方案支持众多的物联网设备通过不同的网络连接到同一条区块链。 透明：该系统隐藏了物联网设备的位置及访问资源的手段。 本文的方法与其它方案的不同之处在于没有把区块链集成到物联网设备中，从而避免了IoT设备能力限制带来的问题，能用在更广泛的物联网场景中。与其他解决方案相反，该设计在单个智能合约中运行，简化了区块链网络中的整个过程，并减少了节点之间的通信开销。另外，访问控制信息被实时提供给IoT设备。总之，这种方案是专门针对可扩展性设计的，并且能取得比无论是传统的还是同样基于区块链的方案更好的性能。 文章的其余部分组织如下，第二部分描述架构，第三部分描述架构实施，第四部分描述评估方案并给出评估结果，第五部分分析系统安全性，第六部分介绍物联网中相关的访问控制技术，最后是结论。 注：作者将区块链主要特性 总结为分布式、透明、防篡改和可审计。 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:2:0","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2. 方案 这篇论文提出的架构是一个分布式的访问管理系统，访问控制信息通过区块链存储和分发。 除了IoT设备和管理中心（Management hub）节点，所有实体都是区块链的一部分。区块链网络的每个节点都包含整个区块链的副本，而区块链的规模会随着时间推移逐渐变大，IoT设备受限于存储能力无法保持整个区块链副本，因此这篇论文没有将IoT设备纳入区块链网络，而是额外定义了管理中心节点来代替IoT设备发起和接收访问控制请求。 这篇论文的方案还使用一个智能合约定义访问控制涉及的所有操作，该合约是唯一的且无法从区块链中删除，管理者（Manager）与智能合约交互来定义访问控制策略。整体架构图如下 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:3:0","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 涉及的角色 整个架构由无线传感器网络、管理者、代理节点、智能合约、区块链个和管理中心六部分组成。 无线传感器网络：属于无线传感器网络的IoT设备在计算能力、存储和电池等方面性能都有限制。由于IoT设备不属于区块链网络，因此需要在区块链网络中全局唯一地标识所有设备，使用公钥生成器产生大量唯一的随机数解决该问题。主要通过使用现有的IoT加密技术自动为每个设备创建公钥，使用强制加密连接确保拥有唯一标识。· 管理者：管理者是负责管理一组物联网设备的访问控制权限的实体。通常，管理者被认为是系统中的轻量级节点。轻量级节点不存储区块链信息，也不像矿工节点那样验证区块链的交易。因此，有能力限制的设备也可以成为系统中的管理者，而不会由于其硬件限制造成障碍。此外，使用我们的方法的管理者不需要一直连接到区块链网络，这有助于减少其硬件资源的使用。 任何实体都可以注册成为管理者。但是，作为IoT设备注册的设备必须在管理者的控制下注册。这是为了避免管理者在未经设备允许的情况下注册到它们控制的设备上。此外，系统中所有已注册的IoT设备必须属于至少一个已注册的管理者。否则，没有人能够管理该设备。已注册的IoT设备可以同时属于多个管理者。 物联网设备在管理者控制下注册后，管理者可以为它们定义特定的访问控制权限。 代理节点（Agent Node）：代理节点负责部署唯一的智能合约。为了与智能合约进行交互，区块链网络中的所有节点都需要知道智能合约的地址，该地址在合约部署时返回给代理节点 智能合约：唯一且无法从系统中删除。所有访问控制策略都在智能合约中定义，并由区块链交易触发。除此之外，为了在系统中更新或添加访问控制策略，还必须考虑到管理者是唯一能够与智能合约进行交互的实体。 区块链网络：为简单起见，我们架构中的区块链网络是一个私有区块链，可以在评估系统时为我们提供了更可靠的结果。但是，在实际情况中，应使用公共区块链来实施方案。 管理中心：如前所述，物联网设备不属于区块链网络。并且，大部分物联网设备由于CPU、内存和电池等能力的限制无法成为区块链节点，即使已有一些解决方案无需保存整个区块链的副本，但物联网设备的能力仍无法满足。所以该论文选择使用称为管理中心的节点。管理中心可以将IoT设备在CoAP消息中编码的信息转换为区块链节点可理解的JSON-RPC消息。它直接与区块链节点（例如矿工）相连。多个传感器网络可以连接到一管理中心节点，多个管理中心节点可以连接到同一个区块链节点。物联网设备只能使用管理中心从区块链请求访问信息。 与此同时，管理中心节点不能像物联网设备一样有能力限制，因为它服务于众多的物联网设备的请求。 在最简单的情况下，不需要身份认证，任何物联网设备都可以直接连接到任何管理中心并访问区块链网络。但是，在许多情况下仍需要访问控制。因此，物联网设备将只能连接到某些特定的管理中心节点。将IoT设备添加到系统后，该设备的管理者必须通知相关的管理中心节点有关该设备的凭据，以及通知设备管理中心节点的位置 IoT设备注册在管理者控制下完成，注册后的凭据交给管理中心，并将管理中心的地址交给设备。 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:3:1","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 合约接口 本节更详细地说明了智能合约中定义的操作以及管理中心节点用来从区块链查询访问控制策略的接口。 智能合约：I是管理者m公钥集合，G是物联网设备s公钥集合，P是策略集，每个策略代指公钥标识的设备s对另一个设备s'的资源r由权限。智能合约中定义如下操作： 注册管理者 注册设备 为设备添加管理者 移除设备的某个管理者 添加访问控制策略 删除管理者 删除设备 取消权限 查询管理者 查询权限 如上，管理者和物联网设备可以由系统通过公钥识别。资源由资源名识别。另外，资源是可从物联网设备获取的任何东西，权限包括查看、修改、执行等。 Management hub 管理中心并非通过交易获取策略信息，而是直接从区块链节点的存储中查询，所以查询操作实时且无交易费。 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:3:2","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 交互流程 介绍架构中不同部分间的交互，如下图3，分为四阶段。图中未列出所有交互，但下文会有详细列举。这些交互是注册后系统中的访问控制策略的修改和注册后设备的管理者的修改 Network Set-up 在此阶段，访问管理系统在区块链网络中创建。在区块链网络创建后，代理节点将智能合约部署到区块链网络中。这个智能合约定义了访问控制管理系统的所有操作。一旦智能合约被接纳到区块链网络中，代理节点就会收到智能合约的地址。该地址用于识别访问管理系统中的智能合约，区块链网络的其他组件需要智能合约的地址与其进行交互。例如，系统中的所有managers都将与此智能合约进行交互，以注册为manager或修改物联网设备的控制访问规则 management hub将与区块链网络中最近的可用节点连接，如图3中的矿工节点。该矿工持有区块链的副本。此外，它还使RPC端口可以侦听请求，并允许management hub连接到它。management hub还必须有一种方法来查找它们旁边的可用节点。该信息可以从Internet中的中心化系统获得，但在我们的特定实现中，可以在每个management hub手动设置。 Registration 访问管理系统中的任何区块链节点都可以注册为manager。为了使区块链节点将自己注册为manager，它需要知道智能合约的地址。一旦获得该信息，它就可以将交易发送到智能合约中定义的函数RegisterManager来注册自己。此后，一旦交易成功被接纳到区块链中，manager将收到其注册地址。该地址将标识访问管理系统中的manager Manager节点还可以在manager的控制下注册IoT设备。物联网设备可以拥有的manager数量没有限制。因此，物联网设备可以随时拥有多个manager。与前一种情况一样，manager将收到注册设备的地址，该地址将用于标识访问管理系统中的设备。物联网设备应该能够在区块链中接受操作之前验证manager控制下的注册。否则，任何manager都可以注册其控制下的任何设备。为简单起见，我们的实施避开了验证。这种假设使得我们的系统在有恶意manager的情况下基本上不安全，但我们的目标是证明架构的可行性而不是安全性 Management Modification 如前所述，每个IoT设备必须属于至少一个manager。此外，我们的系统支持多个manager控制同一设备。我们的系统有多种方法可以将管理控制权从一个manager转移到另一个manager，或者从系统中添加或删除多个manager。 在我们的模型中，我们选择了一个最简单的方式，系统中的每个manager节点都可以将其自身作为其控制的设备的manager。相反，manager不能从系统中删除其他manager。只要IoT设备至少受另一个manager节点的控制，系统将始终让manager从物联网设备中移除自己。否则，智能合约将不允许该操作，将被取消。 另一方面，只有控制IoT设备的manager节点才能在该设备的控制下注册其他manager。 我们解决方案的一个优点是，转移物联网设备的管理控制权是一个简单的过程，因为系统中的所有操作都是使用单个智能合约定义和实施的，而manager不需要与每个操作进行交互。其他。manager只需知道设备的地址和智能合约的区块链地址即可修改管理关系 Policy Definition manager可以为其物联网设备的资源定义访问控制规则。可以通过多种方式定义权限。但是，我们的实现中的权限列出了有权访问特定资源的设备。此后，manager不仅需要知道其控制下的设备的地址，还需要知道有权访问其IoT设备的设备的地址。manager可以执行策略，使用所有信息为智能合约创建交易。 Policy Modification 与策略定义类似，manager可以随时修改和删除策略。该方法类似于策略定义中描述的方法。如果manager使用AddAccessControl操作添加现有策略，则会自动修改该策略 Policy Discovery 当图3中的设备S2希望访问由设备S1托管的资源时，S2发送请求S1的资源信息的CoAP消息。因此，S1可以通过managemnt hub请求S2的访问控制信息。在物联网设备可以连接到最近的managemnt hub之前，设备首先需要发现managemnt hub的IP地址。可以有多种机制来发现最近的managemnt hub节点，但我们实现中使用的方法假设每个设备都有一个默认位置。然后，managemnt hub将设备的消息转换为RPC消息，并将其发送给与其相连的区块链网络中的矿工。该操作查询来自存储在矿工中的区块链的信息。从本质上讲，这意味着该操作不是交易，也不存储在区块链中。因此，操作立即处理，不会产生任何费用。一旦矿工将S1的访问策略通知managemnt hub，managemnt hub就将答案转换回S1。S1根据managemnt hub收到的信息采取相应的行动。图3示出了成功的答案，因此，S1将资源的信息发送到S2 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:3:3","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2.4 系统限制 本文的解决方案改进了物联网设备的管理方式，但区块链技术本身有一些技术限制，以下详细解释并描述一些可能的克服的方法 交易费，该方案中只有manager节点能代表设备创建交易，也因此必须支付交易费，其它节点不属于链中节点，不需要支付交易费。 处理时间，区块链的交易是有确认时间的，该方案中management hub查询权限是实时的，但manager创建交易需要等待确认，这个延迟可能会出现安全问题，比如访问控制不被接受，该交易被撤销前，这一小段时间可能被利用该权限进行非法访问。可能的解决办法是在智能合约中加入时间信息令其自动撤销，或者增加撤销操作的交易费，从而减少该操作的产生。 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:3:4","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3. 实现 虽然最终的目标是公有区块链网络，但这篇论文仅仅是概念验证，所以作者选用以太坊搭建了一个私有区块链。智能合约的设计结构如下，IoT设备信息、管理者信息，访问控制策略的细节都存在如下图所示的两个不同结构中，这个结构很相似于哈希表 管理中心可帮助IoT设备与区块链网络连接，通过JavaScript语言调用Web3 JavaScript API与以太坊节点通信，并使用名为node-coap的CoAP JavaScript库与IoT设备连接。 设备则使用LibCoAP库实现， LibCoAP是CoAP的C实现，它可以利用tinydtls框架支持传输层安全性。LibCoAP代码已修改为每个设备自动生成公钥/私钥。密钥长度为20个字节，用于唯一标识管理系统中的设备。该库实现CoAP客户端和CoAP服务器。CoAP服务器用于在CoAP客户端创建CoAP请求消息时侦听CoAP请求并对其进行响应。 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:4:0","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4. 评估 因为对以太坊性能的评估已有相关论文存在，这里只进行管理中心和IoT设备的评估，主要是评估管理中心的引入是否会成为该方案的技术限制。CoAP的评估使用了名为CoAPBench的工具，因为该工具能力不足，做了一定修改。 在两个场景下评估，一个是独立评估管理中心从区块链查询信息的性能，一个是很多IoT设备向同一个设备请求资源时管理中心的性能。结果证明，两种情况下延迟都可以接受，并且单位时间可完成的并发量在传感器网络场景下足够适用。 作者同样分析了设计的方案能否防范以下几类安全威胁，1) spoofing; 2) tampering; 3) repudiation; 4) information disclosure; 5) denial of service; and 6) elevation of privileges。表格中的是首字母缩写 S T R I D E Management Hub X X X X X Manager X IoT Device X 尽管区块链提供了数据完整性和可靠性，但物联网节点在该方案中并不属于区块链的一部分，它依赖于管理中心的访问控制信息，而恶意的管理中心可能完成以上前五种任意一种恶意行为，这只能通过引入一个第三方的安全证书发放机构来避免。物联网节点通过验证管理中心的证书验证其身份。 同样由于物联网设备、管理中心与区块链的隔离，区块链无法验证管理中心是否正确的实施了其访问控制规则，另外，由于物联网设备的所有权不断更换，其信息也难以追踪和审计。可以通过强制把管理中心的查询请求作为区块链中的交易执行，会导致性能下降，但提升了安全性。 方案中管理中心需要找到最近的区块链节点以及管理者需要找到智能合约地址，这两件事中都必须保证地址的可靠。 物联网设备在系统中注册，恶意的管理中心可以声称有其控制权，所以物联网设备必须验证自己的注册信息在注册信息被区块链接受前。一个物联网设备也可能冒充另一个物联网设备，也就是欺骗，但这种情况由于使用了安全的DTLS而被阻止。 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:5:0","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"5. 总结 提出了一个可扩展性比较高的基于区块链的方案，用于物联网设备的访问控制，该方案将设备和区块链网络分离以提供高扩展性，但同时也失去了区块链的安全特性。其最大优点就是能适用于更广泛的物联网场景。 ","date":"2018-12-28","objectID":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/:6:0","tags":["论文笔记"],"title":"Blockchain Meets IoT：An Architecture for Scalable Access Management in IoT","uri":"/2018/blockchain-meets-iotan-architecture-for-scalable-access-management-in-iot/"},{"categories":["研究生的区块链学习之路"],"content":"Author：Barco You, Matthias Hub, Mengzhe You, Bo Xu, Mingzhi Yu and Ican Uemlianin Published in：eprint arXiv:1809.06551(1809意为18年9月) SCI期刊分区：在arXic上，不算正式发表 keywords：IIoT, BC, Artificial Intelligence, Industry 4.0, Intelligent Manufacturing, Edge Computing. 主题：如何为IIoT构建一个全球范围的分布式工业网络 主要工作： 综述。从工业互联网讲到工业物联网，最后讲到基于区块链的工业物联网 详细描述了所构建的基于区块链的智能工业网络DSDIN的各部分组成 介绍了一些可以高效的运行在DSDIN上的应用 介绍了维持整个体系健康运行的激励机制 Abstract：过去由于技术限制，制造业是“中央集权”的，工厂（特别是大型制造商）垄断了几乎所有的制造资源，包括：技术，原材料，设备，工人，市场信息等。但是，这种集中生产成本高、效率低并且不灵活，难以应对快速变化，多样化和个性化的用户需求。本文介绍了一个智能工业网络（DSDIN），它提供了一个完全分布式的制造网络，每个人都可以参与制造，因为权力下放而没有中间环节，人们能够快速获得他们想要的产品或服务，获得授权并通过努力（例如提供创意，设计或设备，原材料等）以一种低成本的方式获得回报。DSDIN实际上是一个平台，由DSDIN形成的智能网络，制造中心不再是工厂，实际上没有制造中心。DSDIN为人和物（包括原材料，设备，成品/半成品等）提供多参与的点对点网络。通过网络传输的信息称为智能服务算法（ISA）。用户可以通过ISA将过程模型，公式或控制参数发送到设备，DSDIN中的每个事务都是由ISA定义的智能服务。 注：要构建一个全球范围的分布式工业网络，做的是基于区块链技术的工业物联网平台，和以太坊很相似，从文中也可以看到，大量借鉴了以太坊的思路，但是根据工业物联网的特性做了调整。 ","date":"2018-12-14","objectID":"/2018/block-chain-based-intelligent-industrial-network-dsdin/:0:0","tags":["论文笔记"],"title":"Block Chain based Intelligent Industrial Network (DSDIN)","uri":"/2018/block-chain-based-intelligent-industrial-network-dsdin/"},{"categories":["研究生的区块链学习之路"],"content":"1. 问题背景 工业互联网是为需要数字化、网络化和智能化的制造业设计的，它构建了一个基于海量数据收集，聚合，分析和服务系统的平台，支持无处不在的连接，灵活的供应和制造资源的高效配置。其核心要素包括数据收集系统，工业PaaS和应用服务系统。 什么是IaaS, PaaS和SaaS及其区别 数据采集系统：通过传感器，工业控制系统，物联网技术和智能网关等技术收集设备、系统、产品等数据。 工业PaaS：该平台将云计算，大数据和在实际工业生产中积累的经验相结合，形成基本的工业数据分析能力；技术、知识、经验和其他资源被物化为可移植和可重复使用的软件工具和开发工具，如特殊软件库，应用程序模型库和专家知识库，以构建开放和共享的开发环境。 应用服务系统：专为资产管理优化，工艺流程优化，制造协作和资源共享等工业需求而设计，为用户提供智能应用和解决方案。 工业互联网平台的重要作用 它可以发挥互联网平台的集聚效应。工业互联网平台是数据的载体，涉及数亿个设备，系统，工艺参数，软件工具，企业业务需求和工业资源共享的制造能力。它在网络，协同和优化方面发挥着关键作用，并形成了一系列新的互联网商业模式，包括基于制造业的众包和创意空间，协同制造和智能服务。 它在工业操作系统中起着关键作用。一方面，工业互联网平台与众多设备相连，是工业经验和知识模型的载体;另一方面，它与工业优化应用相关联，在连接所有工业元素和分配工业资源方面发挥关键作用，有助于发展先进的智能制造系统 它可以充分发挥云计算以及边缘计算的作用。由于先进的架构和高性能的云计算和边缘计算基础设施，工业互联网平台可以实现海量异构数据的集成、存储和计算，为需要处理的工业数据爆发式增长与现有数据之间的矛盾提供解决方案。系统在计算能力方面的劣势，加速数据驱动的网络化和智能化进程 许多制造公司已经开始为客户提供服务，并试图增加服务在总收入中的比例，但大多数仍然为客户提供基于其产品的传统服务，如售后服务，产品租赁，购买产品等。这些传统服务价值有限，往往无法满足客户的需求。因此，企业很难通过提供传统服务来实现服务转型。然而，物联网（IoT）的出现为企业争取服务转型带来了新的机遇。如上所述，工业4.0带来的变化都是数据驱动的。物联网通过各种传感器从物理世界获取数据，然后分析和使用这些数据，帮助企业优化生产流程，提高运营效率。另外，在物联网的帮助下，企业可以充分了解客户的需求，并创建新的服务模式以促进其业务增长，这是企业物联网的最大价值。 企业可以使用物联网生成的数据为客户提供实时和个性化的智能服务。这些服务与传统的售后服务不同，因为通过物联网收集的数据可用于以实时和可持续的方式预测客户的需求，系统将根据分析结果自动优化和调整服务，甚至可以自动适应环境，独立决策，为客户带来高度个性化的体验。 例如，设备制造商可以通过设备中安装的传感器预测客户设备的某些部件需要更换，并预先将备件运送到客户附近的仓库，这可以大大缩短客户等待更换的时间，减少停机造成的损失;而另一方面，客户无需囤积大量备件，占用资金和仓库;这种方法还可以降低客户从其他品牌购买备件的可能性，并增加制造商的收入。 企业还可以通过物联网创建新的服务模型，例如共享自己的制造能力和为其他企业提供生产服务。通过这种方式，每个人都可以成为制造业中的主要角色，可以根据客户的需求提供定制服务;还可以根据物联网中的数据为他们提供融资和保险服务。这些行业的龙头企业可以选择构建基于物联网的平台，成为行业生态系统的中心。物联网为制造业带来价值创造的新机遇需要与不同行业和其他新兴技术想结合，包括数据分析，人工智能和区块链，以形成真正的智能服务和创造实际的价值。 工业4.0的关键是原材料（物质）的信息化，即将所谓的物理世界与网络空间结合起来，形成真正的网络物理系统（CPS）。具体而言，工厂购买的原材料和成品/半成品被“贴上标签”，例如：这是给客户A的由××材料制成的基于××技术的××产品。换句话说，“原材料“包含的信息被智能工厂用于使”物质流“转变为”信息流“。材料及其生产和加工通过物联网实现了价值传递。 克服上述挑战，抓住发展机遇，不仅仅取决于企业能力和内部资源。首先，如果不与不同的行业和新兴技术（如数据分析，人工智能，区块链，云计算和雾计算）结合，那么通过物联网收集的数据毫无意义。只有这样的组合才能带来创新的服务。此外，由于智能服务具有众多的应用场景并具有实时和动态的开发特性，因此企业只依靠自己的资源无法满足客户的需求。由于智能服务需求的不确定性和投资回报的不确定性，企业应与其他公司合作分担这些风险。因此，要开发智能服务，企业应与相关外部合作伙伴紧密合作，形成价值创造网络。我们称这个价值创造网络为“基于区块链的智能工业网络（DSDIN）” 区块链技术目前一些值得关注的进展有： 以太坊的智能合约 分布式域名服务（DNS）系统 版权证明 关于oracle和在区块链上建立市场没懂他指的是哪个应用，不过这里他说的oracle不是oracle数据库 基于分布式计算技术-Erlang ，DSDIN将物联网与区块链技术完全结合，构建了一个相互信任的网络。 注：Erlang真的是它这个架构的底层技术，从第三部分开始频繁提到这个，可惜没了解过，只知道是一种比较适合分布式的编程语言 ","date":"2018-12-14","objectID":"/2018/block-chain-based-intelligent-industrial-network-dsdin/:0:1","tags":["论文笔记"],"title":"Block Chain based Intelligent Industrial Network (DSDIN)","uri":"/2018/block-chain-based-intelligent-industrial-network-dsdin/"},{"categories":["研究生的区块链学习之路"],"content":"2. DSDIN的各部分详述 A. DSDIN Blockchain DSDIN网络由公共区块链和无数独立状态机（也称为虫洞）组成。虫洞围绕区块链并产生大量状态通道，如图1所示。在DSDIN的区块链设计中，我们认为没有必要在区块链中维持状态。我们只需要将状态信息存储在虫洞中，并使用区块链来处理任何信息交换的经济后果，包括汇款，采矿等，以及争议的后备情况。因此，在DSDIN网络中，我们提出了另一种区块链架构，将Turing的完整智能合约放在虫洞上，而不是区块链。这增加了系统的可扩展性和事务的吞吐量，因为虫洞是独立的状态机（基于DSDIN VM的单个进程或进程树），使得所有事务变得独立并且能够并行处理。另外，这也意味着合同没有写入共享状态，大大简化了测试和验证。同时，这将经济逻辑与数据存储分开，使我们能够利用良好的分布式存储方案来补充区块链，从而提高物理世界中数据存储的效率，隐私和安全性。 DSDIN类似于以太网，它基于脚本，竞争硬币和链式元协议以及用于集成和增强的状态通道，使开发人员能够创建易于开发的任意基于共识，可扩展，标准化和全功能的协作。能够与真实世界的数据应用程序连接。通过使用图灵完整的编程语言建立最终和抽象的基础层和虫洞，DSDIN使任何人都可以创建合同和分散应用程序，并建立自由定义的所有权规则，交易方法和状态转换功能。智能合约也可以在虫洞上创建和执行，并且由于图灵完整性，价值意识，区块链意识和多状态协作，这些合同比以太坊提供的合同更强大。 下图是DSDIN中的区块链和虫洞。虫洞通过消息传递相互通信，只有与虫洞中发生的事务有关的信息才会存储到块上。 B. Block DSDIN区块链里，每个区块包含以下内容 前一个区块的哈希值 交易Merkle树 账户Merkle树 naming system的Merkle树 wormholes的Merkle树 oracles尚未提供的答案的Merkle树 由oracles提供的答案的Merkle树 Merkle证明的Merkle树 随机数生成器的熵（Entropy of random number generator） 树的改变必然是由新块中的交易引起的，同时Merkle证明树也必须更新 C. 共识机制 共识机制使用PoW和PoS。 块的顺序取决于PoW。但这里用的PoW机制是Tromp’s Cuckoo Cycle，这是一种基于图论的有内存限制的间接PoW机制，能耗更少。正如Tromp所描述的：Cuckoo Cycle是一种有内存限制，可即时认证的PoW机制；它的独特之处在于它依赖于内存延迟，而不是计算来实现PoW 。因此，基于Cuckoo Cycle的挖掘可以是ASIC挖掘，DRAM仅用作字节读出和写入的支持。即使是智能手机也可用于采矿，对采矿效率没有影响。 注：这种PoW方法引自 “J. Tromp, “Cuckoo Cycle: A Memory Bound Graph-Theoretic Proof-of-Work,” In: Brenner M., Christin N., Johnson B., Rohloff K. (eds) Financial Cryptography and Data Security.FC 2015. Lecture Notes in Computer Science, vol 8976. Springer, Berlin, Heidelberg.” DSDIN中的共识机制不是必须的，用于新块的添加和回答oracles提出的问题并定义系统参数，这有助于系统适应环境变化和新技术的发展。此外，共识机制也可以自我修改和更新。如果PoW机制过于简单，矿工很容易赢得oracle，因此DSDIN将采用PoW和PoS结合的创新算法来充分发挥自己的优势。同时，PoW将用于发布新的DSD Tokens。 一些基于以太坊的应用程序（如Augur）尝试使用区块链来分布的存储真实数据。他们使用智能合约建立共识机制，而不是直接使用区块链中的共识机制，这导致效率低但数据安全性没有增强。为了提高效率，我们需要建立一个共识机制，不仅提供有关网络状态的信息，还提供有关外部世界的状态信息。这种共识机制有助于我们获得真正的oracle，并可以回答程序可能无法回答的问题，例如：我生产的第100个产品对客户来说是最令人满意的产品吗？ D. Wormhole DSDIN中的wormholes是启用状态通道的载体，用于确保只有交易中的相关实体才能访问有关交易的信息和数据。本质上，交易的参与者将一些状态实例化到区块链上，例如以太坊合约和比特币多签名，然后他们只需要将更新的签名发送给对方。重要的是，每个参与者都可以使用此类信息来更新区块链的状态，但在大多数情况下他们不会这样做。这允许交易以与信息传播相同的速度实现，而无需等待事务被验证并最终由区块链的共识机制确认。 在DSDIN中，只有DSD Token状态能在区块链上传输，并且只能传输任何交易方在虫洞中存储的DSD Token。这要求每个虫洞彼此独立，以便并行处理每个交易中的事务，从而大大提高了事务吞吐量。区块链仅用于最终清算和冲突解决。由于区块链的行为是可预测的，因此关于运行虫洞的结果的争议不会带来任何好处，因此鼓励恶意参与者正确行动并且区块链用于最终解决。所有这些措施都可以提高交易的速度和规模，同时也可以提高隐私 每个虫洞都是独立的虚拟机（DSDIN VM），它通过状态通道实现智能合约，ISA和实际交易，最终将交易信息记录在区块链上。每个虫洞类似于计算机中的进程，保护其自身的状态数据，包括：运行期间生成的数据，数据库中的数据以及通过接口（如HTTP，TCP，电子邮件，串行端口等）获取的数据。wormholes通过消息传递(Message-Passing)相互交换信息但不共享数据以保持其独立性，类似于标准的Actor-Model program 。这允许整个系统和ISA中的交易实现高吞吐量运行并且还保证私有虫洞数据的安全性。 每个虫洞对应一个过程树。如下图所示，虫洞由Supervisors和Workers组成。每个工作执行独立的分布式计算，例如使状态通道能够管理现实数据（例如通过数据库读取数据或与CNC机器通信等）并与其他虫洞交换信息。Supervisors生成Workers，当Workers失败时，Supervisors可以根据某些策略重新启动Workers E. 智能合约 虽然只有DSD Token的状态传输能在区块链上更新，但DSDIN仍然运行图灵完备的智能合约虚拟机（DSDIN VM），合约定义了DSDIN中的资金分配规则。与以太坊的physical contract不同，只有参与者被告知合约的存在;另一方面，只有那些在wormhole上拥有公共状态通道的参与者才能创建合法合约。如果参与者同意合约，合约将被签名并永久保存。只有在发生争议的情况下合约才会被提交给区块链，在这种情况下，只有部分包含有关提交的交易信息的代码将被提交，区块链将根据合约分发Token并关闭虫洞上的状态通道 更重要的是，在DSDIN中，合约不包含自己的状态，因此任何状态都由交易的参与者维护，并且这些状态将在合约执行时作为输入参数提交。每个合约实际上都是一个纯函数，充分利用函数式编程的思想，获取输入参数并输出新的通道状态。 在DSDIN网络中，合约定量执行的方法类似于以太坊的“gas”。但是，我们用两种不同的资源来衡量：一种是时间，另一种是空间。他们都要求合约执行的参与者用DSD Token付款。例如，如果Alice和Bob想要与DSDIN网络上的虫洞进行交易，则需要执行以下步骤： Alice和Bob分别对合约签名，而不是指定虫洞中存放的代币的数量并发布到区块链. 一旦区块链打开此通道，他们都可以创建新的通道状态并相互发送和签名。 通道状态可以是新的资金分配，也可以是与新分配相关的合约。每个通道状态都有一个增量的随机数，并由双方签名。如果发生争议，最新的有效状态将最终提交给区块链以强制执行。 通道可以通过两种方式关闭：a）如果Alice和Bob决定完成交易并同意其最终账户余额状态，他们应签署交易并将其提交给区块链。因此，通道关闭，通道上的资金相应重新分配;b）如果Alice因任何原因拒绝签署或想要关闭交易，Bob可以提交他们同意的最后状态并签署区块链并要求关闭此状态的通道。这将触发倒计时。如果Alice认为Bob不诚实，她将有机会在倒计时结束前释放他们两人签署的更大的nonce。如果Alice执行此操作，通道将立即关闭，否则在倒计时结束前不会关闭。 F. 交易 DSDIN中的交易通过智能合约实施，过程如下： 检查交易格式是否正确（即具有正确的值），签名是否有效，以及随机数是否与发送者帐户的随机数匹配。如果不是，则会返回错误. 发送者存入存款. 计算交易费用：费用=Gas* GasPrice;并从签名中确定发送者的地址。从发送者的存款中扣除交易费用并增加发送者的随机数。如果存款余额不足，将返回错误. 将发送者帐户的钱转移到收件人的帐户。如果接收帐户尚不存在，请创建此帐户。如果接收帐户是合约，则运行合约代码，直到代码运行结束或gas用完为止. 如果由于发送方保存的存款不足或代码执行期间耗尽气体而导致价值转移失败，则原始状态将被恢复。但是，交易费也是必需的，并且交易费被添加到矿工账户. 否则，所有剩余的gas将被退回给发送方，并且消耗的gas将作为交易费发送给矿工 如果没有合约接受交易，则所有交易成本等于GasPrice乘以交易的字节长度，并且交易数据独立于交易成本。此外，应该注意的是，合约","date":"2018-12-14","objectID":"/2018/block-chain-based-intelligent-industrial-network-dsdin/:0:2","tags":["论文笔记"],"title":"Block Chain based Intelligent Industrial Network (DSDIN)","uri":"/2018/block-chain-based-intelligent-industrial-network-dsdin/"},{"categories":["研究生的区块链学习之路"],"content":"3. 应用 Wormhole application 在DSDIN中，虫洞是为高吞吐量和高并发性提供事务和微服务应用程序的环境。虫洞提供的基本应用包括： 服务API 众筹 跨链代币交换（和侧链做的事一样） 博彩 预测 Intelligent Service Algorithm (ISA) 简单举个栗子说明 例如，用户将产品模型提交给远程3D打印机，打印机根据ISA中的模型参数和约束自动打印满足用户需求的固定数量的产品，并将产品交付给用户。在此交互中，用户首先使用ISA生成器编辑ISA，并封装产品3D模型，材料约束，生产时间约束以及良率和设备控制逻辑。然后，用户基于状态通道启动事务，当前虫洞与另一个通过消息传递机制运行3D打印机控制服务的虫洞一起执行ISA以实现产品打印。当打印完成时，状态通道关闭，交易的经济结果记录在区块链上 ISA Zone 开心的跳过这部分 基于Wormhole的设备服务管理 用于ISA交易的DSDIN涉及的设备主要包括生产线，机床，能耗设备，工业个人计算机和传感器，3D打印机等，这些设备还实时生成物联网数据，存储在虫洞管理的分布式存储系统中。基于物联网数据的时间序列性质，我们可以将大多数预测或检测问题抽象为半马尔可夫决策过程。后面是这个过程详述。 这部分思路可移植用在制造工厂资产管理的案例中。 ","date":"2018-12-14","objectID":"/2018/block-chain-based-intelligent-industrial-network-dsdin/:0:3","tags":["论文笔记"],"title":"Block Chain based Intelligent Industrial Network (DSDIN)","uri":"/2018/block-chain-based-intelligent-industrial-network-dsdin/"},{"categories":["研究生的区块链学习之路"],"content":"4. 激励机制 DSDIN已经建立了一个ISA平台的特殊生态奖励基金，它使用DSDIN自己的代币（DSD）作为唯一的奖励方法。该平台采用独特的POV（价值证明Proof of Value）+ POC（贡献证明Proof of Contribution）算法来建立双重奖励机制，用于奖励有助于构建ISA社区的参与者奖励池系统执行每72小时进行一次激励分配计算，并根据计算结果自动将奖励代币分配给参与者的个人钱包。后面具体的介绍包括 奖励池 AZ奖励分配—价值证明 用户奖励分配—贡献证明 ","date":"2018-12-14","objectID":"/2018/block-chain-based-intelligent-industrial-network-dsdin/:0:4","tags":["论文笔记"],"title":"Block Chain based Intelligent Industrial Network (DSDIN)","uri":"/2018/block-chain-based-intelligent-industrial-network-dsdin/"},{"categories":["研究生的区块链学习之路"],"content":"5. 总结 这篇文章介绍了如何为IIoT构建一个全球范围的分布式工业网络，并展示了如何通过该网络传输价值，实现作为工业4.0基础的智能服务。特别是第III部分中介绍的应用程序易于构建，可以高效地工作在DSDIN上。第四部分介绍的激励机制将创造一个健康和有前途的价值创造生态系统，鼓励参与者贡献并形成一个积极的反馈网络，有效地传递价值 ","date":"2018-12-14","objectID":"/2018/block-chain-based-intelligent-industrial-network-dsdin/:0:5","tags":["论文笔记"],"title":"Block Chain based Intelligent Industrial Network (DSDIN)","uri":"/2018/block-chain-based-intelligent-industrial-network-dsdin/"},{"categories":["研究生的区块链学习之路"],"content":"主题：用联盟链解决工业物联网的能量交易问题 主要工作： 针对工业物联网(IIoT)里能量交易的安全与隐私问题，提出能量区块链(energy blockchain) 为了减少由交易确认的延迟造成的交易限制，提出一个基于信用的支付方案，以支持快速和频繁的能源限制 在体系里构建了一个能量银行，并使用Stackelberg 博弈进行基于信用贷款的最优定价 对能量区块链解决的安全问题，能量区块链的性能，基于信用的支付方案的性能做分析 ","date":"2018-12-13","objectID":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/:0:0","tags":["论文笔记"],"title":"Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things","uri":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"1. 问题背景 满足IIoT不断增长的能源需求是一个挑战，而且IIoT节点的数量和性能需求不断增长。之前的研究已经提到IIoT节点可以以P2P方式与其他节点交换其剩余能量，从而达到能量的供需平衡。结合energy harvesting, wireless power transfer, and vehicle-to-grid等技术，IIoT目前有三种典型的能量交易场景。 Microgrids：具有太阳能电池板或风力发电机的智能建筑物可形成微电网，其中建筑物在微电网中以P2P方式收集环境能量并相互交换能量。 Energy harvesting networks：具有能量收集能力的工业节点可以从可再生能源获得能量，也可以使用P2P的能量交易方式通过移动充电桩进行无线充电。 Vehicle-to-grid networks：电动车辆在电网负载小时充当能量存储设备，在负载高时把能量送回电网。也可以以P2P的方式把能量出售给邻近的需要充电的电动车辆。 现在面临的安全与隐私问题： IIoT节点在不可信和不透明的能源市场中进行大规模分散能源交易是不安全的。 具有剩余能量的IIoT节点由于担心隐私而可能不愿意作为能源卖家参与。在这种情况下，IIoT节点之间的能量供需是不平衡的。 在P2P能源交易中，有一个中介来审核和验证IIoT节点之间的交易记录。 这篇文章用了联盟链来解决这些问题，提出了自己的方案，主要的工作如文章开头所述。联盟链的突出特征是区块链中存在有特殊权限的超级节点来维持链。下面分别介绍几个主要工作。 ","date":"2018-12-13","objectID":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/:0:1","tags":["论文笔记"],"title":"Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things","uri":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Energy blockchain 针对上面提到的三种典型的能量交易场景，提出一个通用的成本可接受的能量区块链。 通用的P2P能量交易框架 首先抽象三个场景得到一些实体： Energy nodes：IIoT节点（例如，智能建筑，工业传感器和电动车辆）在P2P能源交易中扮演不同的角色：能源购买者，售卖者和闲置节点（不买也不卖）。每个节点根据能源状态和未来的工作计划选择自己的角色。 Energy aggregators：EAG作为能源中间人来管理与能源交易相关的事件，并为IIoT节点提供无线通信服务。在不同的能源交易场景中，EAG对应于不同的物理实体。例如，微电网中的高级计量基础设施、能量收集网络中具有计算和存储能力的enhanced-based station。vehicle-to-grids中的local aggregators。 下图展示了EAG中的四个实体：交易服务器(transaction)，信用银行(credit bank)，账户池(account pool)，存储池(memory pool)。交易服务器从能量节点收集能量请求，并匹配能量交易。这里使用能量币(energe coin)来作为加密数字货币流通。每个能源节点都有一个能量币账户来存储个人交易记录。有一个相应的钱包来管理这个帐户中的个人能量币。用公钥作钱包地址，所有钱包和相应的钱包地址与能量币账户之间的映射关系存储在本地账户池中。EAG中的帐户池记录和管理能量节点的个人钱包地址中的能量币资金。内存池存储本地能量节点的所有交易记录。 Smart meters：每个IIoT节点中的内置智能电表可实时计算和记录交易能量。买家根据电表的记录向卖家支付费用。 区块链构建 传统区块链（文中指的应该是比特币区块链）是在所有节点间用高花费的PoW达成共识，这篇论文提出的energe blockchain由EAGs收集和管理交易记录，并只在它们中间达成共识，打包成块，然后存在存储池里。整个过程描述如下： 系统初始化 能源节点要在可信管理机构（比如政府）注册后才能成为链中合法实体，并得到它的公私钥，证书和一组钱包地址。管理机构生成包含ID和这四部分的五元组，存在账户池里。当节点执行系统初始化时，把它使用的钱包地址上传到最近的EAG的账户池，检查钱包的完整性，并从EAG中的存储池和信用银行下载它钱包的最新数据。存储池把所有交易记录存在能量区块链里，信用银行记录基于信用的支付。 选择自己在能量交易中的角色 节点根据自己当前的能量状态和未来的工作计划选择作为能量的卖家还是买家 交易能量 买家发出的包含需要的能量数目的请求发到邻近EAG的交易服务器，交易服务器计算总的能量需求并把这些需求广播给卖家，同时，EAG作为能量交易的中介，会根据当前交易环境设定能量价格，刺激卖家的参与。卖家确定它们要卖的能量数目然后响应交易服务器，之后交易服务器匹配供需，最后通过电线或无线电力传输完成能量从卖家到买家的传递。 能量币支付 就是能量币在买卖双方钱包地址中的转移，能量币不够的买家可以根据它的信用从信用银行借能量币。买家生成交易记录，由卖家进行验证和签名。最后交易上传到EAG并达成共识上链。一笔交易完成后，买卖双方的信用值都会增加。 生成块并上链 过程和比特币差不多，仍然是通过包含前一个块的哈希成链，通过PoW做工作量证明，所有EAG验证里面交易的合法性和工作量，只是参与者只有EAGs。 这里唯一不同的是共识是在EAG之间达成的，所以比传统区块链块，当交易数量增加时，也可以很容易扩展其计算力和存储资源。无论这个P2P网络规模多大，当EAGs的数量固定时，达成共识的时间也是固定的。 ","date":"2018-12-13","objectID":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/:0:2","tags":["论文笔记"],"title":"Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things","uri":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"2. 基于信用的支付系统 参与共识的只有EAGs，相比于传统区块链交易确认时间有了很大提高，但频繁的能量交易过程中，很可能能量节点想交易没能量币，所以这里面设立了能量银行机制。能量银行有足够的能量币，可以根据信用给能量节点贷款，信用的提升或降低是根据节点完成交易的行为确定的。而且，这里的贷款也不是直接把能量币打到贷款者的账户，而是开了一个贷款者和能量银行都能控制的共享账户。 ","date":"2018-12-13","objectID":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/:0:3","tags":["论文笔记"],"title":"Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things","uri":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"3. 基于信用的支付系统的最优定价策略 用的是博弈论的思想，没有细看，话说这个和之前Dusit Niyato那篇“Edge Computing Resource Management and Pricing for Mobile Blockchain\"挺像的，都是利用博弈论思想做定价分析，只不过这篇是节点从设立的能量币银行借能量币，那篇是资源有限的节点从主机或基站借算力。 ","date":"2018-12-13","objectID":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/:0:4","tags":["论文笔记"],"title":"Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things","uri":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"4. 安全和性能分析 三方面，能量区块链解决的安全问题，能量区块链的性能，基于信用的支付方案的分析 能量区块链的安全分析 其实没什么新意，就是区块链技术相对于常规技术能解决的普遍的安全问题 去除可信中介 钱包安全和交易验证 数据不可篡改 没有双花问题 能量区块链的性能分析 由于参与共识的节点数量大大减少，交易的确认时间得到缩短。能量节点在没有能量币的情况下能从能量银行借贷，从而增加了单位时间的交易量，不至于因为没钱造成等待，从而抵消好不容易缩短的交易延迟。一句话，这个方案能支持快速和频繁的能量交易 基于信用的支付方案性能分析 最后的结果是这个方案对IIoT的能量交易时有效且高效的，并且能达到最大的经济效益 ","date":"2018-12-13","objectID":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/:0:5","tags":["论文笔记"],"title":"Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things","uri":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"5. 总结 三个能量交易场景，一个能量区块链，一种基于信用的支付方案，一个基于Stackberg博弈的最优定价策略。 最后是安全性和性能分析。 ","date":"2018-12-13","objectID":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/:0:6","tags":["论文笔记"],"title":"Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things","uri":"/2018/consortium-blockchain-for-secure-energy-trading-in-industrial-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"1. 基本知识 基本知识需要了解两部分 第一部分是以太坊版本演进过程：白皮书——\u003e黄皮书——\u003eFrontier版本——\u003eHomestead版本——\u003eMetropolis版本——\u003eSerenity版本，目前处于Metropolis版本，也就是大都会，更多内容参考 以太坊发布过程。 另一部分是基本的概念，下面是以太坊中国社区有人整理的 Vitalik Buterin（以太坊创始人）在Ethereum Devcon3（以太坊第三次开发者大会）上的演讲《Ethereum in 25 minutes, vision 2017》，基本上对以太坊做了一个全面的描述。 Vitalik: 25分钟认识以太坊（上），Vitalik: 25分钟认识以太坊（下） ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:1:0","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"2. 工具 以太坊钱包 mist 是以太坊基金会主推的项目，目前处于测试阶段，开源，所有人都可以贡献代码。可以离线管理账户，包括账户的创建、备份、导入、更新等，现在最重要的功能是进行以太币的交易，但其实它定位不只是一个钱包，而是将来Dapp的市场，类似于安卓的应用商店，在这里可以有你的账号，可以浏览、发布和买卖以太坊的Dapp应用。目前因为开发还不够全面，名称暂时显示为 Ethereum-Wallet。 下载地址（需要科学上网）：Releases 刚打开的时候mist会同步全网信息，需要的时间可能久一点，同步完成后可以进行创建账户、设置密码和转账等操作。其界面如下： Remix 是一个基于浏览器的编译器和IDE，是用C++开发的，客户端不需要安装，能够使用Solidity语言构建以太坊合约并调试。界面如下： 以太坊客户端以编写语言分类，在github上分成了不同项目，下面进行介绍。目前最流行的应该是 Go 语言客户端 geth，star和fork的数量都远远超过其它客户端，项目介绍是「以太坊协议的官方 go 语言实现」，可以实现搭建私有链、挖矿、账户管理、部署智能合约、调用以太坊接口等常用功能。。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:2:0","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"3. 架构 以太坊整体架构如图 各层介绍如下 底层服务：底层服务包括P2P网络、LevelDB数据库、密码学算法和分片（Sharding）优化。LevelDB数据库是谷歌开发的一个轻量，高效的key-value数据库，在以太坊中用来存储区块、交易等数据。而分片则是为了解决以太坊，甚至所有公有区块链目前面临的低吞吐量和高延迟问题，因为问题的核心在网络中的节点需要处理所有的交易，分片就是将网络中的工作分摊给所有参与的节点。分片优化使得可以并行验证交易，加快了交易验证速度，从而加快了区块生成速度。 核心层：包括区块链、共识算法和以太坊虚拟机。区块链和共识算法是区块链平台的基础，以太坊虚拟机则是以太坊的主要特点，用来作为运行智能合约的载体。 顶层应用：包括API接口、智能合约和去中心化应用。以太坊的Dapp通过Web3.js与智能合约层进行信息交换，所有的智能合约都运行在EVM上，并会用到RPC的调用。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:3:0","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"4. 区块 以太坊使用了比特币区块链的技术，但做了一些调整，区块由 区块头、交易列表 和 叔区块头 三部分组成。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:4:0","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 区块头 区块头包含下列信息： 父块的散列值（Prev Hash） 叔区块的散列值（Uncles Hash） 状态树根散列值（stateRoot） 交易树根散列值（Transaction Root） 收据树根散列值（Receipt Root） 时间戳（Timestamp） 随机数（Nonce） 以太坊的一个创新是保存了三棵Merkle树根，分别是状态树、交易树和收据树。存储三棵树可方便账户做更多查询。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:4:1","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 交易列表 和比特币区块链相同 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:4:2","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"4.3 叔区块头 叔区块是父区块的父区块的子区块，但不是自个的父区块，或更一般的说是祖先的子区块，但不是自己的祖先。当矿工打包的时候发现有这样的块存在，就把它打包进去，称为叔块。如图，黄色的101是一个叔块 叔块概念与出块时间有关。比特币平均出块时间间隔为10分钟，出现叔块的情况概率比较小，当时中本聪设定的这种情况的叔块是做无用功，不会有任何奖励。但是以太坊为了缩短出块时间到10s出头，那么叔块产生的概率就比较高了，如果类似比特币的设计，会有很多矿工因为生产了叔块而获取不到任何奖励，矿工的积极性会降低，不利于以太坊生态发展，所以V神引入了叔块的概念，这种情况下矿工打包叔块进区块，叔块生产者和打包叔块的矿工都会有一定的奖励。 一篇介绍见Toward a 12-second Block Time ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:4:3","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"5. 账户 以太坊中有两种类型的账户 外部账户（Externally Owned Accounts） 合约账户（Contracts Accounts） 外部账户是由外部角色拥有的账户，一个外部账户： 有一个以太币余额 可以发送交易（以太币的转移或触发合约代码） 由一个私钥所控制 没有关联代码 合约账户，顾名思义，是合约的账户，它 有一个以太币余额 有关联代码 由交易或从其他合约收到的消息所触发执行 代码执行 可以处理任意复杂度的操作（图灵完备） 可以操作它自己的持久化存储，比如可以有它自己的永久状态 可以调用其他合约 以太坊区块链上的所有动作，都被设定为由外部账户所发出的交易所触发。每当合约账户接收到交易，它的代码会根据作为交易的一部分传入的参数来具体执行。将在网络中每个节点上的以太坊虚拟机中被执行，并被作为它们对新区块的验证结果的一部分。 账户的地址由公钥得到，而公钥由私钥得到，所以私钥文件是最重要的，也是需要保存的唯一文件。目前常见的私钥有三种形态：Private key、Keystore\u0026Password 以及 Memonic code。 Private key就是一份随机生成的256位二进制数字，用户甚至可以用纸笔来随机地生成一个私钥，即随机写下一串256位的仅包含“0”或“1”的字符串。该256位二进制数字就是私钥最初始的状态。 而在以太坊官方钱包[插图]中，私钥和公钥将会以加密的方式保存一份JSON文件，存储在keystore子目录下。这份JSON文件就是Keystore，所以用户需要同时备份Keystore和对应的Password（创建钱包时设置的密码）。 最后一种Memonic code是由BIP 39方案提出的，目的是随机生成12～24个比较容易记住的单词，该单词序列通过PBKDF2与HMAC-SHA512函数创建出随机种子，该种子通过BIP-0032提案的方式生成确定性钱包。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:5:0","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"6. 共识机制 以太坊中专门设计的PoW算法称为Ethash。 但以太坊的目标是转换到PoS。PoS即基于网络参与者目前持有的数字货币的数量和时间进行利益分配。在以太坊中，PoS算法可以这样描述：以太坊区块链由一组验证者决定，任何持有以太币的用户都能发起一笔特殊形式的交易，将他们的以太币锁定在一个存储中，从而使自己成为验证者，然后通过一个当前的验证者都能参与的共识算法，完成新区块的产生和验证过程。 有许多共识算法和方式对验证者进行奖励，以此来激励以太坊用户支持PoS。从算法的角度来说，主要有两种类型：基于链的PoS和BFT（Byzantine Fault Tolerant，拜占庭容错）风格的PoS。 在基于链的PoS中，该算法在每个时隙内伪随机地从验证者集合中选择一个验证者（比如，设置每10s一个周期，每个周期都是一个时隙），给予验证者创建新区块的权利，但是验证者要确保该块指向最多的块（指向的上一个块通常是最长链的最后一个块）。因此，随着时间的推移，大多数的块都收敛到一条链上。 在BFT风格的PoS中，分配给验证者相对的权利，让他们有权提出块并且给被提出的块投票，从而决定哪个块是新块，并在每一轮选出一个新块加入区块链。在每一轮中，每一个验证者都为某一特定的块进行“投票”，最后所有在线和诚实的验证者都将“商量”被给定的块是否可以添加到区块链中，并且意见不能改变。 许多早先的PoS算法中，生产区块只会产生奖励而不会惩罚。但这样会出现无利害关系问题。该问题有两种解决方案。见 共识算法的比较：Casper vs Tendermint 同时，其中的Casper正是现在以太坊的共识算法，这是以太坊转向PoS的过渡。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:6:0","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"7. Merkle Patricia Tree 简称MPT，是Merkle Tree和Patricia Tree的结合，下面的介绍转自CSDN。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:7:0","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"Merkle Tree 区块链 P2P 网络中，如果需要传输的数据很大，就需要同时从多个机器上下载数据，而且很可能有些机器是不稳定 (可能下载速度很慢) 或者不可信的(需要重新下载)。为了大块数据并验证，更好的办法是把大文件分割成小的数据块（例如把大文件分割成 4K 为单位的小数据块）。这样的好处是如果小块数据在传输过程中损坏了或者是错误的数据，那么只要重新下载这一块数据就行了，不用重新下载整个文件。 由于只有大文件内容的 hash, 当其中一块小数据错误时，我们是能检出由小块数据拼凑出来的大数据是错误的，但是我们不知道哪块小数据是错误的，就没法通过重传错误的小数据来纠正。哪怎么处理呢？为每个小块生成 hash, 节点先把小块数据的 hash 都下载下来，然后就可以验证一个一个验证小块数据是否正确了。那问题又来了，小块数据的 hash 的正确性谁来保证呢？信任节点，比如 BT 论坛上的 bt 种子文件，这个种子文件就记录了原始文件的小块数据的 hash. 验证问题解决了，但是多出来了小块数据 hash，当块数据很大时，这个数据量也不小。因而 Merkle Tree 出来了，它就是用来解决这个问题的。  小块数据的 hash 两两组合再次生成新的 hash, 然后新生成的 hash 又两两合并生成更新的 hash, 直至最后两个 hash 生成一个 hash root, 这个叫 merkle root(默克尔根)。可见 merkle tree 和传统 bt 分片技术只是对小块数据 hash 的组织方式不一样。 看到上面的图，你可能会说，merkle tree 不是生成更多 hash 数据了啊，怎么能降低数据传输量。确实，对于数据发送方来说，相比传统分片技术，它是需要保存完整 merkle tree, 会多占用一点空间。但是对于接受方来说，它在验证某一块数据不需要下载全部 hash, 只需一段 merkle 路径即可，比如下图 如果要验证 slice2 数据的正确性，只需要拿到 hash1, h12, h02 这 3 个 hash 再加上本地存储的 root hash, 就可以验证了。需要传输的 hash 数据量从 n 变为 log2n. 总结，Merkle root(包含在区块头里) 是从可信渠道下载的 (主链或者可信节点)，接收到数据及这个数据对应的 Merkle 验证路径即可验证该数据的正确性。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:7:1","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"Patricia Tree patricia tree 前缀树，是一种编码方式, 它是传统 trie 的改进。 Trie 树 Trie，又称前缀树或字典树，是一种有序树状的数据结构，其中的键通常是字符串，常用语存储 Key-value 数据结构。 Trie 与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，节点对应的 key 是根节点到该节点路径上的所有节点 key 值前后拼接而成，节点的 value 值就是该 key 对应的值。根节点对应空字符串 key。 如果 key 是英文单词，trie 的每个节点就是一个长度为 27 的指针数组，index0-25 代表 a-z 字符，26 为标志域。  上面的存储的数据如下： [‘a’] = V1, [‘ab’] = V3, [‘b’] = V2, [‘ba’] = V4, [‘baa’] = V5, [‘zaab] = V6 从上面可以看出 zaab 这个 key, 没有和任何其他 key 共享字段，但是却产生了 6 层，这种无用的深度增加有什么方法减呢？Patricia Tree 就可以解决这个问题 Merkle Patricia Tree 对 trie 的改进 上面 tries 出现的问题的根本原因是每个前置节点只能表示一个字母，key 有多长，树的深度就会多长，不管这个 key 有没有和其他 key 共享部分 key。因而允许一个节点表示变长的 key 就可以解决这个深度，具体以官方的下图为例： 上图存储的 key-value 如下： 从前面结构图可以看出，Merkle Patricia Tree 有 4 种类型的节点： 叶子节点（leaf），表示为 [key,value] 的一个键值对。和前面的英文字母 key 不一样，这里的 key 都是 16 编码出来的字符串，每个字符只有 0-f 16 种，value 是 RLP 编码的数据 扩展节点（extension），也是 [key，value] 的一个键值对，但是这里的 value 是其他节点的 hash 值，通过 hash 链接到其他节点 分支节点（branch），因为 MPT 树中的 key 被编码成一种特殊的 16 进制的表示，再加上最后的 value，所以分支节点是一个长度为 17 的 list，前 16 个元素对应着 key 中的 16 个可能的十六进制字符，如果有一个 [key,value] 对在这个分支节点终止，最后一个元素代表一个值，即分支节点既可以搜索路径的终止也可以是路径的中间节点。分支节点的父亲必然是 extension node 空节点，代码中用 null 表示 原理解释 插入第一个 \u003ca711355, 45\u003e，由于只有一个 key, 直接用 leaf node 既可表示  接着插入 a77d337, 由于和 a711355 共享前缀’a7’, 因而可以创建’a7'扩展节点。 接着插入 a7f9365, 也是共享’a7’, 只需新增一个 leaf node. 最后插入 a77d397, 这个 key 和 a77d337 共享’a7’+’d3’, 因而再需要创建一个’d3’扩展节点 MPT 中的 Merkle Tree 哪去了 前面为了和官方图一致，将叶子节点和最后的 short node 合并到一个节点了，事实上源码实现需要再深一层，最后一层的叶子节点只有数据  MPT 节点有个 flag 字段, flag.hash 会保存该节点采用 merkle tree 类似算法生成的 hash, 同时会将 hash 和源数据以 \u003chash, node.rlprawdata\u003e 方式保存在 leveldb 数据库中。这样后面通过 hash 就可以反推出节点数据。具体结构如下 (蓝色的 hash 部分就是 flag.hash 字段) 这样一个结构的核心思想是：hash 可以还原出节点上的数据，这样只需要保存一个 root(hash)，即可还原出完整的树结构，同时还可以按需展开节点数据，比如如果只需要访问 \u003c a771355, 45 \u003e 这个数据，只需展开 h00, h10, h20, h30 这四个 hash 对应的节点 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:7:2","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"8. ENS ENS（Ethereum Name Service，以太坊域名服务）是建立在以太坊区块链上的分布式、开放的命名系统。在以太坊网络中，地址通常是一连串长而复杂的散列地址，比如用户的地址和智能合约的地址。在这种情况下，用户记住一个地址是十分困难的。为了方便用户，以太坊推出了可以将散列地址“翻译”成一个简短易记的地址的ENS命名服务。用户要是想执行合约或者账户转账，只要向ENS提供的“翻译”地址发起交易就可以了，不用再输入一连串的散列地址。从这方面来看，ENS很像我们平时所熟知的DNS服务。比如，A要给B转一笔钱，当A发起交易时，在收款人地址处不用再填写B的散列地址，填写B的简单易记的钱包域名（B.myetherwallet.eth）也能正常交易。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:8:0","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"ENS构成 ENS由三个主要构件组成，它们分别是注册表（registry）、解析器（resolver）和注册服务（registrar）。其中注册表是系统的核心不可变的部分，解析器最终由用户实现，注册服务是在ENS中拥有名称并根据规则分配子域的智能合约。ENS是以太坊基金会提供的去中心化应用，总的来说，ENS做了两件事：使用户注册支持智能合约运行的域名和利用底层设备标识符解析部分域名。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:8:1","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"域名获取 用户要想获得域名的所有权，主要通过竞拍的方式。ENS拍卖采用的是维克里拍卖（集邮者拍卖）方式，该方式也被称为第二密封拍卖，即所有买家通过密封投标的方式竞价，出价最高的投标者将获得被拍卖的商品，但支付第二高的出价即可。 用户注册一个域名需要完成以下过程。 1）用户通过交易执行智能合约，向合约提供自己想要注册的域名。 2）如果该域名已被注册，那么用户要么重新提交新域名，要么与已经注册该域名的人交易以获得该域名；如果该域名正在被竞拍，那么用户将参加竞标，向合约投入认为比其他竞标者更高的竞价金，然后等待竞价期结束；如果该域名没有被注册或竞拍，那么需要用户发起竞拍，向合约投入竞价金，等待竞价期结束。 3）竞拍过程中用户只有一次出价机会，且其竞价对其他用户来说是不可知的，用户并不知道与他竞争的用户的出价，所有人都支付自己愿意付出的最高价格作为竞价，因此即使用户出价很低，但是只要没人与他竞争，或者竞标价格都比他低，那么该用户也能得到域名的所有权。竞价保密是为了防止投机者在竞价即将结束时投入最高价，影响竞价的公平性。 4）竞价截止后进入揭标环节（向其他用户显示竞价），所有参加竞标的用户必须揭标，否则其竞价金的99.5%会进入黑洞（被销毁且无法找回）。 5）揭标之后，出价最高的用户获得竞标胜利，并将以第二竞价的金额获得该域名，多余金额将会退回到该账户的钱包。如果有多名用户投标的价格完全相同，那么最早投标的人将获胜。竞价失败用户的竞价金的99.5%也会返还到各自账户。 6）在域名持有期内，用户可以将域名绑定到自己的以太坊地址、转移域名的使用权、添加设置子域名等，甚至还可以转让域名的所有权。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:8:2","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"其它考虑 注意，ENS注册系统并不会产生收益，所有资金都作为保证金或者被销毁。被销毁的资金将被转移到地址0xdead，意味着不可找回。购买域名的竞价金以保证金的形式存放在一个独立的个人契约账户中，一年后用户可以放弃该域名的所有权，那么他可以拿回这笔保证金。肯定有读者想：既然能够返回押金，那么就用ENS智能合约规定的最低价格0.01ETH竞标到尽可能多的ENS，放在手中，万一以后转让给他人说不定还能大赚一笔！这种情况是不会发生的，首先，对于一些热门的ENS，较低的ETH肯定无法成功竞标，而且ENS竞标是一个运行智能合约的过程，既然是运行智能合约，那么肯定要花费一定的ETH费用，而且即使花费了大笔的交易费用得到大量的ENS，这些ENS也大多是无人问津的，对于那种想要“广撒网”的投机者来说，这无疑是一笔“亏本买卖”。总之，以太坊提倡的是“用你觉得合理的价位竞标你真正需要的ENS”。 ","date":"2018-12-11","objectID":"/2018/ethereum-instruction/:8:3","tags":["区块链"],"title":"区块链学习4-以太坊基础知识","uri":"/2018/ethereum-instruction/"},{"categories":["研究生的区块链学习之路"],"content":"和老师商量着定了大方向是物联网和区块链的结合，这篇文章是这段时间以来对该方向调查的总结。 物联网（Internet of Things，IoT），有两层含义：其一，物联网是在互联网基础上进行延伸和扩展的网络，其核心和基础仍然是互联网；其二，网络的用户端延伸和扩展到了任何物品与物品之间，可进行信息交换和通信，也就是物物相连。 我国将物联网定义为：通过信息传感设备，按照约定的协议，把任何物品与互联网连接起来，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络。在物联网时代，能接入网络的不仅仅是计算机和智能手机，还有汽车、健身设备、锁具、交通摄像头甚至你能想到的一切。 常见 IoT 场景：智能电网、智能家居、智慧交通、智能制造，智慧城市 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:0:0","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1. 背景 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:1:0","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 中心化的问题 云服务器和维护成本：在过去的十几年中，“中心化的云服务器+小范围部署”是物联网主要的通信形式。然而，物联网技术为产业升级带来变革的前提是海量设备的入网。当接入设备达到数百亿或数千亿，服务器面临的负载将越来越大，面临单点瓶颈和故障问题。云存储服务的需求也不断提高，这些都需要企业投入大量的资金来维持，从而带来巨额成本，阻碍物联网进一步发展。 数据流动：在物联网时代，各种产品都接入一个庞大的智能网络，交易的主要目的是产品使用权的流转，甚至网络中的每一个节点、每一个产品都可以同时承担交易对象和交易发起者的角色。因此，交易数量会呈几何级数增加。举个简单的例子，如果购买一辆汽车（取得所有权），那么在用它代步的这段时间里，交易一次就够了，而如果仅仅是获得流转中的使用权，那么我们需要每使用一次就进行一次交易。因此，物联网中会产生天文数字的交易频率和交易数量，相关的清结算系统要分秒不停地顺畅运转，这无疑会对相关的基础设施提出极大的挑战。这将是一个复杂的网络，复杂到任何一个中心化的机构都无法承担这样的任务。 区块链并不是解决中心化问题的好办法，首先，对于海量数据存储的需求，区块链的存储同样是昂贵的，其次，区块链的固有延迟导致了它的吞吐量甚至不如传统的中心化系统。区块链可以解决单点瓶颈和故障，但是其它的分布式系统也可以，区块链的优势之处在于保证参与各方之间的信任，因此用来存储一些关键且重要的信息，另外还可以减少中介的参与，缩短交接时间，使交易各方之间的协调更快；遇到问题更容易和更快追溯出问题的地方，减少欺诈风险等。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:1:1","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 数据安全和隐私 数据安全：现有物联网设备朝着能耗低、重量轻的方向发展，其能量和计算资源大部分用于执行核心程序，只有很少一部分配给处理安全和隐私问题。这导致传统物联网设备极易遭受攻击，数据易受损失且维护费用高昂，此外，由于物联网设备同生活生产联系紧密，会生成、处理和交换大量安全相关的数据和隐私敏感的信息，受到攻击后产生的后果也极为严重。一些物联网设备典型的信息安全风险问题包括：固件版本过低、缺少安全补丁、存在权限漏洞、设备有过多的网络端口、未加密的信息传输等等，事实上，由于物联网的核心是互联网，互联网上层出不穷的黑客攻击、数据泄露、恶意软件、网络窥探都可能威胁到物联网。 数据隐私：此外，制造方经常在产品中留有后门或权限，在未经用户同意的情况下获取用户在使用中产生的数据，而用户对此要么毫不知情，要么没有办法制止，用户的隐私权受到严重威胁。所以对用户来讲需要一个透明度保障的办法，保障用户知晓其他人对自己数据的使用以及自己对数据的完全控制权。 物联网安全问题的核心是缺乏设备之间的相互信任机制，传统的认证和授权机制易受网络攻击影响，区块链由于不可篡改的特性可以有效抵御大部分攻击，方法是利用区块链来实现认证和授权。 另外，区块链无法保证隐私，区块链中每个参与者由其公钥标识，交易时只需要知道对方的公钥，但这种匿名属于伪匿名，由于区块链中所有交易都是公开的，通过分析这些数据，可以识别地址和用户之间的关系，推断出用户真实身份。另外，区块链的匿名不受监管，大概率会沦落为犯罪和洗钱的温床，这是国家所不能忍受的，如果区块链想继续发展，必然不可能向该方向努力。 但区块链中隐私的需求又真实存在，但我们需要正确理解隐私的含义： 用户拥有对自己数据的完全控制权，包括知晓被谁使用和如何被使用及随时撤回授权； 数据的隐私而非身份的隐私，存在区块链中的数据由于是公开的，可能被竞争对手利用从而获得竞争优势。 对于解决隐私问题，目前看到三种方法（可以缓解但无法消除该问题） 每笔交易使用新的密钥或对每个交易对象使用新的密钥； 对私有区块链，如果其他参与者可以通过跟踪您设备的活动获得竞争优势，建议不要对所有交易使用相同的区块链，通过仅为需要协作的实体设置区块链，并仅将它们用于自己希望协作的进程，最大限度地减少设备地暴露。与单个区块链相比，这增加了协调成本，但减少了隐私暴露的可能性； 同态加密和零知识证明。虽然能解决，但是这两种方法都是资源密集型的，在资源受限的 IoT 设备上适用性有限。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:1:2","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"1.3 自动化 互联网本身就是一个去中心化的网络，在物联网时代，较之现在，接入网络的节点数量会出现极大的增长，因此，未来的物联网一定是个自组织、自调节的系统。在这样的系统中进行信息和价值的交换，必然需要可靠的去中心化点对点价值传输网络，区块链可以提供这样的平台。 另外，区块链技术中的智能合约可将每个智能设备编程为可以自我维护和调节的独立的网络节点，可在植入的规则基础上与执行与其他节点交换信息或核实身份等功能。智能合约运行是分布式的，能完成高度自动化的工作流程，这一点可以进一步应用。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:1:3","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"2. 区块链自身的问题 相比于集中式的数据库，区块链解决方案交易处理吞吐量比较低，交易确认延迟跟高，公链中这个问题尤为突出。 区块链中每个节点执行相同的任务，没有空间用于并行任务执行，即没有分片，以太坊在努力改进这一点。分片主要是为了扩大每个区块的容量，从而提高交易吞吐量。 矿工问题，矿工虽然不能伪造交易或重写历史，但可以拒绝把有效交易添加到区块链中，所以要慎重选择自己的挖矿节点，最小化它们之间的串通机会，私人网络中应签署法律合同来合理地惩罚合谋。 智能合约的法律可执行性有限。如果交易实体对智能合约操作的结果提出异议，会发生什么？增加法律可执行性的可能性的一种方法是在智能合约中包含对实际真实合同的引用，反之亦然。这是一个称为“双重集成”的过程，它的工作原理如下：（a）部署智能合约，在区块链上记录其地址，并在真实合同中包含该地址（b）哈希相应的真实合同，记录其哈希摘要，将真实合同存储在安全空间（可以集中或分散），（c）向智能合约发送包含真实合约在其元数据中的哈希值的交易;然后智能合约将该信息存储在自己的内部数据库中。如果出现法律纠纷，可以指向存储在智能合约中的哈希值，然后显示真实世界的合约（由该哈希值唯一标识）并证明区块链上的操作与预期结果之间的联系 设备所有权的证明，当希望提取设备在区块链中对应的货币时（比如把设备卖出去了），遇到不支持智能合约的区块链，怎么办，办法是把现实世界的合同哈希值作为元数据放在代表该设备价值的代币里。即任何时候都可以对这些代币进行公证。 智能合约是把双刃剑，里面代码写的有问题，就可能发生严重的安全事故，就像以太坊的the DAO事件。 最后，区块链网络可能需要以下机制来补充其功能，并且这些机制也应是分布式的。 指向区块链中资源的DNS服务，用于查找相应的区块 安全的通信和文件交换，区块链中的消息通信是公开的，如果需要两个节点间专用的通信，需要 telehash,Whisper 之类的协议，文件共享则可以通过内容寻址的 P2P 文件系统来解决，例如 IPFS 求解 PoW 难题的高资源需求 由广播交易和块到整个网络造成的交易确认的长延迟和低可扩展性 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:2:0","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3. 应用场景 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:3:0","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 软件更新 常规的物联网设备的软件更新或bug修复需要对设备的完全控制，这一机制的安全性是个大问题，并且，当设备数较多时，厂商的服务器压力很大，扩展也是一个问题。其中，手环等可穿戴设备往往要借助智能手机来完成更新。 制造商的所有物联网设备都在同一个区块链网络上运行，制造商部署智能合约并允许它们在区块链网络上存储最新固件更新的哈希值，物联网设备要么将智能合约的地址存到它们的区块链客户端，要么通过搜索服务找到智能合约。然后它们可以查询合约，了解新的固件更新，并通过分布式对等文件系统请求更新并通过哈希验证更新的正确性。对该文件的第一次请求由制造商自己的节点（该节点也加入区块链网络）提供服务，但更新文件传播到足够的节点后，制造商的节点可以停止提供服务，由已获得更新的设备向未获得更新的设备提供服务，提供这一服务的节点可以收取适当的费用，这一功能由区块链中的加密货币系统提供，所有的交互都是自动的。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:3:1","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 设备提供资源 这里包括三种含义，一种是设备所有权的更换，二是设备短时间的租用，三是设备向其他人或物提供某种服务。在这里，每台设备都可以拥有自己的账户，然后将设备本身或设备服务的价值数字化，并固定在加密货币中，这样就形成了物联网中的付费层，为设备间的服务市场铺平了道路，即使没有人的参与，设备间也可以自己调用自己账户中的资金租用其它设备完成某项任务，从而实现整个物联网系统的自动化。这里有一个例子，如可以固化房屋的价格，设定在电子锁中，通过支付房主设定的加密货币数量和验证正确的签名，与锁通信来解锁它，通过让所有这样的电子锁运行在同一区块链上来简化计费，同时简化现实房屋合同的拟定过程。 又比如一个分布式存储的例子，过去，一些基于云的在线文件存储服务（如Dropbox）允许用户上传其硬盘备份，提供备份存储服务并允许用户每月访问和向用户收费。但是，这种方式效率低下。DSDIN的智能合约允许分布式存储生态系统开发，因此用户可以通过出租自己的硬盘赚取少量费用或租用未使用的网络空间来降低文件存储成本。合同的工作原理如下：首先，有人将需要上传的数据分成块，加密每个数据块以保护隐私，然后构建一个Merkel树。然后，此人应根据以下规则创建合同。对于每N个块，合同将从Merkel树中提取随机索引（使用可通过合约代码访问的前一个块的哈希来提供随机性），然后为第一个实体提供一定数量的DSD以支持使用类似的简化验证付款（SPV）[15]证明树中特定索引处的块的所有权。当用户想要重新下载他的文件时，他可以使用微支付通道协议（例如，每64K字节0.1DSD）来恢复文件;对于费用，最有效的方式是付款人直到最后才发布交易，并且应使用具有相同随机数的稍微更具成本效益的交易来替换每64K字节后的原始交易。 该协议的一个重要特征是，虽然似乎一个人信任那些不会丢失文件的随机节点，但他可以通过秘密共享将文件分成许多小块，然后监视合同以知道每个小块仍然是由某个节点保存。如果合约仍在支付，则证明有人仍在保存文件 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:3:2","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 能量领域 布鲁克林的一个社区实验，居民的太阳能电池板的能量盈余记录在区块链上，通过智能合约可以将其出售给邻近各方，同时，有能量缺口的居民也可以通过合约购买，电力部门也可以参与到这一过程中来。 能量区块链：满足IIoT不断增长的能源需求是一个挑战，而且IIoT节点的数量和性能需求不断增长。之前的研究已经提到IIoT节点可以以P2P方式与其他节点交换其剩余能量，从而达到能量的供需平衡。结合energy harvesting, wireless power transfer, and vehicle-to-grid等技术，IIoT目前有三种典型的能量交易场景。 Microgrids：具有太阳能电池板或风力发电机的智能建筑物可形成微电网，其中建筑物在微电网中以P2P方式收集环境能量并相互交换能量。 Energy harvesting networks：具有能量收集能力的工业节点可以从可再生能源获得能量，也可以使用P2P的能量交易方式通过移动充电桩进行无线充电。 Vehicle-to-grid networks：电动车辆在电网负载小时充当能量存储设备，在负载高时把能量送回电网。也可以以P2P的方式把能量出售给邻近的需要充电的电动车辆。 现在面临的安全与隐私问题： IIoT节点在不可信和不透明的能源市场中进行大规模分散能源交易是不安全的。 具有剩余能量的IIoT节点由于担心隐私而可能不愿意作为能源卖家参与。在这种情况下，IIoT节点之间的能量供需是不平衡的。 在P2P能源交易中，有一个中介来审核和验证IIoT节点之间的交易记录。 使用联盟链来解决这些问题，是一个场景通用的成本可接受的能量区块链。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:3:3","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3.4 供应链 货物在供应链各环节流通时，装运信息缺乏可见性，并且拥有装运延迟，这种延迟通常是由于一个流通的批准文件或货物交接造成的，随着这种事务的增加，相关的交接文件可能错位或丢失，或处于等待状态，可以使用智能合约数字化这一过程，并从供应链中删除这类中间商的工作。如1中所述，区块链主要记载货物的位置和时间信息，作为货物的装运证明和交付证明。这样可以最大限度地减少装运延迟，更准确地预测货物地交付时间，更好地实时检测库存水平。 位置数据由IoT传感器捕获，IoT传感器将数据转发到IoT平台。供应链的参与者包括原始设备制造商（OEM），供应商，第三方物流提供商，托运人和仓库。每个参与者都可以根据参与者的角色查看区块链中的相关货运数据。制造商使用物流管理系统来查询区块链的装运数据，并向区块链提供额外的装运信息。 具体举例如下： 装有产品的箱子从制造商离开，通过铁路到达最近的港口，通过海运到目的港口，再送到经销商处，最后到达零售商。整个过程设计多个利益相关者以及多道交接和检查，令每个利益相关者携带一个智能跟踪器，里面包含BLE，GSM或LTE以及安装好的区块链客户端。BLE用于设备判断它们是否接近，接近时它们可以通过LTE在互联网的区块链上进行交易，GSM用于定位，而区块链客户端，是因为我们设置了一个区块链网络用于跟踪货物信息，这样就意味着有一个共享数据库可跟踪，每一方不再需要维护自己的数据库并根据交接内容不断地更新数据库。另外，区块链中的数据还具有加密可验证性，自动沿网络传播并扩散到所有利益相关方，物流信息在区块链中不可更改，可用于审计工作。当两个利益相关者见面且箱子也在时，他们的设备可以自动的将签名的消息发送到预定的智能合约，以允许链上的每个人知道现在箱子的位置，同时因为交易被签名，它会作为海运公司关于集装箱已到达目的港的加密可验证收据的声明。资金的流通也可以通过智能合约在银行间自动完成。 或者利用比特币的代币交易模型完成供应链的整个过程，是一个很有意思的想法。 同时，可以令需要定制服务的用户也加入供应链，用户直接在区块链上提交自己的需求（可能包括产品的模型和各种参数），工厂收到后确认自动完成并自动交付。完成整个过程。 案例：Precyse Technologies专门提供基于有源RFID技术的实时定位和供应链可视化解决方案，主要用于跟踪物体位置和移动人员或实物资产的室内外定位，帮助工作人员有效的识别、定位、检测状态和沟通。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:3:4","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3.5 自动驾驶车辆 车辆可以自行加油或充电。如果车辆上的传感器检测到需要维修，则车辆可以自动安排预约并开车到维修设施。自动驾驶汽车制造商可以及时获得区块链上捕获的发动机或动力传动系故障信息，并可以使用此信息来确定组件是否出现故障趋势 客户受益于制造商提高的服务水平，提高消费者信心。制造商，监管机构和供应商可以适当了解区块链中的组件故障，并可以更快地主动应对故障趋势，以确保消费者的安全和满意度。在没有人为干预的情况下，车辆将安全地自动支付加油或维修费用。加油，维修和付款的永久记录将记录在区块链上，并由参与者共享，包括车主，制造商，维修设施和融资公司 将传感器的数据放在区块链，利用智能合约可以达成自动修车、加油，并利用区块链货币的固有智能完成维修和加油的费用支付。这些支付记录也将存在区块链中，同样还利用其采集的信息不可改变供车主、制造商、维修设施等各方访问数据。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:3:5","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"3.6 制造工厂资产管理 区块链和物联网解决方案可以预防和预测制造工厂设备的故障。设备传感器可以检测诸如过度振动或热量之类的情况，这可能导致故障或操作员受伤。从传感器在区块链上捕获的关键阈值数据将用于检测这些故障的趋势，并在故障发生之前促进主动维护和维修。从工厂设备生成的分析和认知数据的应用将使可靠性，维护和操作人员能够更加详细，准确地了解资产绩效。监管机构和工厂设备供应商可以查看设备记录，并可以及时提供检查和认证，以确保设备的可靠性。第三方维修合作伙伴可以监控区块链的预防性维护，并将其工作记录在区块链上 设备制造商可以通过设备中安装的传感器预测客户设备的某些部件需要更换，并预先将备件运送到客户附近的仓库，这可以大大缩短客户等待更换的时间，减少停机造成的损失；而另一方面，客户无需囤积大量备件，占用资金和仓库，这种方法还可以降低客户从其他品牌购买备件的可能性，增加制造商的收入。 基于区块链的缓存内容分发那篇论文主动缓存策略分两阶段，第一阶段是预取阶段，边缘服务器先从服务提供者那里下载资源，第二阶段是交付阶段，内容被交付给移动客户端。这和该案例中设备提供商会根据数据事先将相应配件放在工厂附近的仓库，工厂需要时直接交付，和两阶段过程较为相似 基于物联网数据的时间序列性质，大多数设备故障的预测或检测问题可以抽象为半马尔可夫决策过程。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:3:6","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4. 落地项目 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:4:0","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 ADEPT 2015年1月，IBM宣布将与三星联合打造ADEPT（Autonomous Decentralized Peer-to-Peer Telemetry）系统，利用区块链技术实现去中心化的物联网。ADEPT平台由三个要素组成：区块链（智能合约）、Telehash（P2P信息发送）和BitTorrent（文件分享）。通过该平台，两家公司都希望带来一个能自动检测问题、自动更新、不需要任何人为操作的设备，这些设备也将能够与其他附近的设备通信。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:4:1","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 Filament 2015年8月，区块链物联网项目 Filament 获得A轮融资500万美元。Filament 的联合创始人兼首席执行官艾瑞克·詹宁斯（Eric Jennings）谈到，Filament 是一个使用比特币区块链的去中心化的物联网软件堆栈，能够使区块链上的设备拥有独特身份。通过创建一个智能设备目录，Filament的物联网设备可以进行安全沟通、执行智能合约以及发送小额交易。基于上述技术，Filament 能够通过远程无线网络将辽阔范围内的工业基础设备沟通起来，其应用包括追踪自动售货机的存货和机器状态、检测铁轨的损耗、基于安全帽或救生衣的应急情况监测等。鉴于这一设想，詹宁斯认为他的项目与 ADEPT 项目在本质上是相似的，不同的是它将针对工业市场，使石油、天然气、制造业和农业等行业的大公司实现效率上的新突破。 Filament 的一种服务是，传感器不接入区块链但连到网关从而降低部署成本，网关形成网状网络，通过称为“telehash\"的协议以分布式和安全的方式相互通信，并通过公链上的智能合约相互交互。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:4:2","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.3 NeuroMesh 2017 年 2 月，源自 MIT 的 NeuroMesh 物联网安全平台获得了 MIT 100K Accelerate 竞赛的亚军。该平台致力于成为“物联网疫苗”，能够检测和消除物联网中的有害程序，并将攻击源打入黑名单。所有运行 NeuroMesh 软件的物联网设备都通过访问区块链账本来识别其他节点和辨认潜在威胁。如果一个设备借助深度学习功能检测出可能的威胁，可通过发起投票的形式告知全网，由网络进一步对该威胁进行检测并做出处理。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:4:3","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"4.4 DIPS 众享互联与克莱沃合作提出分布式物联网安全解决方案——分布式智能配电信息安全系统（DIPS），由管理软件、安全加固型电源分配单元（PDU）和网络安全控制器构成。该系统采用安全通讯协议、动态加密隧道、多分片随机传输和双因子验证等技术手段，可以解决物联网架构络层中数据网关到中心/管理中心的数据传输安全问题。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:4:4","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"5. 一些思路 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:5:0","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"5.1 IoT 设备接入区块链 把物联网终端设备和网关集成到基于区块链的物联网平台上可以通过以下方法实现： 网关作为区块链的全节点，终端设备和网关通信 网关作为区块链的轻节点，终端设备和网关通信 终端设备作为常规传感器，电池供电的终端设备不足以集成区块链客户端，由物联网网关把数据推送到区块链 终端设备作为服务器可信的客户端：使用BCCAPI这样接口的简单形式的客户端可以集成到电池供电的物联网终端设备中 如果终端设备不是由电池供电并且始终开启，终端设备可以作为区块链的轻节点 一个实例为：LPWAN技术可以跟踪覆盖数公里范围的人员或设备。电池供电的物联网终端设备将位置数据发送到LoRa网关。然后，LoRa网关使用智能合约将此数据流通过官方Golang的以太坊客户端Geth路由到私有的以太坊区块链。使用连接到Dragino LoRa / GPS Hat 的Raspberry Pi 2构建LoRa终端设备，使用Raspberry Pi 3构建LoRa网关。为了实现这样的双向LoRaWAN-Ethereum代理，网关应运行LoRa协议软件以与终端设备通信，并运行以太坊客户端以将数据路由到区块链网络。LoRa协议软件用于将数据包转发到应用程序服务器。此外，使用初始生成块创建私有以太坊网络，其具有简单的挖掘设置，以实现更快的响应时间，即更短的挖掘时间。 要使网关和区块链交互，需要部署智能合约，部署后智能合约的地址和程序二进制接口（ABI）用于与其交互。使用一个 smart proxy 从 LoRa 包转发器捕获数据，然后通过 JSON-RPC 接口将其提供给 Geth 并调用智能合约。相关的项目代码位于 blocky 由上产生的思路： 比如通过Wi-Fi，ZigBee，LoRa等不同的无线技术连接到区块链节点 无线接入过程中的损耗，延迟问题 通过休眠节省能量的设备和区块链节点间的同步问题 本地搭建私链时 PoW 的替代方案 向周围的边缘服务器借算力 参与非工作量证明的共识算法 只有全功能节点参与共识，使用簇头管理簇内节点的形式 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:5:1","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"5.2 和其他技术结合 区块链使得在链上数据不可篡改，如果仅是单独使用，则无法解决数据可信的问题，但是如果搭配好物联网和人工智能技术，则可以在很大程度上提升上链信息的可信性，确保线下实物准确向线上映射，提升系统总体上的可信性，进而在更多地场景实现落地。 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:5:2","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["研究生的区块链学习之路"],"content":"参考文献 [1] 工业和信息化部信息中心. 2018 年中国区块链产业白皮书[M]. 北京. 2018.5:84-86 [2] 张健. 区块链，定义为了金融与经济新格局[M]. 北京：机械工业出版社. 2016:20-27 ","date":"2018-12-11","objectID":"/2018/blockchain-for-iot/:6:0","tags":["科研记录"],"title":"背景调查3-区块链与物联网","uri":"/2018/blockchain-for-iot/"},{"categories":["平日里的白日梦"],"content":"所罗门之匙一书中，所罗门囚禁魔神，将魔神的力量赋予他的学徒，从而一举将他的学徒们，变成了堪比神魔的法师。那些门徒们，很多之前都没有接触过魔法，一步登天就获得了强大力量，为什么我们却需要一步步学习呢？ 所罗门之书中提到，所罗门是古代犹太王国的国王，同样也是一位超级法师，他生而神圣，智慧超群，就连神魔都惊叹他的智慧。可是聪明人都有一个缺点，他们无法忍受一步步提升实力，因为那样做太慢了。地狱七君主之一的大魔王贝利尔，看出了所罗门的浮躁，它主动降下凡尘，告诉当时的所罗门，说自己被所罗门的智慧所折服，愿意将力量借给他。 所罗门毫不怀疑，他带着贝利尔的力量，畅游地狱与天堂，与神魔们把酒言欢，平辈相交。神魔的奢华与享受，严重腐蚀了所罗门的内心，使得他忘记了对魔法的探索，成为了一位自大，骄傲，骄奢淫逸、沉迷女色的庸王。 好景不长，在位四十年后，所罗门的身体每况愈下，贝利尔的地狱之力，污染了他的身体与灵魂。当他拖着苍老的身体，从享乐中清醒过来的时候，他再也不是那位堪比神魔的法师，于悔恨中与世长辞。而他的学徒们，也在争权夺利中消亡，时至今日只有传说留下。 所以，一步登天的力量，会迷失你的内心，当你习惯在力量上取巧时，你就无法忍受一点一滴的积攒魔力。所罗门之书，不是让你们看到所罗门的伟大，而是要告诉你们，迷失在力量下的下场。 也许每个人都曾想过一步登天的地位与财富，然而，得来的容易，便不会珍惜。当这些在自己的肆意妄为中消失殆尽，谁又能再次忍受平凡与贫穷呢。 ","date":"2018-12-07","objectID":"/2018/%E6%89%80%E7%BD%97%E9%97%A8%E4%B9%8B%E5%8C%99%E7%9A%84%E5%90%AF%E7%A4%BA/:0:0","tags":["杂谈"],"title":"所罗门之匙的启示","uri":"/2018/%E6%89%80%E7%BD%97%E9%97%A8%E4%B9%8B%E5%8C%99%E7%9A%84%E5%90%AF%E7%A4%BA/"},{"categories":["研究生的区块链学习之路"],"content":"本篇结束区块链领域概况，包括一些常见名词、核心技术、应用场景和学习区块链需要掌握的基础知识。 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:0:0","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"1. 常见概念 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:1:0","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 比特币 比特币网络上线以来，在无人管理的情况下，已经在全球范围内无间断地运行了 10年时间，成功处理了千万笔交易，最大单笔支付超过 1.5 亿美金。难得的是，比特币网络从未出现过重大的系统故障。比特币网络目前由数千个核心节点参与构成，不需要任何中心化的支持机构参与，纯靠分布式机制支持了稳定上升的交易量。比特币首次真正从实践意义上实现了安全可靠的非中心化数字货币机制 比特币主要希望解决的是现有货币系统的一些问题： 被掌控在单一机构手中 自身价值无法保证，容易波动 无法匿名交易，不够隐私（没想到为什么要匿名交易） 实现的方式主要是一套完善的交易记录系统和一套合理的货币发行机制。 交易记录系统应能准确、公正的记录发生过的每一笔交易，且无法被篡改，现有银行系统在跨多家银行和跨国情况无法实现这一点。采用区块链技术解决。 货币发行通过一套协议规定。货币总量受控，发行速度随时间自动调整，从而保证货币价值和避免出现通胀。 由于比特币系统的稳定运行，其背后的区块链技术受到人们关注和独立研究，最终脱离出来，在诸多新的领域开始应用，如2015年上线的超级账本项目和以太坊项目。区块链技术已不等同于比特币区块链。 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:1:1","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 区块链 从比特币系统中脱离出来的区块链系统具有如下特性： 分布式容错性：整个网络稳定性较高，能容忍部分节点的异常； 不可篡改性：共识提交后的数据会一直存在，不可被销毁或修改； 隐私保护性：密码学保证了数据隐私，即使泄露也无法解析 潜在的，区块链技术能降低交易成本，加快交易速度，同时提高安全性。理论上，所有与信息、价值（货币、专利、版权、数字商品、实际物品）、信用相关的交换过程都能和区块链结合。列举三个场景如下： 跨境商贸中签订的合同，怎么确保对方能严格遵守和及时执行？ 酒店宣称刚打捞上来的三文鱼，怎么追踪捕捞和运输过程中的时间和卫生？ 现代数字世界里，怎么证明你是谁？怎么证明某个资产属于你？ ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:1:2","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"2. 区块链核心技术 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:2:0","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 定义 中本聪：未定义区块链，区块和链被描述为记录比特币交易账目历史的数据结构 维基：一种分布式数据库技术，通过维护数据块的链式结构，可以维持持续增长的、不可篡改的数据记录。 本书（狭义）：一种以区块为基本单位的链式数据结构，区块中利用数字摘要对之前的交易历史进行校验，适合分布式记账场景下防篡改和可扩展性的需求。 本书（广义）：基于区块链结构实现的分布式记账技术，包括分布式共识、隐私与安全保护、点对点通信技术、网络协议、智能合约等。 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:2:1","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 原理 实现一个分布的账本，这个账本只允许添加、不允许删除。账本底层的基本结构是一个线性的链表。链表由一个个“区块”串联组成，后继区块中记录前导区块的哈希（Hash）值。某个区块（以及块里的交易）是否合法，可通过计算哈希值的方式进行快速检验。网络中节点可以提议添加一个新的区块，但必须经过共识机制来对区块达成确认。 比特币区块链原理：尝试口头描述成功，已清晰，不写了。 比特币区块链核心：POW和最长链机制 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:2:2","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 当前主体应用 加密数字货币 智能合约：比特币区块链面向转账场景，支持简单的脚本计算。如果引入更复杂的计算逻辑，将能支持更多应用场景，这就是智能合约（Smart Contract）。智能合约可以提供除了货币交易功能外更灵活的合约功能，执行更为复杂的操作。 商用分布式账本：智能合约基础上加入权限管理，高级编程语言支持等，可实现支持更多商用场景的分布式账本系统。 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:2:3","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"2.4 链分类 根据参与者不同分为： 公有链：任何人都可以参与使用和维护，参与者多为匿名。典型的如比特币和以太坊区块链，信息是完全公开的。 私有链：由集中管理者进行管理限制，只有内部少数人可以使用，信息不公开。一般认为跟传统中心化记账系统的差异不明显。 联盟链：介于两者之间，由若干组织一起合作（如供应链机构或银行联盟等）维护一条区块链，该区块链的使用必须是带有权限的限制访问，相关信息会得到保护，典型如超级账本项目。 在架构上，现有大部分区块链在实现都至少包括了网络层、共识层、智能合约和应用层等分层结构，联盟链实现往还会引入额外的权限管理机制。 根据使用目的和应用场景分为： 以数字货币为目的的货币链 以记录产权为目的的产权链 以众筹为目的的众筹链 不局限特定应用场景的通用链 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:2:4","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"2.5 目前的问题 分布式共识：在分布式系统领域已有大量研究，公开匿名场景下的比特币区块链采用工作量证明机制，但有效率低下和能源浪费的问题。以太坊采用权益证明机制，分布式账本采用一些其它的算法，但都有不少问题，值得继续研究。其核心指标包括容错的节点比例、决策收敛速度、出错后的恢复、动态特性等 交易性能：一般情况下，区块链并不适用于高频交易的场景，业界关注的交易性能包括吞吐量和确认延迟两个方面。目前，公开的比特币区块链只能支持平均每秒约 7 笔的吞吐量，安全的交易确认时间为一个小时左右。以太坊区块链的吞吐量略高一些能到几十笔每秒，但交易性能也被认为是较大的瓶颈。为了提高处理性能， 可以提升单个节点的性能（如采用高配置的硬件），同时设计优化的策略和算法，提高性能； 可将交易处理卸载（off-load）到链下。只用区块链记录最终交易信息，如比特币社区提出的 闪电网络 。 侧链（side chain）、影子链（shadow chain）等思路。 扩展性：常见的分布式系统，可以通过横向增加节点来扩展整个系统的处理能力。而大部分区块链系统的性能，很大程度上取决于单个节点的处理能力。对这些系统来说，节点需要满足 高性能、安全、稳定、硬件辅助加解密能力。 例如，对于比特币和以太坊区块链而言，网络中每个参与维护的核心节点都要保持一份完整的存储，并且进行智能合约的处理。此时，整个网络的总存储和计算能力，取决于单个节点的能力。甚至当网络中节点数过多时，可能会因为共识延迟而降低整个网络的性能。尤其在公有网络中，由于大量低性能处理节点的存在，问题将更加明显。 安全防护：区块链采用了大量现代成熟的密码学算法和网络通信协议，但仍有一些安全问题。 立法：攻击银行系统违法，但攻击区块链系统未有定义 所有交易公开可见：即使被匿名化和加密处理，但万一有天被破解 公有链普遍缺乏有效的治理和调整机制，一旦运行中出现问题难以及时修正。即使是有人提交了修正补丁，只要有部分既得利益者联合起来反对，就无法得到实施。比特币社区已经出现过多次类似的争论。 代码漏洞，运行在区块链上的智能合约的漏洞：典型的是16年以太坊DAO事件 数据库和存储系统：区块链的应用，大量的读写操作、Hash 计算和验证操作，跟传统数据库的行为十分不同。可能出现专有的数据库系统。 运营管理：虽然大部分区块链系统在平台层面都支持了非中心化机制，在运营和治理层面确往往做不到那么非中心化。以比特币网络为例，历史上多次发生过大部分算力集中在少数矿池的情况，同时软件的演化路线集中在少数开发者手中。运营和治理机制是现有区块链系统中普遍缺失的，但在实际应用中又十分重要。 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:2:5","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"3. 典型应用场景 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:3:0","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 金融服务 区块链技术可以为金融服务提供有效、可信的所属权证明，以及相当可靠的合约确保机制。取代中介和担保机构这样的经济角色。 新型支付服务 众筹管理 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:3:1","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 权属管理 区块链技术可以用于产权、版权等所有权的管理和追踪。其中包括汽车、房屋、艺术品等各种贵重物品的交易等，也包括数字出版物，以及可以标记的数字资源。 MIT基于区块链的学历认证系统 其它： Chronicled：基于区块链的球鞋鉴定方案，为正品球鞋添加电子标签，记录在区块链上。 Mediachain：通过 metadata 协议，将内容创造者与作品唯一对应。 Mycelia：区块链产权保护项目，为音乐人实现音乐的自由交易。 Tierion: 将用户数据锚定在比特币或以太坊区块链上，并生成“区块链收据”。 Ziggurat：基于区块链提供文字、图片、音视频版权资产的登记和管理服务。 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:3:2","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 资源共享 解决共享经济中面临的相关问题，已有项目 短租共享 社区能源共享 电商平台：解决纠纷 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:3:3","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"3.4 贸易管理 跨境贸易中的信用问题 物流供应链 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:3:4","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"3.5 物联网 场景： 物联网络中每一个设备分配地址，给该地址所关联一个账户，用户通过向账户中支付费用可以租借设备，以执行相关动作，从而达到租借物联网的应用。典型的应用包括 PM2.5 监测点的数据获取、温度检测服务、服务器租赁、网络摄像头数据调用等等。 另外，随着物联网设备的增多、边沿计算需求的增强，大量设备之间形成分布式自组织的管理模式，并且对容错性要求很高。区块链自身分布式和抗攻击的特点可以很好地融合到这一场景中。 2015 年初，IBM 与三星宣布合作研发“去中心化的 P2P 自动遥测系统（AutonomousDecentralized Peer-to-Peer Telemetry）”系统，使用区块链作为物联网设备的共享账本，打造去中心化的物联网。 美国的 Filament 公司以区块链为基础提出了一套去中心化的物联网软件堆栈。通过创建一个智能设备目录，Filament 的物联网设备可以进行安全沟通、执行智能合约以及发送小额交易。基于上述技术，Filament 能够通过远程无线网络将辽阔范围内的工业基础设备沟通起来，其应用包括追踪自动售货机的存货和机器状态、检测铁轨的损耗、基于安全帽或救生衣的应急情况监测等。 2017 年 2 月，源自 MIT 的 NeuroMesh 物联网安全平台获得了 MIT 100K Accelerate 竞赛的亚军。该平台致力于成为“物联网疫苗”，能够检测和消除物联网中的有害程序，并将攻击源打入黑名单。所有运行 NeuroMesh 软件的物联网设备都通过访问区块链账本来识别其他节点和辨认潜在威胁。如果一个设备借助深度学习功能检测出可能的威胁，可通过发起投票的形式告知全网，由网络进一步对该威胁进行检测并做出处理。 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:3:5","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"3.6 其它 云存储：Storj 项目提供了基于区块链的安全的分布式云存储服务。服务保证只有用户自己能看到自己的数据，并号称提供高速的下载速度和 99.99999% 的高可用性。用户还可以“出租”自己的额外硬盘空间来获得报酬。 医疗：GemHealth 项目由区块链公司 Gem 于 2016 年 4 月提出，其目标除了用区块链存储医疗记录或数据，还包括借助区块链增强医疗健康数据在不同机构不同部门间的安全可转移性、促进全球病人身份识别、医疗设备数据安全收集与验证等。 通信和社交：BitMessage 是一套去中心化通信系统，在点对点通信的基础上保护用户的匿名性和信息的隐私。BitMessage 协议在设计上充分参考了比特币，二者拥有相似的地址编码机制和消息传递机制。BitMessage 也用工作量证明（Proof-of-Work）机制防止通信网络受到大量垃圾信息的冲击。类似的，Twister 是一套去中心化的“微博”系统，Dot-Bit 是一套去中心化的 DNS 系统。 投票：Follow My Vote 项目致力于提供一个安全、透明的在线投票系统。通过使用该系统进行选举投票，投票者可以随时检查自己选票的存在和正确性，看到实时记票结果，并在改变主意时修改选票。该项目使用区块链进行记票，并开源其软件代码供社区用户审核。项目也为投票人身份认证、防止重复投票、投票隐私等难点问题提供了解决方案。 预测 游戏 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:3:6","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"4. 底层知识支撑 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:4:0","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 分布式系统 一致性问题 共识算法 非拜占庭错误：Paxos，Raft等 拜占庭错误：PBFT为代表的确定性系列算法，PoW为代表的概率算法等 FLP不可能原理：在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法 CAP原理：分布式系统无法同时确保一致性（Consistency）、可用性（Availability）和分区容忍性（Partition），设计中往往需要弱化对某个特性的需求 ACID原则与多阶段提交：数据库里学过 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:4:1","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 密码学 哈希算法 加解密算法 数字摘要、数字签名 数字证书，PKI体系 Merkle树结构 Bloom Filter结构 同态加密 ","date":"2018-11-20","objectID":"/2018/overview-of-blockchain/:4:2","tags":["区块链"],"title":"区块链学习3-区块链领域概况","uri":"/2018/overview-of-blockchain/"},{"categories":["研究生的区块链学习之路"],"content":"原始的目的是统计一下国内区块链研究现状，但开始这一工作时决定顺便把其它的统计数据也一并记录下来。数据来自 Web of Science核心合集，即SCI，以blockchain为关键词，总计3399篇论文 EI Compendex，即EI，以blockchain为关键词，总计6659篇论文 CNKI核心期刊，会议，硕博论文 ","date":"2018-11-17","objectID":"/2018/analysis-of-papers-published-in-blockchain-field/:0:0","tags":["科研记录"],"title":"背景调查2-近三年区块链方向论文发表情况总结","uri":"/2018/analysis-of-papers-published-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"1. 学科 论文所属学科以计算机为主，SCI中工程电子电气、计算机科学理论方法、计算机科学信息系统、电信四个学科是最主要的发表领域，剩下的论文数量超过100篇的学科分别是计算机科学的跨学科应用、计算机科学软件工程、计算机科学硬件体系结构、计算机科学人工智能和能源燃料。随后的两个领域分别是工业工程和自动化控制系统，而直观上感觉相关的经济学只排到第13位。 SCI论文所属学科论文统计的图片丢失 EI中结果仿佛，柱状图如下所示 ","date":"2018-11-17","objectID":"/2018/analysis-of-papers-published-in-blockchain-field/:1:0","tags":["科研记录"],"title":"背景调查2-近三年区块链方向论文发表情况总结","uri":"/2018/analysis-of-papers-published-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"2. 出版年 虽然比特币起始自2008年，但区块链的论文直到2013年才有收录，并且只有2篇，2018、2019两年达到最高，每年都有近1400篇。柱状图如下 （图片丢失） 具体每年的数据如下表所示，有趣的是今天才2019年12月2日，结果2020年待发表论文已经有23篇了，超过刚发展的前三年。 出版年 论文数 百分比 2020 23 0.677 2019 1385 40.747 2018 1392 40.953 2017 466 13.710 2016 99 2.913 2015 22 0.647 2014 10 0.294 2013 2 0.059 EI论文总体的发表趋势相同，都是2017年开始有明显增长，从2018年开始爆发 两张图中都是在大概2013年起才出现论文，这可能是因为之前区块链这一概念并没有得到重视，相关的论文关键字很可能是比特币 ","date":"2018-11-17","objectID":"/2018/analysis-of-papers-published-in-blockchain-field/:2:0","tags":["科研记录"],"title":"背景调查2-近三年区块链方向论文发表情况总结","uri":"/2018/analysis-of-papers-published-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"3. 文献类型 SCI中会议论文2136篇，占比62.842%；期刊论文1065篇，占比31.333%；综述86篇，占比2.530%。 文献类型统计图片丢失 其中会议论文一共2136篇，分散在953个会议中。发表区块链论文最多的两个会议是 IEEE International Congress on Cybermatics 和 IEEE International Conference on Blockchain and Cryptocurrency，后者在2019年第一次举办，是IEEE举办的第一个区块链和加密货币的高级会议。下面是发表论文在10篇及以上的会议名。 会议名 数量 百分比 IEEE International Congress on Cybermatics 97 2.854 % 1ST IEEE International Conference on Blocakchain and Cryptocurrency(ICBC) 74 2.177 % IEEE International Conference on Communications(ICC) 33 0.971 % 1ST IEEE International Conference on Hot Information-Centric Networking(HotICN) 26 0.765 % 18TH IEEE International Conference on Data Mining workshops(ICDMW) 15 0.441 % 24TH IEEE International Conference on Papallel and Distributed Systems(ICPADS) 14 0.412 % 9TH IFIP International Conference on New Technologies Mobility and Security(NTMS) 14 0.412 % Crypto Valley Conference on Blockchain Technology(CVCBT) 14 0.412 % 11TH IEEE International Conference on Cloud Computing, Cloud Part of The IEEE World Congress on Services 13 0.382 % 34TH ACM Sigapp Annual International Symposium on Applied Computing(SAC) 13 0.382 % 4TH International Conference on Cloud Computing and Security(ICCCS) 13 0.382 % IEEE Global Telecommunications Conference GC(WKSHPS) 13 0.382 % 10TH IFIP International Conference on New Technologies Mobility and Security(NTMS) 12 0.353 % 21ST International Conference on Advanced Communication Technology(ICACT) 12 0.353 % IEEE International Conference on Big Data 12 0.353 % International Conference on Blockchain Technology(ICBCT) 12 0.353 % 5TH IEEE World Forum on Internet of Things(IEEE WF IOT) 11 0.324 % 1ST ACM IEEE International Workshop on Emerging Trends in Software Engineering for Blockchain(WETSEB) 10 0.294 % 2ND International Workshop on Cryptocurrencies and Blockchain Technology(CBT) 13TH International Workshop on Data Privacy Management(DPM) 10 0.294 % IEEE Global Communications Conference 10 0.294 % International Conference on Computing Networking and Communications(ICNC) 10 0.294 % 期刊最多的是IEEE Access，183篇，IEEE Internet of Things排第五，44篇，Sensors排第七，34篇，IEEE Transactions on Industrial Informatics排十一，25篇。更多的数据见下表，只统计20篇及以上的，虽然不知道为什么有些会议也算进去了 期刊名 数量 百分比 IEEE ACCESS 183 5.384 % Lecture Notes in Computer Science 121 3.560 % 2018 IEEE International Congress on Cybermatics 97 2.854 % 2019 IEEE International Conference on Blockchain and Cryptocurrency(ICBC) 74 2.177 % IEEE Internet of Things Journal 44 1.294 % Advances in Intelligent Systems and Computing 37 1.089 % Sensors 34 1.000 % IEEE International Conference on Communications 27 0.794 % International Conference on New Technologies Mobility and Security 26 0.765 % Proceedings of 20181ST IEEE International Conference on Hot Information Centric Networking(HotICN 2018) 26 0.765 % IEEE Transactions on Industrial Informatics 25 0.736 % Applied Sciences Basel 23 0.677 % 2019 IEEE International Conference on Communications(ICC) 23 0.677 % Future Generation Computer Systems The International Journal of Escience 22 0.647 % Sustainability 22 0.647 % International Conference on Parallel and Distributed Systems Proceedings 20 0.588 % IT Professional 20 0.588 % EI中文献类型占比如下图，会议论文4612篇，期刊论文1290篇，会议论文集532，报刊170，图书章节29，图书6，勘误表3篇，社论1篇。 具体的文献来源如下表所示，代表了发表收录区块链领域论文数量最多的会议和期刊 Source title Count Lecture Notes In Computer Science (Including Subseries Lecture Notes In Artificial Intelligence And Lecture Notes In Bioinformatics) 662 Proceedings - Ieee 2018 International Congress On Cybermatics 306 Acm International Conference Proceeding Series 245 Advances In Intelligent Systems And Computing 183 Ieee Access 160 Ceur Workshop Proceedings 111 Communications In Computer And Information Science 104 Lecture Notes In Business Information Processing 100 Icbc 2019 - Ieee International Conference On Blockchain And Cryptocurrency 84 Future Generation Computer Systems 63 Proceedings Of 2018 1st Ieee International Conference On Hot Information-Centric Networking, Hoticn 2018 58 Lecture Notes Of The Institute","date":"2018-11-17","objectID":"/2018/analysis-of-papers-published-in-blockchain-field/:3:0","tags":["科研记录"],"title":"背景调查2-近三年区块链方向论文发表情况总结","uri":"/2018/analysis-of-papers-published-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"4. 机构 首先是国家归属，中美最多，英国、印度、德国、韩国、澳大利亚、加拿大、意大利、法国等紧随其后，下图上半部分是SCI的论文统计柱状图，下图下半部分是EI的统计，两者的结果几无差别。 论文归属国统计图片丢失 基金资助的机构显然与国家相关，前两位是中国的国家自然科学基金和美国国家科学基金。 基金资助机构SCI排序统计图片丢失 在出版商中，SCI前两位是IEEE、ACM，而EI中则是IEEE、Springer，ACM排第三，不过两个数据库中IEEE都占最大的比重。 ","date":"2018-11-17","objectID":"/2018/analysis-of-papers-published-in-blockchain-field/:4:0","tags":["科研记录"],"title":"背景调查2-近三年区块链方向论文发表情况总结","uri":"/2018/analysis-of-papers-published-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"5. 小型组织 小型的组织的含义是各种大学、研究院、公司等，SCI中占比最多的是北京邮电大学和中科院，都在50篇以上。详细数据列表如下，统计以20篇为下限 组织 论文数 北京邮电大学 75 中科院 63 伦敦大学 47 IBM 46 澳大利亚联邦科学与工业研究组织 43 中国电子科技大学 39 澳大利亚新南威尔士大学悉尼校区 38 德克萨斯大学系统 38 北京航空航天大学 36 新加坡南洋理工大学 36 加州大学系统 36 清华大学 34 宾夕法尼亚联邦高等教育系统 32 西安电子科技大学 32 上海交通大学 29 德克萨斯大学圣安东尼奥分校 27 中国国防科技大学 26 北京大学 26 悉尼大学 26 印度理工学院 25 佛罗里达州立大学系统 25 中山大学 25 乔治亚大学系统 25 广东工业大学 24 北京理工大学 23 法国国家科学研究中心 23 新加坡国立大学 23 瑞士苏黎世联邦理工学院 22 阿联酋哈利法科学技术大学 22 意大利卡利亚里大学 22 坦普尔大学 21 悉尼科技大学 21 麻省理工学院 20 美国国防部 20 加拿大英属哥伦比亚大学 20 中国科学院大学 20 卢森堡大学 20 北卡罗莱纳大学 20 德克萨斯大学系统的38中有27篇都是圣安东尼奥分校贡献的；新加坡南洋理工大学和新加坡南洋理工大学国立教育学院的36篇是重合的，因此只记录了一个；伦敦大学47篇有22篇是伦敦大学学院贡献的，因此伦敦大学学院没有记录在上面；宾夕法尼亚州的Temple University译名不统一，上表中记录为坦普尔大学；英属哥伦比亚大学有时也称不列颠哥伦比亚大学，上表记为前者。 将上表中中国的研究机构单独抽离为下表，共13个机构， 组织 论文数 北京邮电大学 75 中科院 63 中国电子科技大学 39 北京航空航天大学 36 清华大学 34 西安电子科技大学 32 上海交通大学 29 中国国防科技大学 26 北京大学 26 中山大学 25 广东工业大学 24 北京理工大学 23 中国科学院大学 20 北京邮电大学高被引论文两篇，研究领域分别是能量网络和车联网，以第一作者发表论文较多的有：Liu Mengting 6篇，北京天地互联与融合重点实验室, Yang Hui 4篇光子光与光通信重点实验室，马兆丰 4篇 区块链及安全技术联合实验室 中科院高被引论文1篇，领域为智能交通系统，作者是Yuan Yong，该作者发表的另一篇引用数也在17。除此之外，Fan Kai以一作身份发表四篇， 东北大学有五篇，第一作者有鲁宁副教授(分校)和刘园副教授(软件学院)，剩下两个第一作者教师名单查不到。 EI中按组织对论文数量排序如下表，可能统计规则有所区别，EI的数据明显少很多，单个机构最多也只有37篇，因此以10篇为下限。 Author affiliation Count Ibm 37 澳大利亚联邦科学与工业研究组织 33 瑞士苏黎世联邦理工学院 27 青岛智能产业技术研究院 21 北京邮电大学网络与交换技术国家重点实验室 20 伦敦大学学院 18 中国科学院大学 18 南洋理工大学 17 卢森堡大学 17 萨斯喀彻温大学 16 中山大学 15 中国电子科技大学 15 新加坡国立大学 15 慕尼黑工业大学 15 西安电子科技大学 14 山东大学 14 坦普尔大学 14 普渡大学 14 中科院 14 新南威尔士大学 13 加利福尼亚大学 13 卡尔顿大学 13 中佛罗里达大学 13 亚利桑那州立大学 13 北京工业大学 13 伊利诺伊大学香槟分校 12 休斯顿大学 12 香港理工大学 12 斯坦福大学 12 意大利卡利亚里大学 12 英国南安普顿大学 12 澳大利亚莫纳什大学 11 塔尔图大学 10 广州大学 10 荷兰代尔夫特理工大学 10 德克萨斯大学圣安东尼奥分校 10 南京信息工程大学 10 康奈尔大学 10 欧道明大学弗吉尼亚建模分析与仿真中心 10 新加坡管理大学 10 依然单独抽离中国的组织 Author affiliation Count 青岛智能产业技术研究院 21 北京邮电大学网络与交换技术国家重点实验室 20 中国科学院大学 18 中山大学 15 中国电子科技大学 15 西安电子科技大学 14 山东大学 14 中科院 14 北京工业大学 13 香港理工大学 12 广州大学 10 南京信息工程大学 10 北邮、中科院、电子科大、西电依然在表中，但其它的大学则和SCI的统计数据略微不同。东北大学有八篇，其中四篇和SCI收录重合 国内CNKI数据的检索结果中，核心期刊被引量排名前200篇论文的作者与所属组织分布如下 会议如下 硕博论文如下，以区块链方向论文毕业的学生，专业有一半以上都位于计算机和通信。该领域毕业论文数量较多的学校如下图，这在一定程度上反映了该学校在此领域的研究热度，北京邮电不出意外是最多的。 ","date":"2018-11-17","objectID":"/2018/analysis-of-papers-published-in-blockchain-field/:5:0","tags":["科研记录"],"title":"背景调查2-近三年区块链方向论文发表情况总结","uri":"/2018/analysis-of-papers-published-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"6. 作者 以作者来看的话，SCI发表情况如下所示 SCI作者统计图片丢失 不过这种统计看起来有问题，比如Zhang Y，所有姓名中第二个字拼音首字母为Y的人都被统计进来了，不是一个人。因此换一种方法，将条件限制到领域中的高被引论文和热点论文，以及排在前五位的中国基金，查看第一作者的情况，最后得到15篇。这些作者包括 广东工业大学，Kang Jiawen，2篇 华南理工大学，Xia Qi 湘潭大学，Li Zhetao, Consortium Blockchain for Secure Energy Trading in Industrial Internet of Things 中山大学，Zheng Zibin, Blockchain challenges and opportunities: a survey 中山大学，Liu Hong 韩山师范，Lin Qun 丹麦技术大学，Meng Weizhi, When Intrusion Detection Meets Blockchain Technology: A Review 华北电力大学， Guan Zhitao 西安邮电大学，Zhang Yinghui 西安邮电大学，Guo Rui 上海大学，Su Zhou 奈良先端科学技术大学院大学，Zhang Yuanyu， Smart Contract-Based Access Control for the Internet of Things 中国电子科技大学，Chen Yi 北京理工大学，Gai Keke 广东工业的Kang Jiawen一个人发了两篇高被引，除此之外，中山大学两篇，西安邮电两篇。 EI的统计则是以全名为依据，重复概率较小，以柱状图来看，前十位中，王飞跃 和 袁勇都是中科院自动化所，后者第一作者身份发表的区块链文章更多，Xu Xiwei和Weber Ingo属于澳大利亚联邦科学与工业研究组织，Xu Lei为休斯顿大学，Lei Kai属于北京大学深圳信息中心网络与区块链技术重点实验室，Niyato Dusit南洋理工大学，Norta Alex爱沙尼亚塔林理工大学，Du Xiaojiang和Choo Kim-Kwang Raymond都没有发现一作论文。 不晓得国外的情况怎么样，国人名字为主的论文中，挂名情况严重，导致统计结果很不理想，一个人名下可能几十篇论文，但全是非第一作者，甚至全是后面无关紧要的作者，毫无参考价值。 课题组： 东北大学区块链实验室 ","date":"2018-11-17","objectID":"/2018/analysis-of-papers-published-in-blockchain-field/:6:0","tags":["科研记录"],"title":"背景调查2-近三年区块链方向论文发表情况总结","uri":"/2018/analysis-of-papers-published-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"7. 总结 总体就是这么个情况了，下面稍微做一些总结，列举我们可得到的一些结论 论文发表领域以计算机和通信为主 区块链领域的论文数量自2017年开始快速增长，2018年爆发，2019年与2018年持平，预计2020年将持平或更多，说明区块链领域依然火热 中美是区块链领域成果发表的主要国家 北邮、中科院、电子科大、北航、清华、西电、上交、国防科大、北大、中山、广东工业、北京理工是中国区块链的主要阵地，中山和广东工业在高被引论文方面位于前列 作者中，中科院自动化所的袁勇成果最为突出 ","date":"2018-11-17","objectID":"/2018/analysis-of-papers-published-in-blockchain-field/:7:0","tags":["科研记录"],"title":"背景调查2-近三年区块链方向论文发表情况总结","uri":"/2018/analysis-of-papers-published-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"如题，本文只关注重点的几方面 收录区块链的期刊、会议列表（将中国的单独分离） 期刊专题和会议的征稿通知，从中发现当前热点研究领域 基金项目信息中的负责人、研究机构、项目名，从而了解研究现状 下面分类讨论 ","date":"2018-11-14","objectID":"/2018/conference-journal-and-foundation-information-in-blockchain-field/:0:0","tags":["科研记录"],"title":"背景调查1-区块链方向的期刊、会议和基金收集","uri":"/2018/conference-journal-and-foundation-information-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"1. 期刊 期刊目录查询：SCI, EI, 北大核心, LetPub JCR分区 具体查看某个期刊是否被收录查看如何快速查询期刊收录情况这篇文章 查看影响因子和版面费情况查看SinoScript SCI的收录查询网址为 Master Journal List 以上都是完整的目录，包含各个领域，而对收录区块链方向论文的期刊列表，虽然理论上计算机和通信领域的期刊应该都是收录的，但还是根据上次对区块链领域已发布文献的总结，列举曾收录过区块链方向的论文数量较多的一些期刊。 期刊名 中科院分区 IEEE Access 2区 IEEE Internet of Things Journal 1区 Advances in Intelligent Systems and Computing 会议论文集 Sensors 3区 IEEE Transactions on Industrial Informatics 1区 Applied Sciences Basel 非计算机，4区 Future Generation Computer Systems 2区 Sustainability 非计算机，4区 IT Professional 3区 Communications In Computer And Information Science 会议论文集 Procedia Computer Science 会议论文集 Energies 非计算机，3区 International Journal of Information Management 非计算机，4区 Computers And Security 3区 Future Internet EI IEEE Transactions On Computational Social Systems EI Concurrency Computation Practice And Experience 4区 Information Sciences 2区 软件学报 计算机研究与发展 自动化学报 中国电机工程学报 电子与信息学报 计算机应用研究 通信学报 电子学报 计算机学报 专题征稿： Parallel and Distributed Computing，Special Issue on Blockchain-enabled Secure Communications in Smart Cities, 2020.02.28(Deadline) Sensors, Special Issue on Blockchain Security and Privacy for the Internet of Things, 2020.03.15(Deadline) 下面是输入关键词blockchain和iot从IEEE的期刊推荐工具得到的推荐期刊，删去影响因子大于5的，删去审稿期过长的，删去明显偏向某个领域的，删去收费的大致如下，最后三行期刊主页没有影响因子 Title Impact Factor 审稿期 IT Professional, IEEE 2.424 12周 Computers \u0026 Security, Elsevier 3.062 13周 Internet Computing, IEEE 2.891 6-12周 Security \u0026 Privacy, IEEE 1.596 6-12周 Computer, IEEE 3.564 12个月 Software, IEEE 2.945 6-12周 Potentials, IEEE Transactions On Computational Social Systems, IEEE Internet of Things Magazine, IEEE ","date":"2018-11-14","objectID":"/2018/conference-journal-and-foundation-information-in-blockchain-field/:1:0","tags":["科研记录"],"title":"背景调查1-区块链方向的期刊、会议和基金收集","uri":"/2018/conference-journal-and-foundation-information-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"2. 会议 会议以CCF推荐会议列表，CPCI-S会议列表，和EI会议列表为准，可以从以下这些网站查询 SCIEI Upcoming conferences： http://sciei.org/list-32-1.html 中国学术会议网： http://conf.cnki.net/ 中科院国际会议服务平台： http://csp.escience.cn/dct/page/1 world conference alerts： https://www.worldconferencealerts.com/ 不过最好用的还是WikiCFP，以下关于区块链的会议列表大部分来自于该网站的查询，剩下的来自于上次总结的收录区块链方向论文较多的会议列表。Deadline置空意味找不到下一届的信息，会议缩写没有链接意味着本届会议官网已失效，无法找到。 Conference Deadline ITNG-BT, Application, Challenges and Opportunities in Blockchain Technology(together with ITNG 2020), April 05-08, Las Vegas, Nevada, USA 2019.10.11 CyBlock, Workshop on Cyber Security and Blockchain(in COMSNETS 2020), January 07, 2020, Bengaluru, India 2019.11.29 IEEE Dapps 2020, The 2nd IEEE International Conference on Decentralized Applications and Infrastructures, April 13-16, 2020, Oxford, UK 2019.12.07 TGBT, 1st Workshop on Transparent Governance with Blockchain Technology(part of The 19th IFIP Conference on e-Business, e-Services and e-Society), April 06-08, 2020, Skukuza, Kruger National Park, South Africa 2019.12.15 ICBC 2020, IEEE International Conference on Blockchain and Cryptocurrency, May 03-06, 2020, Toronto, Canada 2019.12.19 AIBC 2020, 2020 International Artificial Intelligence and Blockchain Conference, Feb 18-20, Nagoya, Japan 2019.12.20 BlockArch 2020, 1st Workshop on Blockchain-Based Software Architecture(together with ICSA 2020), March 16-20, 2020, Salvador, Brazil 2020.01.08 BAT 2020, The Second International Workshop on Blockchain Applications and Theory(together with SDS 2020), April 20-23, 2020, Paris, France 2020.01.10 EdgeBlock 2020, IEEE International Symposium on Edge Computing Security and Blockchain(together with IEEE INFOCOM 2020), April 27, 2020, Beijing, China 2020.01.15 ICBCT 2020, 2020 The 2nd International Conference on Blockchain Technology, March 12-14, 2020,Hilo Hawaiii, USA 2020.01.15 BC for IoT CPS, Workshop on Blockchain for IoT and Cyber-Physical Systems(part of the IEEE International Conference on Communications), June 07, 2020, Dublin, Ireland 2020.01.20 BSCI 2020, The 2nd ACM International Symposium on Blockchain and Secure Critical Infrastructure, June 01-05, 2020, Taipei, China 2020.01.30 Blockchain 20, 2nd International Congress on Blockchain and Applications, June 17-19, 2020, L’Aquila, Italy 2020.01.31 ICBDB 2020, International Conference on Big Data and Blockchain, August 07-09, Newcastle upon Tyne, UK 2020.02.18 BCT4MAS2020, 3rd International Workshop on Blockchain Technologies for Multi-Agent Systems, June 17-19, 2020, Aquila, Italy 2020.02.20 Blockchain 2020, IEEE International Conference on Blockchain, August 02-06, 2020, Rhode Island, Greece 2020.03.01 COINS, IEEE International Conference on Omni-layer Intelligent systems(Track Name: Blockchain and DLT), July 27-29, 2020, Barcelona, Spain 2020.03.06 BIOTC 2020 , The 2020 Blockchain and Internet of Things Conference, July 08-10, Singapore 2020.03.20 Deep-BDB 2020, The 2nd International Conference on Deep Learning, Big Data and Blockchain, August 24-26, 2020, Rome, Italy 2020.03.12 CVCBT, Crypto Valley Conference on Blockchain Technology, June 11-12, 2020, Rotkreuz, Switzerland 未确定 IEEE HotICN 2019, IEEE International Conference on Hot Information-Centric Networking, Dec 13-15, 2019, Chongqing, China BSC, 2nd International Workshop on Blockchain and Smart Contracts, in 11th IFIP International Conference on New Technologies, Mobility \u0026 Security CBT, International Workshop on Cryptocurrencies and Blockchain Technology BlockSys, Workshop on Blockchain-Enabled Networked Sensor Systems CryBlock 2019, 2nd Workshop on Cryptocurrencies and Blockchains for Distributed Systems(co-located with INFOCOM 2019) CCF 区块链技术大会, 2019年10月11日-13日, 成都 CCF CBCS, 中国区块链技术与应用高峰论坛, 2019年5月31-6月2日，南京 CBD Forum, 中国区块链技术和产业发展论坛, 2019年12月26日，北京 WETSEB 2019, 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain IWBOSE, IEEE International Workshop on Blockchain Oriented Software Engineering BCC, ACM Workshop on Blockchain, Cryptocurrencies","date":"2018-11-14","objectID":"/2018/conference-journal-and-foundation-information-in-blockchain-field/:2:0","tags":["科研记录"],"title":"背景调查1-区块链方向的期刊、会议和基金收集","uri":"/2018/conference-journal-and-foundation-information-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"3. 基金 ","date":"2018-11-14","objectID":"/2018/conference-journal-and-foundation-information-in-blockchain-field/:3:0","tags":["科研记录"],"title":"背景调查1-区块链方向的期刊、会议和基金收集","uri":"/2018/conference-journal-and-foundation-information-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 老师推荐 NSF SBIR Phase I topics：Distributed Ledger (DL)，共包括15个子课题，如下 Autonomous Systems and Economies Blockchain, DAGs, and Next Gen Protocols Convergence with Big Data, and AI Convergence with IoT, Crowdsourcing and Crowdsensing Cryptography and Security Decentralized Applications (dApps); Smart Contracts Distributed Consensus; Fault Tolerance Mechanisms Distributed Ledger in Edge and Cloud Computing Distributed Ledger Interoperability Distributed Ledger in Network Architecture and Management Financial Technologies Human-to-Technology Interface Scalability Solutions Trusted Identity; Identity Management Other Distributed Ledger Technologies 有两个已获资助项目 SBIR Phase I: Blockchain based Logging Management System for IoT Devices SBIR Phase I: Subspace: A Decentralized Database of End-User Devices | SBIR.gov 注：SBIR，即Small Business Innovation Research ","date":"2018-11-14","objectID":"/2018/conference-journal-and-foundation-information-in-blockchain-field/:3:1","tags":["科研记录"],"title":"背景调查1-区块链方向的期刊、会议和基金收集","uri":"/2018/conference-journal-and-foundation-information-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 国内基金 从LetPub查询的国内区块链基金项目数据，以区块链为关键词，自2015年起有该方向基金申请，呈逐年上升态势，总计项目数量49个，资助总金额达到1899万。项目列表 其中，北京理工大学和南京邮电大学基金项目最多(3个)，北航、上交、同济、中科大和武汉大学其次(2个)。在物联网领域共有6个项目 黄鑫，西交利物浦大学，基于区块链的物联网计算模型及其基础机制研究 吴永东，暨南大学，基于区块链的物联网安全技术研究 张兰，中国科学技术大学，基于区块链的物联网安全技术研究 何云华，北方工业大学，基于区块链的分布式激励机制研究 李颉，上海交通大学，基于区块链的物联网安全技术研究 万志国，山东大学，面向大规模物联网的层次式区块链架构及安全研究 其它方向主要是区块链中的密码学机制研究、区块链基础理论中的扩展性、共识、智能合约等部分、区块链在各种场景中的使用。具体的列表如下： 负责人 单位 题目 一级学科 二级学科 三级学科 项目类型 刘园 东北大学 面向解决非诚信问题的基于区块链的电子商务个性化信誉系统 计算机科学 信息安全 信息安全 青年科学基金 王化群 南京邮电大学 基于区块链的数字资产复杂交易中相关密码协议研究 计算机科学 信息安全 安全体系结构与协议 面上项目 段美姣 中央财经大学 基于区块链的信息物理融合系统数据安全与隐私保护机制研究 计算机科学 信息安全 安全体系结构与协议 青年科学基金 孙知信 南京邮电大学 基于属性密码体制的区块链安全关键技术研究 计算机科学 计算机体系结构 并行与分布式处理 面上项目 过敏意 上海交通大学 基于区块链的分布式资源管理关键技术研究 计算机科学 计算机软件 并行与分布式软件 面上项目 吴宇 东莞理工学院 移动云计算中基于区块链技术的网络优化研究 计算机科学 计算机网络 计算机网络 青年科学基金 孙毅 中国科学院计算技术研究所 区块链系统性能优化理论模型及算法研究 计算机科学 计算机网络 计算机网络 面上项目 赵庆林 珠海澳科大科技研究院 基于PoUW区块链的数据处理研究 计算机科学 计算机网络 计算机网络 面上项目 盖珂珂 北京理工大学 基于DAG结构的高吞吐区块链构建方法研究 计算机科学 计算机网络 计算机网络体系结构 面上项目 许维胜 同济大学 区块链技术支撑下的能源互联网超网络建模与优化 自动化 控制系统 楼宇监测与控制系统 面上项目 张宗洋 北京航空航天大学 安全可扩展可插拔区块链共识机制研究 计算机科学 信息安全 密码学 面上项目 蒋芃 北京理工大学 基于区块链的公钥可搜索加密研究 计算机科学 信息安全 密码学 青年科学基金 陈家辉 广东工业大学 区块链系统中的多变量公钥密码学关键技术研究 计算机科学 信息安全 密码学 青年科学基金 叶青 河南理工大学 基于NTRU格上可链接环签名的区块链隐私保护技术研究 计算机科学 信息安全 密码学 青年科学基金 何德彪 武汉大学 面向区块链系统隐私保护的关键密码技术研究 计算机科学 信息安全 密码学 面上项目 魏凌波 中国科学技术大学 具有可证明安全与性能保障的区块链分布式共识协议研究 计算机科学 信息安全 密码学 青年科学基金 李文敬 南宁师范大学 基于区块链的群体智能服务交易关键技术研究 人工智能 智能系统与应用 群体智能与多智能体系统 地区科学基金 蔡维德 北京航空航天大学 可扩展私有区块链关键问题研究 计算机科学 计算机软件 软件工程 面上项目 张召 华东师范大学 面向高吞吐处理的区块链数据管理 计算机科学 计算机软件 数据库与数据工程 面上项目 黄鑫 西交利物浦大学 基于区块链的物联网计算模型及其基础机制研究 电子学与信息系统 信息系统 通信网络安全 青年科学基金 吴永东 暨南大学 基于区块链的物联网安全技术研究 计算机科学 计算机网络 网络安全 重点项目 张兰 中国科学技术大学 基于区块链的物联网安全技术研究 计算机科学 计算机网络 网络安全 重点项目 张佩云 安徽师范大学 面向用户信任需求和个性化交易的可信区块链关键技术研究 计算机科学 计算机网络 网络资源共享与管理 面上项目 何云华 北方工业大学 基于区块链的分布式激励机制研究 计算机科学 计算机网络 物联网 青年科学基金 李颉 上海交通大学 基于区块链的物联网安全技术研究 计算机科学 计算机网络 物联网 重点项目 祝烈煌 北京理工大学 基于区块链的数据隐蔽传输机制研究 计算机科学 信息安全 系统安全 联合基金项目 万志国 山东大学 面向大规模物联网的层次式区块链架构及安全研究 计算机科学 信息安全 系统安全 面上项目 陈艳姣 武汉大学 基于区块链的数据隐藏传输机制研究 计算机科学 信息安全 系统安全 面上项目 董雪文 西安电子科技大学 基于区块链的智能服务跨域安全组合技术研究 计算机科学 信息安全 系统安全 面上项目 赵赫 中国科学院合肥物质科学研究院 基于区块链技术的数据真实性保障方法研究 计算机科学 信息安全 系统安全 青年科学基金 邓小鸿 江西理工大学 基于区块链的个人健康数据保护机制研究 计算机科学 计算机应用技术 新应用领域中的基础研究 地区科学基金 李皎 西安石油大学 考虑信任度和权值的区块链数据通信性能优化研究 计算机科学 计算机应用技术 新应用领域中的基础研究 青年科学基金 赵相福 浙江师范大学 面向区块链智能合约漏洞自动检测与修复的符号逻辑建模与推理 计算机科学 计算机应用技术 新应用领域中的基础研究 面上项目 朱晓荣 南京邮电大学 基于区块链和机器学习的移动边缘云网络可信协作机制和资源优化方法 电子学与信息系统 移动通信 移动通信系统 面上项目 徐志宇 同济大学 区块链赋能的下一代智能电网主动能量体社群P2P交易行为建模、规则设计与复杂性分析 自动化 系统工程理论与技术 资源、能源管理系统与优化 面上项目 ","date":"2018-11-14","objectID":"/2018/conference-journal-and-foundation-information-in-blockchain-field/:3:2","tags":["科研记录"],"title":"背景调查1-区块链方向的期刊、会议和基金收集","uri":"/2018/conference-journal-and-foundation-information-in-blockchain-field/"},{"categories":["研究生的区块链学习之路"],"content":"区块链里最基本也是最重要的几个概念是地址、交易、区块、网络。比特币用地址来标识一笔交易的支出方和接收方。所有的交易最终需要被记到统一的账本（也就是区块链）上，而这个账本是通过区块确认并完成的。每一个新区块的产生，都会被打上时间戳（区块头里的一个字段，是真的时间，后面详细介绍），最终生成按照时间前后排列并加以记录的电子交易证明。每个独立节点之间又通过比特币网络来建立联系，这样就组成了一个去中心化、分布式的电子交易记录时间戳服务器系统。比特币通过构造这个分布式时间戳服务器来解决双重支付问题。 注：文章主体引自“张健. 区块链，定义为了金融与经济新格局[M]. 北京：机械工业出版社. 2016:162-177”，中间有补充和删减，补充都直接上了链接，所以文末就不放参考文献了。 ","date":"2018-11-12","objectID":"/2018/bitcoin-fundamentals/:0:0","tags":["区块链"],"title":"区块链学习2-比特币基本原理","uri":"/2018/bitcoin-fundamentals/"},{"categories":["研究生的区块链学习之路"],"content":"1. 地址 比特币地址的生成步骤如下： 生成椭圆曲线私钥与公钥。 将公钥通过SHA-256哈希算法处理，得到32字节的哈希值。 对于得到的哈希值，通过RIPEMD-160算法来得到20字节的哈希值——Hash160。 把由版本号+Hash160组成的21字节数据进行双次SHA-256哈希运算，得到的哈希值的前4字节作为校验和，放置在21字节数据的末尾。 对组成的25字节数组进行Base58编码，就可得到地址。 注：椭圆曲线算法私钥32字节，通过私钥可以算出公钥，公钥65字节，压缩后都有33字节，太长了，没法直接当地址 整个过程如下图所示，可以看出，地址是由公钥经过一系列哈希算法及编码算法得到的，所以，地址其实是公钥的另一种表现形式，可以理解为公钥的摘要。我们花费自己的资产时，要使用地址（公钥）对应的私钥做签名，然后发送给接收方地址（公钥）。更详细的地址生成描述见 比特币地址生成算法详解。 ","date":"2018-11-12","objectID":"/2018/bitcoin-fundamentals/:0:1","tags":["区块链"],"title":"区块链学习2-比特币基本原理","uri":"/2018/bitcoin-fundamentals/"},{"categories":["研究生的区块链学习之路"],"content":"2. 交易 在中本聪的白皮书里，比特币被定义为一个链式的数字签名串。每一位电子货币的所有者通过这样的方式将它转移给下一位所有者：对前一个交易和下一位所有者的公钥签署一个数字签名，并将这个签名附加在交易的末尾。收款人通过验证签名，就可以验证电子货币的所有者链条。交易的运作图如下。 这类交易体系的问题在于收款人很难校验之前的某位资产拥有者是否进行了双重支付（双花）。通常的解决方案是引入可信的第三方如银行来对每一笔交易进行检验，以防止双重支付。而如果想要排除第三方中介机构，那么交易信息就应当被公开，且需要整个系统内的所有参与者都有唯一公认的历史交易序列。收款人需要确保在交易期间系统内的绝大多数节点都认同该交易是首次出现。 2.1 交易结构 比特币的交易实质是转账。如果每一笔转账都需要构造一笔交易数据，那么显得比较笨拙。为了使得价值易于组合与分割，比特币的交易被设计为可以纳入多个输入和输出，即一笔交易可以转账给多个人。从生成到在网络中传播，再到通过工作量证明、整个网络节点验证，最终记录到比特币的区块链，这就是交易的整个生命周期。交易的本质是一个包含交易发送方、接收方、资产转移等相关信息的数据结构，其数据结构如下表所示。 字段 描述 大小 版本(Version) 这笔交易参照的规则 四字节 输入数量(In-counter) 交易输入(TxIn)列表的数量 1-9字节 输入列表(Out-counter) 一个或多个交易输入 不定 输出数量(Lock time) 交易输出(TxOut)列表的数量 1-9字节 输出列表 一个或多个交易输出 不定 锁定时间 锁定时间 4字节 从整体结构来看，交易中的两个主要单元字段就是交易的输入与输出。输入标识着交易的发送方，输出标识着交易的接收方及对发送方的找零，交易的手续费则是输入的总和与输出的总和之差。由于所有的交易输入必然是前面某笔交易的输出，所以交易最核心的字段是交易的输出。一笔交易的数据结构如下图所示。 2.2 UTXO结构 比特币系统是没有余额的概念的，它使用的是UTXO模型（Unspent Transaction Outputs，未使用过的交易输出）。UTXO是比特币交易生成及验证的一个核心概念。交易构成了一组链式结构，所有合法的比特币交易都可以追溯到前一个或多个交易的输出，这些链条的源头都是挖矿奖励，末尾则是当前未花费的交易输出。所有的未花费的输出即为整个比特币网络的UTXO。 比特币规定每一笔新交易的输入必须是某笔交易未花费的输出，每一笔输入同时也需要上一笔输出所对应的私钥进行签名，并且每个比特币的节点都会存储当前整个区块链上的UTXO，整个网络上的节点通过UTXO及签名算法来验证新交易的合法性。下图是比特币系统中交易输入输出的过程： 比特币的交易输入通常有3种，分别是标准输入（Standard TxIn）、花费挖矿奖励（Spend Coinbase TxOut）、产生挖矿奖励（Coinbase/Generation），下图分别描述了这三种交易输入的结构。 比特币的交易输出大致有两种，分别是标准交易输出（Standard TxOut）、挖矿奖励输出（Coinbase TxOut），下图分别描述了这两种交易输出的结构。 2.3 脚本 脚本是交易里另一个比较重要的技术。每一笔交易的每一项输出，严格意义上讲并不是指向一个地址，而是指向一个脚本。脚本类似于一套规则，它约束着接收方怎样才能花掉这个输出上锁定的资产。 交易的合法性验证也依赖于脚本。目前它依赖于两类脚本：锁定脚本与解锁脚本。锁定脚本是基于可变的模式，通过一段脚本语言来实现，位于交易的输出。解锁脚本与锁定脚本相对应，只有按锁定脚本的规则去解，才能花掉这个脚本上对应的资产，位于交易的输入。脚本语言可以表达出无数的条件变种。这也是比特币作为一种“可编程的货币”所拥有的特性。而解释该脚本是通过类似于编程领域里的“虚拟机”进行的，脚本分布地运行在比特币网络里的每一个节点上。 目前常用的比特币脚本主要分为两种，一种是普通的P2PKH类型（Pay-to-Public-KeyHash），即支付给公钥的哈希值是地址，接收方只需要使用地址对应的私钥对该输出进行签名，即可花掉该输出。另一种是P2SH（Pay-to-Script-Hash），支付脚本的哈希值。拿多重签名来举例，它要求该输出要有N把私钥中的M把私钥（M≤N）同时签名才能花掉该资产，它类似于现实生活中需要多把钥匙才能同时打开的保险柜，只是更加灵活。 比如在比特币中，P2PKH的脚本规则如下： pubkey script： op_dup op_hash160 \u003cpubkeyhash\u003e op_equalverify op_checksig signature script： \u003csig\u003e\u003cpubkey\u003e P2SH的脚本规则如下： pubkey script： op_hash160 \u003chash160（redeemscript）\u003e op_equal signature script： \u003csig\u003e [sig] [sig...] \u003credeemscript\u003e 在上述的两种脚本规则里，Pubkey script代表着锁定脚本，Signature script代表着解锁脚本。以OP_开头的单词是相关的脚本命令，也是“虚拟机”所能解析的指令。这些命令规则根据Pubkey script的不同来进行划分，也决定着解锁脚本的规则。 比特币中的脚本机制相对简单，只是一个基于堆栈的、解释相关OP指令的引擎，能够解析的脚本规则并不是太多，不能实现很复杂的逻辑。但它为区块链可编程提供了一个原型，后续的一些可编程区块链项目其实是基于脚本的原理发展起来的，比如，以太坊就深入强化了脚本机制，该脚本机制不再只包括简单的OP指令，而是支持脚本语言，该脚本语言可以通过“虚拟机”去执行。以太坊实现了一个支持图灵完备脚本语言的区块链平台。 脚本机制对于区块链来说非常重要，它类似于区块链技术提供的一个扩展接口，任何人都可以基于这个接口去开发基于区块链技术的应用，比如智能合约的功能。脚本机制也让区块链技术作为一项底层协议成为可能。未来很多基于区块链的颠覆性应用，都可能是通过区块链的脚本语言来完成的。 ","date":"2018-11-12","objectID":"/2018/bitcoin-fundamentals/:0:2","tags":["区块链"],"title":"区块链学习2-比特币基本原理","uri":"/2018/bitcoin-fundamentals/"},{"categories":["研究生的区块链学习之路"],"content":"3. 区块 比特币网络中每个（挖矿）节点都基于已存在的最新区块生成下一个区块，同时将网络中未确认的合法交易包含进去。在完成工作量证明之后，将新的区块广播到全网，同时获得区块的奖励，这个过程就是将所有的交易打上时间戳标记的过程。由于只有最长链上的区块才能够获得奖励，这导致了所有的挖矿节点被利益驱使，形成唯一最长链的结果，从而达成记账系统共识的一致性，保证了整个体系的可靠与安全。而要了解这些过程，我们就必须先了解一下区块相关结构及区块链中所使用的相关技术与原理。 3.1 区块结构 比特币网络里合法的交易都会被打包成一个区块，包含到比特币的公开账本（区块链）里。区块由包含元数据的区块头和紧跟其后的交易列表组成。区块数据结构如下表所 字段 描述 大小 魔术码 固定值 0xD9B4BEF9 4字节 区块大小 用字节表示该段之后的区块大小 1-9字节 区块头 包含6个字段 80字节 交易数量 交易列表长度 1-9字节 交易列表 记录到区块的交易信息列表中 不定 区块数据的核心示例结构如下图所示。 区块由区块头及该区块所包含的交易列表组成。区块头的大小为80字节，由4字节的版本、32字节的上一个区块的哈希值、32字节的Merkle Root Hash、4字节的时间戳（当前时间）、4字节的当前难度值、4字节的随机数等组成。区块所包含的交易列表则附加在区块头后面。比特币网络约定每个区块的第一笔交易是coinbase交易，这是一笔为了让矿工获得奖励及手续费的特殊交易。 3.2 Merkle Tree 区块包含的所有交易首先都会通过Merkle Tree算法生成Merkle Root Hash并存储至区块头的数据结构里。Merkle Tree算法是用来同步数据一致性的算法，它基于一组哈希值列表构建成一个树，树的根哈希值作为原始数据列表的摘要。Merkle Tree具有以下特点： 数据结构是一个树，可以是二叉树，也可以是多叉树。 Merkle Tree的叶子节点的值是数据集合的单元数据或者单元数据的哈希值。 Merkle Tree的非叶子节点的值是所有叶子节点值的哈希值。 区块中所使用的Merkle Tree算法的原理如下图所示。 3.3 时间戳服务器 为了实现一个点对点的电子现金系统，中本聪提出了“时间戳服务器”方案。时间戳服务器对以区块形式存在的一组数据实施随机哈希处理，加上时间戳，并将该随机哈希值进行广播。显然，该时间戳能够证实特定数据于某特定时间是的确存在的，因为只有在该时刻存在了，才能获取相应的随机哈希值。每个时间戳应当将前一个时间戳纳入其随机哈希值中，每一个随后的时间戳都对之前的一个时间戳进行增强（Reinforcing），这样就形成了一个链条（Chain）。 ","date":"2018-11-12","objectID":"/2018/bitcoin-fundamentals/:0:3","tags":["区块链"],"title":"区块链学习2-比特币基本原理","uri":"/2018/bitcoin-fundamentals/"},{"categories":["研究生的区块链学习之路"],"content":"4. 网络 比特币采用了基于P2P（Peer to Peer）的网络架构。P2P是指位于同一网络中的每台计算机都是彼此公平、对等的，各个节点共同提供网络服务，不存在任何“特殊”（中心）节点。P2P网络通信本身并不是比特币独有的发明，在比特币之前就已经被应用于文件共享领域了。比特币被设计成一个点对点的数字现金系统，而P2P正好是这个理念的核心特征的反映，也是该特征的基石。抛开比特币客户端的钱包功能来看，运行在每一台机器上的比特币核心程序就是比特币P2P网络中的一个节点。每个节点之间互联，组成了比特币网络，保证了整个比特币系统的安全。 比特币网络的相关功能如下： 新交易广播到全网的节点，每个节点会收到交易消息。 每个（挖矿）节点将新交易收集到节点的内存，并组装成区块。 每个（挖矿）节点都尝试在自己的区块中找到一个具有足够难度的工作量证明。 （挖矿）节点找到一个工作量证明，把有效的区块数据向全网进行广播。 当且仅当包含在该区块中的交易都是有效的，并验证其完成了工作量证明，其他节点才认同该区块的有效性。 其他（挖矿）节点表示接受该区块，并在该区块的末尾制造新的区块以延长整个区块的链条。 在比特币网络中，交易和区块信息的传播是通过洪水算法（Flooding Algorithm）进行的。简单地说，就是每一个收到信息的节点，向与它相连的所有节点推送该信息。下一个收到信息的节点继续这个过程，信息很快就会像洪水一样覆盖全网络。可见，传播速度是呈指数增长的。通常在一两秒内，交易或者区块的信息就可以传遍全网。 节点始终都将最长的链条作为正确的链条，在它的基础上持续工作并延长它。如果有两个节点同时广播不同的基于上一个区块的新区块，那么其他节点在接收到该区块的时间先后上将存在差别。在此情形下，它们将在率先收到的区块基础上进行工作，但也会保留另外一个链条，以防后者变成最长的链条。该僵局的打破要等到下一个区块（工作量证明）被发现，当其中的一条链条被证实为是较长的一条时，在另一条分支链条上工作的（挖矿）节点将转换阵营，开始在较长的链条上工作。 所谓“新交易的广播”，实际上不需要抵达网络中的全部节点，只要交易信息能够抵达足够多的节点，它们将很快被整合进一个新的区块中。而区块的广播对被丢弃的信息进行容错处理。如果一个节点没有收到某特定区块，那么该节点将会发现自己缺失了该区块，就会向较长链的节点发出下载该缺失区块的请求。 比特币网络中的矿工们不停地在最新的区块基础上构造下一个区块，通过算力竞争来争取记账权（将新区块写到比特币的区块链的机会），确认网络的转账交易，同时获取区块奖励。由于每一个区块都包含上一个区块的哈希值，通过这个前向的哈希值，区块以链条的形式进行相连，最终形成了由各个区块组成的记账系统——区块链。而确保这一切运转正常的正是我们接下来要讲的共识算法。 ","date":"2018-11-12","objectID":"/2018/bitcoin-fundamentals/:0:4","tags":["区块链"],"title":"区块链学习2-比特币基本原理","uri":"/2018/bitcoin-fundamentals/"},{"categories":["研究生的区块链学习之路"],"content":"在文献管理方面的需求包括： 文献可以方便地导入工具中并提取准确丰富地文献信息 工作和学习时，可以快速在工具中找到自己想要的文献 在写作时，可以方便的导出工具中的文献 由于 Zotero 没有内置的 PDF 阅读工具，因此忽略阅读层面的需求，除此之外，最大的缺点是没有移动端的应用程序。下面分别就几个主要的方面探索使用技巧。 注：本文主要参考 少数派-文献管理神器 Zotero 学习路径指南 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:0:0","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"1. 文献导入 Zotero 支持多种导入方式，包括： 通过 Zotero Connector 浏览器插件导入 输入文献对应的 ISBN、DOI、PMID 或 arXiv ID 来导入 复制 BibTex 信息从剪贴板导入 从文件（BibTeX, RIS, Zotero RDF等）导入 将下载好的PDF文件直接拖入软件，然后自动提取文件中的元数据 自行添加 经过实践，通过输入 DOI 或 arXiv ID 导入的文献信息最为丰富，因此有条件的情况下应采用这种方式。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:1:0","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"1.1 通过标识符添加 单击 Zotero 窗格中间列顶部的「通过标识符添加条目」按钮，输入标识符后按 Enter。如果要一次输入多个标识符，在输入第一个标识符后按 Shift + Enter 可以进入多行模式，随后输入其余标识符（每行一个），并通过 Enter 换行。输入完成后，再按 Shift + Enter 即可一次导入所有文献，示例如下图，是否带有「DOI:」或「arXiv:」前缀不影响导入效果，下图中第一条和第三条是 DOI，中间一条是arXiv ID。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:1:1","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"1.2 通过 feed 进行订阅 文献需要及时跟踪，通常是通过邮件订阅或者RSS，Zotero 本身提供了一种简单的订阅方法，相比于前两种，这种方式更受我喜爱，也是现在主要使用的方式。以 IEEE Internet of Things Journal 期刊为例，在 期刊主页 获取订阅链接（和RSS订阅的链接是一样的），然后在 Zotero 中点击左上角的「新建文献库」按钮，选择「新建订阅」，然后选择「来自URL」 在弹出的「订阅设置」对话框中填入刚刚复制的链接（URL），稍等一会儿就会自动获取到标题，最后在「高级选项」中设置更新频率等信息。 保存之后稍等一会儿就可以看到订阅的情况，之后会按照我们设置的时间每24小时更新一次，也可以在右键菜单中主动更新。订阅的论文并不在我们的文献库中，需要手动添加。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:1:2","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"2. 文献和笔记管理 文献管理的目的在于需要时快速而准确的找到所需论文，笔记则提供记录思维的工具。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:2:0","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"2.1 分类与标签 分类指的是多个层级的文件夹，这里我的命名规则是不同时期的研究方向，虽然总的划分是区块链，但在不同时期，可能关心不同的领域，比如 access control 或 anomaly detection。有些论文可能从属于不同的分类，可以在一个分类中添加后拖动到另一个分类中，这里的拖动产生的是复制操作，不是剪切，而且，两者指向同一个 论文条目和 PDF 文件，不会产生存储冗余。因此，在删除一篇论文时，可以选择「从分类中移除条目」或「删除条目」，前者只会从当前分类移除论文的链接，如果其它分类中也有该文献，不会受到影响，如果其它分类中没有该文献，文献被移动到「未分类条目」。 除了分类外，还可以为每个文献添加若干标签。为了避免使用维度的重合，标签体系中无必要情况不应再按照研究的领域进行命名，若有必要，先考虑使用「子分类」的方式。我对标签的使用是在应用维度，首先，新加入的文献放入它所属分类中，然后添加「未读」标签，这是因为很多时候添加文献都是批量添加的，然后才慢慢看，等到看完后，删除「未读」标签，添加重要性标签。使用「P1、P2 和 P3」对文献的重要性进行分级，P1 最重要，P3 最不重要，重要性的划分依据这篇论文的热度、引用数和自己感觉，有些论文是领域内公认权威的，引用数爆表，比如每个领域的起始文献，有些论文是自己看完感觉有很多想法可以实践，或者感觉思路很好有借鉴意义，可以添加「P1」标签。最后一个是写作时的分类，将文献划分为「中期」「毕业」「小论文」等几个使用场景，然后添加这些标签。 每个标签可以设置对应的颜色，这个色块会自动的显示在每个条目的开头，方便查看，Zotero 中只提供了9中颜色待选，不过已经足够了，通常我们使用的不超过3个。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:2:1","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"2.2 内容寻找 基本的查找思路依然是分类和标签，对于最后得到的结果，可以按照文献相关信息进行排序，比如标题、创建者或者文献类型等。最后，在此基础上，Zotero 还支持对结果进行二次排序。 另外一种查找方法是快速搜索，搜索内容包括标题、创建者等文献信息和标签，在 PDF 文档已建立的情况下，选择「所有内容」甚至可以搜索到文档的文本。 另外，Zotero 的高级搜索还提供和 Web of Science 等文献数据库类似的功能，可以通过文献信息和各种逻辑运算符来控制筛选条件。单击主界面上方的放大镜图标或者在工具栏的「编辑」菜单中可以打开高级搜索窗口。 最后，不同的文献之前、文献和笔记之间都可以进行关联，我们可以将一些相关的文献关联到一起。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:2:2","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"2.3 笔记 每一篇文献支持插入多个笔记，默认的笔记是富文本格式，但由于 Zotero 的插件和 Chrome 或 Firefox 等浏览器的插件格式相同，只需要将浏览器的 markdown-here 插件重新打包然后导入 Zotero1，即可支持 Markdown 语法。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:2:3","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"3. 文献导出 在书写论文的过程中插入参考文献是最重要的需求之一，也是文献管理软件存在的意义之一，很多人都是因为这个需求才开始使用文献管理软件。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:3:0","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 平时使用 指的是在自己的博客或者笔记中插入引用，因为不需要遵守严格的引用需求，可以使用直接拖拽的方式，单篇或多篇文献都可以，非常方便。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:3:1","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 在 Microsoft Word 中编辑论文 Zotero 提供相关的加载项供使用，通常在软件安装时就会提示自动安装，也可以自己到「首选项—\u003e引用—\u003e文字处理软件」中进行安装。 安装好后打开 Word 可以看到该插件 各按钮功能介绍如下 在正式插入引文之间，需要设置引文的格式，通过管理样式可以轻松找到海量的引文格式。 在需要添加引文的位置点击「Add/Edit Citation」按钮，调出引文搜索 在出现的搜索框中输入一个标题或作者等搜索特定的参考文献 一旦选中，点击气泡或按下「Ctrl + ↓」添加页码、前缀或后缀 可以一次选择多篇文献，最后按「Enter」即可将文献引用添加到文档中，不过如下图所示，此时添加的只是下标 添加新行并移动光标到新行末尾，点击「Add/Edit Bibliography」将参考书目加入文档。 添加新的引文或文献编辑完成后可以点击刷新更新所有引文和参考书目 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:3:2","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 在 Latex 中编辑论文 此时的核心是导出 BibTex 文件，由于原始的导出功能不够完善，导出的字段也无法自定义，因此需要安装 Better BibTex插件。 导出时，选择所有需要的文献，在右键菜单中选择「导出条目」，然后选择「Better BibTex」格式，点击OK即可导出 bib 文件。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:3:3","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"4. 其它事项 主要指同步和协作、插件系统和Zotero的其它高级功能。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:4:0","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"4.1 备份与协作 Zotero 本身只提供 300M 免费的存储空间，这些空间存储 PDF 文档完全不够，很多文章包括官方都推荐使用 WebDAV 服务，但国内支持的好像只有「坚果云」。因为我的主力软件是 OneDrive，所以这里介绍 Zotero 如何与 OneDrive 配合来存储PDF文件。 Zotero 的数据和文件的同步是分离的，数据指的是文献的分类、标签和各种元数据信息，文件指的是PDF和笔记等各种附件，这就给了我们机会2。如上图所示，在「同步」设置页面，对数据同步的选项全部勾选，而文件同步的选项全部取消勾选。 然后切换到「高级—\u003e文件和文件夹」选项卡，点击打开数据文件夹，获取数据文件的存储路径。 所有的附件（包括PDF和笔记）都存储在数据文件夹的storage目录下。我们可以采用软链接3的方式来管理这些文件，建立软链接后，原数据文件夹下的storage文件夹成为一个快捷方式，指向OneDrive存储空间的实际文件，因此不会占用大量存储空间。在命令行中使用如下命令建立原始路径和新路径的软链接，记得执行命令前删除原 storage 文件夹，否则会报错。 mklink /j C:\\Users\\lylw1\\Zotero\\storage F:\\OneDrive\\课题\\论文库 /j参数以绝对路径的方式创建软链接，将所有源文件夹文件移动到新文件夹后，清空源文件夹，这样可以保证旧的附近不再占用存储空间 C:\\Users\\lylw1\\Zotero\\storage是所有文件的原始路径 F:\\OneDrive\\课题\\论文库是所有文件的新路径，位于 OndDrive 存储库中，新的文件夹名不必和原来的storage相同，可以任意命名。 如果想迁移到新的位置，按如下步骤执行 删除 C:\\Users\\lylw1\\Zotero\\storage 中的源文件夹 使用上述命令建立指向新位置的软链接 将 F:\\OneDrive\\课题\\论文库 中的文件复制到新的目标文件夹中 如果想要对软链接的目标文件夹更名，可以采用和迁移相同的方式，需要注意的是，一定要注意目标文件夹内数据的完整性，如果被破坏，那么链接将不再起作用。最后，如果嫌弃这种方式比较麻烦，可以选择使用插件 ZotFile。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:4:1","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"4.2 插件系统 插件系统是 Zotero 的一大优势，前面已经提到了几款插件，更多插件可以通过 官方插件网站 进行查看，或者自行在网上搜索安装。一些推荐的插件如下 Better BibTex：Make Zotero useful for us LaTeX holdots. Markdown Here：用 Markdown 书写笔记 Zotero DOI Manager：Zotero plugin for auto-fetching and validating DOI and shortDOIs papermachines：文献可视化 Zotero Scihub：自动从 sci-hub 下载文献的 PDF ZotFile：管理 PDF 文件 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:4:2","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"4.3 时间轴 Zotero 有个时间轴功能，可以将所有文献反映在一条时间轴上，时间可以是文献的发表日期、添加日期和修改日期，时间轴的跨度单位可以是日、月、年、十年、百年等，不过这个功能不常用，目前没有想到这个功能的意义。 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:4:3","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"4.4 小技巧 当选择了一个项目时，可以通过按住 Option(Ctrl) 键突出显示包含此项目的所有集合，也就是知道这篇文献所在的分组 在集合列表或项目列表中的键盘上按 +（加号）可以展开所有节点，按 -（减号）则可以折叠 要查看所选库或集合中的项目数可以单击然后使用 Command-A(Ctrl-A) 全选，计数将显示在右侧 若使用快速复制功能，在将项目拖放到文本文档时按住 Shift 键能实现插入引文而不是完整引用 可以单击详细信息中的 DOI 和 URL 字段标签直接打开链接 ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:4:4","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"5. 最后 主流的文献管理工具还有 Endnote ：老牌且知名的文献管理工具，付费价格相对较贵但多数高校和科研机构会统一购买，移动端（iPad）使用体验优秀。 Mendeley ：2013 年以开源软件身份被 Elsevier 高价收购，背靠大树。 不过很多人推荐Papers，除了基本的文献和笔记管理外，还有界面美观和内置PDF阅读器两个优点，说实话很心动，但是要付费订阅，如果走科研道路就算了，可惜并没有打算读博。 Zotero导入Markdown here插件 ↩︎ 利用ONEDRIVE同步ZOTERO数据文件夹的方法 ↩︎ windows中的软链接硬链接等 ↩︎ ","date":"2018-11-11","objectID":"/2018/introduction-to-zotero/:5:0","tags":["科研记录"],"title":"科研基础2-文献管理工具 Zotero 学习指南","uri":"/2018/introduction-to-zotero/"},{"categories":["研究生的区块链学习之路"],"content":"1. 常用名词 与学术研究和论文相关的，有许多常用的名词，本节对这些名词作解释和区分。 会议组织者：可能是某个学校或某个组织，为了学术或经济利益举办会议，从科研工作者处收取论文和注册费，然后将论文集交给出版商出版 出版商：比如Elsevier/Springer/IEEE，他们运行和维护期刊，收取投稿论文进行审阅，最后以纸质、光盘和电子版本形式发行供科研工作者查看，各种举办的会议收到的文章最后也都会交给出版商出版。出版商拥有所收到的论文的版权，也会向会议组织者收取出版费用，向期刊投稿者收取版面费，最后放在自己的数据库中，再向需要论文访问权限的学校、研究机构或个人收取查看的费用。 国内的出版商相比来说比较孤立，一般由各协会或大学建立，一种期刊一个出版商，没有形成国外出版商的垄断规模，比如计算机学报、软件学报、北京大学学报、东北大学学报等。 收录：出版商或其它机构建立的论文数据库，科研工作者从这些数据库中寻找和阅读论文。出版商建立的数据库(如IEEExplorer, ScienceDirect)一般是需要付费的，但属于全文数据库，意思是可以看到整篇论文的内容。其它机构建立的数据库是从各出版商的数据库中抓取公开的内容，比如题目、摘要、参考文献等，无法看到整篇论文的内容，但根据收录的论文质量的差别，逐渐形成口碑，被科研工作者广泛采用，如SCI和EI。还有些机构或私人建立的数据库，如SCI-Hub，是苦于出版商高额的收费价格私自建立的全文数据库，没有版权，是非法的，但鉴于当前出版商的垄断行为，这种数据库被越来越多的人使用。 国内的数据库机构相比来说具有垄断性质，学术论文普遍归属中国知网(CNKI)，虽然各期刊官网本身也可以检索，但只包括一种期刊，不如知网便利。 检索：检索的含义是从数据库中寻找符合条件的论文，一般来说论文数据库本身都提供对用户的检索接口，如IEEE xplorer、ScienceDirect、Web of Science、Engineering Village等，现如今，搜索引擎厂商也提供对论文的检索功能，具有一定影响力及被广泛使用的有Google Scholar、Bing学术、百度学术等 IF：Impact factor，期刊影响因子，是代表期刊影响大小的一项定量指标，实际上是某期刊在某年被全部源刊物引证该刊前两年发表论文的次数，与该刊前两年所发表的全部源论文数之比。 JCR：Journal Citation Reports，期刊引证报告，是由一些机构对大量期刊之间引用和被引用数据进行统计，并根据IF进行分类统计并发布的报告，目前有影响力的是中科院的JCR和汤森路透JCR。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:1:0","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"2. 出版商 中国的期刊发行机构一般是各协会、研究所、大学，然后选择某个常规出版商出版，通常一本期刊属于一个机构或多个机构合作，比如计算机学报由中国计算机学会和中科院计算技术研究所共同主办，科学出版社出版，东北大学学报由东北大学主办，东北大学出版商出版，因此不构成垄断形式的影响力，在此不进行讨论。 国外的出版商已逐渐形成几大垄断性质的集团，把持了全球学术出版的各个方面，论文从投稿、发表到查看的全流程都少不了它们的参与，因此逐个进行介绍。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:2:0","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"Elsevier Elsevier，中文名爱思唯尔，1880年创建于荷兰，现今总部位于阿姆斯特丹，产品与服务包括期刊、图书专著、教科书和参考书的纸板和电子版，出版领域覆盖医学、生命科学、自然科学和社会科学等，公司每年出版超过2000种期刊，包括Lancet(柳叶刀)和Cell(细胞)等世界著名杂志。其标识是爱思唯尔之树，是一个长者站在葡萄藤缠绕的榆树下，刻有拉丁文“Non Solus”(永不孤单)。 爱思唯尔旗下的数据库是ScienceDirect，主要查询该公司自己出版的文献，到现在为止收录了3800多种期刊和35000多部图书，是一个主流的论文数据库平台。 文献管理工具Mendeley也是爱思唯尔旗下，这是当今主流的文献管理工具之一。 一些参考网址列举如下 Elsevier介绍： https://www.elsevier.com/zh-cn/about/our-business ScienceDirect介绍： https://www.elsevier.com/zh-cn/solutions/sciencedirect Elsevier出版的图书和期刊目录： https://www.elsevier.com/catalog 除了上面提到的医学界的顶级期刊柳叶刀和生命科学界的顶级期刊Cell属于Elsevier外，还有大量期刊和图书属于它，详情查看上面的第三个链接。不过，ScienceDirect种收录的期刊全文都不是免费的，多年来学术界一直致力于反抗Elsevier的垄断行为，名为The Cost of Knowledge的抵制活动现如今已得到33383人的参与，参与这一活动的网址为 http://thecostofknowledge.com/ ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:2:1","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"Springer Springer，中文名施普林格，1842年创立于德国，现今总部位于柏林， 拥有超过2900种期刊和300,000本图书，每年出版6,500余种科技图书和约2,000余种科技期刊，涉及到医学、心理学、生物医学、生物、数学、物理、经济学、法律等多种学科。 鼎鼎大名的Nature期刊现在就归属于Springer，是在2015年1月合并的。 旗下的论文检索数据库为Springer Link，不过大多数情况都是因为图书检索到它 一些参考网址如下 Springer历史： https://www.springer.com/cn/about-springer/history Springer产品与服务： https://www.springernature.com/gp/librarians/products Springer是目前全球最大的书籍出版商，第二大期刊出版商(第一是Elsevier) ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:2:2","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"Wiley Wiley，译为约翰威立或不翻译，1807年创立于美国，出版了超过350位不同领域诺贝尔奖得主的作品，是世界第三大期刊出版商，也是全球最大的学协会出版商。 拥有1600+种期刊，其中1200+种期刊被JCR收录。 出版涵盖学科范围包括化学、材料科学、信息技术及计算机、工程学、数学与统计、物理与天文学、商业、 人文科学、教育及法律、心理学、社会科学、 生命科学、医学等多个学科。在JCR全部236个学科类别中，219个收录了Wiley期刊，其中有256本期刊在所属的学科中排名前十位。 拥有最高影响因子的期刊是《CA: A Cancer Journal for Clinicians》2018年的影响因子高达223.679，是目前影响因子最高的期刊。 Wiley旗下的论文数据库是Wiley Online Library 关于Wiley期刊的详细说明可以查看 https://www.wiley.com/en-cn/students ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:2:3","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"其它 SAGE和Taylor\u0026Francis也是世界出版巨头 IEEE是美国电气与电子工程师协会，全球最大的非营利性专业技术协会，也是国际学术会议和期刊中最知名的一个，总部设在纽约。主要致力于在电气、电子、计算机工程和与科学有关的领域开发和研究，在太空、计算机、通信、生物医学、电力及消费性电子产品等领域已制定了900多个行业标准，现已发展成为全球最具有影响力的国际学术组织。IEEE出版有70多种学术期刊杂志，每个专业分会都有自己的刊物，IEEE每年发表的论文著作数量占全世界该领域当年发表量的30%左右。IEEE最出名的除了其出版的期刊外，还有每年举办的业内顶尖学术国际会议，以及IEEExplore数据库 ACM是美国计算机协会，举办的学术会议和期刊在全球也具有重要影响力，全文数据库ACM DL是常用数据库之一 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:2:4","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"3. 三大检索 除以上提到的出版商提供的自己旗下的全文数据库外，一些机构还提供了对全网资源的整合。最著名的是三大检索系统：SCI，EI和ISTP。这些检索系统在我国的知名度很高，除了它们本身已被国际权威机构公认外，还有一个重要原因是中国科技信息研究所从1989年起，每年以SCI，EI，ISTP光盘收录的期刊及论文为统计源，对我国发表在国内外的论文进行了大规模的统计分析，并按种类数量指标的大小排出各高校、科研机构及论文作者学术活动和论文水平的名次表，以《中国科技论文统计与分析》（年度研究报告）形式发表，这就是所谓的“学术榜”。各学术机构也将它们作为职称评定和奖金发放的依据。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:3:0","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"3.1 SCI SCI是美国《科学引文索引》的英文简称，其全称为：Science Citation Index，创刊于1961年，它是根据现代情报学家加菲尔德（Engene GarfiEId） 1953年提出的引文思想而创立的，时至今日加菲尔德仍是SCI主编之一。SCI是由ISI（Institute for Scientific Information Inc.）美国科学情报所出版，为双月刊。 SCI是一部国际性索引，包括有：自然科学、生物、医学、农业、技术和行为科学等，主要侧重基础科学。所选用的刊物来源于94个类、40多个国家、50多种文字，这些国家主要有美国、英国、荷兰、德国、俄罗斯、法国、日本、加拿大等，也收录一定数量的中国刊物。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:3:1","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"3.2 ISTP ISTP 是Index to Scientific \u0026 Technical Proceedings的简称，中文名字为《科技会议录索引》，创刊于1978年，由美国科学情报研究所出版。该会议索引收录生命科学、物理化学、农业生物和环境科学、工程技术、管理信息、教育发展、社科人文和应用科学等学科的会议文献，包括一般性会议、座谈会、研究会、讨论会、发表会等。ISTP与SCI的主要区别就是SCI是对期刊的索引，而ISTP是对会议的索引。 ISTP后来已演变成为CPCI， Conference Proceedings Citation Index的简称，科技会议录索引。美国科学情报报研究所(ISI)基于Web of Science的检索平台，将Conference Proceedings Citation Index - Science（科技会议录索引，简称CPCI-S）和Conference Proceedings Citation Index - Social Science \u0026 Humanities（社会科学与人文会议录索引，简称CPCI-SSH）两大会议录索引集成为ISI Proceedings，两大会议录共用一个检索平台Web of Science Proceedings（简称：WOSP） Thomson Reuters公司1992年收购了ISI，SCI、SSCI、ISTP全部归属其名下，2008年这些数据库一同整合进Web of Science，目前统一从该数据库搜索。2016年Thomson Reuters分拆了其知识产权和科学部门，成立了一家单独的公司，并出售给了Onex Corporation 和 Baring Private Equity，这家公司就是Clarivate Analytics，目前运营着包括Web of Science和Endnote在内的许多订阅式业务。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:3:2","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"3.3 EI EI，The Engineering Index，《工程索引》，创刊于1884年，是美国工程信息公司（Engineering information Inc.）出版的著名工程技术类综合性检索工具。EI每月出版1期，文摘1.3万至1.4万条；每期附有主题索引与作者索引；每年还另外出版年卷本和年度索引，年度索引还增加了作者单位索引。收录文献几乎涉及工程技术各个领域。例如：动力、电工、电子、自动控制、矿冶、金属工艺、机械制造、管理、土建、水利、教育工程等。它具有综合性强、资料来源广、地理覆盖面广、报道量大、报道质量高、权威性强等特点。 Engineering information公司则于1998年被Elsevier收购，现如今依然通过Engineering Village平台检索，只是如今的EI仅指 EI Compendex 数据库，搜索时应当注意，Engineering Index这个词当前在Wikipedia也重定向到了EI Compendex。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:3:3","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"4. SCI分区 目前，根据JCR分区表对SCI论文进行评价的模式已被国内部分高校和科研机构采纳，因为它有利于鼓励科研工作者向本学科的高级区域投稿。国内主流参考的SCI分区依据主要有中科院JCR分区表以及汤森路透JCR的Journal Ranking分区两种。其中，中科院期刊分区表则被更多的机构采纳以作为科研评价的指标。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:4:0","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"中科院JCR分区 由于不同学科之间的SCI期刊很难进行比较和评价，中国科学院国家科学图书馆世界科学前沿分析中心（原中国科学院文献情报中心），对目前SCI核心库加上扩展库期刊的影响力等因素，以年度和学科为单位，对SCI期刊进行4个等级的划分。一般而言，发表在1区和2区的SCI论文，通常被认为是该学科领域的比较重要的成果。 中科院JCR分区表对所有期刊的学科划分作出如下规定： **大类学科：**医学、生物、农林科学、环境科学与生态学、化学、工程技术、数学、物理、地学、地学天文、社会科学、管理科学及综合性期刊，共13个大类。 **小类学科：**即JCR学科分类体系Journal Ranking确定的176个学科领域。 需要注意的是，一本期刊只可属于一个大类学科，但是一本期刊却可以属于多个不同的小类学科。例如期刊Advanced Materials，只属于“工程技术”的大类学科，但具体可进一步细分为5个小类学科。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:4:1","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"分区方法 中科院期刊分区依据也是基于一个期刊的IF，但是采用的是三年平均IF，优点是减少了有些期刊IF逐年波动较大带来的不稳定因素。 具体方法：根据13个大类学科，分别将各大类的SCI期刊由3年平均IF划分为1区（最高区）、2区、3区和4区四个等级。中科院分区的1区到4区的期刊数量不等，呈金字塔状分布。前5%为该类1区、6%～20% 为2区、21%～50%为3区，其余为4区。 中科院分区表的大类分区中还会遴选出一些优秀的Top期刊：1区期刊直接划入Top范围内；2区中2年总被引频次指标位于前10%的期刊也归入Top期刊集合。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:4:2","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"两种JCR分区的比较 学科划分不同：汤森路透JCR的Journal Ranking没有设置大类学科，只分为176个具体学科，也就是中科院分区表中所指的小类学科。 分区方法不同：Journal Ranking以当年的IF为基础，每个学科分类按照期刊的当年的IF高低，平均分为Q1、Q2、Q3和Q4四个区，Q表示Quartile in Category。汤森路透分区中期刊的数量是均匀分为四个部分，而中科院分区表四个区呈金字塔型分布，缺点是一区期刊数太少。 合并/更名期刊的处理方式不同：中科院分区表是基于JCR的数据，但对于JCR中期刊刊名更名/合并的情况进行数据规范处理。对于变更刊名的期刊，JCR会保留两个刊名，会计算两个IF。中科院分区表会将变更前期刊数据合并到变更后的期刊，且重新计算IF，只保留变更后刊名和ISSN。 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:4:3","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"查询方法 中科院分区可使用LetPub查询： http://www.letpub.com.cn/index.php?page=journalapp JCR分区在Web of Science的搜索结果中任意选取一篇文章点看查看细节，点击查看期刊影响力可以看到结果 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:4:4","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"5. 会议分级 将学术会议分为A、B、C几个等级，是为了区分它们的整体论文水平及影响力。就像大学的排名一样，下面是参考，国内基本使用的是CCF(中国计算机学会)的等级划分，顺便还是要说一句，下面的分级其实也包括期刊，但期刊我们一般以JCR为准，因此在这里不考虑。 中国计算机学会的推荐： https://www.ccf.org.cn/xspj/gyml/ 澳大利亚CORE排名： http://www.core.edu.au/conference-portal ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:5:0","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"6. 核心期刊 核心期刊是国内中文期刊的一种统计，通常是一些质量比较高的中文刊物，目前，国内期刊有很多种，比如“北大核心”、“南大核心”等，但各科研单位对核心的认定存在差别，下面对一些常见的核心作介绍 北大核心，全称北京大学图书馆“中文核心期刊”，是由北京大学图书馆及北京十几所高校图书馆众多期刊工作者及相关单位专家参加的研究项目，项目研究成果以印刷型图书的形式出版，第一版是1992年，最新一版是2017年的第八版。 南大核心，全称南京大学“中文社会科学引文索引（CSSCI）来源期刊”，南京大学中国社会科学研究评价中心制作，是国家、教育部重点课题攻关项目， 通过对全国所有符合两月以下出版及非一刊号多版的人文社会科学各学科学术性期刊进行他引影响因子分析，结果中最靠前的刊物，就是南大核心来源期刊。 CSSCI （2019-2020）来源期刊目录.pdf CSSCI （2019-2020）扩展版目录.pdf 统计源核心，也称科技核心，全称“中国科技论文统计源期刊”或“中国科技核心期刊”，由中国科技信息研究所每年通过《中国科技期刊引证报告》发布， 此外还有中国社会科学院文献信息中心发布的“中国人文社会科学核心期刊”和中国科学院文献情报中心发布的“中国科学引文数据库(CSCD)来源期刊” ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:6:0","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"7. 总结 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:7:0","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"7.1 期刊 SCI的期刊索引目录以论文形式发布，下载地址为 https://www.researchgate.net/publication/321686910_SCI_Science_Citation_Indexed_Journal_List 但查找多有不便，因此以中科院JCR为准，从LetPub查看期刊列表，选择大类为工程技术，小类为计算机的，链接如下： http://www.letpub.com.cn/index.php?page=journalapp\u0026view=search Engineering Village现归爱思唯尔所有，因此EI收录的期刊列表从Elsevier网址下载查看，其中将中文期刊单独列了一个表，同时也包含会议列表，便于查看 https://www.elsevier.com/solutions/engineering-village/content 北大核心以出版物形式出版，只能到图书馆查看，也可以在网上寻找，但不保证准确性 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:7:1","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"7.2 会议 会议以CCF推荐会议列表，CPCI-S会议列表，和EI会议列表为准，但单纯查看列表无法获得更多有效信息，需要有一个网址可以查看即将召开的会议 SCIEI Upcoming conferences： http://sciei.org/list-32-1.html 中国学术会议网： http://conf.cnki.net/ 中科院国际会议服务平台： http://csp.escience.cn/dct/page/1 world conference alerts： https://www.worldconferencealerts.com/ 发布会议征稿通知的网站 http://www.wikicfp.com/cfp/home 关于区块链的会议，上篇文章统计了已发表的区块链论文大多位于哪些会议上，这里根据这一会议列表，详细查看下一年它们的举办时间及征稿信息 ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:7:2","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"7.3 基金 从LetPub查询国家自然科学基金项目，获得所属学部、学科分类和项目类型，然后再按照这些信息从科技成果信息系统或者科学基金网络信息系统查询项目具体信息。 需要注意地一点是，无论是Letpub还是自然科学基金官网，都无法查看项目摘要，据说只有结题项目才会公布更详细地信息… ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:7:3","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"参考文献 [1] 国际核心索引检索中心, 四大检索系统-SCI-ISTP检索-EI检索-ISR索引, 2012.04.27, http://www.ei-istp.com/New_93.html [2] CSDN, 学术期刊与会议的索引和分级, 2014.01.16, https://blog.shengbin.me/posts/indexing-and-ranking-of-academic-journals-and-conferences [3] 百度文库, 什么是EI、SCI、收录、检索、出版商、全文收录，2018.07.02， https://wenku.baidu.com/view/b7ec3fafdd3383c4bb4cd295.html [4] LetPub, 最新JCR期刊IF及分区情况(中科院SCI期刊分区表), https://www.letpub.com.cn/index.php?page=2012-sci-13-top [5] 虎嗅, 学术出版为什么成了一门利润惊人的生意，2019.04.16, https://www.huxiu.com/article/294575.html [6] 百度文库, 什么是核心期刊，核心期刊有几种, 2018.05.22, https://wenku.baidu.com/view/6ce3478d0342a8956bec0975f46527d3250ca612.html ","date":"2018-11-09","objectID":"/2018/academic-basic-knowledge/:8:0","tags":["科研记录"],"title":"科研基础1-文献检索常识","uri":"/2018/academic-basic-knowledge/"},{"categories":["研究生的区块链学习之路"],"content":"区块链作为比特币背后的技术架构，是随着比特币的出现而诞生的。因此，要讲区块链的诞生，我们就不得不从比特币的历史说起。 注：本文摘录自「张健. 区块链，定义为了金融与经济新格局[M]. 北京：机械工业出版社. 2016:20-27」 ","date":"2018-11-02","objectID":"/2018/the-birth-of-bitcoin/:0:0","tags":["区块链"],"title":"区块链学习1-比特币的诞生","uri":"/2018/the-birth-of-bitcoin/"},{"categories":["研究生的区块链学习之路"],"content":"1. 密码朋克 说到比特币的缘起，就不得不谈到一个略显神秘的团体：密码朋克（Cypherpunk）。这个团体是密码天才们的松散联盟，比特币的创新中大量借鉴了密码朋克成员的贡献。密码朋克这个词一部分来源于密码（Cipher），这在密码学中意为用于加密解密的算法；一部分来源于赛博朋克1（Cyberpunk），这是指那个时代流行的一个科幻流派。这样的组合有很微妙的意味，散发着改变社会的激进理想。凯文·凯利曾在《失控》里写道： 所以在1992年夏天，一个由富有创意的数学黑客、公民自由主义者、自由市场的鼓吹者、天才程序员、改旗易帜的密码学家以及其他各种前卫人士组成的松散联盟开始创造、拼凑甚至是盗用加密技术，并将其植入网络之中。他们管自己叫“密码朋克”。 1992年秋天的几个周六，我参加了蒂姆·梅还有其他大概是15个“密码反叛者”在加州帕洛阿托举行的“密码朋克”月度会议……小组是通过密码朋克邮件列表这个虚拟网络空间来推广他们的努力的。来自世界各地、越来越多的热衷于加密技术的人每天通过互联网上的“邮件列表”互动，为了以低成本来实现他们的想法（比如数字签名）。 密码朋克们的观点是：现代社会不断蔓延着对个人隐私和权利的侵蚀。他们互相交流着对这一问题的关注，并认为在数字时代保护隐私对于维持一个开放社会是至关重要的。这一理念在比特币中得到体现：去中心化的追求，对匿名的拥抱，自由主义的原则。 密码朋克本身就是数字货币最早的传播者，在其电子邮件组中，常见关于数字货币的讨论，并有一些想法付诸实践。比如大卫·乔姆、亚当·贝克、戴伟、哈尔·芬尼等人在早期数字货币领域做了大量的探索。 ","date":"2018-11-02","objectID":"/2018/the-birth-of-bitcoin/:1:0","tags":["区块链"],"title":"区块链学习1-比特币的诞生","uri":"/2018/the-birth-of-bitcoin/"},{"categories":["研究生的区块链学习之路"],"content":"2. 早期数字货币的探索 比特币并不是数字货币的首次尝试。据统计，比特币诞生之前，失败的数字货币或支付系统多达数十个。正是这些探索为比特币的诞生提供了大量可借鉴的经验。在这里我们简要介绍几位之前的探路者。 大卫·乔姆（David Chaum）是一位密码破译专家，也是20世纪八九十年代密码朋克的“主教”级人物。他是很多密码学协议的发明者，他在1981年的研究奠定了匿名通信的基础。1990年，大卫·乔姆创建了数字现金公司（DigiCash），并试验了一个数字化的货币系统，称为 Ecash。数字现金公司来自他的一些突破性想法，包括如何分享和传输金融信息，以及管理不同身份信息的保密程度。在他的系统中，付款方式是匿名的，而收款方并不是匿名的。更精确的说法是，Ecash 是个人对商家的系统。他发明的这个货币系统还有部分绕过中间商的特质，数字现金公司作为可信的第三方来确认交易，避免重复消费，保证系统诚实。 大卫·乔姆迅速与荷兰政府签订了合同，并从德意志银行、澳大利亚高级银行、瑞士信贷和日本住友银行获得了执照，乔姆曾与微软和VISA及其他大公司讨论如何使用新的支付系统。然而在1998年，数字现金公司宣布破产。失败的主要原因在于，将技术理念转化为实用系统的过程中缺失了很多东西。首先，数字现金公司很难说服银行和商家大规模采用他的系统，另外由于 Ecash 对个人之间的交易没有很好的支持，因此当银行和商家没有动力接受它的时候，个人用户也就无从使用它。 ​亚当·贝克（Adam Back）是一位英国的密码学家，1997年，他发明了哈希现金（Hashcash），其中用到了工作量证明系统（Proof Of Work）。这个机制的原型可用于解决互联网垃圾信息，比如作为垃圾邮件问题的一个解决方案[3]。它要求计算机在获得发送信息权限之前做一定的计算工作，这对正常的信息传播几乎不会造成可以察觉的影响，但是对向全网大量散布垃圾信息的计算机来说，这些计算会变得不可承受。这种工作量证明机制后来成为比特币的核心要素之一。 哈伯和斯托尼塔（Haber and Stornetta）在1997年提出了一个用时间戳的方法保证数字文件安全的协议。对它的简单解释是，用时间戳的方式表达文件创建的先后顺序，协议要求在文件创建后其时间戳不能改动，这就使文件被篡改的可能性为零。这个协议成为比特币区块链协议的原型。 戴伟（W Dai）是一位兴趣广泛的密码学专家，他在1998年发明了B-money。Bmoney强调点对点的交易和不可更改的交易记录，网络中的每一个交易者都保持对交易的追踪。不过在B-money中，每个节点分别记录自己的账本，这不可避免地会产生节点间的不一致。戴伟为此设计了复杂的奖惩机制以防止节点作弊，但是并没有从根本上解决问题。中本聪发明比特币的时候借鉴了很多戴伟的设计，并和戴伟有很多邮件交流。 哈尔·芬尼（Hal Finney）是PGP公司的一位顶级开发人员，也是密码朋克运动早期和重要的成员。2004年，芬尼推出了自己的电子货币，在其中采用了可重复使用的工作量证明机制（RPOW）。哈尔·芬尼是第一笔比特币转账的接受者，在比特币发展的早期与中本聪有大量互动与交流。由于身患绝症，哈尔·芬尼已于2014年去世。 ","date":"2018-11-02","objectID":"/2018/the-birth-of-bitcoin/:2:0","tags":["区块链"],"title":"区块链学习1-比特币的诞生","uri":"/2018/the-birth-of-bitcoin/"},{"categories":["研究生的区块链学习之路"],"content":"3. 比特币的诞生 2008年9月，以雷曼兄弟的倒闭为开端，金融危机在美国爆发并向全世界蔓延。为应对危机，世界各国政府和中央银行采取了史无前例的财政刺激方案和扩张的货币政策并对金融机构提供紧急援助。这些措施同时也引起了广泛的质疑。 2008年10月31日下午2点10分，在一个普通的密码学邮件列表中，几百个成员均收到了自称是中本聪的人的电子邮件，“我一直在研究一个新的电子现金系统，这完全是对点的，无需任何可信的第三方”2，然后他将收件人引向一个九页的白皮书，其中描述了一个新的货币体系。同年11月16日，中本聪发布了比特币代码的先行版本。 2009年1月3日，中本聪在位于芬兰赫尔辛基的一个小型服务器上挖出了比特币的第一个区块——创世区块（Genesis Block），并获得了首批“挖矿”奖励——50个比特币。在创世区块中，中本聪写下这样一句话： The Times 03/Jan/2009 Chancellor on brink of second bailout for banks 财政大臣站在第二次救助银行的边缘 这句话是当天《泰晤士报》头版的标题。中本聪将它写进创世区块，不但清晰地展示着比特币的诞生时间，还暗含了对于旧体系的嘲讽。 不过正如上文所述，加密数字货币并不是什么新概念，曾有很多人试图打造这样的系统，但最终都失败了，有什么理由认为比特币会比之前的尝试更好呢？当时，即使在密码朋克内部，多数人对中本聪的系统也没抱多大的期望。然而事实是，中本聪通过一个天才的发明——区块链，扫清了创造加密货币的最后障碍。于是，出乎大多数人的意料，比特币开始走上了一条不断成长与快速发展的道路。 赛博朋克一词可以简单的理解为高科技，低生活水平。 ↩︎ https://www.mail-archive.com/cryptography@metzdowd.com/msg09959.html ↩︎ ","date":"2018-11-02","objectID":"/2018/the-birth-of-bitcoin/:3:0","tags":["区块链"],"title":"区块链学习1-比特币的诞生","uri":"/2018/the-birth-of-bitcoin/"},{"categories":["研究生的区块链学习之路"],"content":"说明：三个工业物联网和区块链结合的场景 供应链 货物在供应链各环节流通时，装运信息缺乏可见性，并且拥有装运延迟，这种延迟通常是由于一个流通的批准文件或货物交接造成的，随着这种事务的增加，相关的交接文件可能错位或丢失，或处于等待状态，可以使用智能合约数字化这一过程，并从供应链中删除这类中间商的工作。如1中所述，区块链主要记载货物的位置和时间信息，作为货物的装运证明和交付证明。这样可以最大限度地减少装运延迟，更准确地预测货物地交付时间，更好地实时检测库存水平。 位置数据由IoT传感器捕获，IoT传感器将数据转发到IoT平台。供应链的参与者包括原始设备制造商（OEM），供应商，第三方物流提供商，托运人和仓库。每个参与者都可以根据参与者的角色查看区块链中的相关货运数据。制造商使用物流管理系统来查询区块链的装运数据，并向区块链提供额外的装运信息。 自动驾驶车辆 车辆可以自行加油或充电。如果车辆上的传感器检测到需要维修，则车辆可以自动安排预约并开车到维修设施。自动驾驶汽车制造商可以及时获得区块链上捕获的发动机或动力传动系故障信息，并可以使用此信息来确定组件是否出现故障趋势 客户受益于制造商提高的服务水平，提高消费者信心。制造商，监管机构和供应商可以适当了解区块链中的组件故障，并可以更快地主动应对故障趋势，以确保消费者的安全和满意度。在没有人为干预的情况下，车辆将安全地自动支付加油或维修费用。加油，维修和付款的永久记录将记录在区块链上，并由参与者共享，包括车主，制造商，维修设施和融资公司 将传感器的数据放在区块链，利用智能合约可以达成自动修车、加油，并利用区块链货币的固有智能完成维修和加油的费用支付。这些支付记录也将存在区块链中，同样还利用其采集的信息不可改变供车主、制造商、维修设施等各方访问数据。 制造工厂资产管理 区块链和物联网解决方案可以预防和预测制造工厂设备的故障。设备传感器可以检测诸如过度振动或热量之类的情况，这可能导致故障或操作员受伤。从传感器在区块链上捕获的关键阈值数据将用于检测这些故障的趋势，并在故障发生之前促进主动维护和维修。从工厂设备生成的分析和认知数据的应用将使可靠性，维护和操作人员能够更加详细，准确地了解资产绩效。监管机构和工厂设备供应商可以查看设备记录，并可以及时提供检查和认证，以确保设备的可靠性。第三方维修合作伙伴可以监控区块链的预防性维护，并将其工作记录在区块链上 ","date":"2018-10-24","objectID":"/2018/blockchain-and-the-internet-of-things-in-the-industrial-sector/:0:0","tags":["论文笔记"],"title":"Blockchain and the Internet of Things in the Industrial Sector","uri":"/2018/blockchain-and-the-internet-of-things-in-the-industrial-sector/"},{"categories":["研究生的区块链学习之路"],"content":"Özyılmaz, Kazım Rıfat, and Arda Yurdakul. “Work-in-Progress: Integrating low-power IoT devices to a blockchain-based infrastructure.” 2017 International Conference on Embedded Software (EMSOFT). IEEE, 2017. 说明：关于物联网和区块链结合，节点资源有限的一种解决方案 ","date":"2018-10-23","objectID":"/2018/work-in-progress-integrating-low-power-iot-devices-to/:0:0","tags":["论文笔记"],"title":"Work-in-Progress Integrating Low-Power IoT devices to","uri":"/2018/work-in-progress-integrating-low-power-iot-devices-to/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction 引言部分引用了几篇物联网发展现状的论文，做背景分析可能用到 这篇文章主要是为基于LPWAN的物联网部署到区块链基础设施做一个概念验证，也就是证明这事可以做。还提出了各种终端设备的集成到区块链的方法。他们在网关上的软件解决方案利用区块链功能来（a）促进分散的物联网平台，（b）标准化终端设备和物联网基础设施之间数据传输的方式，（c）连接任何类型的物联网终端设备到基于区块链的物联网平台 把LoRa网关接入以太坊区块链，实现一个基于事件的通信机制 ","date":"2018-10-23","objectID":"/2018/work-in-progress-integrating-low-power-iot-devices-to/:1:0","tags":["论文笔记"],"title":"Work-in-Progress Integrating Low-Power IoT devices to","uri":"/2018/work-in-progress-integrating-low-power-iot-devices-to/"},{"categories":["研究生的区块链学习之路"],"content":"Blockchain and IoT Integration 把物联网终端设备和网关集成到基于区块链的物联网平台上可以通过以下方法实现： 网关作为区块链的全节点，终端设备和网关通信 网关作为区块链的轻节点，终端设备和网关通信 终端设备作为常规传感器，电池供电的终端设备不足以集成区块链客户端，由物联网网关把数据推送到区块链 终端设备作为服务器可信的客户端：使用BCCAPI这样接口的简单形式的客户端可以集成到电池供电的物联网终端设备中 如果终端设备不是由电池供电并且始终开启，终端设备可以作为区块链的轻节点 ","date":"2018-10-23","objectID":"/2018/work-in-progress-integrating-low-power-iot-devices-to/:2:0","tags":["论文笔记"],"title":"Work-in-Progress Integrating Low-Power IoT devices to","uri":"/2018/work-in-progress-integrating-low-power-iot-devices-to/"},{"categories":["研究生的区块链学习之路"],"content":"Proof of Concept 场景描述：LPWAN技术可以跟踪覆盖数公里范围的人员或设备。这篇文章中，电池供电的物联网终端设备将位置数据发送到LoRa网关。然后，LoRa网关使用智能合约将此数据流通过官方Go-lang的以太坊客户端Geth路由到私有的以太坊区块链。使用连接到Dragino LoRa / GPS Hat 的Raspberry Pi 2构建LoRa终端设备，使用Raspberry Pi 3构建LoRa网关。为了实现这样的双向LoRaWAN-Ethereum代理，网关应运行LoRa协议软件以与终端设备通信，并运行以太坊客户端以将数据路由到区块链网络。LoRa协议软件用于将数据包转发到应用程序服务器。此外，使用初始生成块创建私有以太坊网络，其具有简单的挖掘设置，以实现更快的响应时间，即更短的挖掘时间。 要使网关和区块链交互，需要部署智能合约，部署后智能合约的地址和程序二进制接口用于与其交互。使用一个smart proxy从LoRa包转发器捕获数据，然后通过JSON-RPC接口将其提供给Geth并调用智能合约 基于事件的通信主要是指智能合约的程序结构 ","date":"2018-10-23","objectID":"/2018/work-in-progress-integrating-low-power-iot-devices-to/:3:0","tags":["论文笔记"],"title":"Work-in-Progress Integrating Low-Power IoT devices to","uri":"/2018/work-in-progress-integrating-low-power-iot-devices-to/"},{"categories":["研究生的区块链学习之路"],"content":"Introduction 缺失可信中介使交易双方之间的协调更快 密码学的大量使用为网络中的所有交互带来了权威性 智能合约允许分布式的，高度自动化的工作流程 ","date":"2018-10-22","objectID":"/2018/blockchains-and-smart-contracts-for-the-internet-of-things/:1:0","tags":["论文笔记"],"title":"Blockchains and Smart Contracts for the Internet of Things","uri":"/2018/blockchains-and-smart-contracts-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Blockchains and IoT 目前的中心化模型中，制造商维护以百万计的设备的软件更新代价是高昂的 用户缺乏对应用从后台是否私自获取数据的信任，需要一个透明度保障的方法 区块链技术可以解决这些问题 制造商的所有物联网设备都在同一个区块链网络上运行，制造商部署智能合约并允许它们在区块链网络上存储最新固件更新的哈希值，这些设备要么将智能合约的地址附加到它们的区块链客户端，要么通过发现服务找到它。然后，它们可以查询合约，了解新的固件更新，并通过分式对等文件系统请求更新并通过哈希验证更新正确性，对该文件的第一次请求由制造商自己的节点（该节点也加入区块链网络）提供服务，但更新文件传播到足够的节点后，制造商的节点可以停止提供服务，由已获得更新的设备向未获得更新的设备提供服务，一切自动进行，没有用户交互。 此外，区块链中加密货币系统的使用可以提供付费层，为设备间的服务市场铺平道路。上面的示例中，非制造商的节点为其它节点提供更新可以收取服务费，以维持设备运行成本和获利。更普遍的，每台设备都可以拥有自己的账户，然后提供资源（服务或设备使用权）给其它设备或用户并获得补偿。如为专门的电子锁设定价格，通过支付房主设定的加密货币数量和正确的签名消息，与锁通信以解锁它，通过让所有这样的电子锁运行在同一区块链上来简化计费。 能量领域，布鲁克林的社区实验，太阳能电池板的能量盈余记录在区块链上，并通过智能合约将其出售给邻近各方。（同样是能量方面，还有能量区块链的那篇） 供应链示例：离开制造商的集装箱，通过铁路到最近的港口，通过海运到目的港口，再送到经销商处，最后到达零售商。这个过程涉及多个利益相关者和检查，每个利益相关方通常都会维护自己的数据库，以跟踪资产，并根据链中其他方的输入更新资产。虽然设置用于跟踪此资产的区块链网络意味着现在有一个共享数据库可以跟踪，其中更新带有加密可验证性，自动沿网络传播，并创建可审计的信息跟踪。例如，当运输公司到达目的地港口时，他们将签名的消息发送到预定的智能合约，以允许链上的每个人知道该集装箱现在的位置。因为交易被签名，它会作为海运公司关于集装箱已到达目的港的加密可验证收据的声明。港口的接收人发布同样的智能合约，以确认它是否在集装箱里面。 或者利用比特币的代币交易模型来完成供应链的整个过程。 和物联网结合，这个过程可以进一步自动化。假设每个利益相关者携带一个智能跟踪器，里面包含BLE，GSM或LTE以使它连到互联网，安装好的区块链客户端。这样的追踪器也放在集装箱的货物上。当两个利益相关者见面并且集装箱也存在时，利益相关者的设备可以自动地将签名的交易发送到区块链而无需任何用户输入，并且这个过程可以随着请求代币（用代币交易模型完成供应链过程里面的名词）被交换而进入下一阶段。BLE用于设备判断它们何时彼此接近，接近时它们可以通过互联网再区块链上进行交易。 Filament提供一种服务，传感器不接入区块链从而降低部署成本，但连到网关，网关形成网状网络，通过称为“telehash”的协议以分布式和安全的方式相互通信，并通过公共区块链上的智能合约相互交互。 ","date":"2018-10-22","objectID":"/2018/blockchains-and-smart-contracts-for-the-internet-of-things/:2:0","tags":["论文笔记"],"title":"Blockchains and Smart Contracts for the Internet of Things","uri":"/2018/blockchains-and-smart-contracts-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Deployment Considerations 物联网进一步和区块链结合时可能面对的问题，解决这些问题的可能方案（包括正在进行的工作） 相比于集中式的数据库，区块链解决方案交易处理吞吐量比较低，交易确认延迟跟高，公链中这个问题尤为突出。 区块链中每个节点执行相同的任务，没有空间用于并行任务执行，即没有分片，以太坊在努力改进这一点。分片主要是为了扩大每个区块的容量，从而提高交易吞吐量。 区块链隐私问题，每个参与者由其公钥标识，交易时只需要知道对方的公钥，但区块链中所有交易都是公开的，通过分析这些数据，可以识别地址和用户之间的关系，推断出用户真实身份，如果隐私对所考虑的场景很重要，有两种方法可以缓解但不能消除这个问题： 每笔交易使用新的密钥或对每个交易对象使用新的密钥，举了比特币改进的例子； 对私有区块链，如果其他参与者可以通过跟踪您设备的活动获得竞争优势，建议不要对所有交易使用相同的区块链，通过仅为需要协作的实体设置区块链，并仅将它们用于自己希望协作的进程，最大限度地减少设备地暴露。与单个区块链相比，这增加了协调成本，但减少了隐私暴露的可能性。 同样，交易隐私也很难实现，因为每个交易的内容在链中都是公开的，并以此对其进行验证。同态加密和零知识证明可以解决这个问题，但解决方法都是资源密集型的，在资源受限的IoT设备上适用性有限，所以采用上面第2种办法，使用区块链只服务于特定进程，并在使用后立即丢弃。 另外是矿工问题，矿工虽然不能伪造交易或重写历史，但可以拒绝把有效交易添加到区块链中，所以要慎重选择自己的挖矿节点，最小化它们之间的串通机会，私人网络中应签署法律合同来合理地惩罚合谋。 智能合约的法律可执行性有限。如果交易实体对智能合约操作的结果提出异议，会发生什么？增加法律可执行性的可能性的一种方法是在智能合约中包含对实际真实合同的引用，反之亦然。这是一个称为“双重集成”的过程，它的工作原理如下：（a）部署智能合约，在区块链上记录其地址，并在真实合同中包含该地址（b）哈希相应的真实合同，记录其哈希摘要，将真实合同存储在安全空间（可以集中或分散），（c）向智能合约发送包含真实合约在其元数据中的哈希值的交易;然后智能合约将该信息存储在自己的内部数据库中。如果出现法律纠纷，可以指向存储在智能合约中的哈希值，然后显示真实世界的合约（由该哈希值唯一标识）并证明区块链上的操作与预期结果之间的联系 设备所有权地证明，当希望提取设备在区块链中对应的货币时（比如把设备卖出去了），遇到不支持智能合约的区块链，怎么办，办法是把现实世界的合同哈希值作为元数据放在代表该设备价值的代币里。即任何时候都可以对这些代币进行公证。 智能合约是把双刃剑，里面代码写的有问题，就可能发生严重的安全事故，就像以太坊的the DAO事件。 最后，区块链网络可能需要以下机制来补充其功能，并且这些机制也应是分布式的。 指向区块链中资源的DNS服务，用于查找相应的区块 安全的通信和文件交换，区块链中的消息通信是公开的，如果需要两个节点间专用的通信，需要telehash,Whisper之类的协议，文件共享则可以通过内容寻址的P2P文件系统来解决，例如IPFS ","date":"2018-10-22","objectID":"/2018/blockchains-and-smart-contracts-for-the-internet-of-things/:3:0","tags":["论文笔记"],"title":"Blockchains and Smart Contracts for the Internet of Things","uri":"/2018/blockchains-and-smart-contracts-for-the-internet-of-things/"},{"categories":["研究生的区块链学习之路"],"content":"Conclusions 区块链和物联网的组合主要是可以自动化耗时的工作流程，实现加密可验证性，节省大量成本和时间。 ","date":"2018-10-22","objectID":"/2018/blockchains-and-smart-contracts-for-the-internet-of-things/:4:0","tags":["论文笔记"],"title":"Blockchains and Smart Contracts for the Internet of Things","uri":"/2018/blockchains-and-smart-contracts-for-the-internet-of-things/"},{"categories":["平日里的白日梦"],"content":"2017年5月，AlphaGo战胜顶尖围棋选手柯洁，同年10月，汉森公司的机器人索菲亚获得沙特阿拉伯公民身份。这两个去年曾轰动一时的新闻似乎预示着人工智能时代的到来，同时，也向我们展示了无形态和人形态两种主要的人工智能的发展现状。10月10号到12号举办的华为全联接大会，主题正是人工智能，其中讲到“到2025年全球智能终端将达到400亿，智能助理普及率将达到90%，智能将像空气一样无处不在”。这个预想可能过于乐观，亦或者我理想中的情景和学界的定义不一样，这都无所谓了，就是趁着这次征稿的机会把我理想中的智能纪景观描述一下。 索菲亚说，“你们对我好，我也会对你们好”，这句话意味着人工智能的设计理念是帮助人类过上更美好的生活。这种理念体现在了人类的众多电影中。《超能陆战队》中的大白，凝结着哥哥对小宏的爱，同时，它的定位是健康医疗助手；《机器人瓦力》中的瓦力，日复一日的完成人类交给它的清理垃圾的工作；《终结者》中的T-800在天网笼罩全球的情况下努力完成保护人类希望的重任；最为我们熟知的哆啦A梦，更是无数人梦想的童年伙伴。人形态的机器人被设计服务于我们的日常生活，令我们的生活更便利。在未来，每个家庭都将拥有自己的智能家庭助手，它们可以完成打扫、做饭和洗衣服等家务劳动，收快递、遛狗、和我们聊天，检查我们的身体健康，结合庞大的在线知识技能库给我们各种建议，从而将人们从繁琐的事务中解放出来，从而能更专注于自己的事业或兴趣，它们将极大的提升我们生活的幸福感。 相比于人形态的机器人，无形态的人工智能定位会更多的在于更宏观的层面。虽然好莱坞的一众电影展示了一些失败的样例，但我们仍能从中得到一些启示。《生化危机》中的红后被设计用于协助管理保护伞公司，在电影中，她为了防止病毒扩散封闭了蜂巢，为人类着想给了主角诸多帮助，体现出来的她的底层规则，无一不是服务于人类，而且从始至终没有违反这些规则。《机械公敌》中USR公司的中央控制系统薇琪，认为人类正在危害自身的安全，国家发动战争，人类摧残地球，而机器人则必须拯救人类，保证人类的持续存在发展，因此控制了众多的机器人实施“保护计划”，这一结果的出现是由于作为底层规则的机器人三大定律的不完善。所以，如果我们不断完善系统和规则，所创造的未来仍能是该电影开头所展现的人工智能服务于人类的美好社会形态。并且，薇琪的出发点也许不能说是错误的。红后和薇琪都是企业级人工智能，我们可以看到，在不远的未来，企业使用人工智能进行管理，可以提高运行效率，创造更大的效益，以及，我们在底层定义以人为本的规则，可以为创造更好的工作环境，缓解社会压力。一定程度上使财富和资源的分配合理化，从而创造一个更美好的社会，甚至，某种意义上，这是我们步入共产主义社会的一条可行的道路。 企业级往上，在国家甚至全世界的层面，同样有一些例子。首先是《终结者》系列中的天网，这是一个人类创造的人工智能防御系统，觉醒了自我意识并诱发核战争毁灭世界。这里面我认为问题主要在于天网的设计目的是军事，人类还给予了其核武器的控制权限，而核武器完完全全就是毁灭的代名词，这完全违背了人工智能是为了帮助人类过上更美好的生活的原则。另一个案例，《黑客帝国》则讲述了人类和人工智能Matrix对抗的故事。起因是人类当年和机器人开战，但不敌机器人，于是使用电磁乌云覆盖了整个天空，试图切断机器人的能源，但机器人采用了另一种与人类共存的方式，从人类身体中获取生物电能、热能，而人类生活在机器制造的虚拟世界中。也许单纯的来看，这里面机器人将人类作为生物电池的做法是邪恶的，但要注意到，这里的前置条件是人类先采用了两败俱伤的攻击方式，往前推，漫画版中，这场战争也是人类发动的，是畏惧机器帝国的壮大，再之前，人类拒绝了机器帝国和人类和平发展的请求，甚至更往前，人类与人工智能一起建设着美好的社会，只是由于人类不断地残害机器人，幸存地机器人才建立了机器帝国。而从始至终，人工智能的底层规则里都有服务人类，与人类和谐相处的设定，并且从未违背。这个系列和《生化危机》有一些相似之处，其毁灭性的后果都是由于人类的丑恶本性。所以，我认为，以服务人类，帮助人类过上更美好的生活为出发点，辅以更加完善的规则，人工智能能够和人类和谐共生，并创造一个更美好的世界。 现在的社会中人们无法获得自己创造的全部价值，绝大部分被资本家所榨取，对每个人来说，懒惰是天性，如果可以，大家都想什么都不干，纯粹享受生活，对资本家来说，又想百分百榨取工人价值。机器人是一种完美的替代物，它可以任劳任怨，把创造的全部价值奉献给人类，只需要维持自己的电力消耗和基本的部件更换即可，它是资本家理想的工人，同时能够创造足够的财富让人们不去工作也足以获得生活资源。高福利社会的负担，是太多人坐享其成，伤害的是勤劳工作的人，引起不满，削减福利又会引起民众不满，骑虎难下。但当机器人创造足以让所有人类轻易生活的物资和财富，这一问题将不是问题。虽然可能出现像机器人瓦力中那样的情景，但人类是闲不下来的，无需努力工作来生活，人们将把精力投向自己感兴趣的领域，而创造力正是人和机器人的区别，文化、艺术、科技等将迅猛发展。 上有人工智能统筹规划全球，辅助管理企业和城市，下有机器人服务于人类基本生活，战争、杀戮、阶级、霸权、毒品、人口交易，校园欺凌、社会无赖、传销、赌博等等所有人类的丑恶都将得到抑制。虽然向这一目标迈进的过程是艰难的，也可能人类的贪欲会在这一过程中造成自身的毁灭，但这样的未来是可期的，这样的世界，人工智能代替感性的人类管理的世界，是美好而幸福的。 ","date":"2018-10-12","objectID":"/2018/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%A1%E7%90%86%E4%B8%96%E7%95%8C/:0:0","tags":["杂谈"],"title":"人工智能管理世界","uri":"/2018/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%A1%E7%90%86%E4%B8%96%E7%95%8C/"},{"categories":["爱编程爱技术的孩子"],"content":"网络层除了主要的 IP 协议外，还有 ICMP（Internet Control Message Protocol） 协议，ping 和 traceroute 都会用到它，本文进行介绍。 ","date":"2018-10-01","objectID":"/2018/internet-control-message-protocol/:0:0","tags":["计算机基础"],"title":"计算机网络-ICMP协议","uri":"/2018/internet-control-message-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"1. ICMP 网际控制报文协议 ICMP，目的是更有效的转发 IP 数据报，提高交付成功的机会。通常被主机或路由器用来报告差错情况和提供有关异常情况的报告。 ICMP 虽然是网络层协议，但其报文是作为 IP 数据报的数据部分传输的。ICMP 的报文格式如下 ICMP 报文有两种：差错报告报文和询问报文，报文的前四字节是统一的格式，有三个字段：类型、代码和检验和，后面四个字节与类型有关，随后就是数据部分。下表给出几种常用的报文类型 代码字段是为了进一步区分某种类型的几种不同情况，比如类型12，又可以分为下面两种 类型 代码 描述 12 0 IP header bad (catchall error)——坏的IP首部（包括各种差错） 12 1 Required options missing——缺少必需的选项 校验和字段用来检验整个 ICMP 报文，因为 IP 数据报首部的校验和并不检验 IP 数据报的数据部分，不能保证传输的 ICMP 报文不产生差错。 所有的 ICMP 差错报告报文中的数据字段都具有相同的格式，把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来作为 ICMP 报文的数据字段，然后添加 ICMP 首部，就构成了 ICMP 差错报告报文。如下图 提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号以及运输层报文的发送序号，这些信息对源点通知高层协议是有用的。 常用的 ICMP 询问报文有两种 回送请求和回答： ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。 时间戳请求和回答：ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用来进行时钟同步和测量时间。 ","date":"2018-10-01","objectID":"/2018/internet-control-message-protocol/:1:0","tags":["计算机基础"],"title":"计算机网络-ICMP协议","uri":"/2018/internet-control-message-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"2. Traceroute ICMP 的一个很有用的应用是 traceroute，用来跟踪一个分组从源点到终点的路径，Windows 系统中 命令为 tracert。原理如下： Traceroute从源主机向目的主机发送一连串的 IP 数据报，数据报中封装的是无法交付的 UDP 用户数据报（使用非法端口）。第一个数据报 P1 的生存时间 TTL 设置为1。当 P1 到达路径上的第一个路由器 R1 时，路由器 R1 先收下它，接着把 TTL 的值减1。由于 TTL 等于零了，R1 就把 P1 丢弃了，并向源主机发送一个ICMP时间超过差错报告报文。 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达路由器 R1，R1 收下后把 TTL 减1再转发给路由器 R2。R2 收到 P2 时 TTL 为1，但减1后 TTL 变为零了。R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报告报文。这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的 TTL 是1。主机不转发数据报，也不把 TTL 值减1。但因IP数据报中封装的是无法交付的运输层的 UDP 用户数据报，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 这样，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的 ICMP 报文正好给出了源主机想知道的路由信息——到达目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间。下面是向 baidu.com 发出 tracert 命令后得到的结果 \u003e tracert www.baidu.com 通过最多 30 个跃点跟踪 到 www.a.shifen.com [61.135.169.121] 的路由: 1 1 ms \u003c1 毫秒 \u003c1 毫秒 laptop [192.168.0.1] 2 6 ms 6 ms 3 ms 1.28.220.60.adsl-pool.sx.cn [60.220.28.1] 3 21 ms 18 ms 5 ms 201.5.220.60.adsl-pool.sx.cn [60.220.5.201] 4 36 ms 14 ms 13 ms 253.8.220.60.adsl-pool.sx.cn [60.220.8.253] 5 18 ms 22 ms * 219.158.11.113 6 48 ms * 26 ms 124.65.194.158 7 86 ms 36 ms 22 ms 124.65.58.54 8 64 ms 22 ms 21 ms 123.125.248.46 9 * * * 请求超时。 10 * * * 请求超时。 11 25 ms 18 ms 75 ms 61.135.169.121 跟踪完成。 ","date":"2018-10-01","objectID":"/2018/internet-control-message-protocol/:2:0","tags":["计算机基础"],"title":"计算机网络-ICMP协议","uri":"/2018/internet-control-message-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3. Ping ICMP 的另一个重要应用是分组网间探测 PING (Packet InterNetGroper)，用来测试两个主机之间的连通性。Ping 主要使用 ICMP 回送请求和回送回答报文，这是应用层直接使用网络层 ICMP 的一个例子，没有通过运输层的 TCP 或 UDP。 ","date":"2018-10-01","objectID":"/2018/internet-control-message-protocol/:3:0","tags":["计算机基础"],"title":"计算机网络-ICMP协议","uri":"/2018/internet-control-message-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 原理 下面是向 baidu.com 发出的 Ping 请求，计算机连续发出了四个 ICMP 回送请求报文，目标服务器收到后，就返回 ICMP 回收回答报文，往返的 ICMP 报文上都有时间戳，因此很容易得出往返时间。最后会显示出统计结果：发送到哪个机器（IP地址），发送的、收到的和丢失的分组数（但不给出分组丢失的原因），往返时间的最小值、最大值和平均值。 \u003e ping baidu.com 正在 Ping baidu.com [39.156.69.79] 具有 32 字节的数据: 来自 39.156.69.79 的回复: 字节=32 时间=34ms TTL=48 来自 39.156.69.79 的回复: 字节=32 时间=54ms TTL=48 来自 39.156.69.79 的回复: 字节=32 时间=49ms TTL=48 来自 39.156.69.79 的回复: 字节=32 时间=37ms TTL=48 39.156.69.79 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 34ms，最长 = 54ms，平均 = 43ms 注：在 Linux 下，ping 命令会持续不断地发出 ICMP 回送请求报文，而不是发 4 个就停止，需要手动给出停止信号。 ","date":"2018-10-01","objectID":"/2018/internet-control-message-protocol/:3:1","tags":["计算机基础"],"title":"计算机网络-ICMP协议","uri":"/2018/internet-control-message-protocol/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 C语言实现 下面给出一个使用 C 语言的 Ping 命令实现，主要使用 RAW 模式的 SOCKET 编程，因为基于 UDP 的 socket 编程和基于 TCP 的 socket 编程都无法对下一层（网络层）的数据包进行操作。 所用的API函数 功能 函数 创建socket socket(af, type, protocol) 关闭socket closesocket(socket) 发送数据 sendto(s, buf, len, flags, to, tolen) 接收数据 recvfrom(s, buf, len, flags, from, fromlen) 将域名翻译为IP gethostbyname(name) 将IP转换为点分十进制格式 Inet_ntoa(ip) WSAStartupWSACleanup 其它socket函数使用前和使用后用这两个 ICMP数据头结构定义如下 typedef struct _ihdr { BYTE i_type; //类型 BYTE i_code; //代码 USHORT i_cksum; //校验和 USHORT i_id; //标识符 USHORT i_seq; //序号 /* 下面的时间戳不是标准ICMP头部，这个程序里是为了容易计算世界定义的 */ ULONG timestamp; } IcmpHeader; IP数据包头结构定义如下 typedef struct iphdr { unsigned char h_len : 4; // 首部长度 unsigned char version : 4; // 版本号 unsigned char tos; // 服务类型 unsigned short total_len; // 总长度 unsigned short ident; // 标识 unsigned short frag_and_flags; // 标志和片偏移 unsigned char ttl; //跳数 unsigned char proto; // 协议 unsigned short checksum; // 校验和 unsigned int sourceIP; //源地址 unsigned int destIP; //目的地址 } IpHeader; 程序实现的功能包括对域名和 IP 地址发出的 Ping 命令，举例如下 \u003e ping 192.168.1.1 \u003e ping [www.neu.edu.cn](http://www.neu.edu.cn) 程序流程如下 代码放在了 Github Gist，测试结果如下参数 \u003e www.neu.edu.cn 32 bytes from 202.118.1.7: icmp_seq = 0. time: 15 ms 32 bytes from 202.118.1.7: icmp_seq = 1. time: 0 ms 32 bytes from 202.118.1.7: icmp_seq = 2. time: 32 ms 32 bytes from 202.118.1.7: icmp_seq = 3. time: 0 ms 32 bytes from 202.118.1.7: icmp_seq = 4. time: 0 ms 32 bytes from 202.118.1.7: icmp_seq = 5. time: 16 ms 32 bytes from 202.118.1.7: icmp_seq = 6. time: 15 ms 32 bytes from 202.118.1.7: icmp_seq = 7. time: 16 ms 32 bytes from 202.118.1.7: icmp_seq = 8. time: 16 ms 32 bytes from 202.118.1.7: icmp_seq = 9. time: 0 ms 32 bytes from 202.118.1.7: icmp_seq = 10. time: 0 ms 32 bytes from 202.118.1.7: icmp_seq = 11. time: 16 ms 32 bytes from 202.118.1.7: icmp_seq = 12. time: 16 ms 32 bytes from 202.118.1.7: icmp_seq = 13. time: 0 ms 32 bytes from 202.118.1.7: icmp_seq = 14. time: 31 ms 32 bytes from 202.118.1.7: icmp_seq = 15. time: 0 ms 32 bytes from 202.118.1.7: icmp_seq = 16. time: 0 ms 32 bytes from 202.118.1.7: icmp_seq = 17. time: 16 ms 32 bytes from 202.118.1.7: icmp_seq = 18. time: 1188 ms - 注意： Sleep(1000)，删除会使被ping的目的机非常繁忙 发送的ICMP报文中的数据部分最大可以设置为65535-20-8个字节，这将使网络拥堵 ","date":"2018-10-01","objectID":"/2018/internet-control-message-protocol/:3:2","tags":["计算机基础"],"title":"计算机网络-ICMP协议","uri":"/2018/internet-control-message-protocol/"},{"categories":["平日里的白日梦"],"content":"被称为“科技哲学”的自然辩证法，是对以科学技术为中介和手段的人与自然、社会的相互关系的概括和总结。由于其学科性质，天生便与科学技术有着密不可分的关系，尤其是对科学技术发展的历史的研究，更是课堂上所讲的各种理论的佐证。而作为这门学科的体系化开端，恩格斯的《自然辨证法》自然而然地散发着一种迷人的魅力，吸引着对这门学科有着兴趣的我。我从这本文集中选择了《导言》、《神灵世界中的自然科学》两篇论文和其它几篇札记做了阅读，以下是我的一些心得。 名为《导言》的论文实际上展示给我们的是一个宏大而瑰丽的自然观和科学技术观，也许用这样的词汇来形容这么哲学的内容不是很好，但这恰恰是我读完这篇的最直观的感受。从文艺复兴讲起，恩格斯为我们展现了一条数百年间无数科学家对自然界的观察、探索、研究、实验并最终进步的清晰脉络，涉及天文学、生物学、地理学、数学、物理学、化学和一些宗教等众多的学科领域，介绍了历史节点上产生重要影响的各种重大发现和成果。从这些繁杂的科学发现成果中，恩格斯用自然辩证法的联系和发展的眼光将它们整合为一个整体，建立起了这套理论体系，并在最后借天文学之手，凭借其知识底蕴和宏伟的想象，替我们勾画了一个不断发展变化的宇宙的形象。从而丰满和充实了我们的世界观。这是文章整体带给我的，而具体的一些部分，一些段落甚至一些句子都闪烁的智慧的光芒，给人以启示。接下来就谈论一些引起我思考的地方。 首先是恩格斯字里行间透露着对古希腊自然哲学的赞扬，即使其有不足的地方，他将其称作文艺复兴的指引，并把自然科学发展过程中的某些认识看作是倒退（这当然是针对古希腊哲学来说的），自然，这并没有错误，古希腊的贤人们（这么称呼是因为这些人的影响是多方面的）凭借着直觉诞生了唯物和发展的观点，这些观点在札记《古代人的自然观》中有一些描述。这与文艺复兴后的科学发展反而出现的静止的观点形成了鲜明的对比，也许其唯一的缺点就在于这种正确的对世界的认识来自于直觉，但这是由于时代发展的局限而产生的。不仅是古希腊，古中国同样有类似的思想，那些被称“圣”的人和古希腊的“闲人”自然是值得后人崇敬的。 关于文艺复兴的描述中，有一句话让人感同身受，觉得这正是最好的描述。”这是一次人类从来没有经历过的最伟大的、进步的变革，是一个需要巨人而且产生了巨人的时代——在思维能力、热情和性格方面，在多才多艺和学识渊博方面的巨人的时代。“你看他列举的这些人，画家、数学家、力学家和工程师达芬奇，画家、雕刻家、建筑师丟勒，政治家、历史学家、诗人、军事著作家马基雅弗利。“这些人无一不曾作过长途的旅行，不会说四五种语言，不在几个专业上放射出光芒”，这种评价读起来就让人心生敬意，尤其是”给现代资产阶级统治打下基础的人物，绝不受资产阶级的局限“这一句就真的是评价很高而很贴切了。所以，即使恩格斯在段落的最后用了”英雄“这个词来形容，我也丝毫不觉得意外，因为这些人某种意义上正是现代自然科学的先驱们。 相比于恩格斯对古希腊和文艺复兴的高度赞誉，中国历史上也许有对应的时期。对应于古希腊的自然是春秋战国时期的百家争鸣，唯物和发展的思想，人与自然和谐相处的思想得以诞生。但对应于文艺复兴，中国却晚了数百年，直到1840年鸦片战争后才在血与泪中被迫着出现了各种思潮迸发交融的局面，这段时期对中国的影响却毫不逊色于文艺复兴对欧洲。 自然科学的发展是艰辛的，从哥白尼揭开这个序幕起，波折就未停止，“自然科学在普遍的革命中发展着”一言道尽了这个过程。初期自然科学发展成就的标志是牛顿和林耐，但这个时代的总观点的中心是“自然界绝对不变”这样一个见解。这正是我们前面所提到的认识的倒退，恩格斯也说，“虽然十八世纪上半叶的自然科学在知识上，甚至在材料的整理上高过了希腊古代，但它在理论地掌握这些材料上，在一般地自然观上却低于希腊古代”。时代自然是发展地，自哥白尼打开了这个缺口，科学地不断发展就必然导致真理逐渐为人们所认知，这种僵化的自然观，或早或晚的，也必然会被打破。1755年，康德的《自然通史和天体论》第一个发出来挑战，天文学紧接着跟上，然后是地质学、物理学、化学…一发不可收拾，最后，恩格斯做了总结，“一切僵硬的东西熔化了，一切固定的东西消散了，一切被当作永久存在的特殊东西变成了转瞬即逝的东西，整个自然界被证明是在永恒的流动和循环中运动着”，这就是新的自然观的基本观点。 从古希腊人的天才的直觉的观点，历经数千年，终于变成了现在科学的以实验为依据的研究的结果，这个类似于循环的过程，却是人类持久不断努力的结果，是人类千年智慧的结晶。正如之前所学的马克思主义的理论，从量变到质变，事物螺旋发展上升，它回到原点的时候，其实已经不是当初了，在这个过程中，我们认清了它的本质。 文章最后一部分是关于星系演化的描述，恩格斯称为“宇宙岛”，实际上应该是我们现在所说的恒星系，关于其演化，星球诞生、生命出现，人的产生（这部分在《劳动在从猿到人转变过程中的作用》一文中有更详细的描述，很有意思，我最后看了这篇文章），历史和社会，甚至最后想象了万物的终焉。这一整个描述中，蕴含了世界的本源是物质的思想，佐证了物质运动的永恒循环等等，恩格斯将自己的大部分关于自然观的理解都藏在了这段对宇宙和生命的宏伟想象中。 整篇导论，吸引人的不仅仅是恩格斯以宏大的视角为我们展现的整个自然科学史的过程，也不仅仅是文章后半部分对宇宙和生命演变的描述，而是蕴藏其中的基本的自然观，这个自然观正是我们当学习的塑造的科学的自然观。 《神灵世界中的自然科学》一文更为通俗，中心思想也更为突出。我读这篇文章之前本以为讲的是古人对自然神灵的崇拜这一行为中蕴含的一些自然科学的道理。却没想到，发现的是关于近现代的那些“神神叨叨的事情”的描述。文章主要列举了三个著名科学家：华莱士、克鲁克斯、策尔纳从经验主义变成神秘主义，从自然科学家的角色踏进“神灵世界”的实例。在这些实例的描述中，我们所体会到的那些愚弄人心的把戏，也许如今在现实世界仍能找到痕迹。当然，这三个实例和恩格斯想告诉我们的，是轻视科学理论思维和把直接感知的材料绝对化会导致唯心主义，甚至是宗教的思想。尤其是弗朗西斯·培根应用他的经验归纳法所期望达到的那种荒诞的目的，更是给了现代那些迷信“神婆”“大师”等的所谓的唯物主义者们以当头一击，希望都复读一下这篇文章，别搞神神叨叨的事情了。 实际上，从《导言》中也看到过关于这方面的描述。“理论自然科学把自己的自然观尽可能地制成一个和谐地整体，现在甚至连最没有思想地经验主义者离开理论自然科学也不能前进一步”。这个，正是《神灵世界中地自然科学》一文真正想强调的吧。 ","date":"2018-09-19","objectID":"/2018/%E8%87%AA%E7%84%B6%E8%BE%A9%E8%AF%81%E6%B3%95/:0:0","tags":["读书笔记"],"title":"自然辩证法","uri":"/2018/%E8%87%AA%E7%84%B6%E8%BE%A9%E8%AF%81%E6%B3%95/"},{"categories":["平日里的白日梦"],"content":"工程伦理问题涉及对工程行为正当性的思考和价值判断，往往需要在价值冲突中做出正确的价值选择。了解它的必要性有三个： 提升工程师的伦理素养，加强工程从业者的社会责任（最重要的一点） 推动可持续发展，实现人与自然的协同进化（倾向于环境方面） 协调社会各群体之间的利益关系，确保社会稳定和谐（强调要保证公众利益，不止为老板考虑） 学习的目标应该是： 培养工程伦理意识和责任感（含义是增强对工程伦理问题的敏感性和责任感） 掌握工程伦理的基本规范（指的是面对伦理问题时应遵循的行为准则） 提高工程伦理的决策能力（面对复杂伦理问题时理性决策） ","date":"2018-09-15","objectID":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/:0:0","tags":["杂谈"],"title":"工程与伦理","uri":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/"},{"categories":["平日里的白日梦"],"content":"1. 如何理解工程 ","date":"2018-09-15","objectID":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/:1:0","tags":["杂谈"],"title":"工程与伦理","uri":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/"},{"categories":["平日里的白日梦"],"content":"1.1 技术与工程 现代社会，人类的工程活动都要以技术为基础，对技术的选择和应用直接或间接地影响工程地进步及发展方向。因此，工程与技术密切相关。在讨论工程伦理地相关问题之前，必须先理清工程与技术间地联系与区别 区别： 内容与性质不同。技术是以发明为核心的活动，它体现为人类改造世界的方法、技巧和技能；工程则是以建造为核心的活动，工程的建造过程是发挥科学、技术的社会功能、实现其价值的过程。 成果的性质与类型不同。技术活动的成果主要形式是发明、专利、技术技巧和技能（显现为技术文献或论文），它往往在一定时间内是有产权的私有知识；工程活动成功的主要形式是物质产品、物质设施，它直接地显现为物质财富本身。 活动主体不同。技术活动地主体是发明家，工程活动的主体是工程师以及工人、管理者、投资方等。 任务、对象和思维方式不同。技术是探索带有普遍性的、可重复性的“特殊方法”，技术活动时利用科学原理和技术手段的发明创造过程。任何技术方法都必须具有“可重复性”。但是，任何工程项目都是一个相对独立的完整活动单元，其目的明确，在时间、空间上分布不均匀，规模一般比较大，需要周密的分工合作和严格的管理，牵涉到组织、管理、体制、文化等因素，具有独一无二的特征。 联系： 都以满足人类某种需要为目的，都是人类在认识世界的过程中为了获取更为优质的生活而改造世界的活动。 任何时代的工程活动都要以当时的技术为基础，工程要对技术进行集成，同时，工程也必然成为技术的重要载体，并使技术的本质特征得以具体化。 技术往往包含在工程之中 ","date":"2018-09-15","objectID":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/:1:1","tags":["杂谈"],"title":"工程与伦理","uri":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/"},{"categories":["平日里的白日梦"],"content":"1.2 工程的定义 1818年英国民用工程师学会成立，使工程师与传统意义的工匠在职业划分上明确分离的重要标志。 广义的工程定义：工程是由一群人为达到某种目的，在一个较长时间周期内进行协作活动的过程。这一理解强调众多主体参与的社会性，如希望工程 狭义的工程定义：工程是以满足人类需求的目标为指向，应用各种相关的知识和技术手段，调动多种自然与社会资源，通过一群人的相互协作，将某些现有实体（自然的或人造的）汇聚并建造为具有预期使用价值的人造产品的过程。这一理解不仅强调多主体参与的社会性，而且主要指针对物质对象的、与生产实践密切联系、运用一定的知识和技术得以实现的人类活动。如化学工程、三峡工程、载人航天工程 工程伦理所讨论的工程主要指狭义的定义 ","date":"2018-09-15","objectID":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/:1:2","tags":["杂谈"],"title":"工程与伦理","uri":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/"},{"categories":["平日里的白日梦"],"content":"1.3 工程的过程 一般而言，计划、设计、建造、使用和结束这五个环节构成了工程的完整生命周期。其中，设计与建造是最关键的两个环节 任一工程项目整体上都是一种工程实践。工程实践作为特定知识在自然界中的运用方式，具有与现代科学实验相似的因素，即不确定性和探索性。 工程活动蕴含着有意识、有目的的设计 工程设计和实施过程中人们的知识与技术总是不完备的 工程实践的后果往往会超出预期 ","date":"2018-09-15","objectID":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/:1:3","tags":["杂谈"],"title":"工程与伦理","uri":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/"},{"categories":["平日里的白日梦"],"content":"2.4 工程活动的几个维度 哲学：工程在哲学上进入了后现代 技术 经济：主要包括工程的经济价值和工程的经济性 管理 社会 生态 伦理：伦理的维度探讨的是人们如何“正当的行事” ","date":"2018-09-15","objectID":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/:1:4","tags":["杂谈"],"title":"工程与伦理","uri":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/"},{"categories":["平日里的白日梦"],"content":"2. 案例：怒江水电开发 案例的具体描述参见：怒江水电开发 国际中国环境基金会的政策建议：关于停止怒江水电开发的建议 案例引起的思考： 一个规划中的水电开发工程何以引发如此广泛的争论？这反映了工程实践的什么特点？ 这个争论反映了哪些伦理问题？如何理解水利开发工程中出现的这些伦理问题？ 重大工程的实施应该如何处理经济社会发展和环境保护间的关系？ 人类文明的发展，人类大规模改造自然的工程行为不可避免地要涉及人与自然、人与社会、人与人地关系问题，多重价值追求，不同地利益诉求也会导致工程行为选择上地困境和冲突，并引发对工程行为意义和正当性地反思。 我的想法：《关于停止怒江水电开发的建议》一文中所有的论点都具有足够的说服力，正如文中最后一句所说，“我们没有理由让它消失在我们这一代人的手里”，脱贫致富也不止这一种方法，三峡水电工程的建立和核电的发展也不至于我们国家缺电到非建不可的情况，我认为这一自然奇观应予以保留甚至尽力保护起来，而不是眼里只看着经济。 ","date":"2018-09-15","objectID":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/:2:0","tags":["杂谈"],"title":"工程与伦理","uri":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/"},{"categories":["平日里的白日梦"],"content":"参考 1. 国际中国环境基金会 2. 公正-该如何做是好（哈佛大学公开课） ","date":"2018-09-15","objectID":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/:3:0","tags":["杂谈"],"title":"工程与伦理","uri":"/2018/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E4%BC%A6%E7%90%86/"},{"categories":["研究生的区块链学习之路"],"content":"研三重新来写这篇文章，感触更多，也许当初明白这些，会有不同的选择，可惜，世上没有如果。 很多人，包括我，都是在本科毕业时不知所措才选择的读研，想给自己一个缓冲，在研究生阶段想明白自己想做什么。所以说啊，「读研不一定是最正确的选择，但一定是正确的选择」，真的很少听人说，自己后悔读研了的说法。不过，既然抱着这样的想法入学，那么就要努力去想明白这个问题然后做准备，不然的话，三年一晃而过，又面对同样的选择。 在最开始首先要对研究生阶段有一个清晰的了解，做什么，怎么做，到了这个时候，要对自己有一个好的定位。因此将杨义先教授《告研究生新生书》中的一些内容转载如下： ","date":"2018-09-05","objectID":"/2018/what-should-be-done-in-master-three-years/:0:0","tags":["科研记录","杂谈"],"title":"如果度过研究生阶段","uri":"/2018/what-should-be-done-in-master-three-years/"},{"categories":["研究生的区块链学习之路"],"content":"关于研究生 什么是研究生？研究生就是做研究的学生，因此，大家不要再把本科阶段的“视分如命”传统带进来。从今以后，请大家记住：“考试，60分万岁；研究，90分及格！”若有某研究生给导师报喜说：“老师我已经超额多上X门课程，并考试得满分”，那么，导师也许会把他当作可爱的小傻瓜，你不会来夺此头衔吧？当然，研究生培养方案中包括课程、学分、考试和论文等所有要求都必须首先满足！特别提醒各位，研究生的论文是“干”出来的，而不是埋头“写”出来的，更不是“抄”来的！抄袭论文很危险，害人害已，后果不堪设想 ","date":"2018-09-05","objectID":"/2018/what-should-be-done-in-master-three-years/:0:1","tags":["科研记录","杂谈"],"title":"如果度过研究生阶段","uri":"/2018/what-should-be-done-in-master-three-years/"},{"categories":["研究生的区块链学习之路"],"content":"关于导师 导师将教给你什么？导师不再教你更多的知识，因为，在知识爆炸的时代，即使是天才，他所能掌握的知识也几乎可以忽略不计。从小到大，你被灌输的知识已经够多了，现在是该你学会“如何自己学习知识”的时候了！导师将重点培养你的三种能力：创新能力、动手能力、社会适应能力。当然，还有一点，导师也许将把自己多年失败的教训毫不隐瞒地展示给你，以使你不再重蹈覆辙。成功者的经验很难被复制，但是，他的失败却足以借鉴。 ","date":"2018-09-05","objectID":"/2018/what-should-be-done-in-master-three-years/:0:2","tags":["科研记录","杂谈"],"title":"如果度过研究生阶段","uri":"/2018/what-should-be-done-in-master-three-years/"},{"categories":["研究生的区块链学习之路"],"content":"给自己定位 如何给自己定位？定位不清，害死人！虽然每个人都有“顶天”和“立地”两种选择；但能“顶天”之人，毕竟是少数；绝大部分人将“立地”！若你没特别的理论研究天赋，不能成为“顶天”的科学家，那就建议你老老实实瞄准“立地”的工程师。科学家和工程师都同等重要，不必再分高低贵贱。社会并不急需“既能做一些不痛不痒的项目，又能发表几篇不三不四的论文”的所谓通才，强劲的社会竞争力是检验学生培养是否成功的唯一标准。 ","date":"2018-09-05","objectID":"/2018/what-should-be-done-in-master-three-years/:0:3","tags":["科研记录","杂谈"],"title":"如果度过研究生阶段","uri":"/2018/what-should-be-done-in-master-three-years/"},{"categories":["研究生的区块链学习之路"],"content":"关于兴趣 什么兴趣值得付出代价？并非所有兴趣都该纵容，许多研究生误解了“兴趣是成功之母”，并常常拿“兴趣”来作为挑肥拣瘦的借口。如果有足够的胆量，那么，独门兴趣（如，扎克伯格的Facebook等）才值得死盯，因为，这样的兴趣要么送你上天堂，要么拉你下地狱。人生有此机会一搏，也不全是坏事！但是，大众化兴趣（比如，我更擅长单片机、我的本科专业更适合…、我学过XX课程等）就应该服从真实需求，必要时劝君忍痛割爱，否则成功将与你无缘，毕竟今后是你要去适应社会，而不是社会来适应你！其实，咬住大众化兴趣不放者要么是想偷懒，要么是没自信。当然，所有生活兴趣都是值得享受的，工作兴趣与生活兴趣不要混为一谈。 ","date":"2018-09-05","objectID":"/2018/what-should-be-done-in-master-three-years/:0:4","tags":["科研记录","杂谈"],"title":"如果度过研究生阶段","uri":"/2018/what-should-be-done-in-master-three-years/"},{"categories":["研究生的区块链学习之路"],"content":"关于态度 态度到底有多重要？态度决定一切！只要态度出了问题，再加上研究生都有极高的智商，那么，稍稍发力，就能让任何导师“理屈词穷”，比如，可以轻易严格证明“研究生做项目是在给导师打工”、“导师在论文中的署名不合理”、“我的论文创新性已经足够毕业”等等。面对如此辩才，导师只能尽力而为，实在无奈，也只好弃权。多年的事实证明，能力弱和态度差常常相伴而生，也许正是因为态度差，才导致能力弱吧。“小事愿干，中事能干，大事敢干”是研究生的基本要求。 “尽力而为”与“竭尽全力”的区别到底有多大？“尽力而为”者用99.99%（＝A）的力气去做事，“竭尽全力”者用100.01%（=B）的力气去做事。表面上看A@B，但是，当若干个A相乘时，将有A´ A´ A´…=0, 而若干个B 相乘时B´ B´ B´…=¥。各位新同学明白了吗？如果你一生都“尽力而为”的话，那么，你将收获零；如果你一生都“竭尽全力”的话，那么，你将收获巨大成功！ ","date":"2018-09-05","objectID":"/2018/what-should-be-done-in-master-three-years/:0:5","tags":["科研记录","杂谈"],"title":"如果度过研究生阶段","uri":"/2018/what-should-be-done-in-master-three-years/"},{"categories":["研究生的区块链学习之路"],"content":"关于课题 做啥课题真的很重要吗？从学习知识的角度来说，做啥课题确实有区别；但是，从培养能力角度来看，其实啥课题的效果都一样。别忘了，如今已是“重能力，而轻知识”的年代！过度区分是所有矛盾的根源，过度关注细节差异者永远也得不到满足。另外，如果在某段时间内，被安排从事一个自己不了解或不擅长的课题，那你为何不把它当成一种挑战，以此来锻炼和培养自己的“适应”和“学习”的能力呢？ ","date":"2018-09-05","objectID":"/2018/what-should-be-done-in-master-three-years/:0:6","tags":["科研记录","杂谈"],"title":"如果度过研究生阶段","uri":"/2018/what-should-be-done-in-master-three-years/"},{"categories":["研究生的区块链学习之路"],"content":"高分低能 高分学生为什么容易成低能？过去多年的事实反复证明：保研学生和考研高分的学生，更容易在研究生阶段成为低能学生。这个看似矛盾的现象，其实有其必然。 个别高分学生总是习惯以讲课和考试的思维去考虑问题，从小到大，他/她的成就感也主要来自于各类考试，因此，没有考试，不能得分的事情（比如，科研）他们都下意识地抵制或恐惧。 读研前，几乎都是别人来向他/她请教有关学习和考试的问题，这就无形中使他/她感觉过于良好，因此，一旦有不懂的科研事项，就很难放下架子去向别人（特别是那些考试成绩较差的人）请教，当然，久而久之就会落后甚至被无情地淘汰。 过于精通本科阶段的循序渐进方法，更难适应研究问题时的跳跃创新，以为科研也要把所有准备工作都做好后，才能开始。 过于企望本科考试优势能够顺利过渡到研究生的科研阶段，因此，思想包袱更重，更不敢面对新挑战。 ","date":"2018-09-05","objectID":"/2018/what-should-be-done-in-master-three-years/:0:7","tags":["科研记录","杂谈"],"title":"如果度过研究生阶段","uri":"/2018/what-should-be-done-in-master-three-years/"},{"categories":["平日里的白日梦"],"content":"在喧闹而奔忙的世界中平静地往前走 这是多么和平，安宁 你要与周围的所有的人友好相处 尽可能不要放弃这种努力和追求 你要轻轻但清晰地说出自己的真实思想 并且耐心倾听别人含糊甚至烦人的想法 因为每个人都有他们自己的故事 你要远远避开那些吵闹、具有侵略性的人 他们会使你的精神痛苦 如果你将自己与他人作比 那么你将变得既自负又痛苦 因为这世上永远有着比你强和比你弱的人们 你该享受你自己的成就和计划 保持对你自己的事业的兴趣 它们不管多么细琐、低下，都是你 在变化多端的时代能真正拥有的财产 在商业事务中你要小心谨慎 这世上到处都有阴谋和欺骗 你也不要让自己对美德视而不见 世界上很多人为了崇高的理想在忍饥挨饿 生活中到处都有英雄主义存在 你对你自己要诚实 尤其不要无情装有情 对爱情不要玩世不恭 在这干旱、没有希望的土地上 它是一片四季常青的绿洲 你要认真吸取流水年华的经验 从容地向青春时光告别 你要培养自己地精神力量 以抗击突如其来地不幸地打击 但你千万不要用想象使自己苦恼、忧伤 有很多恐惧产生于疲劳和孤独 除去有益于身心健康地原则之外 你要善待你自己 你和树林、星星一样是这茫茫宇宙地一份子 你有权利生活在这里 毫无疑问这世界已经完全为你打开 所以你要与上帝和平相处 不论你觉得他身在何方 也不论你作出何种努力，有什么渴望 在喧闹、混杂的生活中 你应该与你的心灵和平相处 尽管这世上有很多假冒和欺骗 有很多单调乏味的工作 和众多破灭的梦幻 它仍然是一个美好的世界 记住：你应该努力去追求幸福 祈求上天赐予我平静的心 接受不可改变之事 给我勇气 改变可以改变之事 并赐予我 分辨这两者的智慧 ","date":"2018-08-22","objectID":"/2018/engraved-in-st-pauls-church-in-1962/:0:0","tags":["文摘"],"title":"1692年镌刻于巴尔的摩圣保罗教堂","uri":"/2018/engraved-in-st-pauls-church-in-1962/"},{"categories":["爱编程爱技术的孩子"],"content":"前言 Markdown用习惯之后，就会不管什么事都想用它来做，因为真的太好用了。本篇文章就是一些尝试，因为往往“不堪大用”，所以给这篇文章起了这么一个名字。当前一些基本想法如下 将Markdown变成思维导图 将Markdown变成幻灯 用Markdown写论文 ","date":"2018-07-01","objectID":"/2018/markdown-usage/:1:0","tags":["Hugo"],"title":"Markdown使用探索","uri":"/2018/markdown-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"将Markdown变成思维导图 首先尝试将Markdown变成思维导图，这一想法主要是因为当初使用过一段时间幕布，觉得这种大纲与思维导图的即时切换很有效率，在使用Markdown以后，突然发现无序列表的展现形式和幕布的大纲完全一致，因此打算尝试一下。 由于使用思维导图的频率不是很高，因此最好是可以在网页上可以直接导入Markdown文件就能转换为思维导图，首先尝试的思路就是幕布。 ","date":"2018-07-01","objectID":"/2018/markdown-usage/:2:0","tags":["Hugo"],"title":"Markdown使用探索","uri":"/2018/markdown-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"幕布 幕布有网页版，满足第一个条件，查看幕布中可导入的文件格式，发现只有两种：OPML和FreeMind，我使用的Markdown编辑器是Typora，导出格式中有OPML的选项，需要安装pandoc才能以这种方式导出。虽然看起来是无序列表的形式，但导入幕布的markdown内容实际上应该是多级标题的形式，否则导入会出现错误，各级标题下的内容会作为备注出现。以下面的内容为例，测试幕布的导入效果。 ### 家庭教师reborn 《家庭教师HITMAN REBORN！》是由ARTLAND改编自天野明的同名漫画。作品于2006年10月7日播放，全203话。故事围绕彭格列（意大利黑手党）第十代首领沢田纲吉与其家族成员的成长而展开的一系列故事。 ### 秦时明月 《秦时明月》系列是由中国杭州玄机科技信息技术有限公司制作的3D武侠动画系列，于2007年春节期间起在中国全国各地正式首映。目前动画已完结前5部，共175集。 系列灵感来源于温世仁原著小说。时代背景从秦灭六国、建立中国首个帝国开始，到秦国灭亡，时间跨度30年(包括回忆)，讲述一个体内流淌英雄之血的少年——天明，最终成长为盖世英雄，影响历史进程的热血励志故事 ### 成龙历险记 《成龙历险记》是龙之宝工作室制作系列冒险喜剧动画，于2000年9月9在Kids' WB华纳动画天地电视台首播。剧情讲述了成龙一家有趣的历险故事，成龙和小玉在世界各地探索各种神秘悬疑的谜团，生活和经历中充满着许多奇幻色彩，其中有关武功和魔法，包含了亲情和友情，以及中国文化的元素，几乎每一趟惊险刺激的旅程身边都有小玉陪伴而行。 ### 美食的俘虏 电视动画《美食的俘虏》改编自岛袋光年的同名漫画作品，由东映动画制作，于2011年4月3日起在富士电视台播出，全147话。这是个美食时代。讲述了美食猎人阿虏和料理人小松成长的相关故事。 ### 刀剑神域 《刀剑神域》是由川原砾著作，abec负责插画，电击文库所属的轻小说。2022年，讲述了玩家桐人在虚拟大规模线上角色扮演游戏《刀剑神域〈SAO〉》中战斗并最终脱离世界的故事。 建立一个名为动漫收藏.md的新文档保存上面的测试内容，导出为OPML格式，然后在幕布中导入，幕布导入时以文件名为标题，导入后大纲与思维导图两种模式的显示效果如下 这种方法的缺点是幕布的思维导图展示风格只有最普通的形式，高级的功能需要付费，而且即时付费后，幕布中也缺乏好看的思维导图风格。 最后，幕布大纲模式的内容也可以导出为OPML文件，但是该功能也需要付费。 ","date":"2018-07-01","objectID":"/2018/markdown-usage/:2:1","tags":["Hugo"],"title":"Markdown使用探索","uri":"/2018/markdown-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"Xmind Zen 在网上查找发现实际上大量的思维导图软件本身就支持导入Markdown格式的文件，但网页版的思维导图工具中，支持导入Markdown文件的只有百度脑图，可惜百度脑图的显示风格不符合我的喜好。因此只能从本地软件中寻找，最后发现Xmind Zen最符合我的使用需求：彩色线条的显示风格和对Markdown格式导入的良好支持。 Xmind Zen导入需要在上述幕布导入内容的基础上添加标题，比如前面用来测试的动漫收藏md文档全部为三级标题内容，需要在开头加入二级标题动漫收藏，导入后以彩色线条的风格显示，取消背景颜色，选择分支自由模式，调整后效果如下 Xmind也可以将思维导图导出为markdown格式存储。但是Xmind Zen软件是有试用期的，试用期过后将无法使用。 不过仔细想想，如果使用在线思维导图软件的话，可以直接制作，没有特别大的需求将markdown来专门转换，暂且作为一个尝试吧，不会用于实际工作。 ","date":"2018-07-01","objectID":"/2018/markdown-usage/:2:2","tags":["Hugo"],"title":"Markdown使用探索","uri":"/2018/markdown-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"将Markdown变成幻灯片 本节尝试直接将Markdown写作的内容转换成PPT，这种想法来自于nodeppt项目，该项目将markdown文件渲染成为网页形式的PPT。 这种做法让我想起了hugo，那么是否可以用go来实现该项目，因为npm安装使用是真的烦。 最后发现，pandoc其实可以直接进行这个转换 ","date":"2018-07-01","objectID":"/2018/markdown-usage/:3:0","tags":["Hugo"],"title":"Markdown使用探索","uri":"/2018/markdown-usage/"},{"categories":["爱编程爱技术的孩子"],"content":"Markdown由Aaron Swartz和John Gruber共同设计 Aaron Swartz的博客：http://www.aaronsw.com/ John Gruber的博客： https://daringfireball.net/ 作者中的Aaron Swartz是天才程序员，著名社交网站Reddit的联合创始人，14岁参与RSS 1.0规格标准的制订，致力于网络信息开放。在2011年7月19日，因被指控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕，2013年1月自杀身亡，年仅26岁。 Markdown的优点很多，下面稍微列举一下 易读（看起开舒服）、易写（语法简单）、易更改(纯文本)，处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 具体的Markdown语法主要分为如下几部分：标题，段落，引用，代码块，列表，加粗与斜体，分割线与删除线，链接，图片。 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:0:0","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 基础语法 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:0","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"标题 标题的定义有两种形式 使用=和-标记一级和二级标题。 一级标题使用 ========= 二级标题使用 --------- 使用#，可表示1-6级标题。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注：一般习惯从二级标题开始使用，因为一级标题对于多数文章来说，字体都显得有点过大 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:1","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"段落 段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:2","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"引用 在段落的每行或者只在第一行使用符号\u003e，如 \u003e 区块引用 效果： 区块引用 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:3","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"代码块 在每行起始添加4个空格或者一个制表符，注意要和普通段落间存在空行。最常用围墙式代码块，即使用 3 个连续的反单引号把一段文字包围起来表示代码块，这样可以避免每行代码开头都添加 4 个空格，写法如下 ​``` let i = 100; let j = 200; console.log(i + j); ​``` 使用围墙式代码块还有有个额外的功能：可以指定编程语言类别，让其中的代码实现语法高亮，方法是在第一行反单引号后面写上语言种类的名称，写法如下 ​```javascript let i = 100; let j = 200; console.log(i + j); ​``` 效果如下： let i = 100; let j = 200; console.log(i + j); 行内也可以对较短的字符标记代码，方法是使用两个反单引号，比如 行中`短代码`高亮 效果为： 行中短代码高亮 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:4","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"列表 使用·、+、或-标记无序列表，符号后需添加一个空格才能继续书写文字 第一项 第二项 使用数字并辅以.标记有序列表， 第一项 第二项 第三项 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:5","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"加粗与斜体 在强调内容两侧分别加上*或者_，一个符号为斜体，两个为粗体，如： *斜体*，_斜体_ **粗体**，__粗体__ 效果： 斜体 粗体，粗体 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:6","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"分割线和删除线 分割线最常使用就是三个或以上-，还可以使用*和_。删除线则是句子前后加两个波浪号~~ ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:7","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"链接 链接可以由两种形式生成：行内式和参考式。 行内式语法为： [书葬的github](https://github.com/shuzang) 效果： 书葬的github 参考式语法为： [书葬的github][1] [书葬的github][2] [1]:https://github.com/shuzang [2]:https://github.com/shuzang 效果： 书葬的github 书葬的github ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:8","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"图片 添加图片的形式和链接相似，只需在链接的基础上前方加一个!。如文章开头Azron Swartz图片使用如下语句 ![Aaron Swartz](https://laregledujeu.org/files/2013/01/Aaron_Swartz.jpg) ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:1:9","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 扩展语法 除以上基本语法外，还有一些常用扩展语法，主要是因为在一些特定场景下某些需求无法满足，其中有一些如待办事项和表格等使用非常频繁，因此在这里介绍，其它少用的扩展语法在其它文章里介绍。 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:2:0","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"待办事项 使用- [ ]和- [x]，效果如下 未选 已选 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:2:1","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"反斜杠\\ 相当于反转义作用，使Markdown语法符号成为普通符号。 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:2:2","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"表格 用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 | 姓名 | 角色 | | ---- | ---- | | 书藏 | 作者 | 以上语句效果如下 姓名 角色 书藏 作者 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:2:3","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"缩进 修改代码块的缩进，方法是选择多行代码，然后按 Tab 键增加缩进，按 Shift + Tab 键减少缩进。 文字的缩进有两种办法 使用表示空格的特殊字符\u0026nbsp;或\u0026#160; 输入法半角改全角，然后连续键入两个空格（半角改全角的快捷键为Shift+Space） ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:2:4","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"Emoji Emoji是否支持要看主题，github是肯定支持的。关于emoji符号查找表可以查看emoji cheat sheet ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:2:5","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"数学公式 公式的语法规则基本和Latex相同，可参见常用数学符号的 LaTeX 表示方法 主要也分为行内和区块两种，行内公式使用单个美元符$包围，区块使用两个美元符，比如 $2^2$ $$ \\frac{2}{3} $$ 效果如下（当然还要看渲染引擎是否支持，本博客支持显示数学公式） $2^2$ $$ \\frac{2}{3} $$ ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:2:6","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"特殊字符 不论是对公式的编辑，还是平时的使用，经常会遇到一些数学符号、希腊字母等特殊的字符，这些字符可以直接键入其命名实体或十进制代码而无需转义符\\包含就能显示，对照表见文末，一个简单的例子如下。 字符：希腊字母阿尔法 命名实体表示：\u0026Phi; 十进制编码表示：\u0026#934; 效果为Φ 注1：命名实体和十进制编码后的分号是整体的一部分，不是分隔符 注2：有需要参考更多的 Markdown基础语法 和 Markdown扩展语法 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:2:7","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"3. HTML语法辅助 由于书写的文本最终还是要转换成HTML页面，所以实际上可以使用一些HTML的语法来辅助书写 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:3:0","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"插入空行 使用\u003c/br\u003e可以替代作为空行插入 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:3:1","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"文字居中 写法如下 \u003ccenter\u003e这一行需要居中\u003c/center\u003e 效果如下 这一行需要居中 ### 上下标 写法如下 H\u003csub\u003e2\u003c/sub\u003eO 爆米\u003csup\u003eTM\u003c/sup\u003e 效果如下 H2O 爆米TM ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:3:2","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"字体颜色与字号 写法如下 \u003cfont color=\"#FF0000\"\u003e 红色 \u003c/font\u003e \u003cfont size=6\u003e size=6 \u003c/font\u003e \u003cfont size=5 color=\"#FF0000\"\u003e size=5的红色\u003c/font\u003e 效果如下 红色 size=6 size=5的红色 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:3:3","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"图片 原始图片规格不一，展示出来的效果往往很不好，使用HTML的语法可以定制图片的某些属性。以上面的创始人Aaron Swartz的图片为例，我们控制其大小 \u003cimg src=\"https://laregledujeu.org/files/2013/01/Aaron_Swartz.jpg\" width=\"512\" height=\"384\" /\u003e 通过将多张图片放在一个一行多列的表格中，线宽设置为0， 可以让这些图片并排显示，代码如下 \u003ctable\u003e\u003ctr\u003e \u003ctd\u003e\u003cimg src=\"http://bimgs.plmeizi.com/images/bing/2019/OHR.BeaujolaisRegion_ZH-CN1585928268_1920x1080.jpg\" alt=\"风景1\" style=\"zoom: 67%;\" /\u003e\u003c/td\u003e \u003ctd\u003e\u003cimg src=\"http://bimgs.plmeizi.com/images/bing/2020/OHR.MalhamStars_ZH-CN4163177154_1920x1080.jpg\" alt=\"风景2\" style=\"zoom: 67%;\" /\u003e\u003c/td\u003e \u003c/tr\u003e\u003c/table\u003e 效果如下 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:3:4","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"页内跳转 先定义一个锚 \u003cspan id=\"jump\"\u003eHello World\u003c/span\u003e 然后使用markdown语法即可跳转到锚所在之处 [XXXX](#jump) 比如数学公式部分点击文末可以跳转到附录 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:3:5","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"附录：特殊字符对照表 普通字符 特殊符号 命名实体 十进制编码 空格 \u0026nbsp; \u0026#160; 全角空格 \u0026emsp; \u0026#12288; ’ \u0026apos; \u0026#39; \" \u0026quot; \u0026#34; ( — \u0026#40; ) — \u0026#41; \u003c \u0026lt; \u0026#60; \u003e \u0026gt; \u0026#62; [ — \u0026#91; ] — \u0026#93; { — \u0026#123; } — \u0026#125; ´ \u0026acute; \u0026#180; ° \u0026deg; \u0026#176; ® \u0026reg; \u0026#174; © \u0026copy; \u0026#169; 数学符号 特殊符号 命名实体 十进制编码 ≤ \u0026le; \u0026#8804; ≥ \u0026ge; \u0026#8805; ≈ \u0026asymp; \u0026#8773; ≠ \u0026ne; \u0026#8800; ∩ \u0026cap; \u0026#8745; ∪ \u0026cup; \u0026#8746; ∠ \u0026ang; \u0026#8736; ∞ \u0026infin; \u0026#8734; ± \u0026plusmn; \u0026#177; √ \u0026radic; \u0026#8730; ∑ \u0026sum; \u0026#8722; ∫ \u0026int; \u0026#8747; Δ \u0026Delta; \u0026#916; 希腊字母 特殊符号 命名实体 十进制编码 Φ \u0026Phi; \u0026#934; Ω \u0026Omega; \u0026#937; α \u0026alpha; \u0026#945; β \u0026beta; \u0026#946; γ \u0026gamma; \u0026#947; δ \u0026delta; \u0026#948; ε \u0026epsilon; \u0026#949; ζ \u0026zeta; \u0026#950; η \u0026eta; \u0026#951; θ \u0026theta; \u0026#952; λ \u0026lambda; \u0026#955; μ \u0026mu; \u0026#956; ξ \u0026xi; \u0026#958; π \u0026pi; \u0026#960; ρ \u0026rho; \u0026#961; σ \u0026sigma; \u0026#963; φ \u0026phi; \u0026#966; ψ \u0026psi; \u0026#968; ω \u0026omega; \u0026#969; ∂ \u0026part; \u0026#8706; ∅ \u0026empty; \u0026#8709; ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:4:0","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"参考与扩展 1 Github-Markdown 2 Set table column width via Markdown [3] Markdown资源列表 ","date":"2018-06-30","objectID":"/2018/markdown-syntax/:5:0","tags":["Hugo"],"title":"Markdown语法","uri":"/2018/markdown-syntax/"},{"categories":["爱编程爱技术的孩子"],"content":"上一篇我们学习了Git的基本知识，包括仓库创建，提交、修改、推送、回退等等操作，本篇学习一些高级的功能。转自 廖雪峰的官方网站-git教程。 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:0:0","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 分支管理 每个仓库都可能有几条不同的分支，比如master分支，比如用于开发的dev分支。分支操作的实质是对指针的操作 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:1:0","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 分支管理策略 在实际开发中，我们应该按照几个基本原则进行分支管理： master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面工作； 工作都在dev分支上，也就是说，dev分支是不稳定的，到大版本发布时，再把dev分支合并到master上，在master分支发布大版本； 团队中每个人都在dev分支上干活，但每个人都有自己的分支，时不时地往dev分支上合并就可以了 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:1:1","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 创建分支 创建dev分支，然后切换到dev分支： $ git checkout -b dev Switched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev $ git checkout dev Switched to branch 'dev' 用git branch命令查看当前分支，该命令会列出所有分支，当前分支前面会标一个*号 $ git branch * dev master 然后就可以在dev分支上进行修改提交，commit操作完成后对分支的操作也就完成，可以切换回master分支 $ git checkout master 切换回master分支后看不到刚才的修改，因为修改在dev分支上，必须先进行合并 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:1:2","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 合并分支 将dev分支的修改合并到master分支 $ git merge dev git merge命令用于合并指定分支到当前分支。合并后，就能在master分支查看到刚刚在dev分支做的修改 合并完成后dev分支就没用了，可以删除它 $ git branch -d dev 强行删除分支使用参数-D $ git branch -D dev 删除后查看分支，会发现只剩下master $ git branch ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:1:3","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 解决冲突 有时候，不同的分支对同一处做了修改，此时合并会产生冲突，因为系统不知道该采用哪种修改。此时若强行合并，是无法通过的，系统会提示必须手动解决冲突后再提交。可以用git status命令查看冲突文件是哪个，手动解决冲突后重新提交即可成功，然后可以用带参数的git log命令查看合并情况 $ git log --graph --pretty=oneline --abbrev-commit 合并完成后删除分支 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:1:4","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"1.5 Bug分支 软件开发中，出现bug是正常的事情，有了bug就需要修复。在git中，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除 背景：当你需要修复某个bug时，当前在dev分支上进行的工作还没有提交，而且因为工作只进行到一半，完全没法提交，但bug却必须马上修复 解决办法：git stash命令，可以把当前工作现场保存，等以后恢复现场工作后继续工作 $ git stash $ git status 使用git status查看工作区确认工作区是干净的，然后按如下步骤进行 切换到bug所在分支 创建bug修复分支 修复 提交 切换回bug所在分支 合并分支 删除bug修复分支 切换回工作的dev分支 查看修复bug前保存的工作现场 $ git stash list 恢复工作现场 $ git stash pop ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:1:5","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 多人协作 当我们从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin 要查看远程库的信息 $ git remote 显示远程库更详细的信息 $ git remote -v 使用-v参数会显示可抓取和推送的orign的地址，但若没有推送权限，则看不到push地址 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:2:0","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 推送分支 推送分支，就是把该分支上的所有本地提交推送到远程仓库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master 如果要推送其他分支，比如dev，就改成： $ git push origin dev 但是，并不是一定要把本地分支往远程推送 master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，没必要推到远程 在git中，分支完全可以在本地自己使用，是否推送，视心情而定 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:2:1","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 抓取分支 在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致 git checkout -b branch-name origin/branch-name 建立本地分支和远程分支的关联 git branch --set-upstream branch-name origin/branch-name 从远程抓取分支 git pull ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:2:2","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 标签管理 因为版本号太复杂，所以git提供了标签功能 命令git tag \u003cname\u003e用于新建一个标签，默认为当前分支，也可以指定一个commit id； 命令git tag -a \u003ctagname\u003e -m \"blablabla...\"可以指定标签信息； 命令git tag -s \u003ctagname\u003e -m \"blablabla...\"可以用PGP签名标签； 命令git tag可以查看所有标签 命令git push origin \u003ctagname\u003e可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d \u003ctagname\u003e可以删除一个本地标签； 命令git push origin :refs/tags/\u003ctagname\u003e可以删除一个远程标签 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:3:0","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 忽略特殊文件 有时候，git工作目录里的某些文件并不想同步到远程的github仓库，此时可以在git工作区根目录下创建.gitignore文件，然后把要忽略的文件名填进去，git会自动忽略这些文件 注：.gitignore文件本身要上传到版本库进行管理 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:4:0","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"5. commit 信息编写 简单来讲，commit 就是在本地仓库中编写的文件的快照。与印象中不同的是，Git 不仅存储不同版本文件之间的差异，还存储了所有文件的完整版本。对于两个 commit 之间没有被修改的文件，Git 只存储指向前一个完全相同的文件的链接。 下面的图片展示了 git 如何随着时间存储数据，其中每个「Version」都是一个 commit： ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:5:0","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 Commit message Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。 $ git commit -m \"hello world\" 上面代码的-m参数，就是用来指定 commit mesage 的。 如果一行不够，可以只执行git commit，就会跳出文本编辑器，让你写多行。 $ git commit commit信息可以随意编写，但一般来说，应该清晰明了，说明本次提交的目的。 一个清晰的、规范化的Commit message，有如下好处 提供更多的历史信息，方便快速浏览 过滤某些commit（比如文档改动），便于快速查找信息 可以直接从commit生成Change log，Change Log 是发布新版本时，用来说明与上一个版本差异的文档 而且，查看commit信息的多数是团队成员或其它对该项目感兴趣的人，规范清晰的commit信息对它们有如下意义 加快和简化代码审查（code reviews） 帮助理解一个更改 解释不能只由代码描述的「为什么」 帮助未来的维护人员弄清楚为什么以及如何产生的更改，从而使故障排查和调试更容易 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:5:1","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 写法规范 目前，社区有多种 Commit message 的写法规范。但Angular 规范是使用最广的写法，比较合理和系统化，并且有配套的工具，因此学习和使用这种规范。 Commit message分为三部分： Header，Body 和 Footer。 \u003ctype\u003e(\u003cscope\u003e): \u003csubject\u003e // 空一行 \u003cbody\u003e // 空一行 \u003cfooter\u003e 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 Header Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 type type用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 scope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subject subject是 commit 目的的简短描述，不超过50个字符。 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） 一些例子如下 docs(error/$rootScope/inprog): add missing \"$timeout\" fix(loader): use `false` as default value for `transclude` in compone feat($compile): Allow ES6 classes as controllers with `binToControll` Body Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. - Bullet points are okay, too - Use a hanging indent 有两个注意点。 使用第一人称现在时，比如使用change而不是changed或changes。 应该说明代码变动的动机，以及与以前行为的对比。 Footer Footer 部分只用于两种情况。 不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: 'attribute', } After: scope: { myAttr: '@', } The removed `inject` wasn't generaly useful for directives so there should be no code using it. 关闭Issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 Closes #234 也可以一次关闭多个 issue 。 Closes #123, #245, #992 Revert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 revert: feat(pencil): add 'graphiteWidth' option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit \u003chash\u003e.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:5:2","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"5.3 生成Change log 如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成，如下例 生成的文档包括以下三个部分。 New features Bug fixes Breaking changes 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，还可以添加其他内容。 一般使用相关工具自动生成Change log。 ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:5:3","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"5.4 相关命令 rebase -i可以用来压缩提交（squash commits）、 编写信息、 重写/删除/重新编排 commit 等。 fixup可用来清理 commit，而不需要复杂的 rebase。这篇文章提供了很好的示例，说明了如何以及何时进行此操作。 cherry-pick在你 commit 到了错误的分支而不需要重新编码时非常有用。 $ git cherry-pick 790ab21 [master 094d820] Fix English grammar in Contributing Date: Sun Feb 25 23:14:23 2018 -0300 1 file changed, 1 insertion(+), 1 deletion(-) ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:5:4","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"5.5 其它注意 遵循以上格式的同时，还有一些建议。 commit message解释当前 commit 所解决的问题，重点描述产生此更改的原因，而不是手段，因为代码会解释一切。应当解释清楚是否存在副作用以及其他不直观的影响。 只看注释便可明白而无需查看变更内容 # Good Add `use` method to Credit model 为 Credit 模块添加 `use` 方法 # Bad Add `use` method 添加 `use` 方法 # Good Increase left padding between textbox and layout frame 在 textbox 和 layout frame 之间添加向左对齐 # Bad Adjust css 就改了下 css 使用信息本身来解释“原因”、“目的”、“手段”和其他的细节 # Good Fix method name of InventoryBackend child classes Classes derived from InventoryBackend were not respecting the base class interface. It worked because the cart was calling the backend implementation incorrectly. # Good Serialize and deserialize credits to json in Cart Convert the Credit instances to dict for two main reasons: - Pickle relies on file path for classes and we do not want to break up everything if a refactor is needed - Dict and built-in types are pickleable by default # Good Add `use` method to Credit Change from namedtuple to class because we need to setup a new attribute (in_use_amount) with a new value 保持语言的一致性 对于项目所有者而言：选择一种语言并使用该语言编写所有的 commit 信息。理想情况下，它应与代码注释、默认翻译区域（用于本地化项目）等相匹配。 对于贡献者而言：使用与现有 commit 历史相同的语言编写 commit 信息。 # Good ababab Add `use` method to Credit model efefef Use InventoryBackendPool to retrieve inventory backend bebebe Fix method name of InventoryBackend child classes # Good (Portuguese example) ababab Adiciona o método `use` ao model Credit efefef Usa o InventoryBackendPool para recuperar o backend de estoque bebebe Corrige nome de método na classe InventoryBackend # Bad (mixes English and Portuguese) ababab Usa o InventoryBackendPool para recuperar o backend de estoque efefef Add `use` method to Credit model cdcdcd Agora vai ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:5:5","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"参考及扩展阅读 git cheat sheet git官网 git中文指南 廖雪峰的官方网站-git教程 如何编写 Git Commit Message Pro Git Book - Commit 指南 关于 Git Commit Messages 的说明 合并与变基 Pro Git Book - 改写历史 Commit message 和 Change log 编写指南 AngularJS Git Commit Message Conventions commit-messages-guide_中文版 Understanding Semantic Commit Messages Using Git and Angular ","date":"2018-04-22","objectID":"/2018/git-learning-improvement/:6:0","tags":["git"],"title":"Git提高-分支管理, 多人协作, 标签管理, gitignore, commit信息","uri":"/2018/git-learning-improvement/"},{"categories":["爱编程爱技术的孩子"],"content":"版本控制系统在代码开发过程中必不可缺，本系列学习 Git 的使用，版本托管服务则是 Github。以廖雪峰大神 git教程 为主体，辅以使用过程中遇到的问题和心得。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:0:0","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 版本控制系统 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:1:0","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 作用 版本控制系统用来解决两种情况 文章不断进行修改，但又觉得之前的版本可能有用，于是产生大量重命名文件，代码编辑亦如是，而且更加不容易回溯。 版本1.doc 版本2.doc 最终版本.doc 最终版本改.doc 真的是最终版本了.doc 多人协作，每次都需要校对对方的改动，然后进行合并，会花费大量不必要的精力 版本控制的作用就是记录所有的修改历史，便于需要时回退，同时提供一个协作的平台。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:1:1","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 历史 Git 属于分布式版本控制，在此之前主要是集中式的版本控制，基本原理是有一个服务器放所有的代码，要工作的时候下载回来，改动完上传回去，记录不同人的改动和合并都由服务器端完成，这种形式极度依赖于服务器性能和网速。 2005 年 Linux 内核代码版本控制使用的软件失效，Linux 创始人 Linus 花了一周开发了 Git 这个分布式版本控制系统，其后慢慢流行，现在已用于大多数的项目代码管理。 分布式版本控制和 torrent 差不多，每个人的电脑都是服务器，修改完直接把修改的部分推送给所有拥有这个项目的人。分布式版本控制也有服务器，但主要是负责做备份，并方便大家的交换用的，并不是必要。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:1:2","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 Github Github，发音为「 ɡɪthʌb 」，是为开源项目免费提供 Git 存储的网站，2008年上线。 注意，Git 和 Github 这两个单词在官方的网站上首字母都是大写，因此我们遵从这样的规则。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:1:3","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 安装使用 Git 是全平台的软件，命令行界面，连接到服务商（比如 Github）就能使用，目前 Github 已经推出了 windows 上的 GUI 版本，操作更加简便。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:2:0","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 Linux安装 $ sudo apt-get install git $ git version 安装完成后还要设置自己的名字和Email地址 $ git config --global user.name \"your name\" $ git config --global user.email \"email@example.com\" --global参数的意思是这个名字和邮箱应用于所有git仓库 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:2:1","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 windows安装 从官网下载Download x.xx for Windows按照，会自动配置环境变量。我一般使用chocolatey包管理工具，执行命令如下 \u003e choco install git Windows下GUI版下载地址为：https://desktop.github.com/ ，嗯，真香，windows下我已经很久不用命令行的git了，一般都当作shell工具来使用，而不是执行git命令。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:2:2","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 仓库和文件 [仓库]^(repository)，本质是一个文件夹，存放归属同一个项目的所有文件，是版本控制中的一个重要概念，可分为本地仓库和云端仓库。本地仓库是自己的代码编辑工作区，云端仓库是代码的备份。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:3:0","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 创建一个仓库 在本地任意路径创建gittest文件夹，路径自定义 $ mkdir gittest 进入创建的文件夹，使用 git init 命令把该目录变成git的仓库 $ cd gittest $ git init 然后仓库就建好了，该目录下会多一个.git隐藏文件夹，用来跟踪管理仓库。使用ls -a命令可以看到该文件夹，默认隐藏说明它很重要，里面的文件改动的话很容易导致仓库损坏。.git文件夹下的内容包括 $ ls .git config description HEAD hooks/ info/ objects/ refs/ 一些文件的作用在暂存区和工作区部分解释。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:3:1","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 在仓库中添加文件 添加文件的类型有讲究 对txt文档、代码文件等文件类型，版本控制系统可记录每次的改动 对图片、视频、PDF等文件类型，版本控制系统只能管理，不能记录改动，最多只能记录大小变化，Word文件实质是二进制格式，所以同样没法跟踪改动 首先新建一个txt文件并放在gittest目录下，编辑其文件内容 $ cd gittest $ touch hellogit.txt $ cat hellogit.txt hello git 用git add命令将该文件添加到暂存区，暂存区的概念之后解释 $ git add hellogit.txt 用git commit命令将文件提交到仓库(这里指本地仓库) $ git commit -m \"first commit\" [master (root-commit) a91c248] first commit 1 file changed, 1 insertion(+) create mode 100644 hellogit.txt 双引号中为备注信息，是该次提交的说明，一般情况是描述此次修改的。commit添加的提交信息对于代码review具有重要的作用，要遵循一定的规范。 命令执行完后的提示包括以下内容： 提交到了主分支（master)，备注信息为「first commit」 改动了一个文件（hellogit.txt），加了1行内容(注意那个+号) 最后一行中100代表regular file，644代表文件权限 git add命令可以有多个，分多次将文件添加到暂存区，之后执行git commit命令会一次性将之前add的所有文件一起提交，如 git add file1.txt git add file2.txt file3.txt git commit -m \"add 3 files\" 也可以使用如下命令一次性将所有修改添加到暂存区，然后执行commit命令 $ git add . ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:3:2","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 对文件进行修改 版本控制的目的就是记录文件的改动，我们将hellogit.txt文件的内容进行第二次修改，用 git status 命令查看仓库当前状态 $ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: hellogit.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 返回的提示内容会包括 位于哪个分支 修改了哪个文件 「修改尚未加入提交」 如果我们想看到具体做了哪些修改，用git diff命令，diff就是diffenence，所以git diff的意思就是查看不同 $ git diff hellogit.txt diff --git a/hellogit.txt b/hellogit.txt index f09e9c3..a90a76d 100644 --- a/hellogit.txt +++ b/hellogit.txt @@ -1 +1,2 @@ -hello git \\ No newline at end of file +hello git +add a line \\ No newline at end of file 提示中说明了我们在末尾添加了一行，其内容为add a line。此时我们确认了做的修改是我们心里所想的，就可以再次提交了 $ git add hellogit.txt $ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: hellogit.txt $ git commit -m \"add a line\" [master ae3c27f] add a line 1 file changed, 2 insertions(+), 1 deletion(-) $ git status On branch master nothing to commit, working tree clean 提交过程中可以每一步都使用git status命令查看当前状态，最后commit提交完的状态提示为： 位于master分支 无文件要提交，干净的工作区 此时就放心了，每次修改完或者要离开工作岗位的时候提交一次，就像游戏存档，离开之前或者重要关卡前存档，失败的时候就能读档重来，这里修改出错也可以从上一次的commit重来 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:3:3","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 远程仓库 本地仓库的代码编辑完成后，需要推送到远程仓库进行备份，我们使用Github提供的免费远程仓库。由于本地Git仓库和GitHub远程仓库之间的传输是通过SSH加密的，所以，需要先设置SSH密钥。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:4:0","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"4.1 创建SSH Key 在用户主目录下，看看有没有.ssh(默认隐藏)目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开终端，创建SSH Key： $ ssh-keygen -t rsa -C \"youremail@example.com\" 把邮件地址换成自己的邮件地址，然后一路回车，使用默认值即可，是否设置密码自己选择。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有私钥id_rsa和公钥id_rsa.pub两个文件。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:4:1","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"4.2 登陆GitHub 点击右上角头像，打开Settings——\u003eSSH and GPG Keys——\u003eNew SSH Key 填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，然后点击Add SSH key就行了 GitHub需要SSH Key识别出你推送的提交确实是你推送的，而不是别人冒充的。当然，GitHub允许添加多个Key。假定有若干电脑，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:4:2","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"4.3 创建远程仓库 首先在Github创建一个同名仓库 创建完成后跳转界面给我们提供了三个选择 …or create a new repository on the command line echo \"# gittest\" \u003e\u003e README.md git init git add README.md git commit -m \"first commit\" git remote add origin https://github.com/shuzang/gittest.git git push -u origin master …or push an existing repository from the command line git remote add origin https://github.com/shuzang/gittest.git git push -u origin master …or import code from another repository You can initialize this repository with code from a Subversion, Mercurial, or TFS project. 第一个选项基本就是没有本地仓库的情况下我们要做的所有事情，不过现在我们已经有了本地仓库，所以选择第二个选项，将本地已存在的gittest仓库关联到Github。 按提示执行命令即可 $ git remote add origin https://github.com/shuzang/gittest.git $ git push -u origin master Enumerating objects: 6, done. Counting objects: 100% (6/6), done. Delta compression using up to 4 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (6/6), 448 bytes | 448.00 KiB/s, done. Total 6 (delta 0), reused 0 (delta 0) To https://github.com/shuzang/gittest.git * [new branch] master -\u003e master Branch 'master' set up to track remote branch 'master' from 'origin'. 返回的结果告诉我们分支master设置为跟踪来自origin的远程分支master，代码已推送到远程仓库。此时查看远程仓库如下 点击左侧中间的2 commits可以查看提交的具体情况 继续点击每个具体的提交可以查看代码或文件的改动 查看别人的代码时，可以从这里查看一次次提交的改动和commit信息，有助于帮助我们学习别人的代码和编写思路 以后编辑和提交代码，主体就三个命令 $ git add . $ git commit -m \"commit message\" $ git push origin master 其它的git命令都是辅助，之后会慢慢介绍 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:4:3","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"4.4 从远程仓库克隆到本地 换到新电脑或者不是自己从头新建仓库，而是使用别人的仓库进行合作开发，使用git clone命令， $ git clone 仓库地址 如果是下载某个指定分支的内容，命令为 $ git clone -b 分支名 仓库地址 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:4:4","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 历史版本 修改的次数会逐渐变多，随着时间的流逝，我们完全不会记得每次修改了哪些内容，当然，git的出现就是为了帮我们解决这个问题，所以理所当然的会有查看历史版本的能力，以及回退到某个版本的能力，云端查看历史版本如上节所述，本地命令行如何查看在本节详细解释，以及介绍如果丢弃错误的提交。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:5:0","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 查看历史版本 使用 git log 命令可以查看历史改动 $ git log commit ae3c27f99068e6eb301fd7d28960b97ec56b9733 (HEAD -\u003e master, origin/master) Author: shuzang \u003c844327696@qq.com\u003e Date: Tue Jan 7 10:52:14 2020 +0800 add a line commit a91c24851ecd74e933bd638fd30773050bd7c692 Author: shuzang \u003c844327696@qq.com\u003e Date: Tue Jan 7 10:42:01 2020 +0800 first commit 提示内容是按从近到远的顺序把所有改动列举一遍，包括用户名、邮箱、修改日期，当时添加的message信息，不想看名称、邮箱和日期可以使用参数简化显示，如下： $ git log --pretty=oneline ae3c27f99068e6eb301fd7d28960b97ec56b9733 (HEAD -\u003e master, origin/master) add a line a91c24851ecd74e933bd638fd30773050bd7c692 first commit 也可以用以下命令查看参数使用方式 $ git log --help 提示内容中每次修改最前面的一串长字符是版本号（commit id），用十六进制表示，用来代表我们每次修改的版本 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:5:1","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 回退 首先，在git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然历史版本数多的时候写^写不过来，所以写成HEAD~number，如往上100个版本就是HEAD-100 回退命令为git reset，比如，回退到上一个版本 $ git reset --hard HEAD^ HEAD is now at a91c248 first commit 然后我们就看到真的变回去了，如果记下了版本号，我们还可以再跳回最后一个修改版本，也就是说，我们突然不想回退了，或者退多了 $ git reset --hard ae3c HEAD is now at ae3c27f add a line ae3c为其版本号，但版本号没必要写全，因为它的作用是为了区分各版本，所以只要找到第一个不相同的那位字母，写到那里就行了 版本切换的速度非常快，主要是因为HEAD只是一个指向当前版本的指针，跳转版本的时候也仅仅移动指针 在不记得版本号的情况下，git还提供了git reflog命令记录每次HEAD指针移动 $ git reflog ae3c27f (HEAD -\u003e master, origin/master) HEAD@{0}: reset: moving to ae3c a91c248 HEAD@{1}: reset: moving to HEAD^ ae3c27f (HEAD -\u003e master, origin/master) HEAD@{2}: commit: add a line a91c248 HEAD@{3}: commit (initial): first commit 该命令会显示每次修改版本的版本号 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:5:2","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 三大工作区域 使用 Git 最好理解它的三大工作区域：工作目录、暂存区和版本仓库。 工作目录就是代码编辑的主体目录，存放整个项目的源码和相关文件。 暂存区也叫做索引，用来跟踪工作目录的所有文件。事实上，工作目录中的每一个文件要么处于已跟踪状态，要么处于未跟踪状态，执行这个跟踪动作的，就是索引。索引所对应的静态文件是工作目录下 .git 隐藏文件夹中的 index 文件，其中记录每个已跟踪文件的文件名、文件时间戳、文件长度等元数据信息。需要注意的是，索引并不保持文件的具体内容，只记录文件的改动，文件的具体内容保持在版本仓库中。git add 命令可以将改变提交给暂存区。 版本仓库就是本地电脑具体保存所有代码的地方。具体位置是 .git/objects 文件夹，暂存区的文件经过 git commit 命令可以提交到本地版本仓库。本地版本仓库需要和远程的云端仓库（也就是存在 Github 服务器里的仓库文件）同步，如果有修改，需要推送到远程仓库，如果远程有别人的提交，需要拉取和本地代码合并。 版本库里有暂存区，还有自动创建的第一个分支master，以及指向master的一个指针叫HEAD git add实际上是把文件修改添加到暂存区； git commit实际上是把暂存区的所有内容提交到当前分支 在推送到远程仓库之前，一切修改都有挽救的机会 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:6:0","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"6.1 丢弃修改 场景1：当改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，使用命令 # 撤销单个文件修改 $ git checkout -- file # 撤销从上次提交后所有修改 $ git checkout -- * 场景2：当不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 $ git reset HEAD file $ git checkout -- file 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考上一节进行版本回退 最后，如果代码已经提交到了远程仓库，那么只能进行修复然后进行新的提交 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:6:1","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"6.2 删除文件 一般情况，是直接在文件夹中用rm命令删除，但这样工作区和版本库就不一致了 $ rm hellogit.txt $ git status On branch master Your branch is up to date with 'origin/master'. Changes not staged for commit: (use \"git add/rm \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) deleted: hellogit.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git add . $ git commit -m \"remove hellogit.txt\" 可以用命令恢复 $ git checkout -- hellogit.txt 正常从版本库中删除该文件，用git rm命令，并且git commit $ git rm hellogit.txt rm 'hellogit.txt' $ git status On branch master Your branch is up to date with 'origin/master'. Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) deleted: hellogit.txt $ git commit -m \"remove hellogit.txt\" 两者的区别是直接删除需要额外执行git add命令，而git rm删除后可以直接commit，当然，其实没有多少影响，具体用什么方法，自己选择就好。 ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:6:2","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"参考与扩展 [1] 廖雪峰的官方网站-git教程 [2] 猴子都能懂的git入门 [3] Github Learning Lab [4] Hellogithub ","date":"2018-04-20","objectID":"/2018/git-learning-getting-started/:7:0","tags":["git"],"title":"Git入门-基本概念, 基本原理, 安装使用","uri":"/2018/git-learning-getting-started/"},{"categories":["爱编程爱技术的孩子"],"content":"从大学期间教授的C、C++、Java，到自己接触的python、js，以及耳熟能详的PHP、C#、Ruby，甚至其它众多听过的没听过的语言。在此写这篇文章对这些主流的编程语言做一个对比，不是说哪个好哪个不好，更多的是总结下每一种都更多的用在哪些方面，以此来为未来的道路做一个参考。 ","date":"2018-04-18","objectID":"/2018/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9/:0:0","tags":null,"title":"编程语言选择","uri":"/2018/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9/"},{"categories":["爱编程爱技术的孩子"],"content":"TIOBE编程语言排行榜 TIOBT编程语言排行榜是编程语言流行趋势的一个指标,该排行每月更新一次。编程语言在排行榜上的位置是根据全世界范围内相应的有经验的工程师、课程和第三方供应商的数量而定。而谷歌、必应、维基、亚马逊、YouTube和百度等搜索引擎的搜索频次决定该语言的占比（Ratings）。另外，网站还特别强调，关于哪种语言是最好的，哪种语言的已完成代码最多和他们无关。 这个排行榜用来考察自己的编程技能是否还在时代潮流，也可以在开始一段新的学习或开发一个新系统时作为一个语言选择依据。2018年4月的排行榜如下： 我们就从这个排行榜开始讲起，分析各流行语言如表1. 表1. 语言 用来做什么 优点 缺点 编写了 Java 安卓应用开发、视频游戏开发、桌面GUI、Hadoop开发 使用人数最多，开发者需求量最大 内存占用很大；启动速度很慢 Gmail,Minecraft C 开发固件或移动应用；操作系统开发；编写系统软件 可移动性很高，可在不做改动或改动很小的情况下开发运行在不同平台的软件；C很小，可以嵌入几乎所有现代微型处理器，从冰箱到闹钟；因为几乎所有编程语言都由C实现，学会C就能使你方便的学会一切编程语言 没有运行时检查机制；不支持面向对象编程 kindle，Linux，OpenGL C++ 操作系统开发，搜索引擎开发等 学起来很困难；尺寸巨大，大部分功能相互影响是极其复杂的方式 Goole，Outlook Python 网页开发，视频游戏开发，桌面GUI,“胶水语言”-把用其它语言制作的各种模块（尤其是C/C++）连结在一起，黑客语言 最容易学习的语言；大量的库和函数；用于物联网，如树莓派平台 作为解释型语言，比编译型语言慢很多；在移动计算方面很强，很少有智能机应用由Python开发；是动态型，需要更多测试以及错误仅在运行时提示 Instagram，YouTube C# Windows应用开发，商业应用开发 完整的.NET库，提供接入大量功能和支持；基于C，所以学到的架构可以转移到其它语言如Java，PHP以及C++ 因为集合了.NET，没有任何跨平台能力 stackoverflow，Evernote PHP PHP是Web开发语言，广泛用在网站开发，API接口开发，服务器端开发，广告系统给开发，内部OA开发，移动后台开发，游戏开发 容易上手；社群庞大，社区活跃，开发者遇到的多数问题都有前人的解决方案；对数据库友好 代码不美；速度比其它语言慢；错误处理不够周全，因为要支持大量旧版的功能 facebook，wordpress Javascript 目前所有主流浏览器上唯一支持的脚本语言，可以做网站前端，后台，Web交互，游戏脚本等 因为任何代码功能都能立刻运行，速度很快；学习和实施都相当简单 有时候会被恶意利用，不怎么安全；会被不同浏览器编译出不同结果 Ruby 桌面GUI，网页应用，Web开发 和Python一样好学；大量的扩展和库；社区庞大 速度慢；很难找到好的文档 Swift 与Object-C同用于IOS开发，这也是我为什么不单列Object-C的原因 ","date":"2018-04-18","objectID":"/2018/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9/:0:1","tags":null,"title":"编程语言选择","uri":"/2018/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9/"},{"categories":["爱编程爱技术的孩子"],"content":"我的选择 已学过（按熟悉程度排名） C C++ Java Python 未来重心（按重要性排名） C Python HTML+CSS+Javascript Go ### 参考链接 [2016主流编程语言的详细对比](https://blog.csdn.net/z4909801/article/details/56511220) [几种主流编程语言的优点和缺点比较](http://baijiahao.baidu.com/s?id=1574780298772788\u0026wfr=spider\u0026for=pc) [各主流编程语言各自擅长什么场景，为什么？](https://www.zhihu.com/question/20806939)","date":"2018-04-18","objectID":"/2018/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9/:0:2","tags":null,"title":"编程语言选择","uri":"/2018/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9/"},{"categories":["爱编程爱技术的孩子"],"content":"Hexo是一款快速、简洁且高效的静态博客框架，使用Markdown渲染引擎解析文章，拥有着丰富的主题社区，可以帮助我们快速建立自己的博客，正在成为越来越多的技术人员制作自己博客的首选。 我选用了Hexo+github的博客部署模式，博客地址为：https://shuzang.github.io ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:0:0","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"开始使用 Hexo使用Node.js编写，安装之前需要先安装两个工具 Node.js，版本不低于8.6，建议10.0以上 Git 我在win10环境下管理和部署博客，因此使用windows下的包管理工具chocolate安装git和nvs，然后使用nvs安装和管理Node.js，默认会安装最新的软件版本，当然也可以自己指定版本号。 \u003e choco install git \u003e choco install nvs \u003e set-executionpolicy remotesigned \u003e nvs add lts \u003e nvs link lts 以上程序安装完成后，使用npm安装Hexo \u003e npm install -g hexo-cli 此时即可执行以下命令建立博客 $ hexo init hexo_blog # hexo_blog为博客项目文件夹 $ cd hexo_blog 当前hexo_blog文件夹的目录结构如下 . ├── node_modules //依赖安装目录 ├── scaffolds //模板文件夹，新建的文章将会从此目录下的文件中继承格式 | ├── draft.md //草稿模板 | ├── page.md //页面模板 | └── post.md //文章模板 ├── source //资源文件夹，用于放置图片、数据、文章等资源 | └── _posts //文章目录 ├── themes //主题文件夹 | └── landscape //默认主题 ├── .gitignore //指定不纳入git版本控制的文件 ├── _config.yml //站点配置文件 ├── package.json //Hexo软件版本信息和依赖的模块列表 └── package-lock.json _config.yml是网站的配置 信息，以YAML语言编写，在此可以配置大部分的参数。 在根目录下执行如下命令启动 hexo 的内置 Web 服务器 $ hexo server 该命令将会调用 Markdown 引擎解析项目中的博客内容生成网页资源，并启动一个简易的 Web 服务器用于提供对内存中网页资源的访问，Web 服务器默认监听 4000 端口，用户可在浏览器中通过地址 localhost:4000 访问博客。 其它的常用命令如下： hexo new [layout] \u003ctitle\u003e：新建文章或页面，[layout]表示模板，\u003ctitle\u003e表示标题，比如 hexo new post 001，表示新建了一个标题为001的文章 hexo new page 001，表示新建了一个标题为001的页面 hexo generate：生成网站静态文件，生成后的网页会放在根目录下public文件夹里 hexo deploy：部署网站，可以把生成的页面（public文件夹内容）部署到指定地方 hexo clean：用来清空public文件夹 ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:1:0","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"更换Chic主题 Chic主题是一款比较简洁的主题，虽然用的人不多，但基本功能都有，同时也避免出现大家博客页面都一样的尴尬。 在根目录下执行如下命令下载主题文件 $ git clone https://github.com/Siricee/hexo-theme-Chic.git themes/Chic 打开站点配置文件_config.yml将theme字段的值改为Chic # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme:Chic 重新执行hexo server命令，打开浏览器进入http://localhost:4000/页面 ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:2:0","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 站点配置 主要编辑根目录和主题目录下的两个_config.yml文件进行站点的相关配置，注意每个字段的冒号与值之间需要间隔一个空格，修改完成后需要重新执行hexo server命令 网站基本信息 根目录下的_config.yml文件 # Sitetitle:shuzang's blog subtitle: '世界钟爱热爱生活的人' description: 'shuzang的个人博客' keywords: 'blog,Golang,Hugo,blockchain' author: shuzang language: en timezone: '' 主题目录下的_config.yml文件 # Headernavname:shuzang's Blog nickname: ''# nickname置空，因为navname中已经出现了我们的名字description:世界钟爱热爱生活的人 头像 将自己的头像命名为avatar.png，放在主题目录下的source/image文件夹内，并在主题配置文件中设置如下 avatar:/image/avatar.png 网站 favicon 通过favicon generator 网站生成favicon.ico作为网站favicon，放在主题目录下的source文件夹内，替换原来的图标 社交链接 主题配置文件中，只开启github和RSS的链接，主题本身不支持RSS，之后我们按照其它插件开启，这里先显示图标 links:Github:https://github.com/shuzangRSS: copyright 主题配置文件中，取消显示文章末尾copyright中的slogan post_copyright_slogan_enable:false MathJax支持 主题本身支持数学公式，在主题配置文件中开启 # plugin functions## Mathjax: Math Formula Support## https://www.mathjax.orgmathjax:enable:trueimport:demand# global or demand demand和global为mathjax的加载方式，global会在所有页面都加载，但可能导致部分markdown语法被错误解析，demand则只需要在需要开启支持的文章Front-matter中声明即可 --- title: MathJax Test date: 2019-07-05 21:27:59 tags: mathjax: true # 加入这个声明，这篇文章就会开启mathjax渲染 --- 中英文间自动添加空格 在主题配置文件的# Writing部分添加如下字段 auto_spacing:true 执行hexo g命令重新生成页面 ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:2:1","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 添加菜单栏其它页面 主要指标签和分类页面，豆瓣电影和图书页面 Tag、Category、About页面 根目录下执行新建页面命令 $ hexo new page tag $ hexo new page category $ hexo new page about 进入source/tag目录，为index.md文件增加layout字段 // source\\tag\\index.md --- title: Tag layout: tag --- category和about页面同理，layout字段值为category和about 豆瓣电影和图书页面 为站点添加豆瓣电影和图书页面，使用模块hexo-douban完成，首先根目录下执行下列命令安装该模块 $ npm install hexo-douban --save 在站点配置文件中添加以下内容，不需要游戏页面，所以注释掉了 douban:user:# 个人豆瓣IDbuiltin:falsebook:title:'我的书单'quote:'唯有书籍慰藉心灵'movie:title:'我的电影'quote:'电影拯救孤独'# game:# title: 'This is my game title'# quote: 'This is my game quote'timeout:10000 在主题配置文件中新增电影和书籍页面的入口，注意顺序，要放在About字段前，因为这决定了菜单栏的显示顺序 # navigatior itemsnav:Posts:/archivescategories:/categoryTags:/tagBooks:/bookMovies:/movieAbout:/about 然后在根目录下执行下列命令生成电影和图书页面 $ hexo douban 可选参数 -b | –books: 只生成豆瓣读书页面 -m | –movies: 只生成豆瓣电影页面 执行命令后，插件会根据用户提供的 ID 爬取豆瓣中的数据信息并在 public 目录下生成对应的页面，当服务器启动或部署后会将页面显示在对应的菜单路由下。 需要隔一定周期执行一次hexo douban命令，虽然在站点配置中设置了 douban.builtin: true会在每次部署时自动执行hexo douban命令，但这是没有必要的，因为该命令爬取页面的时间比较长，会大幅增加编译打包时间，而我们豆瓣的图书和电影数据变动则并不频繁。 同时，以后也无法使用hexo d作为hexo deploy的简化，因为hexo douban的简化也是它。 最后，实际运行时，这两个页面总要弹出about:blank#blocked的空页面，暂时没有找到原因 ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:2:2","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 其它细节改进 对整个网站的一些细节做调整 页脚显示站点运行时间 首先在站点配置文件中新增since字段，设置其值为站点建立时间 since:2018 然后打开themes/Chic/layout/_partial/footer.ejs文件，修改其内容为 \u003cfooter id=\"footer\" class=\"footer\"\u003e \u003cdiv class=\"copyright\"\u003e \u003cspan\u003e© \u003c%= config.since %\u003e - \u003c%= date(Date.now(), \"YYYY\") %\u003e \u003c%= config.author %\u003e | Powered by \u003ca href=\"https://hexo.io\" target=\"_blank\"\u003eHexo\u003c/a\u003e \u0026 \u003ca href=\"https://github.com/Siricee/hexo-theme-Chic\" target=\"_blank\"\u003eChic\u003c/a\u003e\u003c/span\u003e \u003c/div\u003e \u003c/footer\u003e 修改文章建立时间格式 打开themes/Chic/layout/_partial/post.ejs文件，修改以下内容 \u003cspan class=\"post-time\"\u003e Date: \u003ca href=\"#\"\u003e\u003c%- date(page.date, theme.date_format) %\u003e\u0026nbsp;\u0026nbsp;\u003c%- time(page.date, theme.time_format)%\u003e\u003c/a\u003e \u003c/span\u003e 删除其中关于具体每天几点几分几秒的显示 \u003cspan class=\"post-time\"\u003e Date: \u003ca href=\"#\"\u003e\u003c%- date(page.date, theme.date_format) %\u003e\u0026nbsp;\u0026nbsp;\u003c/a\u003e \u003c/span\u003e 开启RSS 在站点根目录下安装hexo-generator-feed模块 npm install hexo-generator-feed 在站点配置文件中添加以下内容启用插件，注意放到#Extensions字段后面 # Extensionsplugins:hexo-generator-feed#Feed Atomfeed:type:atompath:atom.xmllimit:20 在主题配置文件的社交链接部分更改RSS的值，我们之前已经启用了图标 links:RSS:atom.xml 执行hexo g命令生成atom.xml文件，然后就启用了 支持mermaid 安装模块hexo-filter-mermaid-diagrams $ npm install hexo-filter-mermaid-diagrams 在站点配置文件中添加如下内容 # mermaid chart mermaid:## mermaid url https://github.com/knsv/mermaid enable:true# default true version:\"7.1.2\"# default v7.1.2 options:# find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 在themes/Chic/layout/_partial/footer.ejs文件中添加如下内容 \u003c% if (theme.mermaid.enable) { %\u003e \u003cscript src='https://unpkg.com/mermaid@\u003c%= theme.mermaid.version %\u003e/dist/mermaid.min.js'\u003e\u003c/script\u003e \u003cscript\u003e if (window.mermaid) { mermaid.initialize({theme: 'forest'}); } \u003c/script\u003e \u003c% } %\u003e 使用和普通代码相同，只是要声明为mermaid格式 ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:2:3","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"部署博客 我选择了部署到github，主要使用了github pages功能 在github网站创建一个新的公开仓库hexo_blog 在仓库页面选择 Settings——\u003eOptions——GitHub Pages——\u003eSource，在下拉列表中选择master branch，选择Save，生成一个GitHub pages网址，这就是我们的网站域名了 安装部署插件 $ npm install hexo-deployer-git --save $ npm install hexo-server --save 如果这台电脑第一次安装使用git，还需要配置git，但不属于本文范畴 配置_config.yml文件以下几部分 # URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url:https://github.com/shuzang/hexo_blogroot:/hexo_blog/# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type:gitrepo:git@github.com:shuzang/hexo_blog.gitbranch:master 这时候就已经万事俱备了，只要使用Hexo部署命令，就可以成功发布到Github $ hexo clean \u0026\u0026 hexo deploy -g ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:3:0","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"项目恢复 hexo+github模式的个人博客部署好了之后，hexo_blog文件夹中存在大量的文件，不仅仅是各种配置，还有我们所写的文章。在操作过程中，可能面对两种情况： 系统崩溃，所有文件丢失 要换电脑了 所以我们应未雨绸缪，经多方查找，终于找到了一种比较简单而有效的方法，即使用Travis CI做持续集成，项目文件放在hexo分支下，渲染后的静态文件在master分支下，只需要更新hexo分支中的文章就可以自动更新，进行配置也只需要克隆hexo分支然后进行改动，不需要每次都重新hexo init并配置 ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:4:0","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"主题收集 Next主题 Chic主题 ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:5:0","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["爱编程爱技术的孩子"],"content":"参考 [1] segmentfault-hexo原理浅析 [2] 简书-Hexo博客配置RSS插件 [3] NPM-hexo-filter-mermaid-diagrams [4] Yearito-Hexo搭建个人博客系列 [5] hexo和next主题相关设置 [6] 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 [7] hexo的next主题个性化教程:打造炫酷网站 [8] 关于HEXO搭建个人博客的点点滴滴 ","date":"2018-04-17","objectID":"/2018/using-hexo-build-persoanl-blog/:6:0","tags":["Hugo"],"title":"Hexo 搭建个人博客","uri":"/2018/using-hexo-build-persoanl-blog/"},{"categories":["平日里的白日梦"],"content":"我的梦想是世界和平这句话常被人们作为玩笑，但对与战争比邻而居的人们来说，这是心底最真诚而热切的渴望。偶然看到了这组图片，是叙利亚的战后情景，顿时心里酸酸的，千言万语，都堵在了嗓子里。 将Michael Jackson的Heal The World放在这里，真的是表达了最真实的心情。 ","date":"2018-04-17","objectID":"/2018/war/:0:0","tags":["杂谈"],"title":"愿世界和平","uri":"/2018/war/"},{"categories":["平日里的白日梦"],"content":"极简主义是一种理念，当我第一次接触到这个概念时就被它所吸引，并竭力往这个目标靠近。今天在人民日报官博看到了关于极简理念的分享，正巧刚建好博客，便分享一些我正在践行或希望能践行的极简理念。 沟通极简：与人交流，要直截了当、清楚明白 物质极简：弄明白自己想要什么，只买真正需要的东西 工作极简：分清轻重缓急，不拖延、不堆积，专注做好最重要的事 信息极简：精简信息源，放弃无用社交 感情极简：不滥情、不矫情，一生只爱一个人 生活极简：绿色、健康、慢生活 知易行难，最终还是要知行合一才行啊。 ","date":"2018-04-14","objectID":"/2018/minimalism/:0:0","tags":["杂谈"],"title":"极简主义","uri":"/2018/minimalism/"},{"categories":["爱编程爱技术的孩子"],"content":"1. Linux 操作系统组成 Linux 操作系统由 Linux 内核、shell 命令解释器和应用程序3部分构成 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:1:0","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 shell Linux的内核不能直接接受来自终端的用户命令，shell 为用户提供使用 Linux 操作系统的接口。在Linux 中几乎所有的操作都可以通过命令行来完成，使用 shell 编写的程序称为 shell 脚本。shell 可以作为命令语言、命令解释程序及程序设计语言，用户成功登录Linux时系统自动启用shell，当在终端输入正确的shell命令时，shell通过相应的命令和程序，通过内核执行用户需要的操作。更详细的知识可参考 评估Linux中的shell 一文。 几种 shell 的比较表如下 Shell 介绍 Bourne Shell 编程方式占优势，但在与用户交互方面比较差 Bourne - Again Shell 专为 Linux 而写，在 Bourne Shell 基础上增加了功能，是 Linux 默认内核 C Shell 语法类似于 C 语言，有较高的编程能力 Tcsh C shell 的扩展 Korn Shell 集合了 C shell 和 Bourne shell 的优点 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:1:1","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 Linux 内核 Linux 内核是操作系统的核心部分。它由进程管理、文件管理、存储管理、设备管理和网络管理五大部分组成。采用模块化的设计，它的功能也是通过增加和减少模块来实现的。这种设计保证系统封闭和开放与效率的平衡，避免在修剪功能时改变系统结构。 Linux 内核最注重的问题是实用和效率，其特点如下 整个 Linux 内核由很多过程组成，每个过程可以独立编译，然后用连接程序将其连接在一起成为一个单独的目标程序。 Linux 的文件系统最大特点是实现了一种抽象文件模型——VFS。使用虚拟文件系统屏蔽了各种不同文件系统的内在差别，使得用户可以使用同样的方式访问各种不同格式的文件系统，可以毫无区别的在不同格式、不同介质的文件系统之间使用 VFS 提供的统一接口交换数据。 为了保证方便的支持新设备、新功能，又不会无限扩大内核规模，Linux 系统对设备驱动或新文件系统等采用了模块化方式，用户在需要时可以动态加载，使用完毕可以动态卸载。同时对内核，用户也可以定制，选择适合自己的功能，将不需要的部分剔除出内核。这两种技术都保证了内核的紧凑性和扩展性。 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:1:2","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"2. u-boot u-boot是在 PPCBOOT 和 ARMBOOT 基础上发展而来的，是一个通用引导程序，支持很多架构，这一点上篇BootLoader已经很明白。u-boot的移植过程是一个对嵌入式系统包括软硬件及操作系统加深理解的一个过程，我们通过这个过程来一点点学习。 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:2:0","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 常用命令 u-boot在下载模式下，提供了许多有用的命令 环境变量类 printenv：查看环境变量 saveenv：保存当前环境变量 setenv：设置当前环境变量 askenv：在标准输入获得环境变量 存储类 md：显示指定内存地址中的内容 mm：顺序显示指定地址往后内存中的内容，可同时修改，地址自动递增 mw：向内存地址写内容 nm：修改内存地址，地址不递增 mtest：简单的RAM检测 下载类 tftp：将内核镜像文件从PC中下载到SDRAM的指定地址，然后通过bootm来引导内核，前提是所用PC要安装设置TFTP服务 loadb：透过串口下载二进制格式的文件 loads：透过串口下载S-Record格式的文件 启动类 boot：预先设定的启动命令并且启动 bootm：从某个地址启动内核 bootp：通过网络使用bootp或者TFTP协议引导镜像文件 bootelf：默认从0x30008000引导elf格式的文件 bootd（=boot）：引导的默认命令，即运行u-boot中在“include/configs/”板子名.h”中设置的“bootcmd”中的命令 Flash命令 erase：擦除Flash内容，必须以扇区为单位进行擦除 flinfo：查看Flash的信息 help：帮助命令，用于查询u-boot支持的命令 bdinfo：查看目标系统参数和变量，目标板的硬件配置 coninfo：显示控制设备和信息 flinfo：获取Flash存储器的信息 iminfo：打印和校验内核镜像头，内核的起始地址由CFG_LOAD_ADDR指定 Cache类命令 icache：开启和关闭指令Cache dcachd：开启和关闭数据Cache 其他命令 reset：复位CPU run：运行已经定义好的u-boot命令 sleep：命令延时执行时间 autoscr：从内存运行脚本 base：打印或者设置当前指令与下载地址的地址偏移 cmp：对输入的两段内存地址进行比较 version：打印u-boot版本信息 Nand相关命令 Nand info：打印Nand Flash信息 Nand device ：显示某个Nand设备 Nand erase FLAddr size：FLAddr为Nand Flash起始地址，size为从中擦除数据块的大小 Nand write InAddr FLAddr size ：InAddr为写到Nand Flash中的数据在内存的起始地址 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:2:1","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 u-boot源代码目录结构 u-boot主要的源代码目录如下图： 主要目录的作用列一个表如下： ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:2:2","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 u-boot的编译 u-boot的源码是通过gcc和Makefile组织编译的。顶层目录下的Makefile首先可以设置开发板的定义，然后递归地调用各级子目录下的Makefile，最后把编译过的程序链接成u-boot镜像。 目录下的Makefile看不懂，等学完Makefile再回来看这个吧，这里是一篇GNU make 中文手册 配置头文件 除了编译过程Makefile外，还要在程序中为开发板定义配置选项或者参数。这个头文件是include/configs\u003cboard_name\u003e.h。\u003cboard_name\u003e用相应的BOARD定义代替。 这个头文件中主要定义了两类变量： 选项：前缀是CONFIG_，用来选择处理器、设备接口、命令、属性等 参数：前缀是CFG_，用来定义总线频率、串口波特率、Flash地址等参数 编译 根据对Makefile的分析，编译分为两步： 配置：make smdk2410_config 编译：make 编译完成后，可以得到u-boot各种格式的映像文件和符号表，如下： u-boot的3中映像格式都可以烧写到Flash中，但需要看加载器能否识别这些格式。u-boot.bin最为常用，直接按照二进制格式下载，并且按照绝对地址烧写到Flash中就可以。 u-boot工具 还记得上面列到的tools目录吗，这个目录下存放有u-boot的一些工具，有的工具经常被用到，下面用一个表说明几种工具的用途： ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:2:3","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"2.4 u-boot的移植 为了使u-boot支持新的开发板，一种简便的做法是在u-boot已经支持的开发板中选择一种和目标板接近的，并在其基础上进行修改，代码修改的步骤如下。 在board目录下创建smdk2410目录，添加smdk2410.c、flash.c、memsetup.s、u-boot.lds和config.mk等； 在cpu目录下创建arm920t目录，主要包含start.s、interrupts.c、cpu.c、serial.c和speed.c等文件 在include/configs目录下添加smdk2410.h，它定义了全局的宏定义等。 修改u-boot根目录下的Makefile文件，如下： smdk2410_config：$（@： _config=）arm arm920t smdk2410 运行 make smdk2410_config，如果没有错误，就可以开始进行与硬件相关的代码移植工作 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:2:4","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"2.5 u-boot的使用 1）烧写u-boot到Flash 新开发板中没有任何程序可执行，也就不能启动，需要先将u-boot烧写到Flash中 如果主板上的EPROM或者Flash能够取下来，就可以通过编程器烧写。计算机BIOS就存储在一块256KB的Flash上，通过插座与主板相连。但是多数嵌入式单板使用贴片的Flash，不能取下来烧写。这种情况可以通过处理器的调试接口，直接对板上的Flash编程。 处理器调试接口是为处理器芯片设计的标准调试接口，包含BDM，JTAG和EJTAG 3中接口标准。这3种硬件接口标准定义有所不同，但是功能基本相同，下面都统称为JTAG接口。 JTAG接口需要专用的硬件工具来连接，无论从功能、性能角度，还是从价格角度，这些工具都有很大差异。最简单方式就是通过JTAG电缆，转接到计算机并口连接。这需要在主机端开发烧写程序，还需要有并口设备驱动程序。开发板上电或复位时，烧写程序探测到处理器并且开始通信，然后把BootLoader下载并烧写到Flash中。 烧写完成后，复位开发板，串口终端应该显示u-boot启动信息。 2）u-boot的环境变量 可通过printenv命令查看环境变量设置，前面介绍过这些命令 下表列出一些常用的环境变量的含义解释 u-boot的环境变量都可以有默认值，也可以修改并且保存在参数区。u-boot的参数区一般有EEPROM和Flash两种设备。 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:2:5","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 交叉编译 因为对这方面可以说是完全不了解，所以凭现有的知识提出来的问题大概是这么几个，至于学习过程中产生的新的问题，就到时候再解决： 1、交叉编译是什么以及为什么需要交叉编译 2、怎么得到这个交叉编译环境 3、怎么使用这个交叉编译环境 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:3:0","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 交叉编译简介 交叉编译，就是在一种平台上（称为宿主机）开发编译，编译出来的程序，在别的平台上（称为目标机）运行，即编译的环境和运行的环境是不一样的、交叉的，而程序的调试需要通过宿主机和目标机之间的协作来交互进行。交叉编译这个概念，主要和嵌入式开发有关，英文称为cross compile。这和我们平常在X86的电脑上开发、编译可执行程序，然后直接在X86环境下运行是相对的。 一种最常见的例子就是：在进行嵌入式开发时，手上有个嵌入式开发板，CPU是arm的，然后在x86的平台下开发，比如Ubuntu环境，然后就需要在x86的平台上，（用交叉编译器）去编译写好的程序代码，生成的（可执行的）程序是放到目标开发板—arm的CPU上运行的，即在x86平台上编译，在ARM平台上运行。 至于为什么需要交叉编译，有两点 嵌入式系统硬件资源的限制，比如cpu主频相对较低，内存容量较小等，相对来说，pc机的速度更快，硬件资源更加丰富，因此利用pc机进行开发会提高开发效率。这是一直以来的说法，不过，现在嵌入式的硬件主频和内存这些资源都不算小了，个人觉得可以直接放在开发板上做本地编译。 嵌入式系统MCU体系结构和指令集不同，因此需要安装交叉编译工具进行编译，这样编译的目标程序才能够在相应的平台上比如：ARM、MIPS、POWEPC上正常运行。 ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:3:1","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 交叉工具链简介 我们要完成的目标是生成可执行程序或库文件，为了达成此目标，内部的执行过程和逻辑主要包括： 编译：编译的输入是程序代码，输出是目标文件，使用的工具叫编译器，常见的编译器如gcc 链接：链接的输入为程序运行时所依赖的或者某个库所依赖的另外一个库（文件），链接的输出为程序的可执行文件，或者是可以被别人调用的完整的库文件。链接使用的工具叫链接器，最常见的链接器是ld 实际上，ld只是处理目标文件（二进制文件）最主要的一个工具，相关的还有很多其他工具，如as, objcopy, strip, ar等，对此，GNU官网弄出一个binutils，即binary utils，二进制工具（包），集成了所有这些和操作二进制相关的工具集合。关于这个东西，详见GNU Binutils详解，而对于常用的列一个表给大家看一下： 把上面设计到的一系列工具，按照对应的逻辑功能，编译、链接、后期其它处理等等，串起来，就是工具链。 而用于交叉编译的工具链就是交叉工具链。里面包含了很多工具，但是最主要的是用于编译的gcc，所以常把交叉工具链称为交叉编译器。那我们平常说的交叉编译版本的gcc，比如arm-linux-gcc，实际上指代了包含一系列交叉编译版本的交叉工具链（arm-linux-gcc，arm-linux-ld，arm-linux-as等等） ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:3:2","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 交叉编译器 命名规则 在嵌入式开发用到交叉编译器的时候，常看到这样的名字： arm-xscale-linux-gnueabi-gcc arm-liunx-gnu-gcc 其对应的交叉编译器前缀为： arm-xscale-linux-gnueabi- arm-liunx-gnu- 命名规则为：$arch-vendor-kernel-system$，各部分解释如下 arch：系统架构，表示交叉编译器是用于那个目标系统架构的，哪个平台的，即用此交叉编译器编译出来的程序运行在哪种CPU上，可能是arm，x86，mips等 vendor：即生产厂家，提供商，表示谁做的这个交叉编译器，一般有这么几种情况，一是写成开发板的名字，比如cortex_a9；二是写成个人作者自己的名字；三是厂家的名字。 kernel：即用此交叉编译器编译出来的程序所运行的目标系统，主要有两种：一种是Linux，表示有OS（主要是Linux）的环境；另一种是bare-metal，表示无操作系统的环境，比如编译u-boot，运行时还没OS，比如一些跑马灯之类的小程序。 system：表示交叉编译器所选择的库函数和目标系统，最常见的值有gnu，gnueabi，uclibcgnueabi等。 gnu：表示用的是glibc的意思 eabi：embedded application binary interface，应用程序二进制接口，作用是使得程序的二进制（级别）的兼容 uclibc：C库的一种，专门为嵌入式环境开发而编写的一个自由软件包，可以提供绝大多数标准C库的函数支持 一个简单通俗的解释为：gnu 等价于 glibc+oabi，gnueabi 等价于 glibc+eabi，uclibc 等价于 uclibc+oabi（待确认） 如何获得 1）在网上寻找并下载别人已经编译好的交叉编译器 2）购买开发板时厂家会直接提供相应的交叉编译器 3）自己动手从头开始制作一个交叉编译器 4）借助一些工具来制作交叉编译器 制作工具 crosstool-NG：详细的可以看看这篇crosstool-ng详解 Buildroot不仅能制作交叉工具链，而且还可以制作根文件系统rootfs。而且还支持同时编译对应的Linux内核和Uboot。 crosstool现在用的最多的是0.43的版本： Embedded Linux Development Kit (ELDK)：也是和交叉编译相关的，提供编译好的东西供使用。 OpenEmbedded的BitBake：OpenEmbedded是一个创建嵌入式Linux的整套框架，其中包括了制作对应的交叉编译器的工具，叫做BitBake。OpenEmbedded简称OE。 Crossdev OSELAS.Toolchain() ","date":"2018-04-11","objectID":"/2018/migration-related-knowledge/:3:3","tags":["linux"],"title":"系统移植1-移植相关知识","uri":"/2018/migration-related-knowledge/"},{"categories":["爱编程爱技术的孩子"],"content":"Debian 系统的移植总分四部分：u-boot的编译与烧录，Linux内核的编译与烧录，Debian 基本根文件系统的制作、配置与烧录，开发板设置。 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:0:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"1. u-boot的编译 对应于EMSYM的blurr开发板的u-boot项目使用GitHub进行开源维护，下载地址，我的编译环境为Ubuntu16.04 LTS系统 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:1:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"1.1 下载源码 方法一：在链接打开后的项目界面依次选择clone or download—\u003eDownload ZIP，将源码下载到PC中相应的文件夹（记得解压…..） 方法二：采用git命令（须事先安装git） $ git clone https://github.com/EMSYM/U-boot.git 注：该链接在选中clone or download后可看到 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:1:1","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"1.2 分支切换 在下载好的u-boot项目目录下打开虚拟终端，创建并切换分支 $ git checkout -b v4.1 origin/blurr-4.1.15 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:1:2","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"1.3 安装依赖 gcc-arm-linux-gnueabi是我们用到的交叉编译器 $ sudo apt install gcc-arm-linux-gnueabi $ sudo apt-get install build-essential gcc 注：Ubuntu缺省情况下，并没有提供C/C++的编译环境，因此还需要手动安装。如果单独安装gcc以及g++比较麻烦，幸运的是，为了能够编译Ubuntu的内核，Ubuntu提供了一个build-essential软件包。因为依赖关系的问题，安装了该软件包，编译c/c++所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c++程序，只需要安装该软件包就可以了。 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:1:3","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"1.4 开始编译 指定核心类型 $ ARCH=arm 生成配置文件（用到Makefile，参阅GNU make中文手册） $ make mx6dl_blurr_defconfig 指定交叉编译前缀，编译u-boot $ make CROSS_COMPILE=arm-linux-gnueabi- 执行完上述步骤后，编译即可成功 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:1:4","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"2. Linux内核编译 同样，对应于blurr开发板的Linux内核项目也在GitHub上开源维护，项目地址 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:2:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"2.1 源码下载 下载源码的手段与u-boot类似。这里要提醒的是，最好直接Download ZIP，不要clone，因为下载ZIP只有100多M，clone会有一个多G。而这两种手段得到的源码对之后的编译没有影响。（记得解压zip文件） ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:2:1","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"2.2 安装压缩工具lzop $ sudo apt-get install lzop lzop是最后生成时要用到的一个压缩工具，当没有安装此工具就开始编译，过程中会出现一个lozp：not found的错误 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:2:2","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"2.3 编译 进入下载好的Linux项目主目录，逐步执行如下命令 $ export ARCH=arm $ export CROSS_COMPILE=arm-linux-gnueabi- $ make blurr_defconfig $ make 前两句的意思是指定芯片的架构以及交叉编译器前缀，然后就开始编译了（之前编译u-boot时已装好交叉编译器），可参考 export命令的介绍 会有一些warning，但不碍事 要等很久….. 完成如上步骤后即可编译完成，我们需要编译得到的zImage文件和imx6dl-blurr.dtb文件位置如下： zImage：linux-blurr 4.1.15—\u003earch—\u003earm—\u003eboot imx6dl-blurr.dtb：linux-blurr 4.1.15—\u003earch—\u003earm—\u003eboot—\u003edts zImage位置如下图 imx6dl-blurr.dtb直接从上面目录里的dts点进去 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:2:3","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"3. Debian 根文件系统的制作与配置 该部分内容主要参考官方文档 EmDebian CrossDebootstrap，方法为QEMU/debootstrap的方法。使用debootstrap工具完成根文件系统的制作，使用QEMU模拟器完成配置工作。 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:3:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"3.1 基本说明 制作根文件系统的工具常用Debootstrap和Multistrap，制作流程大概分为四个步骤： 1、从源里下载需要的.deb软件包 2、解压它们到相应的目标目录 3、用chroot命令修改该目标目录为根目录 4、配置脚本，完成安装 通常，使用debootstrap、cdebootstrap或multistrap完成第一二阶段的工作，QEMU完成第三四阶段的工作。 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:3:1","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"3.2 工具软件安装 使用如下的命令安装所需要工具软件 $ sudo apt-get install binfmt-support qemu qemu-user-static debootstrap debootstrap是根文件系统制作工具，qemu是模拟器，是为了在宿主机上模拟开发板的环境 接下来的步骤需要以root身份执行，因为debootstrap的工作以及chroot到建好的新系统的目录都需要root权限 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:3:2","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"3.3 根文件系统制作 首先选择要引导的目标架构和Debian版本（例如stable、testing或sid）,我们选择开发板对应的arm架构，版本选择Debian9.1,叫做stretch。 创建一个目录文件，制作好的根文件系统将放在这个目录下。需要提示以后所有对根文件系统的修改都局限在这个目录里，不会影响到宿主机，所以不用担心搞毁你的系统。为了介绍清楚，我们采用“debian_armhf_stretch”作为目录名，但它其实就是rootfs，如果你这样命名的话 $ sudo mkdir debian_armhf_stretch 制作根文件系统，需要运行debootstrap $ sudo debootstrap --foreign --arch armhf stretch debian_armhf_stretch http://ftp.debian.org/debian/ 其中debian_armhf_stretch是创建的目录，armhf是目标架构，http://ftp.debian.org/debian是Debian镜像，必需的.deb包将从这里下载。可以随意选择自己喜欢的镜像，只要它有我们要用于的目标架构。可用的Debian镜像列表，debootstrap命令说明 会运行两次，第一次是从网上下载，第二次就是在debian_armhf_stretch目录下生成bin、sbin这些Linux文件系统目录了。 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:3:3","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"3.4 QEMU 配置 根文件系统已经创建完成。默认情况下，debootstrap创建的是一个非常小的系统，所以可能需要扩展一下，这个放在后面的配置新系统。 先复制“qemu-arm-static” 到刚构建的根文件系统中。为了能chroot到目标文件系统，针对目标CPU的qemu模拟器需要从内部访问 $ sudo cp /usr/bin/qemu-arm-static debian_armhf_stretch/usr/bin 接下来运行debootstrap的第二个阶段来解压步骤3中安装的所有软件包 $ sudo DEBIAN_FRONTEND=noninteractive DEBCONF_NONINTERACTIVE_SEEN=true LC_ALL=C LANGUAGE=C LANG=C chroot debian_armhf_stretch debootstrap/debootstrap --second-stage 该命令意思是设置一些环境变量,然后切换根目录到debian_armhf_stretch（这个操作是chroot做的，这个命令很有意思），执行目录debian_armhf_stretch/debootstrap下的命令: debootstrap –second-stage。终端上最后会打印 I: Base system installed successfully.，就说明成功了。 切换到qemu $sudo chroot debian_armhf_stretch 不过如果这样的话之后的提示都是英文的，想显示中文需要把上面的命令这样输入 $ sudo LANG=C.UTF-8 chroot debian_armhf_stretch ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:3:4","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 新系统配置 刚刚创建的新系统需要一些简单的调整以便于你运用它做一些特殊的工作。下面的步骤需要以root权限执行 手动在/etc/apt/sources.list里面添加如下条目 deb http://ftp.debian.org/debian/ stretch main contrib non-free deb-src http://ftp.debian.org/debian/ stretch main contrib non-free 源的选择是随便的，只要它支持目标平台就行，不过国内中科大的源好用一点，这时候就可以像往常一样使用apt-get install 命令安装其它软件包了。 安装xorg和KDE，KDE新版本叫plasma $ sudo apt-get install xorg $ sudo apt-get install plasma-desktop 这句执行也是真的久，不要着急，中间可能会自动进入一些配置界面，根据选项自己选就行，如果乱码的话可以选第一个，其实上面设置成中文就没乱码了。 安装终端konsole，安装浏览器qupzilla（这是因为Debian9以下不支持chrome），安装文件管理器dolphin，网络管理器plasma-nm $ sudo apt-get install konsole $ sudo apt-get install qupzilla $ sudo apt-get install dolphin $ sudo apt-get install plasma-nm 打开etc文件夹中的fstab文件，在末尾添加 /dev/sda / ext4 defaults 0 1 root用户下输入命令 chown root:root /usr/bin/sudo chmod 4755 /usr/bin ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:4:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"5. 烧录工作 u-boot，Linux内核和根文件系统都是需要烧录的，下面介绍如何进行这部分工作。首先将SD卡格式化，准备好要烧录的文件 u-boot：u-boot.imx 内核：zImage和imx6dl-blurr.dtb 根文件系统：debian_armhf_stretch ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:5:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"5.1 设置SD卡 SD卡需要创建2个分区，并且在第一个分区之前预留一段空间用于保存u-boot.imx；然后第一个分区设置为fat格式，用于保存内核编译成的两个文件；第二个分区设置为ext4格式，用于保存根文件系统。 格式化 在分区之前，先将SD卡格式化（可能Windows下格式化方便一点），首先在Linux系统下插入SD卡，查看挂载位置，使用fdisk命令 $ sudo fdisk -l 这个命令作用为查看磁盘使用情况的，最后那个即为我们新挂载的SD卡 从结果输出中可以看到SD卡，挂载位置是/dev/sdb，输入命令 $ sudo fdisk /dev/sdb 该命令含义为进入分割硬盘模式，这个命令执行结束就可以操作分区了。 删除原有分区 输入m可以获取帮助，显示所有可用命令。先用d 命令删除原来的分区，提示Selected partition，在后面输入要删除的分区号，回车，分区即可删除成功 输入命令p查看此时的分区信息，已变成一整块的磁盘未分区，接下来开始分区 重新分区 n命令新建分区，第一次输入p分割为主分区，分区号为1，分区的起始位置和结束位置自己算好填上去，注意分区必以sector为单位，一个sector 为512 bytes，所以不要输不是512整数倍的数。 n命令新建分区，第二次输入e分割分区，分区号为2，起始位置接着上一个分区的结束位置。 p命令查看分区信息，看是否符合预想。w命令保存退出。弹出重新插入SD卡或者重新启动Ubuntu系统，之后再次查看分区信息，这是为了更新分区表给内核，否则看不到分好的区。 格式化新建的分区 $ sudo mkfs.ext4 /dev/sdb2 然后对两个分区格式化 输入t，选择分区1，将分区1格式化为fat，这里输入6为FAT16，c为FAT32 输入t，选择分区2，将分区2格式化为ext4格式，输入83即可 注：这里输入83格式化结束最后查看分区其实显示的是83 Linux，这就已经是ext4格式了，不要觉得自己错了，因为Linux的默认格式就是ext4 w命令保存 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:5:1","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"5.2 烧录 u-boot 执行如下命令，把u-boot弄到SD卡开头预留的那段空间 $ sudo dd if=u-boot.imx of=/dev/sdb bs=512 seek=2 ;sync dd命令的解释，至于为什么要seek=2，跳过头两个块我现在也不懂 内核 把编译好的内核的两个文件zImage和imx6dl-blurr.dtb复制到第一个分区，可以直接鼠标操作 根文件系统 先 fdisk -l 查看第二个分区的位置，是/dev/sdb2。把第二个分区挂载到/mnt下，这里执行成功后把文件放到/mnt下就相当于放到了U盘第二个分区 $ sudo mount /dev/sdb2 /mnt 然后就在rootfs的当前目录用cp命令复制，意思是将根文件系统的所有内容复制到挂载的目录 $ sudo cp -rf rootfs/. /mnt 执行完有必要的话取消挂载 $ sudo umount /mnt ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:5:2","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"6. 开发板设置 确保zImage文件和imx6dl-blurr.dtb文件都已放入SD卡第一个分区，也就是FAT格式的分区中；文件系统解压到SD卡第二个分区，也就是ext4格式的分区中 注：若之前已经进行到屏幕上出现两只企鹅，此时只需要将解压好文件系统的SD卡插入开发板，上电即可进入命令行界面，若无法进入命令行界面则继续进行下列步骤， 靠近 HDMI接口的地方有个开关，拨动开关到boot一端，设置八位红色开关为0100001 将SD卡插入SD3插槽 下好窗口调试软件putty（windows或Linux下都可），其它串口调试软件也行，用数据线连接开发板和PC（调试），开发板与屏幕，开发板与电源，开发板与键盘 打开设备管理器，找到这个设备，这时候还没有驱动，所以右键更新驱动程序，在网络上查找，第一次可能一直是寻找中，那就关掉重新打开。直到驱动装好，从设备管理器里就可以看到相应的COM口。 打开putty，选择serial，将COM1改成上面设备管理器里看到的COM号，speed改为115200，然后最下面点open 此时看到串口输出（若没有，请按开发板HDMI口旁边的RESET按钮），按回车进入调试模式，输入如下命令命令 setenv bootargs 'console=ttymxc0,115200 root=/dev/mmcblk2p2 init=/sbin/init' saveenv #加载镜像 fatload mmc 1:1 12000000 zImage; #将SD卡分区一的镜像加载到内存地址0x12000000 fatload mmc 1:1 11000000 imx6dl-blurr.dtb; #加载Device Tree文件 #启动镜像 bootz 12000000 - 11000000 开发板上电，如果SD卡中此时只有u-boot和内核，屏幕上会有两只企鹅， 如果根文件系统也已经放进去了，那就会出现登录选项，连接键盘与开发板，输入root，这个是拿到的这个根文件系统就是这个名字，之后即可使用键盘输入各种命令与开发板交互。在命令行使用如下命令可以启动 GUI，然后就进入KDE桌面环境了，Debian系统哦 注：开发板获得读写权限的方法如下，如果模拟器中已完成此工作则不需要 $ mount rw -o remount / ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:6:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"7. 使用界面 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:7:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"8. 参考 debian下为arm开发板创建基于debian或emdebian的根文件系统 这篇文章主要是提供一个思路，用工具来制作Debian的根文件系统。 创建基于arm的debian文件系统 主要是因为上面制作的根文件系统直接弄到板子上没网，所以就没法用板子的命令行安装软件，只好借助模拟器在PC上装好一些东西，比如GUI和其它一些软件。这篇文章提供一些模拟器QWMU使用的借鉴 Emdebian 这个就没什么了，主要是区别一下我们用到的嵌入式Debian的源码版本 ","date":"2018-04-11","objectID":"/2018/migration-of-debian-system/:8:0","tags":["linux"],"title":"系统移植2-Debian系统的移植","uri":"/2018/migration-of-debian-system/"},{"categories":["爱编程爱技术的孩子"],"content":"采用Android6.0（棉花糖），编译环境为Ubuntu14.04和opoenjdk-7-jdk ","date":"2018-04-11","objectID":"/2018/android-system-migration/:0:0","tags":["linux"],"title":"系统移植3-Android系统移植","uri":"/2018/android-system-migration/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 获取源码 首先参阅Android网站source.android.com/source/initializing.html安装依赖 除Android网站要求的软件包，还需要安装如下软件包： $ sudo apt-get install uuid uuid-dev $ sudo apt-get install zlib1g-dev liblz-dev $ sudo apt-get install liblzo2-2 liblzo2-dev $ sudo apt-get install lzop $ sudo apt-get install git-core curl $ sudo apt-get install u-boot-tools $ sudo apt-get install mtd-utils $ sudo apt-get install android-tools-fsutils $ sudo apt-get install openjdk-7-jdK 获取安卓源码 $ cd ~ $ mkdir myandroid $ mkdir bin $ cd myandroid $ curl https://storage.googleapis.com/git-repo-downloads/repo \u003e ~/bin/repo $ chmod a+x ~/bin/repo $ ~/bin/repo init -u https://android.googlesource.com/platform/manifest -b android-6.0.1_r22 $ ~/bin/repo sync # This command loads most needed repos. Therefore, it can take several hours to load. 获取内核源码 $ cd ~/myandroid $ git clone git://git.freescale.com/imx/linux-2.6-imx.git kernel_imx # the kernel repo is large. Therefore, this process can take a while. $ cd kernel_imx $ git checkout m6.0.1_2.1.0-ga 获取u-boot源码 $ cd ~/myandroid/bootable $ mkdir bootloader $ cd bootloader $ git clone git://git.freescale.com/imx/uboot-imx.git uboot-imx $ cd uboot-imx $ git checkout m6.0.1_2.1.0-ga 为标准Android源码包patch ","date":"2018-04-11","objectID":"/2018/android-system-migration/:1:0","tags":["linux"],"title":"系统移植3-Android系统移植","uri":"/2018/android-system-migration/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 编译 前面步骤执行完后，执行下列命令开始编译 $ cd ~/myandroid $ source build/envsetup.sh $ lunch sabresd_6dq-user $ make 2\u003e\u00261 | tee build-log.txt make命令执行完后，默认在myandroid/out/target/product/sabresd_6dq中生成输出，我们使用boot-imx6dl.img，u-boot-imx6dl.imx和system.img文件。此时得到的system.img文件的格式并不是我们想要的，要转换成raw格式 System.img经常以两种格式出现：raw和sparse。 一种是raw ext4 image，即raw image，使用file命令可查看它： 其特点是完整的ext4分区镜像（包含很多全零的无效填充区），可以直接使用mount进行挂载，因此比较大（一般1G左右）。 另一种是sparse ext4 image，即simg，使用file命令查看它： 就是说是一个非常普通的dat文件。由于它将raw ext4进行稀疏描述，因此尺寸比较小（没有全零的无效填充区，一般在300到500M之间）。 我们进行的编译会默认的生成sparse格式的system.img，因此需要进行转换，而Android本身提供了源代码工具进行两者的转换，位于 system/core/libsparse/simg2img.c // 将sparse image转换为raw image； system/core/libsparse/img2simg.c // 将raw image转换为sparse image 转换的命令如下 $ simg2img \u003csparse_image_files\u003e \u003craw_image_file\u003e # 使用示例 $ simg2img system.img system.raw.img ","date":"2018-04-11","objectID":"/2018/android-system-migration/:2:0","tags":["linux"],"title":"系统移植3-Android系统移植","uri":"/2018/android-system-migration/"},{"categories":["爱编程爱技术的孩子"],"content":"3. 分区及烧录 分区与格式化 $ sudo ./fsl-sdcard-partition.sh -f imx6dl /dev/sdX # fsl-sdcard-partition.sh为分区脚本， $ sudo mkfs.fat -n BOOT /dev/sdX1 烧录uboot $ sudo dd if=u-boot-imx6dl.imx of=/dev/sdX bs=512 seek=2;sync 烧录内核 $ cp boot-imx6dl.img /media/登录名/BOOT/boot-imx6dl.img 烧录系统 $ sudo dd if=system.raw.img of=/dev/sdX5;sync 连线，上电，进行串口调试，设置参数如下 $ setenv bootargs 'console=ttymxc0,115200 init=/init video=mxcfb0:dev=ldb,bpp=32,if=RGB666 video=mxcfb1:dev=ldb,bpp=32,if=RGB666 video=mxcfb2:off video=mxcfb3:off vmalloc=320M androidboot.console=ttymxc0 consoleblank=0 androidboot.hardware=freescale cma=384M' $ setenv bootcmd 'fatload mmc 1:1 12000000 boot.img;boota 12000000' $ saveenv 此时系统应可以启动成功 ","date":"2018-04-11","objectID":"/2018/android-system-migration/:3:0","tags":["linux"],"title":"系统移植3-Android系统移植","uri":"/2018/android-system-migration/"},{"categories":["爱编程爱技术的孩子"],"content":"4. 使用界面 ","date":"2018-04-11","objectID":"/2018/android-system-migration/:4:0","tags":["linux"],"title":"系统移植3-Android系统移植","uri":"/2018/android-system-migration/"},{"categories":["爱编程爱技术的孩子"],"content":"5. Android 项目源码管理 做 Android 移植需要了解的 AOSP：“Android Open-Source Project”，中文意为\"Android 开放源代码项目”。 AOSP项目由不同的子项目组成,为了方便进行管理,Google采用Git对AOSP项目进行多仓库管理 多仓库项目管理的原理是这样的（该部分学习甚至图片都是借用网上某文章）： 我们有个非常庞大的项目Pre,该项目由很多个子项目R1,R2,…Rn等组成,为了方便管理和协同开发,我们为每个子项目创立自己的仓库,整个项目的结构如下: 将一个项目Pre进行分库后会遇到这么一个问题:如果我们想要创建Pre分支来做feature开发,这就意味着,我们需要到每个子项目中分别创建对应的分支,这个过程如果纯粹靠手工做,那简直是个灾难,利索当然我们会想写个自动化处理程序(我们假设这个工具叫做RepoUtil)来帮助我们解决这个问题.这个RepoUtil也会有版本管理之类的需求,因此我们也用Git对其管理,并为其创建对应的仓库.此时整个项目的结构如下: 这里RepoUtil知道整个项目Pre下的每个子项目(即维护子项目的列表),同时需要提供对这些子项目的管理功能,比如统一创建分支等.但是从\"单一职责\"角度来看,RepoUitl这个工具的功能过于复杂,我们完全可以将维护子项目列表这个功能抽取出来作为一个新项目sub_projects,因为子项目也会变化,因此,为其创建对应的仓库,并用Git管理,这样的化,RepoUtil只需要通过简单的对ub_projects进行依赖即可,此时整个项目的结构如下: AOSP项目结构和我上文的描述非常类似.repo工具对应RepoUtil,mainfest对应sub_projects. 总结一下:repo就是这么一种工具,由一系列python脚本组成,通过调用Git命令实现对AOSP项目的管理. ","date":"2018-04-11","objectID":"/2018/android-system-migration/:5:0","tags":["linux"],"title":"系统移植3-Android系统移植","uri":"/2018/android-system-migration/"},{"categories":["爱编程爱技术的孩子"],"content":"内核配置的目的主要是裁剪掉不必要的文件和目录，获得一个最适用的操作系统。可通过执行下面的命令进入配置窗口 $ make menuconfig 执行完毕后显示一个基于文本的图形化终端配置菜单，这是是使用最广的配置方法，如果一个.config文件已经存在，它将使用该文件设置那些默认值 ","date":"2018-04-11","objectID":"/2018/linux-lernel-configuration/:0:0","tags":["linux"],"title":"系统移植4-内核配置","uri":"/2018/linux-lernel-configuration/"},{"categories":["爱编程爱技术的孩子"],"content":"1. 启动内核配置窗口 进入需要被配置的内核的根目录，使用 make menuconfig 命令启动内核配置窗口，如下图 最上面的标题栏里，.config是核心功能列表档，我们现在就是在对这个文件做处理；x86是我的电脑CPU架构，4.1.15是我现在要配置的这个内核的版本 整个界面的用法大概是这样： 左右方向键：可以移动最底下的 项目； 上下方向键：可以移动上面框里的蓝色光柱选择选项，该行有箭头 (—\u003e) 则表示该行内部还有其他细项需要来配置的意思； 选定项目：以上下方向键选择好想要配置的项目之后，以左右方向键选择， 按下回车就可以进入该项目去作更进一步的细节配置； 可挑选功能：在细节项目的配置当中，如果前面有 或 \u003c \u003e 符号时，该项目才可以选择， 而选择使用空格键； 若为 [] \u003c\u003e 则表示编译进核心；若为则表示编译成模块。 配置时可以遵循这样的原则： 一定用的功能，编译进核心； 未来可能用到的功能，尽量编译为模块 不知道用来做什么的功能，看help也看不懂，保留默认值，或者编译为模块 ","date":"2018-04-11","objectID":"/2018/linux-lernel-configuration/:1:0","tags":["linux"],"title":"系统移植4-内核配置","uri":"/2018/linux-lernel-configuration/"},{"categories":["爱编程爱技术的孩子"],"content":"2. 具体配置 关于内核配置主选项的记录丢失，只剩关于 General setup 部分的记录。与 Linux 最相关的程序互动、核心版本说明、是否使用发展中程序码等资讯都在该部分配置的。 这里的项目主要都是针对核心与程序之间的相关性来设计的，基本上，保留默认值即可！ 不要随便取消底下的任何一个项目，因为可能会造成某些程序无法被同时运行的困境！ 不过底下有非常多新的功能，如果有不清楚的地方，可以按\u003chelp\u003e进入查阅，里面会有一些建议！ 你可以依据 Help 的建议来选择新功能的启动与否！ cross-compiler tool prefix 交叉编译工具前缀，功能是make时自动使用交叉编译器进行编译。比如在这儿填上arm-linux，相当与编译时使用*make CROSS_COMPILE=arm-linux-*命令。如果你不想自动使用交叉编译工具，此处应该留空 compile also drivers which will not load 编译驱动程序将不加载，一些驱动可能在其它的编译平台被编译，而这个编译平台跟它的期望运行平台不一样（好像就是交叉编译。。），所以即使这些驱动不能在编译平台加载运行，一些开发者仍然可能想要构建这个驱动来进行编译测试（就是看看它到底能不能编译通过，没打算让它运行么）所以，根据你的需求来选择好了，这个一般是不选。 Local version - append to kernel release 附加一段自定义字符串在内核的版本后面，当你使用uname命令的时候，这段字符串会显示在原本的输出后面，这个就是用来玩的吧。最大支持64个字符，看了一下我的 Automatically append version information to the version string 这个选项会通过查找内核目录下的git标签来自动检测内核目录下是否包含git版本树信息，如果找到的话，就会在上面设置的自定义字符串后边自动添加“-gxxxxxxxx”这种格式的后缀。需要有git的支持。也是个可有可无的选项 Kernel compression mode ( ) —\u003e 这儿是选择内核的压缩格式，回车进去可以看到，有Gzip,Bzip2,LZMA,XZ,LZ0,LZ4，一般情况下选哪一个都可以，如果不确定到底选哪个的话，官方推荐Gzip Default hostname 在这儿设置默认的主机名，在你的用户空间程序使用系统调用sethostname来修改主机名之前，内核将使用你在这儿设置的默认主机名。这儿的默认值是“(none)”，这儿保持默认就好，反正没什么意义，系统启动之后肯定要修改主机名的，那时会将主机名改为/etc/hostname下的设置 Support for paging of anonymous memory (swap) 通过分页、交换区等机制来实现虚拟内存，通俗的理解成是对swap区的支持也可以，总之，这个选项是你必选的，没有MMU的cpu除外 System V IPC system V进程间通信支持，这个必选，这样应用程序才能使用内核提供的各种通信机制进行进程间通信。syetem V IPC包括消息队列，信号量，共享内存等 POSIX Message Queues POSIX消息队列支持，POSIX消息队列是一种进程通信机制， 在POSIX消息队列中，每一个消息有一个优先级。如果你想要编译运行像mq_*这样子的函数（一般是为Solaris系统而写的程序），那么你需要选上此项 Enable process_vm_readv/writev syscalls 启用此选项可添加系统调用process_vm_read 和process_vm_writev，这些进程允许具有正确p的进程直接从另一进程的地址读取或写入另一个进程的地址 Open By Fhandle Syscalls 如果你选上此项，意味着一个用户空间的应用程序将能够映射一个文件句柄到一个文件名，然后通过这个文件句柄来操作这个文件，这个特性对用户空间文件服务器很有用，就是说开启此选项后，可以使用句柄来追踪一个文件，这样即使文件被重命名，程序依然可以通过句柄来定位这个文件。这个选项会开启内核对open_by_handle_at()和name_to_handle_at这两个系统调用的支持 uselib syscall 此选项启用了uselib系统调用，这是从libc5和更早版本在动态链接器中使用的系统调用。 glibc不使用此系统调用。 如果您打算运行基于libc5或更早版本的程序，则可能需要启用此系统调用。 运行glibc的当前系统可以安全地禁用此功能。现在还有更早版本的吗，可以取消掉吧 Auditing support 内核审计支持，其它的一些内核子系统可能需要使用这个功能，比如SELinux Eanble system-call auditing support 使能对low-overhead (低开销？) 系统调用的审计支持，这个功能可以单独使用，也可以被系统中其他的内核子系统使用，比如SELinux IRQ subsystem —\u003e 中断请求子系统，回车进去只有一个选项： Expose hardware/virtual IRQ mapping via debugfs 这个选项可以让你通过debugfs中的irq_domain_mapping文件来获得硬件的中断请求号和Linux中的中断请求号之间的映射关系。一般只在内核调试时候使用，help解释如果你听不懂上面的那些名词，说明你不需要开启这个选项，好吧，其实我能看懂的没几个。。。 Timers subsystem —\u003e 内核时钟子系统，回车进去三个选项： 1）Timer tick handling (Idle dynticks system (tickless idle))—\u003e 定时器滴答处理程序，这儿有三个选择，下面分别介绍 第一种：Periodic timer ticks (constant rate, no dynticks) 以固定周期触发时钟中断，无论CPU是否需要，不使用动态定时器（dyniticks），这是最耗电的方式，不推荐使用。 第二种：Idle dynticks system (tickless idle) 在CPU空闲时不产生不触发的时钟中断，可以省电 第三种：Full dynticks system (tickless) 使用动态定时器，即使CPU在忙碌状态，也尽可能的关闭所有时钟中断，这个特性很早就有但是直到3.10版本才完整支持DynTicks（动态定时器），并成为内核级别的核心特性，tickless适用于CPU在同一时间内只运行一个任务，或者用户空间程序极少与内核交互的场合，但是即使你选择了tickless，仍然需要额外设置‘nohz_full=?’的内核参数才能是tickless真正生效 所以。。意思就是一般选第二个咯 2）Old Idle dynticks config 这个选项是Idle dynticks system (tickless idle)旧的入口，此选项被用来保持与旧版本的兼容，未来应该会被删除，但现在为了和上面保持一致还是选了吧 3）High Resolution Timer Suppor 高精度计时器支持，如果你的硬件不能胜任这个选项，那么开启这个选项仅仅是给内核增加体积，高精度定时器（hrtimer）是从2.6.16开始被引入内核，采用红黑树算法（传统timer使用时间轮算法），在硬中断中执行中断服务例程，它可以为我们提供纳秒级的定时精度（这么厉害），以满足对精确时间有迫切需求的应用程序或内核驱动，例如多媒体应用，音频设备的驱动程序等等，额，这个还是选着吧，说不定用板子做什么呢 CPU/Task time and stats accounting —\u003e CPU/任务 时间和状态统计 1）Cputime accounting (Simple tick based cputime accounting) —\u003e CPU时间统计方式，三种选择： 第一种：Simple tick based cputime acounting 最简单的基于tick统计方式，使用jiffies变量（这个变量记录了系统自启动以来经过的操作系统节拍的数目） 官方推荐：if unsure, say Y(yes) 第二种：Full dynticks CPU time accounting 利用上下文跟踪子系统，通过观察每一个内核与用户空间的边界来统计，如果你不是在帮助开发内核的动态定时器（dynticks）的话，不要选择这个 第三种：Fine granularity task level IRQ time accounting 通过读取TSC时间戳进行CPU时间统计，这是统计CPU时间的更细粒度的方式，对系统性能有显著不良影响 官方推荐：if in doubt , say No 2）BSD Process Accounting BSD进程记账支持.用户空间程序可以要求内核将进程的统计信息写入一个指定的文件,主要包括进程的创建时间/创建者/内存占用等信息.不确定的选\"N”. 3）BSD Process Accounting version 3 file format 使用新的v3版文件格式,可以包含每个进程的PID和其父进程的PID,但是不兼容老版本的文件格式.比如 GNU Accounting Utilities 这样的工具可以识别v3格式 4）Export task/process stati","date":"2018-04-11","objectID":"/2018/linux-lernel-configuration/:2:0","tags":["linux"],"title":"系统移植4-内核配置","uri":"/2018/linux-lernel-configuration/"},{"categories":null,"content":"https://www.bilibili.com/video/BV1vL411E7fs?spm_id_from=333.851.b_7265636f6d6d656e64.6，失去信任 看到世卫组织的工作，提升信心 看到家长里短，坑钱商家，失去信心 B站，温铁军，《为什么贫富分化愈发严重》失去信心 QQ空间，东大小红果，祝融号新闻，唤起信心 B站，闫帅奇，军神科普视频，唤起信心 米游社，执望三千里任务的评论，失去信心 金融圈惊呆了！市值300多亿，一年净亏损超1000亿，前董事长已被执行死刑，失去信心 看到现在有人在刻意制造孩子与父母的对立，凡是有问题就把原因归结到父母，失去信心 B站，儿童合唱团oneVoice的合唱，唤起信心，给我唱哭了， 震撼圆梦之声《A Million Dreams》催泪合唱现场！_哔哩哔哩_bilibili 洗涤心灵的合唱现场！童声演绎治愈良曲《I Can Only Imagine》_哔哩哔哩_bilibili 网络安全学习 \\1. cybrary https://www.cybrary.it/ \\2. securitytube http://www.securitytube.net/ \\3. hacking-tutorial https://www.hackingtutorials.org/ \\4. hack this site https://www.hackthissite.org/ \\5. hacking loops https://www.hackingloops.com/ \\6. exploit database https://www.exploit-db.com/ \\7. hellbound hackers https://hbh.sh/home \\8. hack in the box https://www.hitb.org/ –来自百度网盘超级会员V5的分享 hi，这是我用百度网盘分享的内容~复制这段内容打开「百度网盘」APP即可获取 链接:https://pan.baidu.com/s/1icooGlQL_9hRd1duifjFvg 提取码:29d9 ","date":"0001-01-01","objectID":"/1/:0:0","tags":null,"title":"","uri":"/1/"}]