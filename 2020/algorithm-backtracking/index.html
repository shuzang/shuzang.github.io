<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>算法-回溯 - Shuzang's Blog</title><meta name=author content="Shuzang"><meta name=author-link content><meta name=description content="在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Bra"><meta name=keywords content="数据结构与算法"><meta itemprop=name content="算法-回溯"><meta itemprop=description content="在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Bra"><meta itemprop=datePublished content="2020-05-04T00:00:00+00:00"><meta itemprop=dateModified content="2020-09-03T00:00:00+00:00"><meta itemprop=wordCount content="3647"><meta itemprop=image content="https://shuzang.github.io/logo.png"><meta itemprop=keywords content="数据结构与算法,"><meta property="og:title" content="算法-回溯"><meta property="og:description" content="在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Bra"><meta property="og:type" content="article"><meta property="og:url" content="https://shuzang.github.io/2020/algorithm-backtracking/"><meta property="og:image" content="https://shuzang.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-04T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-03T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shuzang.github.io/logo.png"><meta name=twitter:title content="算法-回溯"><meta name=twitter:description content="在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Bra"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://shuzang.github.io/2020/algorithm-backtracking/><link rel=prev href=https://shuzang.github.io/2020/summary-of-smart-contract-knowledge-points/><link rel=next href=https://shuzang.github.io/2020/image-container-and-repository/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><meta name=google-site-verification content="UA-209130979-1"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"算法-回溯","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2020\/algorithm-backtracking\/"},"genre":"posts","keywords":"数据结构与算法","wordcount":3647,"url":"https:\/\/shuzang.github.io\/2020\/algorithm-backtracking\/","datePublished":"2020-05-04T00:00:00+00:00","dateModified":"2020-09-03T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Shuzang"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=/images/avatar.png srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes=auto data-title="Shuzang's Blog" data-alt="Shuzang's Blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Posts</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=/images/avatar.png srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes=auto data-title=/images/avatar.png data-alt=/images/avatar.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Posts</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>算法-回溯</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
Shuzang</span></span>
<span class=post-category>收录于 <a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 爱编程爱技术的孩子</a></span></div><div class=post-meta-line><span title="发布于 2020-05-04 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2020-05-04>2020-05-04</time></span>&nbsp;<span title="更新于 2020-09-03 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2020-09-03>2020-09-03</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 3647 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 8 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-回溯的基本思想>1. 回溯的基本思想</a><ul><li><a href=#11-解空间树>1.1 解空间树</a></li><li><a href=#12-基本思想>1.2 基本思想</a></li><li><a href=#13-一般步骤>1.3 一般步骤</a></li></ul></li><li><a href=#2-子集树>2. 子集树</a></li><li><a href=#3-排列树>3. 排列树</a></li></ul></nav></div></div><div class=content id=content><p>在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Branch&amp;Bound）就是两种减小搜索空间大小的技术。</p><h2 id=1-回溯的基本思想>1. 回溯的基本思想</h2><h3 id=11-解空间树>1.1 解空间树</h3><p>假设可以用一个 n 元组 $X=(x_1,x_2,……,x_n)$ 来表示所求问题的解，其中 $x_i$ 的取值范围为某个有穷集合 S。我们把 $X=(x_1,x_2,……,x_n)$ 所有可能取值的组合称作问题的解空间。</p><p>举个例子，假设 0-1 背包问题中物品有 3 个，用 $X=(x_1,x_2,x_3)$ 表示，其中 $x_i \in \{0,1\}, 1 \leq i \leq 3$，则问题的解空间为 $\{(0,0,0),(0,1,0),(0,0,1),(1,0,0),(0,1,1),(1,0,1),(1,1,0),(1,1,1)\}$</p><p>我们用一颗 n+1 层的树来表示解空间，其中，第 i 层和第 i+1 层之间边的标号表示变量 $x_{i+1}$ 的可能取值，从根结点到叶节点路径上的标号就构成问题的一个可能的解。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200501_%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200501_%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200501_%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200501_%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png 2x" sizes=auto data-title=解空间树 data-alt=解空间树 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>我们还可以这样理解解空间，将解空间划分为两个维度：一个可行解中元素的个数和每个元素的取值范围。这两者正好对应解空间树的深度（实际是深度-1）和宽度。比如在上面的 0-1 背包问题中，问题的一个解由一个 3 元组 $X=(x_1,x_2,x_3)$ 表示，这里每个解中有 3 个元素，因此解空间树的深度是 4，每个元素有 0 和 1 两个取值，因此每个节点有两棵子树。</p><p>注：这里树的深和宽不是标准化的说法，仅为了便于说明。理解上面这段话非常有利于实际解决问题时解空间树的构造。</p><h3 id=12-基本思想>1.2 基本思想</h3><p>回溯的基本思想是：在问题的解空间树中，按照深度优先的策略，从根结点出发搜索。搜索至任一结点时，先判断该结点和其儿子结点的边所标记的值是否满足解的要求，是就加入到解中，继续向下深度优先搜索以其儿子结点为根的子树，否则就结束对以该儿子结点为根的子树的搜索，选择对另一个儿子结点作为根的子树进行搜索。全部搜索完毕或都不满足就向父节点回溯。</p><p>仍以 0-1背包问题为例，设物品重量为 $w=[16,15,15]$，物品价值为 $v=[45,25,25]$，背包容量 $c=30$。定义 $r$ 为当前背包的剩余容量，$v$ 为当前背包的价值。因为物品有 3 个，所以树深为 3+1=4，又因为每个解元素有两种取值，1为放入背包，0为不放入，所以每个结点有两棵子树，最终解空间树绘制如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200501_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200501_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200501_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200501_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png 2x" sizes=auto data-title=背包问题的解空间树 data-alt=背包问题的解空间树 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>遇到某个结点判断与儿子结点的边是否满足条件时，用到剪枝函数，分两种</p><ol><li>约束函数：就是不可行的解，比如上图第二层第一个结点，r=14，小于当前物品重量 15，因此子树不可行；</li><li>限界函数：就是非最优解，比如上图虚线框起来的结点，因为之前得到的最大价值为 v=50，这里出现的 v 都小于该值，所以不是最优解。</li></ol><p>我们理解了基本思想后，就可以很容易的发现回溯的最坏时间复杂度是 $O(N×2^N)$</p><h3 id=13-一般步骤>1.3 一般步骤</h3><p>回溯法的一般步骤为</p><ol><li>针对所给问题，定义问题解空间</li><li>确定易于搜索的解空间树</li><li>以深度优先的方式搜索解空间树，并在搜索过程中用剪枝函数避免无效搜索<ul><li>用约束函数考察左子树是否可行</li><li>用限界函数考察右子树是否（有可能）最优</li></ul></li></ol><p>经常用回溯法解决的问题有两类：子集树和排列树。<strong>子集树</strong>是从 n 个元素的集合中找出满足某种性质的子集，<strong>排列树</strong>是确定 n 个元素满足某种性质的排列，下面分别介绍两类问题的思路。</p><h2 id=2-子集树>2. 子集树</h2><p>给定一个不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<a href=https://leetcode-cn.com/problems/subsets/ target=_blank rel="external nofollow noopener noreferrer">leetcode 78题-子集</a></p><p>注：解集不能包含重复的子集</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>示例输入: nums = [1,2,3]
</span></span><span class=line><span class=cl>示例输出:
</span></span><span class=line><span class=cl>[
</span></span><span class=line><span class=cl>  [3],
</span></span><span class=line><span class=cl>  [1],
</span></span><span class=line><span class=cl>  [2],
</span></span><span class=line><span class=cl>  [1,2,3],
</span></span><span class=line><span class=cl>  [1,3],
</span></span><span class=line><span class=cl>  [2,3],
</span></span><span class=line><span class=cl>  [1,2],
</span></span><span class=line><span class=cl>  []
</span></span><span class=line><span class=cl>]</span></span></code></pre></td></tr></table></div></div><p>回溯法可以保证生成的结果完整无冗余，实际上，就是输出整棵子集树（解空间树）。本题中，解向量的维度是 3 ，每个解元素有选择和不选择两种可能，因此解空间树是一颗4层的二叉树。</p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>subsets</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用闭包可以节省 nums,res,cur 三个参数的传递，同时避免 res 的全局定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 必须事先声明，否则无法在函数中调用自身
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>backTrace</span> <span class=kd>func</span><span class=p>(</span><span class=nx>level</span> <span class=kt>int</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 回溯的思路是每个元素都有选择与不选择两种可能，解空间树是一棵 n+1 层二叉树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>backTrace</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>level</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// len(nums)+1 层说明位于叶子节点，将当前可行解加入结果数组
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>level</span> <span class=p>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 建立一个新切片，将结果复制到新切片，然后再添加到结果集，因为 cur 是指向结果的指针，指向的结果后面还会变动
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>tmp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=nx>cur</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nb>copy</span><span class=p>(</span><span class=nx>tmp</span><span class=p>,</span><span class=nx>cur</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span><span class=nx>tmp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 遍历二叉树的两个分叉
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// i 为 0 表示当前元素不加入当前解
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>backTrace</span><span class=p>(</span><span class=nx>level</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>cur</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>cur</span><span class=p>,</span><span class=nx>nums</span><span class=p>[</span><span class=nx>level</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=nf>backTrace</span><span class=p>(</span><span class=nx>level</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 删除当前元素然后进行回溯
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>cur</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>backTrace</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>一种常用的减小时空复杂度的方法是位运算，用于每个元素的可能取值为 0 和 1 的情况。取值只有 0 和 1 的情况下，我们可以将一条完整的路径看作一个二进制数字，比如一个 n+1 层的二叉树的每一个可行解都可以看作一个 n+1 位的二进制数字，二进制数字的每一位代表该层的元素选择或不选择，这样，只要生成所有可能的二进制数就构成了一个完整的解空间，程序如下</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>subsets</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ln</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这样移位保证左边0的存在，比如一共3位，保证001而不是0，可以从 1000 到 10000 进行遍历，取每个值的右边三位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>s</span><span class=p>,</span> <span class=nx>e</span> <span class=o>:=</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>ln</span><span class=p>,</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=nx>ln</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>e</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>tmp</span> <span class=p>[]</span><span class=kt>int</span> 
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>ln</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 通过与运算判断当前位是否为1，为1则加入结果，i为当前元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>i</span><span class=o>&amp;</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=nx>j</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>                <span class=nx>tmp</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>tmp</span><span class=p>,</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nx>tmp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>上面的子集树问题还有另一种回溯思路，那就是单独计算每一种可能长度的解的集合，然后统一添加到最终的集合。比如对于 nums=[1,2,3]，一个元素的解集为{[1],[2],[3]}，两个元素的解集为{[1,2],[2,3],[1,3]}，三个元素的解集为{[1,2,3]}，再加上空集，就是总的结果。程序如下</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>subsets</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用闭包可以节省 nums 和 res 两个参数的传递，同时避免 res 的全局定义
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>backTrace</span> <span class=kd>func</span><span class=p>(</span><span class=nx>cur</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span><span class=nx>length</span> <span class=kt>int</span><span class=p>)</span> <span class=c1>// 必须事先声明，否则无法在函数中调用自身
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>backTrace</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>cur</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span><span class=nx>length</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 结束条件为元素个数达到了当前限定的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>cur</span><span class=p>)</span> <span class=o>==</span> <span class=nx>length</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 将结果复制到新切片后再添加到结果集，因为 cur 是指向结果的指针，指向的结果后面还会变动
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>tmp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=nx>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>copy</span><span class=p>(</span><span class=nx>tmp</span><span class=p>,</span><span class=nx>cur</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span><span class=nx>tmp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 可以看作遍历子树，儿子节点所有可能的取值是未使用过的值，也就是索引 index 之后的值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>index</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 当前节点加入结果，然后递归遍历子树
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>cur</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>cur</span><span class=p>,</span><span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=nf>backTrace</span><span class=p>(</span><span class=nx>cur</span><span class=p>,</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=nx>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 进行回溯，去除当前结果，回到上一层
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>cur</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 对于每个长度的序列，将所有可能加入最终的结果集
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>backTrace</span><span class=p>(</span><span class=nx>cur</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>用回溯法搜索子集树的一般算法为</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>Backtrack</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>//t：递归深度，即当前活动结点在解空间树中的深度，根节点t=1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//n：解空间树的高度，即问题的规模
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//算法已搜索到一个叶结点，对可行解x进行记录或输出
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=nx>t</span> <span class=p>&gt;</span> <span class=nx>n</span> <span class=nf>output</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>  <span class=c1>//搜索当前活动结点的子树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=p>=</span> <span class=mi>0</span> <span class=nx>to</span> <span class=mi>1</span> <span class=nx>do</span> <span class=c1>//以二叉树为例  
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>x</span><span class=p>[</span><span class=nx>t</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>  <span class=c1>//当前活动结点x[t]的第i个取值
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>//满足约束条件且目标函数未越界时，搜索子树
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=nf>Constraint</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span> <span class=nx>and</span> <span class=nf>Bound</span><span class=p>(</span><span class=nx>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>Backtrack</span><span class=p>(</span><span class=nx>t</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><p>如果说上面求子集的例子其实是求所有的可能，没有进行剪枝，下面可以给出另一个例子</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>题目：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
</span></span><span class=line><span class=cl>示例：
</span></span><span class=line><span class=cl>输入：n = 3
</span></span><span class=line><span class=cl>输出：[
</span></span><span class=line><span class=cl>       &#34;((()))&#34;,
</span></span><span class=line><span class=cl>       &#34;(()())&#34;,
</span></span><span class=line><span class=cl>       &#34;(())()&#34;,
</span></span><span class=line><span class=cl>       &#34;()(())&#34;,
</span></span><span class=line><span class=cl>       &#34;()()()&#34;
</span></span><span class=line><span class=cl>     ]</span></span></code></pre></td></tr></table></div></div><p>程序如下</p><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>generateParenthesis</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span><span class=p>,</span><span class=nx>b</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>backTrace</span> <span class=kd>func</span><span class=p>(</span><span class=nx>level</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>backTrace</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>level</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>level</span> <span class=p>&gt;</span> <span class=mi>2</span><span class=o>*</span><span class=nx>n</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>a</span> <span class=o>==</span> <span class=nx>b</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>cur</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>            
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>a</span> <span class=p>&lt;</span> <span class=nx>n</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>cur</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>cur</span><span class=p>,</span><span class=sc>&#39;(&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>a</span><span class=o>++</span>
</span></span><span class=line><span class=cl>            <span class=nf>backTrace</span><span class=p>(</span><span class=nx>level</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>            <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>cur</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>a</span><span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>b</span> <span class=p>&lt;</span> <span class=nx>a</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>cur</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>cur</span><span class=p>,</span><span class=sc>&#39;)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>b</span><span class=o>++</span>
</span></span><span class=line><span class=cl>            <span class=nf>backTrace</span><span class=p>(</span><span class=nx>level</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>cur</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>b</span><span class=o>--</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>backTrace</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>其中 a &lt; n 和 b &lt; a 就是用来剪枝的，回溯的一个关键步骤就是在调用回溯函数之前添加到结果集，之后从结果集删除，这就是回溯的本质含义。</p><h2 id=3-排列树>3. 排列树</h2><p>以全排列的例子开头，<a href=https://leetcode-cn.com/problems/permutations/ target=_blank rel="external nofollow noopener noreferrer">leetcode 64题-全排列</a></p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>题目：给定一个没有重复数字的序列，返回其所有可能的全排列。
</span></span><span class=line><span class=cl>示例输入: [1,2,3]
</span></span><span class=line><span class=cl>示例输出:
</span></span><span class=line><span class=cl>[
</span></span><span class=line><span class=cl>  [1,2,3],
</span></span><span class=line><span class=cl>  [1,3,2],
</span></span><span class=line><span class=cl>  [2,1,3],
</span></span><span class=line><span class=cl>  [2,3,1],
</span></span><span class=line><span class=cl>  [3,1,2],
</span></span><span class=line><span class=cl>  [3,2,1]
</span></span><span class=line><span class=cl>]</span></span></code></pre></td></tr></table></div></div><p><strong>排列与子集问题的区别在于每一层子树的个数都减1</strong>，因为已选择的元素不必再次出现，因此，全排列问题是一棵4层，然后每层子树个数依次减一的树，这样时间复杂度也很容易理解，就是 $N!$。</p><p>解上面问题的程序如下</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>permute</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>int</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>cur</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>backTrace</span> <span class=kd>func</span><span class=p>(</span><span class=nx>level</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>backTrace</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>level</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>level</span> <span class=p>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>tmp</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=nb>len</span><span class=p>(</span><span class=nx>cur</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=nb>copy</span><span class=p>(</span><span class=nx>tmp</span><span class=p>,</span><span class=nx>cur</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>res</span><span class=p>,</span><span class=nx>tmp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>level</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>cur</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>cur</span><span class=p>,</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=c1>// nums 数组中，level-1 索引前的是已用过的，不能选，只能选 level-1 之后的，在未选元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//集合中选了任何一个元素后，与未选元素集合的第一个交换，相当于把刚刚选择的元素加入了已选元
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//素集合，到下一层索引向前移动一格，就保证了下一层的未选元素集合正确
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span><span class=nx>nums</span><span class=p>[</span><span class=nx>level</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>level</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span><span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nf>backTrace</span><span class=p>(</span><span class=nx>level</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>cur</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span><span class=nx>nums</span><span class=p>[</span><span class=nx>level</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>level</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span><span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>backTrace</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>思路和子集树基本相同，多的一个步骤交换是用来处理每层子树个数减一这个问题的，实质是不断的调整未选择元素的集合。交换是一种高效的做法，除此之外，还可以用一个 Map 来标记已选和未选元素。</p><p>用回溯法搜索排列树的一般算法为</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Backtrack(k)
</span></span><span class=line><span class=cl>  //t：递归深度，即当前活动结点在解空间树中的深度，根节点t=1
</span></span><span class=line><span class=cl>  //n：解空间树的高度，即问题的规模
</span></span><span class=line><span class=cl>  //算法已搜索到一个叶结点，对可行解x进行记录或输出
</span></span><span class=line><span class=cl>  if t &gt; n output(x)
</span></span><span class=line><span class=cl>  else
</span></span><span class=line><span class=cl>  //搜索当前活动结点的子树
</span></span><span class=line><span class=cl>  //处理[t:n]的排列
</span></span><span class=line><span class=cl>    for i = t to n do 
</span></span><span class=line><span class=cl>      swap(x[t],x[i])
</span></span><span class=line><span class=cl>      //满足约束条件且目标函数未越界时，搜索子树
</span></span><span class=line><span class=cl>      if (Constraint(t) and Bound(t))
</span></span><span class=line><span class=cl>        Backtrack(t+1)
</span></span><span class=line><span class=cl>      swap(x[t],x[i]) // 回溯到交换之前</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2020-09-03 00:00:00">更新于 2020-09-03&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/2020/algorithm-backtracking/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://shuzang.github.io/2020/algorithm-backtracking/ data-title=算法-回溯 data-hashtags=数据结构与算法><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://shuzang.github.io/2020/algorithm-backtracking/ data-hashtag=数据结构与算法><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://shuzang.github.io/2020/algorithm-backtracking/ data-title=算法-回溯><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ class=post-tag>数据结构与算法</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2020/summary-of-smart-contract-knowledge-points/ class=post-nav-item rel=prev title=智能合约知识点总结><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>智能合约知识点总结</a>
<a href=/2020/image-container-and-repository/ class=post-nav-item rel=next title=Docker-镜像、容器与仓库>Docker-镜像、容器与仓库<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.117.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/>Shuzang</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/shuzang title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/lightgallery/lightgallery.min.js defer></script><script src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/js/theme.min.js defer></script></body></html>