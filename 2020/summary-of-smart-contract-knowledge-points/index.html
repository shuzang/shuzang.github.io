<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>智能合约知识点总结 - Shuzang's Blog</title><meta name=author content><meta name=author-link content><meta name=description content="项目进行过程中知识点的总结
1. 字符串比较
翻译自：Fravoll-String Equality Comparison
比较两个给定字符串是否相等，是 Solidity 编程中最常见的一种情况，但语言本身并没有提供内置函数用于字符串比较，本文介绍两种可用方法并分析 Gas 消耗情况。
1.1 StringUtils 库
第一种方法是使用 Ethereum 基金会提供的 StringUtils 库，它对每个字符进行成对比较，如果有一个字符对不匹配，则返回false。这种办法可以返回正确的结果，对于短字符串和字符不同发生在字符串前面的情况仅消耗少量 Gas。但是对于相等的字符串和长字符串，这种方法的 Gas 消耗较高，因为必须做很多比较才能得到正确结果。因此，字符串比较的两个可衡量的因素是字符串平均长度和正确率。
1.2 哈希函数
作者提出使用哈希函数进行比较，同时检查所提供的字符串的长度，从一开始就剔除长度不匹配的字符串。其步骤如下

检查两个字符串是否有相同长度，通过转换为 bytes 类型完成，因为 bytes 类型有内置长度函数。如果相同进入第2步，如果不相同返回结果；
使用 keccak256() 函数对两个字符串求哈希，然后比较计算得到的哈希值，从而确定是否相等。

一个示例代码如下


1
2
3
4
5
6
7
8


# 这段代码未经安全审计，使用有风险
function hashCompareWithLengthCheck(string a, string b) internal returns (bool) {
    if(bytes(a).length != bytes(b).length) {
        return false;
    } else {
        return keccak256(abi.encodePacket(a)) == keccak256(abi.encodePacket(b));
    }
}

abi.encodePacket(...) returns (bytes) 用于对给定参数执行紧打包编码，官方文档中不推荐使用 keccak256(...) 直接计算哈希，而是使用 keccak256(abi.encodePacked(...))
1.3 Gas 消耗分析
在 Remix 编写代码测试了三种不同情况的字符串比较的 Gas 消耗

比较哈希
比较每个字符，同时比较字符串长度
比较哈希，同时比较字符串长度

结果如下表所示，输入列为输入的待比较字符串，输出列的单位为 Wei



Input A
Input B
Hash
Character + Length
Hash + Length




abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
7062
1261


abcdefghijklmnopqrstuvwxyX
abcdefghijklmnopqrstuvwxyz
1225
7012
1261


Xbcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
912
1261


aXcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
1156
1261


abXdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
1400
1261


abcdefghijkl
abcdefghijklmnopqrstuvwxyz
1225
690
707


a
a
1225
962
1261


ab
ab
1225
1156
1261


abc
abc
1225
1450
1261



可以看出，哈希+字符串长度 的比较方式 Gas 消耗更加稳定，这种方式比较高效。
2. 可见性与Getter函数
转自：Solidity 0.6.4 中文文档
Solidity 有两种函数调用：内部调用（Internal Function Calls）和外部调用（External Function Calls）。前者指直接或递归地调用合约内部函数，不会产生实际的 EVM 调用，因此也被称为「消息嗲用」，后者指从合约外部调用合约中的函数，会产生一个 EVM 调用。
2.1 可见性
因此，函数和状态变量有四种可见性。函数可以指定为 external，public，internal 或 private，对于状态变量， 默认是 internal 且不能设置为 external。

external：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f()可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.
public：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。
internal：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。
private：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。


合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。

可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间，如下例


1
2
3
4
5
6
7


pragma solidity  >=0.4.16 <0.7.0;

contract C {
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;
}

在下面的例子中，D 可以调用 c.getData（） 来获取状态存储中 data 的值，但不能调用 f 。 合约 E 继承自 C ，因此可以调用 compute。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28


pragma solidity >=0.4.0 <0.7.0;

contract C {
    uint private data;

    function f(uint a) private returns(uint b) { return a + 1; }
    function setData(uint a) public { data = a; }
    function getData() public returns(uint) { return data; }
    function compute(uint a, uint b) internal returns (uint) { return a+b; }
}

// 下面代码编译错误
contract D {
    function readData() public {
        C c = new C();
        uint local = c.f(7); // 错误：成员 `f` 不可见
        c.setData(3);
        local = c.getData();
        local = c.compute(3, 5); // 错误：成员 `compute` 不可见
    }
}

contract E is C {
    function g() public {
        C c = new C();
        uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员）
    }
}

2.2 Getter 函数
编译器自动为所有 public 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 data 的函数， 该函数没有参数，返回值是一个 uint 类型，即状态变量 data 的值。 状态变量的初始化可以在声明时完成。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


pragma solidity  >=0.4.0 <0.7.0;

contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public {
        uint local = c.data();
    }
}

getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果使用外部访问（即用 this. ），它被认作为一个函数。


1
2
3
4
5
6
7
8
9


pragma solidity ^0.4.0 <0.7.0;

contract C {
    uint public data;
    function x() public {
        data = 3; // 内部访问
        uint val = this.data(); // 外部访问
    }
}

如果你有一个数组类型的 public 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 data(0) 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18


pragma solidity >=0.4.0 <0.7.0;

contract arrayExample {
  // public state variable
  uint[] public myArray;

  // 指定生成的Getter 函数
  /*
  function myArray(uint i) public view returns (uint) {
      return myArray[i];
  }
  */

  // 返回整个数组
  function getArray() public view returns (uint[] memory) {
      return myArray;
  }
}

现在可以使用 getArray() 获得整个数组，而 myArray(i) 是返回单个元素。
下一个例子稍微复杂一些：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


pragma solidity ^0.4.0 <0.7.0;

contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}

这将会生成以下形式的函数


1
2
3
4


function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) {
    a = data[arg1][arg2][arg3].a;
    b = data[arg1][arg2][arg3].b;
}

请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。
3. 合约间调用
之前的实验合约间的调用没有成功，这次就仔细地研究一下合约间地调用机制。分为两种情况

调用者和被调用者在一个sol文件中
调用者和被调用者在不同的sol文件中

本文提到的合约调用方法的实质是抽象合约的使用。
3.1 同sol文件的智能合约调用
下面的智能合约中，Main和Add两个合约定义在一个Main.sol文件中，可以同时编译，然后逐个部署。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


pragma solidity ^0.5.0;


contract Main {
  Add add;
  
  constructor(address _m) public {
     add = Add(_m);
  }
  
  function Addnumber() public view returns (uint) {
    return add.add5(10);
  }
}

contract Add {
  function add5(uint s) public pure returns (uint){
      return 5+s;
  }
}

以使用Remix为例，点击编译按钮编译Main.sol文件，将会同时编译Main和Add两个合约。

然后首先部署Add合约，因为Main合约的部署需要Add的合约地址作为参数。切换到部署和运行选项卡，选择Add合约，点击Deploy，成功部署后，复制合约地址。

然后重新选择Main合约，填入Add合约地址作为参数，点击部署按钮。

测试合约间调用，由合约内容可知，Main合约中的Addnumber函数调用了Add合约的add5函数，传入参数为10，得到的结果应为15。展开左侧的Deployed Contracts，点击Addnumber进行调用，结果如下。

3.2 不同sol文件的智能合约调用
这一次我们测试不同sol文件的智能合约调用，来一个复杂一点的，两个合约分别是Add.sol和Main.sol。
Add.sol使用了一个结构体来定义数值，并通过映射定义查找表来寻找这个值。文件中定义了两个函数，numRegister用来向表中添加数值，addValue用来将从表中查到的指定值+5返回。之所以用这个结构是因为我们的项目里用到了，这里来测试一下可不可行。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


pragma solidity ^0.5.0;

contract Add {
    struct Num{
        uint value;
    }
    mapping(uint => Num) public lookupTable;
    
    function numRegister(uint key, uint _value) public {
        lookupTable[key].value = _value;
    }
    
    function addValue(uint key) public view returns (uint) {
        return lookupTable[key].value + 5;
    }

}

Main.sol没有多大变化


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


pragma solidity ^0.5.0;

contract Main {
  Add add;
  
  constructor(address _m) public {
     add = Add(_m);
  }
  
  function Addnumber() public view returns (uint) {
    return add.addValue(5);
  }
}

contract Add {
      function addValue(uint key) public view returns (uint);
}

仍然是先编译部署Add合约，部署后调用numRegister函数写入数值5，并调用addValue函数测试返回。

接着编译部署Main合约，复制Add合约地址作为初始化参数，部署后调用Addnumber函数测试

3.3 总结
合约内的调用方法是相同的，都要先实例化，然后传入被调合约地址，接着才能调用。而写在不同sol文件中时，需要额外声明被调合约的抽象合约，有些文章中说使用call，callcode或delegatecall，但并不建议，因为这三个函数都是非常底层的函数，破坏了类型的安全，只能作为最后的手段使用。
详细的解释参考了StackExchange-Calling function from deployed contract
4. 函数修饰词pure和view
转自深入理解Solidity-函数
这两个函数修饰词的作用是告诉编译器函数是否会读取/修改状态，view 表示保证不修改状态，pure 表示保证不读取也不修改状态。Solidity v0.4.17 之前没有这两个修饰词，而是使用 constant 关键字，和 view 的含义相同，不过在 v0.5.0 之后被移除，现在只能使用这两个 view 和 pure。
4.1 view 视图函数
Getter 方法会被自动标记为 view，除此之外，一个 view 修饰的例子如下


1
2
3
4
5
6
7


pragma solidity  >=0.5.0 <0.7.0;

contract C {
    function f(uint a, uint b) public view returns (uint) {
        return a * (b + 42) + now;
    }
}

view 保证函数不修改状态，以下操作会被认为是修改状态

修改状态变量。
产生事件。
创建其它合约。
使用 selfdestruct。
通过调用发送以太币。
调用任何没有标记为 view 或者 pure 的函数。
使用低级调用。
使用包含特定操作码的内联汇编。

4.2 pure 纯函数
pure 保证不读取也不修改状态，不修改的定义上面已经提到，下面的操作被认为是读取状态

读取状态变量。
访问 address(this).balance 或者 .balance。
访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。
调用任何未标记为 pure 的函数。
使用包含某些操作码的内联汇编。

一个 pure 修饰的例子如下


1
2
3
4
5
6
7


pragma solidity >=0.5.0 <0.7.0;

contract C {
    function f(uint a, uint b) public pure returns (uint) {
        return a * (b + 42);
    }
}

5. 浮点数处理
首先声明，Solidity 中支持浮点数定义，但无法赋值和进行计算。文档中对其描述是「目前还不完全支持」，虽然这意味着以后可能会完全支持，但等不及了，下面记录几个可参考的资料。

来自 ethereum stackexchange 中的回答，介绍了一些可用的库；
ABDK Math Quad，包含两个合约库，一个支持定点数，一个支持浮点数；
Mikhail Vladimirov 的 Math in Solidity 系列文章，介绍如何在 Solidity 中处理各种数学运算，写的非常棒。

6. 地址类型
在智能合约中显式传入地址类型时，可能会出现如下错误

Address checksum
This looks like an address but has an invalid checksum. If this is not used as an address, please prepend &lsquo;00&rsquo;.

关于该问题的一个讨论见 https://github.com/ethereum/EIPs/issues/55
这是因为合约中现在使用地址类型必须做一个转换，不是简单的全部大写字母或小写字母，而是遵循一定的规则，这个规则见 ethereum/EIPs#55
但是网上提供的解决方案一般是使用JS库中的转换函数，在智能合约中无法直接解决，好在，web3提供了一个在线API接口，可以调用其checkAddressChecksum函数对地址进行转换，然后将转换后的结果直接用于合约代码。
7. Gas limit问题
在搭建的以太坊私链上进行智能合约部署时，出现了以下问题


1
2


INFO [03-21|13:50:11.690] Served eth_sendTransaction               reqid=24 t=684.186µs    err=&#34;exceeds block gas limit&#34;
Error: exceeds block gas limit undefined

出现该错误的原因如错误描述，是当前合约所需的gas超过了区块的最大gas。这可能与参数gasLimit有关。在创世区块的配置文件中，我们使用了默认的配置值，为0x2fefd8，转换为10进制即3141592。
注：在线转换工具"><meta name=keywords content="区块链"><meta itemprop=name content="智能合约知识点总结"><meta itemprop=description content="项目进行过程中知识点的总结
1. 字符串比较
翻译自：Fravoll-String Equality Comparison
比较两个给定字符串是否相等，是 Solidity 编程中最常见的一种情况，但语言本身并没有提供内置函数用于字符串比较，本文介绍两种可用方法并分析 Gas 消耗情况。
1.1 StringUtils 库
第一种方法是使用 Ethereum 基金会提供的 StringUtils 库，它对每个字符进行成对比较，如果有一个字符对不匹配，则返回false。这种办法可以返回正确的结果，对于短字符串和字符不同发生在字符串前面的情况仅消耗少量 Gas。但是对于相等的字符串和长字符串，这种方法的 Gas 消耗较高，因为必须做很多比较才能得到正确结果。因此，字符串比较的两个可衡量的因素是字符串平均长度和正确率。
1.2 哈希函数
作者提出使用哈希函数进行比较，同时检查所提供的字符串的长度，从一开始就剔除长度不匹配的字符串。其步骤如下

检查两个字符串是否有相同长度，通过转换为 bytes 类型完成，因为 bytes 类型有内置长度函数。如果相同进入第2步，如果不相同返回结果；
使用 keccak256() 函数对两个字符串求哈希，然后比较计算得到的哈希值，从而确定是否相等。

一个示例代码如下


1
2
3
4
5
6
7
8


# 这段代码未经安全审计，使用有风险
function hashCompareWithLengthCheck(string a, string b) internal returns (bool) {
    if(bytes(a).length != bytes(b).length) {
        return false;
    } else {
        return keccak256(abi.encodePacket(a)) == keccak256(abi.encodePacket(b));
    }
}

abi.encodePacket(...) returns (bytes) 用于对给定参数执行紧打包编码，官方文档中不推荐使用 keccak256(...) 直接计算哈希，而是使用 keccak256(abi.encodePacked(...))
1.3 Gas 消耗分析
在 Remix 编写代码测试了三种不同情况的字符串比较的 Gas 消耗

比较哈希
比较每个字符，同时比较字符串长度
比较哈希，同时比较字符串长度

结果如下表所示，输入列为输入的待比较字符串，输出列的单位为 Wei



Input A
Input B
Hash
Character + Length
Hash + Length




abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
7062
1261


abcdefghijklmnopqrstuvwxyX
abcdefghijklmnopqrstuvwxyz
1225
7012
1261


Xbcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
912
1261


aXcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
1156
1261


abXdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
1400
1261


abcdefghijkl
abcdefghijklmnopqrstuvwxyz
1225
690
707


a
a
1225
962
1261


ab
ab
1225
1156
1261


abc
abc
1225
1450
1261



可以看出，哈希+字符串长度 的比较方式 Gas 消耗更加稳定，这种方式比较高效。
2. 可见性与Getter函数
转自：Solidity 0.6.4 中文文档
Solidity 有两种函数调用：内部调用（Internal Function Calls）和外部调用（External Function Calls）。前者指直接或递归地调用合约内部函数，不会产生实际的 EVM 调用，因此也被称为「消息嗲用」，后者指从合约外部调用合约中的函数，会产生一个 EVM 调用。
2.1 可见性
因此，函数和状态变量有四种可见性。函数可以指定为 external，public，internal 或 private，对于状态变量， 默认是 internal 且不能设置为 external。

external：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f()可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.
public：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。
internal：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。
private：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。


合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。

可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间，如下例


1
2
3
4
5
6
7


pragma solidity  >=0.4.16 <0.7.0;

contract C {
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;
}

在下面的例子中，D 可以调用 c.getData（） 来获取状态存储中 data 的值，但不能调用 f 。 合约 E 继承自 C ，因此可以调用 compute。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28


pragma solidity >=0.4.0 <0.7.0;

contract C {
    uint private data;

    function f(uint a) private returns(uint b) { return a + 1; }
    function setData(uint a) public { data = a; }
    function getData() public returns(uint) { return data; }
    function compute(uint a, uint b) internal returns (uint) { return a+b; }
}

// 下面代码编译错误
contract D {
    function readData() public {
        C c = new C();
        uint local = c.f(7); // 错误：成员 `f` 不可见
        c.setData(3);
        local = c.getData();
        local = c.compute(3, 5); // 错误：成员 `compute` 不可见
    }
}

contract E is C {
    function g() public {
        C c = new C();
        uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员）
    }
}

2.2 Getter 函数
编译器自动为所有 public 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 data 的函数， 该函数没有参数，返回值是一个 uint 类型，即状态变量 data 的值。 状态变量的初始化可以在声明时完成。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


pragma solidity  >=0.4.0 <0.7.0;

contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public {
        uint local = c.data();
    }
}

getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果使用外部访问（即用 this. ），它被认作为一个函数。


1
2
3
4
5
6
7
8
9


pragma solidity ^0.4.0 <0.7.0;

contract C {
    uint public data;
    function x() public {
        data = 3; // 内部访问
        uint val = this.data(); // 外部访问
    }
}

如果你有一个数组类型的 public 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 data(0) 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18


pragma solidity >=0.4.0 <0.7.0;

contract arrayExample {
  // public state variable
  uint[] public myArray;

  // 指定生成的Getter 函数
  /*
  function myArray(uint i) public view returns (uint) {
      return myArray[i];
  }
  */

  // 返回整个数组
  function getArray() public view returns (uint[] memory) {
      return myArray;
  }
}

现在可以使用 getArray() 获得整个数组，而 myArray(i) 是返回单个元素。
下一个例子稍微复杂一些：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


pragma solidity ^0.4.0 <0.7.0;

contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}

这将会生成以下形式的函数


1
2
3
4


function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) {
    a = data[arg1][arg2][arg3].a;
    b = data[arg1][arg2][arg3].b;
}

请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。
3. 合约间调用
之前的实验合约间的调用没有成功，这次就仔细地研究一下合约间地调用机制。分为两种情况

调用者和被调用者在一个sol文件中
调用者和被调用者在不同的sol文件中

本文提到的合约调用方法的实质是抽象合约的使用。
3.1 同sol文件的智能合约调用
下面的智能合约中，Main和Add两个合约定义在一个Main.sol文件中，可以同时编译，然后逐个部署。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


pragma solidity ^0.5.0;


contract Main {
  Add add;
  
  constructor(address _m) public {
     add = Add(_m);
  }
  
  function Addnumber() public view returns (uint) {
    return add.add5(10);
  }
}

contract Add {
  function add5(uint s) public pure returns (uint){
      return 5+s;
  }
}

以使用Remix为例，点击编译按钮编译Main.sol文件，将会同时编译Main和Add两个合约。

然后首先部署Add合约，因为Main合约的部署需要Add的合约地址作为参数。切换到部署和运行选项卡，选择Add合约，点击Deploy，成功部署后，复制合约地址。

然后重新选择Main合约，填入Add合约地址作为参数，点击部署按钮。

测试合约间调用，由合约内容可知，Main合约中的Addnumber函数调用了Add合约的add5函数，传入参数为10，得到的结果应为15。展开左侧的Deployed Contracts，点击Addnumber进行调用，结果如下。

3.2 不同sol文件的智能合约调用
这一次我们测试不同sol文件的智能合约调用，来一个复杂一点的，两个合约分别是Add.sol和Main.sol。
Add.sol使用了一个结构体来定义数值，并通过映射定义查找表来寻找这个值。文件中定义了两个函数，numRegister用来向表中添加数值，addValue用来将从表中查到的指定值+5返回。之所以用这个结构是因为我们的项目里用到了，这里来测试一下可不可行。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


pragma solidity ^0.5.0;

contract Add {
    struct Num{
        uint value;
    }
    mapping(uint => Num) public lookupTable;
    
    function numRegister(uint key, uint _value) public {
        lookupTable[key].value = _value;
    }
    
    function addValue(uint key) public view returns (uint) {
        return lookupTable[key].value + 5;
    }

}

Main.sol没有多大变化


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


pragma solidity ^0.5.0;

contract Main {
  Add add;
  
  constructor(address _m) public {
     add = Add(_m);
  }
  
  function Addnumber() public view returns (uint) {
    return add.addValue(5);
  }
}

contract Add {
      function addValue(uint key) public view returns (uint);
}

仍然是先编译部署Add合约，部署后调用numRegister函数写入数值5，并调用addValue函数测试返回。

接着编译部署Main合约，复制Add合约地址作为初始化参数，部署后调用Addnumber函数测试

3.3 总结
合约内的调用方法是相同的，都要先实例化，然后传入被调合约地址，接着才能调用。而写在不同sol文件中时，需要额外声明被调合约的抽象合约，有些文章中说使用call，callcode或delegatecall，但并不建议，因为这三个函数都是非常底层的函数，破坏了类型的安全，只能作为最后的手段使用。
详细的解释参考了StackExchange-Calling function from deployed contract
4. 函数修饰词pure和view
转自深入理解Solidity-函数
这两个函数修饰词的作用是告诉编译器函数是否会读取/修改状态，view 表示保证不修改状态，pure 表示保证不读取也不修改状态。Solidity v0.4.17 之前没有这两个修饰词，而是使用 constant 关键字，和 view 的含义相同，不过在 v0.5.0 之后被移除，现在只能使用这两个 view 和 pure。
4.1 view 视图函数
Getter 方法会被自动标记为 view，除此之外，一个 view 修饰的例子如下


1
2
3
4
5
6
7


pragma solidity  >=0.5.0 <0.7.0;

contract C {
    function f(uint a, uint b) public view returns (uint) {
        return a * (b + 42) + now;
    }
}

view 保证函数不修改状态，以下操作会被认为是修改状态

修改状态变量。
产生事件。
创建其它合约。
使用 selfdestruct。
通过调用发送以太币。
调用任何没有标记为 view 或者 pure 的函数。
使用低级调用。
使用包含特定操作码的内联汇编。

4.2 pure 纯函数
pure 保证不读取也不修改状态，不修改的定义上面已经提到，下面的操作被认为是读取状态

读取状态变量。
访问 address(this).balance 或者 .balance。
访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。
调用任何未标记为 pure 的函数。
使用包含某些操作码的内联汇编。

一个 pure 修饰的例子如下


1
2
3
4
5
6
7


pragma solidity >=0.5.0 <0.7.0;

contract C {
    function f(uint a, uint b) public pure returns (uint) {
        return a * (b + 42);
    }
}

5. 浮点数处理
首先声明，Solidity 中支持浮点数定义，但无法赋值和进行计算。文档中对其描述是「目前还不完全支持」，虽然这意味着以后可能会完全支持，但等不及了，下面记录几个可参考的资料。

来自 ethereum stackexchange 中的回答，介绍了一些可用的库；
ABDK Math Quad，包含两个合约库，一个支持定点数，一个支持浮点数；
Mikhail Vladimirov 的 Math in Solidity 系列文章，介绍如何在 Solidity 中处理各种数学运算，写的非常棒。

6. 地址类型
在智能合约中显式传入地址类型时，可能会出现如下错误

Address checksum
This looks like an address but has an invalid checksum. If this is not used as an address, please prepend &lsquo;00&rsquo;.

关于该问题的一个讨论见 https://github.com/ethereum/EIPs/issues/55
这是因为合约中现在使用地址类型必须做一个转换，不是简单的全部大写字母或小写字母，而是遵循一定的规则，这个规则见 ethereum/EIPs#55
但是网上提供的解决方案一般是使用JS库中的转换函数，在智能合约中无法直接解决，好在，web3提供了一个在线API接口，可以调用其checkAddressChecksum函数对地址进行转换，然后将转换后的结果直接用于合约代码。
7. Gas limit问题
在搭建的以太坊私链上进行智能合约部署时，出现了以下问题


1
2


INFO [03-21|13:50:11.690] Served eth_sendTransaction               reqid=24 t=684.186µs    err=&#34;exceeds block gas limit&#34;
Error: exceeds block gas limit undefined

出现该错误的原因如错误描述，是当前合约所需的gas超过了区块的最大gas。这可能与参数gasLimit有关。在创世区块的配置文件中，我们使用了默认的配置值，为0x2fefd8，转换为10进制即3141592。
注：在线转换工具"><meta itemprop=datePublished content="2020-05-04T00:00:00+00:00"><meta itemprop=dateModified content="2020-05-04T00:00:00+00:00"><meta itemprop=wordCount content="5016"><meta itemprop=image content="https://shuzang.github.io/logo.png"><meta itemprop=keywords content="区块链,"><meta property="og:title" content="智能合约知识点总结"><meta property="og:description" content="项目进行过程中知识点的总结
1. 字符串比较
翻译自：Fravoll-String Equality Comparison
比较两个给定字符串是否相等，是 Solidity 编程中最常见的一种情况，但语言本身并没有提供内置函数用于字符串比较，本文介绍两种可用方法并分析 Gas 消耗情况。
1.1 StringUtils 库
第一种方法是使用 Ethereum 基金会提供的 StringUtils 库，它对每个字符进行成对比较，如果有一个字符对不匹配，则返回false。这种办法可以返回正确的结果，对于短字符串和字符不同发生在字符串前面的情况仅消耗少量 Gas。但是对于相等的字符串和长字符串，这种方法的 Gas 消耗较高，因为必须做很多比较才能得到正确结果。因此，字符串比较的两个可衡量的因素是字符串平均长度和正确率。
1.2 哈希函数
作者提出使用哈希函数进行比较，同时检查所提供的字符串的长度，从一开始就剔除长度不匹配的字符串。其步骤如下

检查两个字符串是否有相同长度，通过转换为 bytes 类型完成，因为 bytes 类型有内置长度函数。如果相同进入第2步，如果不相同返回结果；
使用 keccak256() 函数对两个字符串求哈希，然后比较计算得到的哈希值，从而确定是否相等。

一个示例代码如下


1
2
3
4
5
6
7
8


# 这段代码未经安全审计，使用有风险
function hashCompareWithLengthCheck(string a, string b) internal returns (bool) {
    if(bytes(a).length != bytes(b).length) {
        return false;
    } else {
        return keccak256(abi.encodePacket(a)) == keccak256(abi.encodePacket(b));
    }
}

abi.encodePacket(...) returns (bytes) 用于对给定参数执行紧打包编码，官方文档中不推荐使用 keccak256(...) 直接计算哈希，而是使用 keccak256(abi.encodePacked(...))
1.3 Gas 消耗分析
在 Remix 编写代码测试了三种不同情况的字符串比较的 Gas 消耗

比较哈希
比较每个字符，同时比较字符串长度
比较哈希，同时比较字符串长度

结果如下表所示，输入列为输入的待比较字符串，输出列的单位为 Wei



Input A
Input B
Hash
Character + Length
Hash + Length




abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
7062
1261


abcdefghijklmnopqrstuvwxyX
abcdefghijklmnopqrstuvwxyz
1225
7012
1261


Xbcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
912
1261


aXcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
1156
1261


abXdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
1400
1261


abcdefghijkl
abcdefghijklmnopqrstuvwxyz
1225
690
707


a
a
1225
962
1261


ab
ab
1225
1156
1261


abc
abc
1225
1450
1261



可以看出，哈希+字符串长度 的比较方式 Gas 消耗更加稳定，这种方式比较高效。
2. 可见性与Getter函数
转自：Solidity 0.6.4 中文文档
Solidity 有两种函数调用：内部调用（Internal Function Calls）和外部调用（External Function Calls）。前者指直接或递归地调用合约内部函数，不会产生实际的 EVM 调用，因此也被称为「消息嗲用」，后者指从合约外部调用合约中的函数，会产生一个 EVM 调用。
2.1 可见性
因此，函数和状态变量有四种可见性。函数可以指定为 external，public，internal 或 private，对于状态变量， 默认是 internal 且不能设置为 external。

external：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f()可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.
public：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。
internal：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。
private：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。


合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。

可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间，如下例


1
2
3
4
5
6
7


pragma solidity  >=0.4.16 <0.7.0;

contract C {
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;
}

在下面的例子中，D 可以调用 c.getData（） 来获取状态存储中 data 的值，但不能调用 f 。 合约 E 继承自 C ，因此可以调用 compute。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28


pragma solidity >=0.4.0 <0.7.0;

contract C {
    uint private data;

    function f(uint a) private returns(uint b) { return a + 1; }
    function setData(uint a) public { data = a; }
    function getData() public returns(uint) { return data; }
    function compute(uint a, uint b) internal returns (uint) { return a+b; }
}

// 下面代码编译错误
contract D {
    function readData() public {
        C c = new C();
        uint local = c.f(7); // 错误：成员 `f` 不可见
        c.setData(3);
        local = c.getData();
        local = c.compute(3, 5); // 错误：成员 `compute` 不可见
    }
}

contract E is C {
    function g() public {
        C c = new C();
        uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员）
    }
}

2.2 Getter 函数
编译器自动为所有 public 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 data 的函数， 该函数没有参数，返回值是一个 uint 类型，即状态变量 data 的值。 状态变量的初始化可以在声明时完成。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


pragma solidity  >=0.4.0 <0.7.0;

contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public {
        uint local = c.data();
    }
}

getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果使用外部访问（即用 this. ），它被认作为一个函数。


1
2
3
4
5
6
7
8
9


pragma solidity ^0.4.0 <0.7.0;

contract C {
    uint public data;
    function x() public {
        data = 3; // 内部访问
        uint val = this.data(); // 外部访问
    }
}

如果你有一个数组类型的 public 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 data(0) 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18


pragma solidity >=0.4.0 <0.7.0;

contract arrayExample {
  // public state variable
  uint[] public myArray;

  // 指定生成的Getter 函数
  /*
  function myArray(uint i) public view returns (uint) {
      return myArray[i];
  }
  */

  // 返回整个数组
  function getArray() public view returns (uint[] memory) {
      return myArray;
  }
}

现在可以使用 getArray() 获得整个数组，而 myArray(i) 是返回单个元素。
下一个例子稍微复杂一些：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


pragma solidity ^0.4.0 <0.7.0;

contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}

这将会生成以下形式的函数


1
2
3
4


function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) {
    a = data[arg1][arg2][arg3].a;
    b = data[arg1][arg2][arg3].b;
}

请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。
3. 合约间调用
之前的实验合约间的调用没有成功，这次就仔细地研究一下合约间地调用机制。分为两种情况

调用者和被调用者在一个sol文件中
调用者和被调用者在不同的sol文件中

本文提到的合约调用方法的实质是抽象合约的使用。
3.1 同sol文件的智能合约调用
下面的智能合约中，Main和Add两个合约定义在一个Main.sol文件中，可以同时编译，然后逐个部署。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


pragma solidity ^0.5.0;


contract Main {
  Add add;
  
  constructor(address _m) public {
     add = Add(_m);
  }
  
  function Addnumber() public view returns (uint) {
    return add.add5(10);
  }
}

contract Add {
  function add5(uint s) public pure returns (uint){
      return 5+s;
  }
}

以使用Remix为例，点击编译按钮编译Main.sol文件，将会同时编译Main和Add两个合约。

然后首先部署Add合约，因为Main合约的部署需要Add的合约地址作为参数。切换到部署和运行选项卡，选择Add合约，点击Deploy，成功部署后，复制合约地址。

然后重新选择Main合约，填入Add合约地址作为参数，点击部署按钮。

测试合约间调用，由合约内容可知，Main合约中的Addnumber函数调用了Add合约的add5函数，传入参数为10，得到的结果应为15。展开左侧的Deployed Contracts，点击Addnumber进行调用，结果如下。

3.2 不同sol文件的智能合约调用
这一次我们测试不同sol文件的智能合约调用，来一个复杂一点的，两个合约分别是Add.sol和Main.sol。
Add.sol使用了一个结构体来定义数值，并通过映射定义查找表来寻找这个值。文件中定义了两个函数，numRegister用来向表中添加数值，addValue用来将从表中查到的指定值+5返回。之所以用这个结构是因为我们的项目里用到了，这里来测试一下可不可行。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


pragma solidity ^0.5.0;

contract Add {
    struct Num{
        uint value;
    }
    mapping(uint => Num) public lookupTable;
    
    function numRegister(uint key, uint _value) public {
        lookupTable[key].value = _value;
    }
    
    function addValue(uint key) public view returns (uint) {
        return lookupTable[key].value + 5;
    }

}

Main.sol没有多大变化


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


pragma solidity ^0.5.0;

contract Main {
  Add add;
  
  constructor(address _m) public {
     add = Add(_m);
  }
  
  function Addnumber() public view returns (uint) {
    return add.addValue(5);
  }
}

contract Add {
      function addValue(uint key) public view returns (uint);
}

仍然是先编译部署Add合约，部署后调用numRegister函数写入数值5，并调用addValue函数测试返回。

接着编译部署Main合约，复制Add合约地址作为初始化参数，部署后调用Addnumber函数测试

3.3 总结
合约内的调用方法是相同的，都要先实例化，然后传入被调合约地址，接着才能调用。而写在不同sol文件中时，需要额外声明被调合约的抽象合约，有些文章中说使用call，callcode或delegatecall，但并不建议，因为这三个函数都是非常底层的函数，破坏了类型的安全，只能作为最后的手段使用。
详细的解释参考了StackExchange-Calling function from deployed contract
4. 函数修饰词pure和view
转自深入理解Solidity-函数
这两个函数修饰词的作用是告诉编译器函数是否会读取/修改状态，view 表示保证不修改状态，pure 表示保证不读取也不修改状态。Solidity v0.4.17 之前没有这两个修饰词，而是使用 constant 关键字，和 view 的含义相同，不过在 v0.5.0 之后被移除，现在只能使用这两个 view 和 pure。
4.1 view 视图函数
Getter 方法会被自动标记为 view，除此之外，一个 view 修饰的例子如下


1
2
3
4
5
6
7


pragma solidity  >=0.5.0 <0.7.0;

contract C {
    function f(uint a, uint b) public view returns (uint) {
        return a * (b + 42) + now;
    }
}

view 保证函数不修改状态，以下操作会被认为是修改状态

修改状态变量。
产生事件。
创建其它合约。
使用 selfdestruct。
通过调用发送以太币。
调用任何没有标记为 view 或者 pure 的函数。
使用低级调用。
使用包含特定操作码的内联汇编。

4.2 pure 纯函数
pure 保证不读取也不修改状态，不修改的定义上面已经提到，下面的操作被认为是读取状态

读取状态变量。
访问 address(this).balance 或者 .balance。
访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。
调用任何未标记为 pure 的函数。
使用包含某些操作码的内联汇编。

一个 pure 修饰的例子如下


1
2
3
4
5
6
7


pragma solidity >=0.5.0 <0.7.0;

contract C {
    function f(uint a, uint b) public pure returns (uint) {
        return a * (b + 42);
    }
}

5. 浮点数处理
首先声明，Solidity 中支持浮点数定义，但无法赋值和进行计算。文档中对其描述是「目前还不完全支持」，虽然这意味着以后可能会完全支持，但等不及了，下面记录几个可参考的资料。

来自 ethereum stackexchange 中的回答，介绍了一些可用的库；
ABDK Math Quad，包含两个合约库，一个支持定点数，一个支持浮点数；
Mikhail Vladimirov 的 Math in Solidity 系列文章，介绍如何在 Solidity 中处理各种数学运算，写的非常棒。

6. 地址类型
在智能合约中显式传入地址类型时，可能会出现如下错误

Address checksum
This looks like an address but has an invalid checksum. If this is not used as an address, please prepend &lsquo;00&rsquo;.

关于该问题的一个讨论见 https://github.com/ethereum/EIPs/issues/55
这是因为合约中现在使用地址类型必须做一个转换，不是简单的全部大写字母或小写字母，而是遵循一定的规则，这个规则见 ethereum/EIPs#55
但是网上提供的解决方案一般是使用JS库中的转换函数，在智能合约中无法直接解决，好在，web3提供了一个在线API接口，可以调用其checkAddressChecksum函数对地址进行转换，然后将转换后的结果直接用于合约代码。
7. Gas limit问题
在搭建的以太坊私链上进行智能合约部署时，出现了以下问题


1
2


INFO [03-21|13:50:11.690] Served eth_sendTransaction               reqid=24 t=684.186µs    err=&#34;exceeds block gas limit&#34;
Error: exceeds block gas limit undefined

出现该错误的原因如错误描述，是当前合约所需的gas超过了区块的最大gas。这可能与参数gasLimit有关。在创世区块的配置文件中，我们使用了默认的配置值，为0x2fefd8，转换为10进制即3141592。
注：在线转换工具"><meta property="og:type" content="article"><meta property="og:url" content="https://shuzang.github.io/2020/summary-of-smart-contract-knowledge-points/"><meta property="og:image" content="https://shuzang.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-04T00:00:00+00:00"><meta property="article:modified_time" content="2020-05-04T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shuzang.github.io/logo.png"><meta name=twitter:title content="智能合约知识点总结"><meta name=twitter:description content="项目进行过程中知识点的总结
1. 字符串比较
翻译自：Fravoll-String Equality Comparison
比较两个给定字符串是否相等，是 Solidity 编程中最常见的一种情况，但语言本身并没有提供内置函数用于字符串比较，本文介绍两种可用方法并分析 Gas 消耗情况。
1.1 StringUtils 库
第一种方法是使用 Ethereum 基金会提供的 StringUtils 库，它对每个字符进行成对比较，如果有一个字符对不匹配，则返回false。这种办法可以返回正确的结果，对于短字符串和字符不同发生在字符串前面的情况仅消耗少量 Gas。但是对于相等的字符串和长字符串，这种方法的 Gas 消耗较高，因为必须做很多比较才能得到正确结果。因此，字符串比较的两个可衡量的因素是字符串平均长度和正确率。
1.2 哈希函数
作者提出使用哈希函数进行比较，同时检查所提供的字符串的长度，从一开始就剔除长度不匹配的字符串。其步骤如下

检查两个字符串是否有相同长度，通过转换为 bytes 类型完成，因为 bytes 类型有内置长度函数。如果相同进入第2步，如果不相同返回结果；
使用 keccak256() 函数对两个字符串求哈希，然后比较计算得到的哈希值，从而确定是否相等。

一个示例代码如下


1
2
3
4
5
6
7
8


# 这段代码未经安全审计，使用有风险
function hashCompareWithLengthCheck(string a, string b) internal returns (bool) {
    if(bytes(a).length != bytes(b).length) {
        return false;
    } else {
        return keccak256(abi.encodePacket(a)) == keccak256(abi.encodePacket(b));
    }
}

abi.encodePacket(...) returns (bytes) 用于对给定参数执行紧打包编码，官方文档中不推荐使用 keccak256(...) 直接计算哈希，而是使用 keccak256(abi.encodePacked(...))
1.3 Gas 消耗分析
在 Remix 编写代码测试了三种不同情况的字符串比较的 Gas 消耗

比较哈希
比较每个字符，同时比较字符串长度
比较哈希，同时比较字符串长度

结果如下表所示，输入列为输入的待比较字符串，输出列的单位为 Wei



Input A
Input B
Hash
Character + Length
Hash + Length




abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
7062
1261


abcdefghijklmnopqrstuvwxyX
abcdefghijklmnopqrstuvwxyz
1225
7012
1261


Xbcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
912
1261


aXcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
1156
1261


abXdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
1225
1400
1261


abcdefghijkl
abcdefghijklmnopqrstuvwxyz
1225
690
707


a
a
1225
962
1261


ab
ab
1225
1156
1261


abc
abc
1225
1450
1261



可以看出，哈希+字符串长度 的比较方式 Gas 消耗更加稳定，这种方式比较高效。
2. 可见性与Getter函数
转自：Solidity 0.6.4 中文文档
Solidity 有两种函数调用：内部调用（Internal Function Calls）和外部调用（External Function Calls）。前者指直接或递归地调用合约内部函数，不会产生实际的 EVM 调用，因此也被称为「消息嗲用」，后者指从合约外部调用合约中的函数，会产生一个 EVM 调用。
2.1 可见性
因此，函数和状态变量有四种可见性。函数可以指定为 external，public，internal 或 private，对于状态变量， 默认是 internal 且不能设置为 external。

external：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f()可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.
public：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。
internal：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。
private：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。


合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。

可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间，如下例


1
2
3
4
5
6
7


pragma solidity  >=0.4.16 <0.7.0;

contract C {
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;
}

在下面的例子中，D 可以调用 c.getData（） 来获取状态存储中 data 的值，但不能调用 f 。 合约 E 继承自 C ，因此可以调用 compute。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28


pragma solidity >=0.4.0 <0.7.0;

contract C {
    uint private data;

    function f(uint a) private returns(uint b) { return a + 1; }
    function setData(uint a) public { data = a; }
    function getData() public returns(uint) { return data; }
    function compute(uint a, uint b) internal returns (uint) { return a+b; }
}

// 下面代码编译错误
contract D {
    function readData() public {
        C c = new C();
        uint local = c.f(7); // 错误：成员 `f` 不可见
        c.setData(3);
        local = c.getData();
        local = c.compute(3, 5); // 错误：成员 `compute` 不可见
    }
}

contract E is C {
    function g() public {
        C c = new C();
        uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员）
    }
}

2.2 Getter 函数
编译器自动为所有 public 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 data 的函数， 该函数没有参数，返回值是一个 uint 类型，即状态变量 data 的值。 状态变量的初始化可以在声明时完成。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


pragma solidity  >=0.4.0 <0.7.0;

contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public {
        uint local = c.data();
    }
}

getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果使用外部访问（即用 this. ），它被认作为一个函数。


1
2
3
4
5
6
7
8
9


pragma solidity ^0.4.0 <0.7.0;

contract C {
    uint public data;
    function x() public {
        data = 3; // 内部访问
        uint val = this.data(); // 外部访问
    }
}

如果你有一个数组类型的 public 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 data(0) 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18


pragma solidity >=0.4.0 <0.7.0;

contract arrayExample {
  // public state variable
  uint[] public myArray;

  // 指定生成的Getter 函数
  /*
  function myArray(uint i) public view returns (uint) {
      return myArray[i];
  }
  */

  // 返回整个数组
  function getArray() public view returns (uint[] memory) {
      return myArray;
  }
}

现在可以使用 getArray() 获得整个数组，而 myArray(i) 是返回单个元素。
下一个例子稍微复杂一些：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10


pragma solidity ^0.4.0 <0.7.0;

contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}

这将会生成以下形式的函数


1
2
3
4


function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) {
    a = data[arg1][arg2][arg3].a;
    b = data[arg1][arg2][arg3].b;
}

请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。
3. 合约间调用
之前的实验合约间的调用没有成功，这次就仔细地研究一下合约间地调用机制。分为两种情况

调用者和被调用者在一个sol文件中
调用者和被调用者在不同的sol文件中

本文提到的合约调用方法的实质是抽象合约的使用。
3.1 同sol文件的智能合约调用
下面的智能合约中，Main和Add两个合约定义在一个Main.sol文件中，可以同时编译，然后逐个部署。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20


pragma solidity ^0.5.0;


contract Main {
  Add add;
  
  constructor(address _m) public {
     add = Add(_m);
  }
  
  function Addnumber() public view returns (uint) {
    return add.add5(10);
  }
}

contract Add {
  function add5(uint s) public pure returns (uint){
      return 5+s;
  }
}

以使用Remix为例，点击编译按钮编译Main.sol文件，将会同时编译Main和Add两个合约。

然后首先部署Add合约，因为Main合约的部署需要Add的合约地址作为参数。切换到部署和运行选项卡，选择Add合约，点击Deploy，成功部署后，复制合约地址。

然后重新选择Main合约，填入Add合约地址作为参数，点击部署按钮。

测试合约间调用，由合约内容可知，Main合约中的Addnumber函数调用了Add合约的add5函数，传入参数为10，得到的结果应为15。展开左侧的Deployed Contracts，点击Addnumber进行调用，结果如下。

3.2 不同sol文件的智能合约调用
这一次我们测试不同sol文件的智能合约调用，来一个复杂一点的，两个合约分别是Add.sol和Main.sol。
Add.sol使用了一个结构体来定义数值，并通过映射定义查找表来寻找这个值。文件中定义了两个函数，numRegister用来向表中添加数值，addValue用来将从表中查到的指定值+5返回。之所以用这个结构是因为我们的项目里用到了，这里来测试一下可不可行。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


pragma solidity ^0.5.0;

contract Add {
    struct Num{
        uint value;
    }
    mapping(uint => Num) public lookupTable;
    
    function numRegister(uint key, uint _value) public {
        lookupTable[key].value = _value;
    }
    
    function addValue(uint key) public view returns (uint) {
        return lookupTable[key].value + 5;
    }

}

Main.sol没有多大变化


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17


pragma solidity ^0.5.0;

contract Main {
  Add add;
  
  constructor(address _m) public {
     add = Add(_m);
  }
  
  function Addnumber() public view returns (uint) {
    return add.addValue(5);
  }
}

contract Add {
      function addValue(uint key) public view returns (uint);
}

仍然是先编译部署Add合约，部署后调用numRegister函数写入数值5，并调用addValue函数测试返回。

接着编译部署Main合约，复制Add合约地址作为初始化参数，部署后调用Addnumber函数测试

3.3 总结
合约内的调用方法是相同的，都要先实例化，然后传入被调合约地址，接着才能调用。而写在不同sol文件中时，需要额外声明被调合约的抽象合约，有些文章中说使用call，callcode或delegatecall，但并不建议，因为这三个函数都是非常底层的函数，破坏了类型的安全，只能作为最后的手段使用。
详细的解释参考了StackExchange-Calling function from deployed contract
4. 函数修饰词pure和view
转自深入理解Solidity-函数
这两个函数修饰词的作用是告诉编译器函数是否会读取/修改状态，view 表示保证不修改状态，pure 表示保证不读取也不修改状态。Solidity v0.4.17 之前没有这两个修饰词，而是使用 constant 关键字，和 view 的含义相同，不过在 v0.5.0 之后被移除，现在只能使用这两个 view 和 pure。
4.1 view 视图函数
Getter 方法会被自动标记为 view，除此之外，一个 view 修饰的例子如下


1
2
3
4
5
6
7


pragma solidity  >=0.5.0 <0.7.0;

contract C {
    function f(uint a, uint b) public view returns (uint) {
        return a * (b + 42) + now;
    }
}

view 保证函数不修改状态，以下操作会被认为是修改状态

修改状态变量。
产生事件。
创建其它合约。
使用 selfdestruct。
通过调用发送以太币。
调用任何没有标记为 view 或者 pure 的函数。
使用低级调用。
使用包含特定操作码的内联汇编。

4.2 pure 纯函数
pure 保证不读取也不修改状态，不修改的定义上面已经提到，下面的操作被认为是读取状态

读取状态变量。
访问 address(this).balance 或者 .balance。
访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。
调用任何未标记为 pure 的函数。
使用包含某些操作码的内联汇编。

一个 pure 修饰的例子如下


1
2
3
4
5
6
7


pragma solidity >=0.5.0 <0.7.0;

contract C {
    function f(uint a, uint b) public pure returns (uint) {
        return a * (b + 42);
    }
}

5. 浮点数处理
首先声明，Solidity 中支持浮点数定义，但无法赋值和进行计算。文档中对其描述是「目前还不完全支持」，虽然这意味着以后可能会完全支持，但等不及了，下面记录几个可参考的资料。

来自 ethereum stackexchange 中的回答，介绍了一些可用的库；
ABDK Math Quad，包含两个合约库，一个支持定点数，一个支持浮点数；
Mikhail Vladimirov 的 Math in Solidity 系列文章，介绍如何在 Solidity 中处理各种数学运算，写的非常棒。

6. 地址类型
在智能合约中显式传入地址类型时，可能会出现如下错误

Address checksum
This looks like an address but has an invalid checksum. If this is not used as an address, please prepend &lsquo;00&rsquo;.

关于该问题的一个讨论见 https://github.com/ethereum/EIPs/issues/55
这是因为合约中现在使用地址类型必须做一个转换，不是简单的全部大写字母或小写字母，而是遵循一定的规则，这个规则见 ethereum/EIPs#55
但是网上提供的解决方案一般是使用JS库中的转换函数，在智能合约中无法直接解决，好在，web3提供了一个在线API接口，可以调用其checkAddressChecksum函数对地址进行转换，然后将转换后的结果直接用于合约代码。
7. Gas limit问题
在搭建的以太坊私链上进行智能合约部署时，出现了以下问题


1
2


INFO [03-21|13:50:11.690] Served eth_sendTransaction               reqid=24 t=684.186µs    err=&#34;exceeds block gas limit&#34;
Error: exceeds block gas limit undefined

出现该错误的原因如错误描述，是当前合约所需的gas超过了区块的最大gas。这可能与参数gasLimit有关。在创世区块的配置文件中，我们使用了默认的配置值，为0x2fefd8，转换为10进制即3141592。
注：在线转换工具"><meta name=application-name content="Shuzang's Blog"><meta name=apple-mobile-web-app-title content="Shuzang's Blog"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://shuzang.github.io/2020/summary-of-smart-contract-knowledge-points/><link rel=prev href=https://shuzang.github.io/2020/algorithm-greedu/><link rel=next href=https://shuzang.github.io/2020/algorithm-backtracking/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.2.0/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.2.0/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"智能合约知识点总结","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2020\/summary-of-smart-contract-knowledge-points\/"},"genre":"posts","keywords":"区块链","wordcount":5016,"url":"https:\/\/shuzang.github.io\/2020\/summary-of-smart-contract-knowledge-points\/","datePublished":"2020-05-04T00:00:00+00:00","dateModified":"2020-05-04T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"作者"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-title="Shuzang's Blog" data-alt="Shuzang's Blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collection/><i class="fa-solid fa-bookmark fa-fw fa-sm" aria-hidden=true></i> 集子</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collection/><i class="fa-solid fa-bookmark fa-fw fa-sm" aria-hidden=true></i> 集子</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>智能合约知识点总结</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i></span></span>
<span class=post-category>收录于 <a href=/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 研究生的区块链学习之路</a></span></div><div class=post-meta-line><span title="发布于 2020-05-04 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2020-05-04>2020-05-04</time></span>&nbsp;<span title="更新于 2020-05-04 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2020-05-04>2020-05-04</time></span>&nbsp;<span title="5016 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5100 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 11 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-字符串比较>1. 字符串比较</a><ul><li><a href=#11-stringutils-库>1.1 StringUtils 库</a></li><li><a href=#12-哈希函数>1.2 哈希函数</a></li><li><a href=#13-gas-消耗分析>1.3 Gas 消耗分析</a></li></ul></li><li><a href=#2-可见性与getter函数>2. 可见性与Getter函数</a><ul><li><a href=#21-可见性>2.1 可见性</a></li><li><a href=#22-getter-函数>2.2 Getter 函数</a></li></ul></li><li><a href=#3-合约间调用>3. 合约间调用</a><ul><li><a href=#31-同sol文件的智能合约调用>3.1 同sol文件的智能合约调用</a></li><li><a href=#32-不同sol文件的智能合约调用>3.2 不同sol文件的智能合约调用</a></li><li><a href=#33-总结>3.3 总结</a></li></ul></li><li><a href=#4-函数修饰词pure和view>4. 函数修饰词pure和view</a><ul><li><a href=#41-view-视图函数>4.1 view 视图函数</a></li><li><a href=#42-pure-纯函数>4.2 pure 纯函数</a></li></ul></li><li><a href=#5-浮点数处理>5. 浮点数处理</a></li><li><a href=#6-地址类型>6. 地址类型</a></li><li><a href=#7-gas-limit问题>7. Gas limit问题</a><ul><li><a href=#原因查找>原因查找</a></li><li><a href=#解决办法>解决办法</a></li></ul></li></ul></nav></div></div><div class=content id=content><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2020-05-04，文中内容可能已过时。</div></div></div><p>项目进行过程中知识点的总结</p><h2 id=1-字符串比较>1. 字符串比较</h2><p>翻译自：<a href=https://fravoll.github.io/solidity-patterns/string_equality_comparison.html target=_blank rel="external nofollow noopener noreferrer">Fravoll-String Equality Comparison</a></p><p>比较两个给定字符串是否相等，是 Solidity 编程中最常见的一种情况，但语言本身并没有提供内置函数用于字符串比较，本文介绍两种可用方法并分析 Gas 消耗情况。</p><h3 id=11-stringutils-库>1.1 StringUtils 库</h3><p>第一种方法是使用 Ethereum 基金会提供的 StringUtils 库，它对每个字符进行成对比较，如果有一个字符对不匹配，则返回false。这种办法可以返回正确的结果，对于短字符串和字符不同发生在字符串前面的情况仅消耗少量 Gas。但是对于相等的字符串和长字符串，这种方法的 Gas 消耗较高，因为必须做很多比较才能得到正确结果。因此，字符串比较的两个可衡量的因素是字符串平均长度和正确率。</p><h3 id=12-哈希函数>1.2 哈希函数</h3><p>作者提出使用哈希函数进行比较，同时检查所提供的字符串的长度，从一开始就剔除长度不匹配的字符串。其步骤如下</p><ol><li>检查两个字符串是否有相同长度，通过转换为 <code>bytes</code> 类型完成，因为 <code>bytes</code> 类型有内置长度函数。如果相同进入第2步，如果不相同返回结果；</li><li>使用 <code>keccak256()</code> 函数对两个字符串求哈希，然后比较计算得到的哈希值，从而确定是否相等。</li></ol><p>一个示例代码如下</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=err>#</span> <span class=err>这段代码未经安全审计，使用有风险</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nf>hashCompareWithLengthCheck</span><span class=p>(</span><span class=kt>string</span> <span class=n>a</span><span class=p>,</span> <span class=kt>string</span> <span class=n>b</span><span class=p>)</span> <span class=k>internal</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=kt>bytes</span><span class=p>(</span><span class=n>a</span><span class=p>).</span><span class=n>length</span> <span class=o>!=</span> <span class=kt>bytes</span><span class=p>(</span><span class=n>b</span><span class=p>).</span><span class=n>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>keccak256</span><span class=p>(</span><span class=nb>abi</span><span class=p>.</span><span class=n>encodePacket</span><span class=p>(</span><span class=n>a</span><span class=p>))</span> <span class=o>==</span> <span class=nb>keccak256</span><span class=p>(</span><span class=nb>abi</span><span class=p>.</span><span class=n>encodePacket</span><span class=p>(</span><span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><code>abi.encodePacket(...) returns (bytes)</code> 用于对给定参数执行<a href=https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html#abi-packed-mode target=_blank rel="external nofollow noopener noreferrer">紧打包编码</a>，官方文档中不推荐使用 <code>keccak256(...)</code> 直接计算哈希，而是使用 <code>keccak256(abi.encodePacked(...))</code></p><h3 id=13-gas-消耗分析>1.3 Gas 消耗分析</h3><p>在 Remix 编写代码测试了三种不同情况的字符串比较的 Gas 消耗</p><ol><li>比较哈希</li><li>比较每个字符，同时比较字符串长度</li><li>比较哈希，同时比较字符串长度</li></ol><p>结果如下表所示，输入列为输入的待比较字符串，输出列的单位为 Wei</p><table><thead><tr><th style=text-align:left>Input A</th><th style=text-align:left>Input B</th><th style=text-align:right>Hash</th><th style=text-align:right>Character + Length</th><th style=text-align:right>Hash + Length</th></tr></thead><tbody><tr><td style=text-align:left>abcdefghijklmnopqrstuvwxyz</td><td style=text-align:left>abcdefghijklmnopqrstuvwxyz</td><td style=text-align:right>1225</td><td style=text-align:right>7062</td><td style=text-align:right>1261</td></tr><tr><td style=text-align:left>abcdefghijklmnopqrstuvwxy<strong>X</strong></td><td style=text-align:left>abcdefghijklmnopqrstuvwxyz</td><td style=text-align:right>1225</td><td style=text-align:right>7012</td><td style=text-align:right>1261</td></tr><tr><td style=text-align:left><strong>X</strong>bcdefghijklmnopqrstuvwxyz</td><td style=text-align:left>abcdefghijklmnopqrstuvwxyz</td><td style=text-align:right>1225</td><td style=text-align:right>912</td><td style=text-align:right>1261</td></tr><tr><td style=text-align:left>a<strong>X</strong>cdefghijklmnopqrstuvwxyz</td><td style=text-align:left>abcdefghijklmnopqrstuvwxyz</td><td style=text-align:right>1225</td><td style=text-align:right>1156</td><td style=text-align:right>1261</td></tr><tr><td style=text-align:left>ab<strong>X</strong>defghijklmnopqrstuvwxyz</td><td style=text-align:left>abcdefghijklmnopqrstuvwxyz</td><td style=text-align:right>1225</td><td style=text-align:right>1400</td><td style=text-align:right>1261</td></tr><tr><td style=text-align:left>abcdefghijkl</td><td style=text-align:left>abcdefghijklmnopqrstuvwxyz</td><td style=text-align:right>1225</td><td style=text-align:right>690</td><td style=text-align:right>707</td></tr><tr><td style=text-align:left>a</td><td style=text-align:left>a</td><td style=text-align:right>1225</td><td style=text-align:right>962</td><td style=text-align:right>1261</td></tr><tr><td style=text-align:left>ab</td><td style=text-align:left>ab</td><td style=text-align:right>1225</td><td style=text-align:right>1156</td><td style=text-align:right>1261</td></tr><tr><td style=text-align:left>abc</td><td style=text-align:left>abc</td><td style=text-align:right>1225</td><td style=text-align:right>1450</td><td style=text-align:right>1261</td></tr></tbody></table><p>可以看出，哈希+字符串长度 的比较方式 Gas 消耗更加稳定，这种方式比较高效。</p><h2 id=2-可见性与getter函数>2. 可见性与Getter函数</h2><p>转自：<a href=https://learnblockchain.cn/docs/solidity/contracts.html#getter target=_blank rel="external nofollow noopener noreferrer">Solidity 0.6.4 中文文档</a></p><p>Solidity 有两种函数调用：内部调用（Internal Function Calls）和外部调用（External Function Calls）。前者指直接或递归地调用合约内部函数，不会产生实际的 EVM 调用，因此也被称为「消息嗲用」，后者指从合约外部调用合约中的函数，会产生一个 EVM 调用。</p><h3 id=21-可见性>2.1 可见性</h3><p>因此，函数和状态变量有四种可见性。函数可以指定为 <code>external</code>，<code>public</code>，<code>internal</code> 或 <code>private</code>，对于状态变量， 默认是 <code>internal</code> 且不能设置为 <code>external</code>。</p><ul><li><code>external</code>：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 <code>f</code> 不能从内部调用（即 <code>f</code> 不起作用，但 <code>this.f()</code>可以）。 当收到大量数据的时候，外部函数有时候会更有效率，因为数据不会从calldata复制到内存.</li><li><code>public</code>：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于 public 状态变量， 会自动生成一个 getter 函数（见下面）。</li><li><code>internal</code>：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 <code>this</code> 调用。</li><li><code>private</code>：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</li></ul><blockquote><p>合约中的所有内容对外部观察者都是可见的。设置一些 <code>private</code> 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。</p></blockquote><p>可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间，如下例</p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span>  <span class=o>&gt;=</span><span class=mi>0</span><span class=p>.</span><span class=mi>4</span><span class=p>.</span><span class=mi>16</span> <span class=o>&lt;</span><span class=mi>0</span><span class=p>.</span><span class=mi>7</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>f</span><span class=p>(</span><span class=kt>uint</span> <span class=n>a</span><span class=p>)</span> <span class=k>private</span> <span class=k>pure</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>setData</span><span class=p>(</span><span class=kt>uint</span> <span class=n>a</span><span class=p>)</span> <span class=k>internal</span> <span class=p>{</span> <span class=nb>data</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=k>public</span> <span class=nb>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>在下面的例子中，<code>D</code> 可以调用 <code>c.getData（）</code> 来获取状态存储中 <code>data</code> 的值，但不能调用 <code>f</code> 。 合约 <code>E</code> 继承自 <code>C</code> ，因此可以调用 <code>compute</code>。</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span> <span class=o>&gt;=</span><span class=mi>0</span><span class=p>.</span><span class=mi>4</span><span class=p>.</span><span class=mi>0</span> <span class=o>&lt;</span><span class=mi>0</span><span class=p>.</span><span class=mi>7</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=k>private</span> <span class=nb>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>f</span><span class=p>(</span><span class=kt>uint</span> <span class=n>a</span><span class=p>)</span> <span class=k>private</span> <span class=k>returns</span><span class=p>(</span><span class=kt>uint</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>setData</span><span class=p>(</span><span class=kt>uint</span> <span class=n>a</span><span class=p>)</span> <span class=k>public</span> <span class=p>{</span> <span class=nb>data</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>getData</span><span class=p>()</span> <span class=k>public</span> <span class=k>returns</span><span class=p>(</span><span class=kt>uint</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>data</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>compute</span><span class=p>(</span><span class=kt>uint</span> <span class=n>a</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>b</span><span class=p>)</span> <span class=k>internal</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 下面代码编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>contract</span> <span class=nc>D</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>readData</span><span class=p>()</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>C</span> <span class=n>c</span> <span class=o>=</span> <span class=k>new</span> <span class=n>C</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint</span> <span class=n>local</span> <span class=o>=</span> <span class=n>c</span><span class=p>.</span><span class=n>f</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span> <span class=c1>// 错误：成员 `f` 不可见
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>c</span><span class=p>.</span><span class=n>setData</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>local</span> <span class=o>=</span> <span class=n>c</span><span class=p>.</span><span class=n>getData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>local</span> <span class=o>=</span> <span class=n>c</span><span class=p>.</span><span class=n>compute</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span> <span class=c1>// 错误：成员 `compute` 不可见
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>E</span> <span class=k>is</span> <span class=n>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>g</span><span class=p>()</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>C</span> <span class=n>c</span> <span class=o>=</span> <span class=k>new</span> <span class=n>C</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint</span> <span class=n>val</span> <span class=o>=</span> <span class=n>compute</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span> <span class=c1>// 访问内部成员（从继承合约访问父合约成员）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=22-getter-函数>2.2 Getter 函数</h3><p>编译器自动为所有 <strong>public</strong> 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 <code>data</code> 的函数， 该函数没有参数，返回值是一个 <code>uint</code> 类型，即状态变量 <code>data</code> 的值。 状态变量的初始化可以在声明时完成。</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span>  <span class=o>&gt;=</span><span class=mi>0</span><span class=p>.</span><span class=mi>4</span><span class=p>.</span><span class=mi>0</span> <span class=o>&lt;</span><span class=mi>0</span><span class=p>.</span><span class=mi>7</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=k>public</span> <span class=nb>data</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>Caller</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>C</span> <span class=n>c</span> <span class=o>=</span> <span class=k>new</span> <span class=n>C</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>f</span><span class=p>()</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint</span> <span class=n>local</span> <span class=o>=</span> <span class=n>c</span><span class=p>.</span><span class=nb>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>getter 函数具有外部（external）可见性。如果在内部访问 getter（即没有 <code>this.</code> ），它被认为一个状态变量。 如果使用外部访问（即用 <code>this.</code> ），它被认作为一个函数。</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span> <span class=o>^</span><span class=mi>0</span><span class=p>.</span><span class=mi>4</span><span class=p>.</span><span class=mi>0</span> <span class=o>&lt;</span><span class=mi>0</span><span class=p>.</span><span class=mi>7</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint</span> <span class=k>public</span> <span class=nb>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>x</span><span class=p>()</span> <span class=k>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>data</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// 内部访问
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>uint</span> <span class=n>val</span> <span class=o>=</span> <span class=nb>this</span><span class=p>.</span><span class=nb>data</span><span class=p>();</span> <span class=c1>// 外部访问
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>如果你有一个数组类型的 <code>public</code> 状态变量，那么你只能通过生成的 getter 函数访问数组的单个元素。 这个机制以避免返回整个数组时的高成本gas。 可以使用如 <code>data(0)</code> 用于指定参数要返回的单个元素。 如果要在一次调用中返回整个数组，则需要写一个函数，例如：</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span> <span class=o>&gt;=</span><span class=mi>0</span><span class=p>.</span><span class=mi>4</span><span class=p>.</span><span class=mi>0</span> <span class=o>&lt;</span><span class=mi>0</span><span class=p>.</span><span class=mi>7</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>arrayExample</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// public state variable
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint</span><span class=p>[]</span> <span class=k>public</span> <span class=n>myArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 指定生成的Getter 函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  function myArray(uint i) public view returns (uint) {
</span></span></span><span class=line><span class=cl><span class=cm>      return myArray[i];
</span></span></span><span class=line><span class=cl><span class=cm>  }
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 返回整个数组
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>function</span> <span class=nf>getArray</span><span class=p>()</span> <span class=k>public</span> <span class=k>view</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint</span><span class=p>[]</span> <span class=k>memory</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>myArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>现在可以使用 <code>getArray()</code> 获得整个数组，而 <code>myArray(i)</code> 是返回单个元素。</p><p>下一个例子稍微复杂一些：</p><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span> <span class=o>^</span><span class=mi>0</span><span class=p>.</span><span class=mi>4</span><span class=p>.</span><span class=mi>0</span> <span class=o>&lt;</span><span class=mi>0</span><span class=p>.</span><span class=mi>7</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>Complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>struct</span> <span class=nc>Data</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bytes3</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>mapping</span> <span class=p>(</span><span class=kt>uint</span> <span class=o>=&gt;</span> <span class=kt>uint</span><span class=p>)</span> <span class=n>map</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>mapping</span> <span class=p>(</span><span class=kt>uint</span> <span class=o>=&gt;</span> <span class=kd>mapping</span><span class=p>(</span><span class=kt>bool</span> <span class=o>=&gt;</span> <span class=n>Data</span><span class=p>[]))</span> <span class=k>public</span> <span class=nb>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这将会生成以下形式的函数</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=kd>function</span> <span class=nf>data</span><span class=p>(</span><span class=kt>uint</span> <span class=n>arg1</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>arg2</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>arg3</span><span class=p>)</span> <span class=k>public</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint</span> <span class=n>a</span><span class=p>,</span> <span class=kt>bytes3</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=nb>data</span><span class=p>[</span><span class=n>arg1</span><span class=p>][</span><span class=n>arg2</span><span class=p>][</span><span class=n>arg3</span><span class=p>].</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=nb>data</span><span class=p>[</span><span class=n>arg1</span><span class=p>][</span><span class=n>arg2</span><span class=p>][</span><span class=n>arg3</span><span class=p>].</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。</p><h2 id=3-合约间调用>3. 合约间调用</h2><p>之前的实验合约间的调用没有成功，这次就仔细地研究一下合约间地调用机制。分为两种情况</p><ol><li>调用者和被调用者在一个sol文件中</li><li>调用者和被调用者在不同的sol文件中</li></ol><p>本文提到的合约调用方法的实质是抽象合约的使用。</p><h3 id=31-同sol文件的智能合约调用>3.1 同sol文件的智能合约调用</h3><p>下面的智能合约中，Main和Add两个合约定义在一个Main.sol文件中，可以同时编译，然后逐个部署。</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>pragma</span> <span class=nx>solidity</span> <span class=o>^</span><span class=mf>0.5</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>contract</span> <span class=nx>Main</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Add</span> <span class=nx>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>(</span><span class=nx>address</span> <span class=nx>_m</span><span class=p>)</span> <span class=kr>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>add</span> <span class=o>=</span> <span class=nx>Add</span><span class=p>(</span><span class=nx>_m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>Addnumber</span><span class=p>()</span> <span class=kr>public</span> <span class=nx>view</span> <span class=nx>returns</span> <span class=p>(</span><span class=nx>uint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>add</span><span class=p>.</span><span class=nx>add5</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>contract</span> <span class=nx>Add</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>add5</span><span class=p>(</span><span class=nx>uint</span> <span class=nx>s</span><span class=p>)</span> <span class=kr>public</span> <span class=nx>pure</span> <span class=nx>returns</span> <span class=p>(</span><span class=nx>uint</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>5</span><span class=o>+</span><span class=nx>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>以使用Remix为例，点击编译按钮编译Main.sol文件，将会同时编译Main和Add两个合约。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472178-e6294d00-025a-11ea-8b4b-41a53b471c18.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472178-e6294d00-025a-11ea-8b4b-41a53b471c18.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472178-e6294d00-025a-11ea-8b4b-41a53b471c18.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472178-e6294d00-025a-11ea-8b4b-41a53b471c18.png?size=large 2x" sizes=auto data-title=编译 data-alt=编译 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>然后首先部署Add合约，因为Main合约的部署需要Add的合约地址作为参数。切换到部署和运行选项卡，选择Add合约，点击<code>Deploy</code>，成功部署后，复制合约地址。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472256-0e18b080-025b-11ea-9a24-e324c82cd7b5.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472256-0e18b080-025b-11ea-9a24-e324c82cd7b5.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472256-0e18b080-025b-11ea-9a24-e324c82cd7b5.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472256-0e18b080-025b-11ea-9a24-e324c82cd7b5.png?size=large 2x" sizes=auto data-title="deploy simple Add" data-alt="deploy simple Add" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>然后重新选择Main合约，填入Add合约地址作为参数，点击部署按钮。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472285-1a047280-025b-11ea-8bb5-a1fb5c65574e.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472285-1a047280-025b-11ea-8bb5-a1fb5c65574e.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472285-1a047280-025b-11ea-8bb5-a1fb5c65574e.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472285-1a047280-025b-11ea-8bb5-a1fb5c65574e.png?size=large 2x" sizes=auto data-title="deploy simple Main" data-alt="deploy simple Main" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>测试合约间调用，由合约内容可知，Main合约中的Addnumber函数调用了Add合约的add5函数，传入参数为10，得到的结果应为15。展开左侧的<code>Deployed Contracts</code>，点击Addnumber进行调用，结果如下。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472220-f5a89600-025a-11ea-9d2a-b39c8e39a810.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472220-f5a89600-025a-11ea-9d2a-b39c8e39a810.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472220-f5a89600-025a-11ea-9d2a-b39c8e39a810.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472220-f5a89600-025a-11ea-9d2a-b39c8e39a810.png?size=large 2x" sizes=auto data-title="call test" data-alt="call test" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h3 id=32-不同sol文件的智能合约调用>3.2 不同sol文件的智能合约调用</h3><p>这一次我们测试不同sol文件的智能合约调用，来一个复杂一点的，两个合约分别是Add.sol和Main.sol。</p><p>Add.sol使用了一个结构体来定义数值，并通过映射定义查找表来寻找这个值。文件中定义了两个函数，numRegister用来向表中添加数值，addValue用来将从表中查到的指定值+5返回。之所以用这个结构是因为我们的项目里用到了，这里来测试一下可不可行。</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>pragma</span> <span class=nx>solidity</span> <span class=o>^</span><span class=mf>0.5</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>contract</span> <span class=nx>Add</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>struct</span> <span class=nx>Num</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>uint</span> <span class=nx>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>mapping</span><span class=p>(</span><span class=nx>uint</span> <span class=p>=&gt;</span> <span class=nx>Num</span><span class=p>)</span> <span class=kr>public</span> <span class=nx>lookupTable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>numRegister</span><span class=p>(</span><span class=nx>uint</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>uint</span> <span class=nx>_value</span><span class=p>)</span> <span class=kr>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>lookupTable</span><span class=p>[</span><span class=nx>key</span><span class=p>].</span><span class=nx>value</span> <span class=o>=</span> <span class=nx>_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nx>addValue</span><span class=p>(</span><span class=nx>uint</span> <span class=nx>key</span><span class=p>)</span> <span class=kr>public</span> <span class=nx>view</span> <span class=nx>returns</span> <span class=p>(</span><span class=nx>uint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>lookupTable</span><span class=p>[</span><span class=nx>key</span><span class=p>].</span><span class=nx>value</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>Main.sol没有多大变化</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>pragma</span> <span class=nx>solidity</span> <span class=o>^</span><span class=mf>0.5</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>contract</span> <span class=nx>Main</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Add</span> <span class=nx>add</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>(</span><span class=nx>address</span> <span class=nx>_m</span><span class=p>)</span> <span class=kr>public</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>add</span> <span class=o>=</span> <span class=nx>Add</span><span class=p>(</span><span class=nx>_m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>Addnumber</span><span class=p>()</span> <span class=kr>public</span> <span class=nx>view</span> <span class=nx>returns</span> <span class=p>(</span><span class=nx>uint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>add</span><span class=p>.</span><span class=nx>addValue</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>contract</span> <span class=nx>Add</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kd>function</span> <span class=nx>addValue</span><span class=p>(</span><span class=nx>uint</span> <span class=nx>key</span><span class=p>)</span> <span class=kr>public</span> <span class=nx>view</span> <span class=nx>returns</span> <span class=p>(</span><span class=nx>uint</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>仍然是先编译部署Add合约，部署后调用numRegister函数写入数值5，并调用addValue函数测试返回。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472316-2d174280-025b-11ea-96a6-51af8dd4fd4c.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472316-2d174280-025b-11ea-96a6-51af8dd4fd4c.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472316-2d174280-025b-11ea-96a6-51af8dd4fd4c.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472316-2d174280-025b-11ea-96a6-51af8dd4fd4c.png?size=large 2x" sizes=auto data-title="deploy comlex Add" data-alt="deploy comlex Add" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>接着编译部署Main合约，复制Add合约地址作为初始化参数，部署后调用Addnumber函数测试</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472331-399b9b00-025b-11ea-933f-8c03ff95c55a.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472331-399b9b00-025b-11ea-933f-8c03ff95c55a.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472331-399b9b00-025b-11ea-933f-8c03ff95c55a.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/YJS_20191108_68472331-399b9b00-025b-11ea-933f-8c03ff95c55a.png?size=large 2x" sizes=auto data-title="deploy comlex Main" data-alt="deploy comlex Main" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h3 id=33-总结>3.3 总结</h3><p>合约内的调用方法是相同的，都要先实例化，然后传入被调合约地址，接着才能调用。而写在不同sol文件中时，需要额外声明被调合约的抽象合约，有些文章中说使用<code>call</code>，<code>callcode</code>或<code>delegatecall</code>，但并不建议，因为这三个函数都是非常底层的函数，破坏了类型的安全，只能作为最后的手段使用。</p><p>详细的解释参考了<a href=https://ethereum.stackexchange.com/questions/9733/calling-function-from-deployed-contract target=_blank rel="external nofollow noopener noreferrer">StackExchange-Calling function from deployed contract</a></p><h2 id=4-函数修饰词pure和view>4. 函数修饰词pure和view</h2><p>转自<a href=https://learnblockchain.cn/docs/solidity/contracts.html#view target=_blank rel="external nofollow noopener noreferrer">深入理解Solidity-函数</a></p><p>这两个函数修饰词的作用是告诉编译器函数是否会读取/修改状态，view 表示保证不修改状态，pure 表示保证不读取也不修改状态。Solidity v0.4.17 之前没有这两个修饰词，而是使用 constant 关键字，和 view 的含义相同，不过在 v0.5.0 之后被移除，现在只能使用这两个 view 和 pure。</p><h3 id=41-view-视图函数>4.1 view 视图函数</h3><p>Getter 方法会被自动标记为 <code>view</code>，除此之外，一个 view 修饰的例子如下</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span>  <span class=o>&gt;=</span><span class=mi>0</span><span class=p>.</span><span class=mi>5</span><span class=p>.</span><span class=mi>0</span> <span class=o>&lt;</span><span class=mi>0</span><span class=p>.</span><span class=mi>7</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>f</span><span class=p>(</span><span class=kt>uint</span> <span class=n>a</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>b</span><span class=p>)</span> <span class=k>public</span> <span class=k>view</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=p>(</span><span class=n>b</span> <span class=o>+</span> <span class=mi>42</span><span class=p>)</span> <span class=o>+</span> <span class=nb>now</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>view 保证函数不修改状态，以下操作会被认为是修改状态</p><ol><li>修改状态变量。</li><li>产生事件。</li><li>创建其它合约。</li><li>使用 <code>selfdestruct</code>。</li><li>通过调用发送以太币。</li><li>调用任何没有标记为 <code>view</code> 或者 <code>pure</code> 的函数。</li><li>使用低级调用。</li><li>使用包含特定操作码的内联汇编。</li></ol><h3 id=42-pure-纯函数>4.2 pure 纯函数</h3><p>pure 保证不读取也不修改状态，不修改的定义上面已经提到，下面的操作被认为是读取状态</p><ol><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或者 <code>.balance</code>。</li><li>访问 <code>block</code>，<code>tx</code>， <code>msg</code> 中任意成员 （除 <code>msg.sig</code> 和 <code>msg.data</code> 之外）。</li><li>调用任何未标记为 <code>pure</code> 的函数。</li><li>使用包含某些操作码的内联汇编。</li></ol><p>一个 pure 修饰的例子如下</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-solidity data-lang=solidity><span class=line><span class=cl><span class=k>pragma solidity</span> <span class=o>&gt;=</span><span class=mi>0</span><span class=p>.</span><span class=mi>5</span><span class=p>.</span><span class=mi>0</span> <span class=o>&lt;</span><span class=mi>0</span><span class=p>.</span><span class=mi>7</span><span class=p>.</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>contract</span> <span class=nc>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>function</span> <span class=nf>f</span><span class=p>(</span><span class=kt>uint</span> <span class=n>a</span><span class=p>,</span> <span class=kt>uint</span> <span class=n>b</span><span class=p>)</span> <span class=k>public</span> <span class=k>pure</span> <span class=k>returns</span> <span class=p>(</span><span class=kt>uint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=p>(</span><span class=n>b</span> <span class=o>+</span> <span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=5-浮点数处理>5. 浮点数处理</h2><p>首先声明，Solidity 中支持浮点数定义，但无法赋值和进行计算。文档中对其描述是「目前还不完全支持」，虽然这意味着以后可能会完全支持，但等不及了，下面记录几个可参考的资料。</p><ol><li>来自 <a href=https://ethereum.stackexchange.com/questions/83785/what-fixed-or-float-point-math-libraries-are-available-in-solidity target=_blank rel="external nofollow noopener noreferrer">ethereum stackexchange</a> 中的回答，介绍了一些可用的库；</li><li><a href=https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md target=_blank rel="external nofollow noopener noreferrer">ABDK Math Quad</a>，包含两个合约库，一个支持定点数，一个支持浮点数；</li><li>Mikhail Vladimirov 的 <a href=https://medium.com/coinmonks/math-in-solidity-part-1-numbers-384c8377f26d target=_blank rel="external nofollow noopener noreferrer">Math in Solidity</a> 系列文章，介绍如何在 Solidity 中处理各种数学运算，写的非常棒。</li></ol><h2 id=6-地址类型>6. 地址类型</h2><p>在智能合约中显式传入地址类型时，可能会出现如下错误</p><blockquote><p>Address checksum</p><p>This looks like an address but has an invalid checksum. If this is not used as an address, please prepend &lsquo;00&rsquo;.</p></blockquote><p>关于该问题的一个讨论见 <a href=https://github.com/ethereum/EIPs/issues/55 target=_blank rel="external nofollow noopener noreferrer">https://github.com/ethereum/EIPs/issues/55</a></p><p>这是因为合约中现在使用地址类型必须做一个转换，不是简单的全部大写字母或小写字母，而是遵循一定的规则，这个规则见 <a href=https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md target=_blank rel="external nofollow noopener noreferrer">ethereum/EIPs#55</a></p><p>但是网上提供的解决方案一般是使用JS库中的转换函数，在智能合约中无法直接解决，好在，web3提供了一个<a href=https://web3-tools.netlify.com/ target=_blank rel="external nofollow noopener noreferrer">在线API接口</a>，可以调用其<code>checkAddressChecksum</code>函数对地址进行转换，然后将转换后的结果直接用于合约代码。</p><h2 id=7-gas-limit问题>7. Gas limit问题</h2><p>在搭建的以太坊私链上进行智能合约部署时，出现了以下问题</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>INFO</span> <span class=p>[</span><span class=mi>03</span><span class=o>-</span><span class=mi>21</span><span class=o>|</span><span class=mi>13</span><span class=o>:</span><span class=mi>50</span><span class=o>:</span><span class=mf>11.690</span><span class=p>]</span> <span class=nx>Served</span> <span class=nx>eth_sendTransaction</span>               <span class=nx>reqid</span><span class=o>=</span><span class=mi>24</span> <span class=nx>t</span><span class=o>=</span><span class=mf>684.186</span><span class=nx>µs</span>    <span class=nx>err</span><span class=o>=</span><span class=s2>&#34;exceeds block gas limit&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>Error</span><span class=o>:</span> <span class=nx>exceeds</span> <span class=nx>block</span> <span class=nx>gas</span> <span class=nx>limit</span> <span class=kc>undefined</span></span></span></code></pre></td></tr></table></div></div><p>出现该错误的原因如错误描述，是当前合约所需的gas超过了区块的最大gas。这可能与参数gasLimit有关。在创世区块的配置文件中，我们使用了默认的配置值，为<code>0x2fefd8</code>，转换为10进制即<code>3141592</code>。</p><p>注：<a href=http://tool.oschina.net/hexconvert/ target=_blank rel="external nofollow noopener noreferrer">在线转换工具</a></p><h3 id=原因查找>原因查找</h3><p>因为部署智能合约之前已经进行过挖矿，区块链中已有数个区块，我们查询目前的gasLimit值。</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=o>&gt;</span><span class=nx>eth</span><span class=p>.</span><span class=nx>getBlock</span><span class=p>(</span><span class=nx>eth</span><span class=p>.</span><span class=nx>blockNumber</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>difficulty</span><span class=o>:</span> <span class=mi>131072</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>extraData</span><span class=o>:</span> <span class=s2>&#34;0xd683010900846765746886676f312e3132856c696e7578&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>gasLimit</span><span class=o>:</span> <span class=mi>3147727</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>gasUsed</span><span class=o>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>hash</span><span class=o>:</span> <span class=s2>&#34;0x7e03472bcad02f6e85a3cdb21cfba856da58a4955dd2b6d21e3b8561446ae390&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>logsBloom</span><span class=o>:</span> <span class=s2>&#34;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>miner</span><span class=o>:</span> <span class=s2>&#34;0x79b43b2196723fff1485999aba45fda3e8b4df58&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>mixHash</span><span class=o>:</span> <span class=s2>&#34;0x10a5130f4ea573f1f1599c11b8ade9ac3feb256c0414db1a277b7b63e8343d48&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>nonce</span><span class=o>:</span> <span class=s2>&#34;0x6bba1166a347ba0f&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>number</span><span class=o>:</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>parentHash</span><span class=o>:</span> <span class=s2>&#34;0xed8c7febfc1ab5e4e388bd886be1182635e77b0047f530c93af4eb31f898bd7c&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>receiptsRoot</span><span class=o>:</span> <span class=s2>&#34;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>sha3Uncles</span><span class=o>:</span> <span class=s2>&#34;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>size</span><span class=o>:</span> <span class=mi>534</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>stateRoot</span><span class=o>:</span> <span class=s2>&#34;0x741c086895803cc3f85c8e7fb738acfb42aa03a12a03edf246b1c14055123b78&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>timestamp</span><span class=o>:</span> <span class=mi>1552396507</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>totalDifficulty</span><span class=o>:</span> <span class=mi>263168</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>transactions</span><span class=o>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>  <span class=nx>transactionsRoot</span><span class=o>:</span> <span class=s2>&#34;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>uncles</span><span class=o>:</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>发现此时区块的gasLimit值为<code>3147727</code>。</p><p>查找我们部署的合约web3代码</p><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>var</span> <span class=nx>testContract</span> <span class=o>=</span> <span class=nx>web3</span><span class=p>.</span><span class=nx>eth</span><span class=p>.</span><span class=nx>contract</span><span class=p>([{</span><span class=s2>&#34;constant&#34;</span><span class=o>:</span><span class=kc>true</span><span class=p>,</span><span class=s2>&#34;inputs&#34;</span><span class=o>:</span><span class=p>[{</span><span class=s2>&#34;name&#34;</span><span class=o>:</span><span class=s2>&#34;a&#34;</span><span class=p>,</span><span class=s2>&#34;type&#34;</span><span class=o>:</span><span class=s2>&#34;uint256&#34;</span><span class=p>}],</span><span class=s2>&#34;name&#34;</span><span class=o>:</span><span class=s2>&#34;multiply&#34;</span><span class=p>,</span><span class=s2>&#34;outputs&#34;</span><span class=o>:</span><span class=p>[{</span><span class=s2>&#34;name&#34;</span><span class=o>:</span><span class=s2>&#34;d&#34;</span><span class=p>,</span><span class=s2>&#34;type&#34;</span><span class=o>:</span><span class=s2>&#34;uint256&#34;</span><span class=p>}],</span><span class=s2>&#34;payable&#34;</span><span class=o>:</span><span class=kc>false</span><span class=p>,</span><span class=s2>&#34;stateMutability&#34;</span><span class=o>:</span><span class=s2>&#34;pure&#34;</span><span class=p>,</span><span class=s2>&#34;type&#34;</span><span class=o>:</span><span class=s2>&#34;function&#34;</span><span class=p>}]);</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>test</span> <span class=o>=</span> <span class=nx>testContract</span><span class=p>.</span><span class=k>new</span><span class=p>(</span>
</span></span><span class=line><span class=cl>   <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>from</span><span class=o>:</span> <span class=nx>web3</span><span class=p>.</span><span class=nx>eth</span><span class=p>.</span><span class=nx>accounts</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>     <span class=nx>data</span><span class=o>:</span> <span class=s1>&#39;0x6080604052348015600f57600080fd5b5060a58061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063c6888fa114602d575b600080fd5b605660048036036020811015604157600080fd5b8101908080359060200190929190505050606c565b6040518082815260200191505060405180910390f35b600060078202905091905056fea165627a7a72305820028fd57d2fec4df9170b559fe84245ed4f81bc40f3cad3c185c8035501bdb3220029&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>     <span class=nx>gas</span><span class=o>:</span> <span class=s1>&#39;4700000&#39;</span>
</span></span><span class=line><span class=cl>   <span class=p>},</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>e</span><span class=p>,</span> <span class=nx>contract</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>e</span><span class=p>,</span> <span class=nx>contract</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>contract</span><span class=p>.</span><span class=nx>address</span> <span class=o>!==</span> <span class=s1>&#39;undefined&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Contract mined! address: &#39;</span> <span class=o>+</span> <span class=nx>contract</span><span class=p>.</span><span class=nx>address</span> <span class=o>+</span> <span class=s1>&#39; transactionHash: &#39;</span> <span class=o>+</span> <span class=nx>contract</span><span class=p>.</span><span class=nx>transactionHash</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>})</span></span></span></code></pre></td></tr></table></div></div><p>发现合约所需gas为<code>4700000</code>，比gasLimit值高，所以部署失败，出现了<code>Error: exceeds block gas limit undefined</code>的错误</p><h3 id=解决办法>解决办法</h3><p>第一种解决办法是修改<code>genesis.json</code>中的gasLimit参数，设置一个更大的值。但这样做需要重新构建网络，极为繁琐。</p><p>另一种解决办法是通过geth命令的<code>--targetgaslimit</code>参数来调整gasLimit值</p><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=o>&gt;</span> <span class=o>--</span><span class=nx>targetgaslimit</span> <span class=mi>4712388</span></span></span></code></pre></td></tr></table></div></div><p>这里没有调整成功，提示原因是端口在运行，可能和docker有关，不知道怎么解决。</p><p>该问题最后是通过调整web3中的gaslimit值解决的，因为这个简单的智能合约怎么看都不像能消耗4700000gas的样子，果然查询之后发现只消耗100000左右，于是将web3代码中的gaslimit调整到120000，重新部署，果然成功。</p><p>一个关于gaslimit的解释见：<a href=https://tinycalf.github.io/2018/07/02/20180702-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%9D%97gas%E4%B8%8A%E9%99%90%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E7%A0%94%E7%A9%B6/ target=_blank rel="external nofollow noopener noreferrer">以太坊Block Gaslimit动态调整机制分析</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2020-05-04 00:00:00">更新于 2020-05-04&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/2020/summary-of-smart-contract-knowledge-points/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Pocket" data-sharer=pocket data-url=https://shuzang.github.io/2020/summary-of-smart-contract-knowledge-points/><i class="fa-brands fa-get-pocket fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://shuzang.github.io/2020/summary-of-smart-contract-knowledge-points/ data-title=智能合约知识点总结><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/ class=post-tag>区块链</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2020/algorithm-greedu/ class=post-nav-item rel=prev title=算法-贪心><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>算法-贪心</a>
<a href=/2020/algorithm-backtracking/ class=post-nav-item rel=next title=算法-回溯>算法-回溯<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/alipay.png data-title=" 支付宝" data-alt=" 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/wechatpay.png data-title=" 微信" data-alt=" 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">Hava a great day !</div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2024</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/shuzang/shuzang.github.io title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.6.1/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.2/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.2/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/fuse.js@6.6.2/dist/fuse.min.js defer></script><script src=https://unpkg.com/twemoji@14.0.2/dist/twemoji.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.2/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.2/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.2/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.2/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/js/theme.min.js defer></script></body></html>