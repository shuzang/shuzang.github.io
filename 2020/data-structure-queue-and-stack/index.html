<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>数据结构-队列与栈 - Shuzang's Blog</title><meta name=author content="Shuzang"><meta name=author-link content><meta name=description content="队列与栈是最常使用的两种数据结构，其中，队列的核心特征是先入先出，栈的核心特征是后入先出，只要符合这两个特征，就属于队列（栈），不因实现形式的不同（数组或链表）而有差别，可以根据具体情况选择使用起来更方便的实现形式。
在本文中，我们对队列与栈的核心功能，循环队列这种特殊结构，以及队列和栈的主要应用，尤其是广度优先搜索和深度优先搜索进行介绍。"><meta name=keywords content="数据结构与算法"><meta itemprop=name content="数据结构-队列与栈"><meta itemprop=description content="队列与栈是最常使用的两种数据结构，其中，队列的核心特征是先入先出，栈的核心特征是后入先出，只要符合这两个特征，就属于队列（栈），不因实现形式的不同（数组或链表）而有差别，可以根据具体情况选择使用起来更方便的实现形式。
在本文中，我们对队列与栈的核心功能，循环队列这种特殊结构，以及队列和栈的主要应用，尤其是广度优先搜索和深度优先搜索进行介绍。"><meta itemprop=datePublished content="2020-02-22T00:00:00+00:00"><meta itemprop=dateModified content="2020-06-30T00:00:00+00:00"><meta itemprop=wordCount content="4430"><meta itemprop=image content="https://shuzang.github.io/logo.png"><meta itemprop=keywords content="数据结构与算法,"><meta property="og:title" content="数据结构-队列与栈"><meta property="og:description" content="队列与栈是最常使用的两种数据结构，其中，队列的核心特征是先入先出，栈的核心特征是后入先出，只要符合这两个特征，就属于队列（栈），不因实现形式的不同（数组或链表）而有差别，可以根据具体情况选择使用起来更方便的实现形式。
在本文中，我们对队列与栈的核心功能，循环队列这种特殊结构，以及队列和栈的主要应用，尤其是广度优先搜索和深度优先搜索进行介绍。"><meta property="og:type" content="article"><meta property="og:url" content="https://shuzang.github.io/2020/data-structure-queue-and-stack/"><meta property="og:image" content="https://shuzang.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-22T00:00:00+00:00"><meta property="article:modified_time" content="2020-06-30T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shuzang.github.io/logo.png"><meta name=twitter:title content="数据结构-队列与栈"><meta name=twitter:description content="队列与栈是最常使用的两种数据结构，其中，队列的核心特征是先入先出，栈的核心特征是后入先出，只要符合这两个特征，就属于队列（栈），不因实现形式的不同（数组或链表）而有差别，可以根据具体情况选择使用起来更方便的实现形式。
在本文中，我们对队列与栈的核心功能，循环队列这种特殊结构，以及队列和栈的主要应用，尤其是广度优先搜索和深度优先搜索进行介绍。"><meta name=application-name content="Shuzang's Blog"><meta name=apple-mobile-web-app-title content="Shuzang's Blog"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://shuzang.github.io/2020/data-structure-queue-and-stack/><link rel=prev href=https://shuzang.github.io/2020/life-weekly-8/><link rel=next href=https://shuzang.github.io/2020/data-structure-tree-and-binary-tree/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"数据结构-队列与栈","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2020\/data-structure-queue-and-stack\/"},"genre":"posts","keywords":"数据结构与算法","wordcount":4430,"url":"https:\/\/shuzang.github.io\/2020\/data-structure-queue-and-stack\/","datePublished":"2020-02-22T00:00:00+00:00","dateModified":"2020-06-30T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Shuzang"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=/images/avatar.png srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes=auto data-title="Shuzang's Blog" data-alt="Shuzang's Blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collection/><i class="fa-solid fa-bookmark fa-fw fa-sm" aria-hidden=true></i> 收藏夹</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=/images/avatar.png srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes=auto data-title=/images/avatar.png data-alt=/images/avatar.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collection/><i class="fa-solid fa-bookmark fa-fw fa-sm" aria-hidden=true></i> 收藏夹</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>数据结构-队列与栈</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><img loading=lazy src=/images/avatar.png srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes=auto data-title=Shuzang data-alt=Shuzang class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Shuzang</span></span>
<span class=post-category>收录于 <a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 爱编程爱技术的孩子</a></span></div><div class=post-meta-line><span title="发布于 2020-02-22 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2020-02-22>2020-02-22</time></span>&nbsp;<span title="更新于 2020-06-30 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2020-06-30>2020-06-30</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 4430 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 9 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-队列>1. 队列</a><ul><li><a href=#11-队列实现>1.1 队列实现</a></li><li><a href=#12-利用标准库实现>1.2 利用标准库实现</a></li><li><a href=#13-循环队列>1.3 循环队列</a></li></ul></li><li><a href=#2-队列与bfs>2. 队列与BFS</a><ul><li><a href=#21-遍历>2.1 遍历</a></li><li><a href=#22-最短路径>2.2 最短路径</a></li></ul></li><li><a href=#3-栈>3. 栈</a><ul><li><a href=#31-栈实现>3.1 栈实现</a></li><li><a href=#32-内置库>3.2 内置库</a></li><li><a href=#33-例子有效括号>3.3 例子：有效括号</a></li></ul></li><li><a href=#4-栈和dfs>4. 栈和DFS</a><ul><li><a href=#41-递归隐式栈>4.1 递归（隐式栈）</a></li><li><a href=#42-显式栈>4.2 显式栈</a></li></ul></li><li><a href=#5-其它>5. 其它</a><ul><li><a href=#51-用栈实现队列>5.1 用栈实现队列</a></li><li><a href=#52-用队列实现栈>5.2 用队列实现栈</a></li></ul></li></ul></nav></div></div><div class=content id=content><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2020-06-30，文中内容可能已过时。</div></div></div><p>队列与栈是最常使用的两种数据结构，其中，队列的核心特征是先入先出，栈的核心特征是后入先出，只要符合这两个特征，就属于队列（栈），不因实现形式的不同（数组或链表）而有差别，可以根据具体情况选择使用起来更方便的实现形式。</p><p>在本文中，我们对队列与栈的核心功能，循环队列这种特殊结构，以及队列和栈的主要应用，尤其是广度优先搜索和深度优先搜索进行介绍。</p><h2 id=1-队列>1. 队列</h2><p>队列是一个先入先出的数据结构，插入时新元素只能添加到队列末尾，取出时只能获取第一个元素。也因此我们需要维护两个指针。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-05-03-at-151021-1593830694330.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-05-03-at-151021-1593830694330.png, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-05-03-at-151021-1593830694330.png 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-05-03-at-151021-1593830694330.png 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-05-03-at-151021-1593830694330.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-05-03-at-151021-1593830694330.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h3 id=11-队列实现>1.1 队列实现</h3><p>队列的实现可以使用动态数组或链表，最基本的功能包括：插入，删除，取第一个元素以及判空。由于 Golang 切片的易操作性，队列的实现即为简单，front 和 rear 指针被隐藏了起来。</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>queue</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span> <span class=c1>// 建立队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>  <span class=c1>// 插入元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queue</span> <span class=p>=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span> <span class=c1>// 删除元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>value</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=c1>// 取第一个元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>queue</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{}</span> <span class=c1>// 判空
</span></span></span></code></pre></td></tr></table></div></div><p>但当我们使用链表实现时，头尾指针是必需的，维持头和尾两个指针可以将插入和删除操作的复杂度保持在$O(1)$。</p><h3 id=12-利用标准库实现>1.2 利用标准库实现</h3><p>Go 没有提供内置的队列库，是因为可以很容易使用链表实现，只要保证新元素添加到链表尾，取元素从链表头取即可。</p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>queue</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span> <span class=c1>// 建立队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queue</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span> <span class=c1>// 入队：添加新元素到末尾
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queue</span><span class=p>.</span><span class=nf>Front</span><span class=p>().</span><span class=nx>Value</span><span class=p>.(</span><span class=nx>valueType</span><span class=p>)</span> <span class=c1>// 获取队首元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queue</span><span class=p>.</span><span class=nf>Remove</span><span class=p>(</span><span class=nx>queue</span><span class=p>.</span><span class=nf>Front</span><span class=p>()).(</span><span class=nx>valueType</span><span class=p>)</span> <span class=c1>// 出队：删除队首元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>queue</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=c1>// 队列长度
</span></span></span></code></pre></td></tr></table></div></div><h3 id=13-循环队列>1.3 循环队列</h3><p>队列对空间的浪费比较严重，这从上面的程序中可以看出，因为数组在在不停地延长，而头指针之前指向的空间都没有被释放。循环队列是解决该问题的一种办法，主要思路是重用之前被浪费的存储。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png 2x" sizes=auto data-title="插入元素 23" data-alt="插入元素 23" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>循环队列使用一段固定的空间，当尾指针指向队列尾时，如果有新元素添加进来而队列非空，可以将尾指针重新指向最开始的存储空间。循环队列的核心是队列空和满的判定，我们少用一个元素来区分队列空和队列满，约定 front 指向队列头元素，rear 指向队列尾元素的下一个位置，队列内容为 $[front,rear)$。</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 循环队列结构定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MyCircularQueue</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>front</span><span class=p>,</span><span class=nx>rear</span> <span class=kt>int</span> <span class=c1>// front指向第一个元素，rear指向最后一个元素的下一个位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Initialize your data structure here. Set the size of the queue to be k. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Constructor</span><span class=p>(</span><span class=nx>k</span> <span class=kt>int</span><span class=p>)</span> <span class=nx>MyCircularQueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>MyCircularQueue</span><span class=p>{</span><span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=nx>k</span><span class=o>+</span><span class=mi>1</span><span class=p>),</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Insert an element into the circular queue. Return true if the operation is successful. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyCircularQueue</span><span class=p>)</span> <span class=nf>EnQueue</span><span class=p>(</span><span class=nx>value</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nf>IsFull</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=nx>this</span><span class=p>.</span><span class=nx>rear</span><span class=p>]</span> <span class=p>=</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>rear</span> <span class=p>=</span> <span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>rear</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span> <span class=c1>//尾指针防止溢出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Delete an element from the circular queue. Return true if the operation is successful. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyCircularQueue</span><span class=p>)</span> <span class=nf>DeQueue</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nf>IsEmpty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>front</span> <span class=p>=</span> <span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>front</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span> <span class=c1>//头指针防止溢出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Get the front item from the queue. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyCircularQueue</span><span class=p>)</span> <span class=nf>Front</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nf>IsEmpty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>[</span><span class=nx>this</span><span class=p>.</span><span class=nx>front</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Get the last item from the queue. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyCircularQueue</span><span class=p>)</span> <span class=nf>Rear</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nf>IsEmpty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>[(</span><span class=nx>this</span><span class=p>.</span><span class=nx>rear</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>))</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>)]</span> <span class=c1>//尾指针返回正确的位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Checks whether the circular queue is empty or not. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyCircularQueue</span><span class=p>)</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nx>front</span> <span class=o>==</span> <span class=nx>this</span><span class=p>.</span><span class=nx>rear</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Checks whether the circular queue is full or not. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyCircularQueue</span><span class=p>)</span> <span class=nf>IsFull</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>rear</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>queue</span><span class=p>)</span> <span class=o>==</span> <span class=nx>this</span><span class=p>.</span><span class=nx>front</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>使用链表实现循环队列时在细节上可能有所不同。</p><h2 id=2-队列与bfs>2. 队列与BFS</h2><p>广度优先搜索（BFS）的实现与队列是密不可分的，最常用在树和图中，使用非常普遍。下面使用伪代码提供两个模板，一个是遍历，一个是找最短路径，这两个模板足够应付绝大多数题目。</p><h3 id=21-遍历>2.1 遍历</h3><p>遍历的伪代码模板如下，核心思想就是将初始节点入队，然后在循环中对队列头元素的所有邻居节点进行处理，如果没有被访问过就入队。</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BFS</span><span class=p>(</span><span class=nx>root</span> <span class=nx>Node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>create</span> <span class=nx>queue</span>  <span class=c1>// 创建队列，存储所有待处理结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>create</span> <span class=nx>visited</span> <span class=c1>// 标记已访问过的结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>add</span> <span class=nx>root</span> <span class=nx>to</span> <span class=nx>queue</span> <span class=c1>// 根结点入队
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// BFS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>queue</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>empty</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>cur</span> <span class=nx>Node</span> <span class=p>=</span> <span class=nx>the</span> <span class=nx>first</span> <span class=nx>node</span> <span class=nx>in</span> <span class=nx>queue</span>
</span></span><span class=line><span class=cl>        <span class=nx>remove</span> <span class=nx>the</span> <span class=nx>first</span> <span class=nx>node</span> <span class=nx>from</span> <span class=nx>queue</span> <span class=c1>// 实际情况可将以上两步合并为一步
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>add</span> <span class=nx>cur</span> <span class=nx>to</span> <span class=nx>visited</span> <span class=c1>// 标记当前结点为已访问
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=nx>curNeighbor</span>  <span class=o>:=</span> <span class=k>range</span> <span class=nx>the</span> <span class=nx>neighbors</span> <span class=nx>of</span> <span class=nx>cur</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>curNeighbor</span> <span class=nx>not</span> <span class=nx>in</span> <span class=nx>visited</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                 <span class=nx>add</span> <span class=nx>next</span> <span class=nx>to</span> <span class=nx>queue</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>     
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>以「岛屿数量」题目为例，给出一个改模板的使用示例。<a href=https://leetcode-cn.com/problems/number-of-islands/ target=_blank rel="external nofollow noopener noreferrer">leetcode题目地址</a></p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 题目描述
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>给定一个由</span> <span class=sc>&#39;1&#39;</span><span class=err>（</span><span class=nx>陆地</span><span class=err>）</span><span class=nx>和</span> <span class=sc>&#39;0&#39;</span><span class=err>（</span><span class=nx>水</span><span class=err>）</span><span class=nx>组成的的二维网格</span><span class=err>，</span><span class=nx>计算岛屿的数量</span><span class=err>。</span><span class=nx>一个岛被水包围</span><span class=err>，</span><span class=nx>并且它是通过水平方向或</span>
</span></span><span class=line><span class=cl><span class=nx>垂直方向上相邻的陆地连接而成的</span><span class=err>。</span><span class=nx>你可以假设网格的四个边均被水包围</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>示例输入</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=mi>11000</span>
</span></span><span class=line><span class=cl><span class=mi>11000</span>
</span></span><span class=line><span class=cl><span class=mo>00100</span>
</span></span><span class=line><span class=cl><span class=mo>00011</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>输出</span><span class=p>:</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=c1>// 程序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>numIslands</span><span class=p>(</span><span class=nx>grid</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>res</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span><span class=mi>0</span> <span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>]);</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 将连成一篇的陆地算作1个
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;1&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>BFS</span><span class=p>(</span><span class=nx>grid</span><span class=p>,</span><span class=nx>i</span><span class=p>,</span><span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nx>res</span><span class=o>++</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>point</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span><span class=p>,</span><span class=nx>y</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BFS</span><span class=p>(</span><span class=nx>grid</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>x</span><span class=p>,</span><span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>point</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span><span class=nx>point</span><span class=p>{</span><span class=nx>x</span><span class=p>,</span><span class=nx>y</span><span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nx>grid</span><span class=p>[</span><span class=nx>x</span><span class=p>][</span><span class=nx>y</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;0&#39;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//以“右-&gt;下-&gt;左-&gt;上”顺序循环，dx,dy是每一种转向的坐标变化方式
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>dx</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>dy</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>queue</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>queue</span> <span class=p>=</span> <span class=nx>queue</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>nx</span><span class=p>,</span><span class=nx>ny</span> <span class=o>:=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>x</span> <span class=o>+</span> <span class=nx>dx</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span><span class=nx>cur</span><span class=p>.</span><span class=nx>y</span> <span class=o>+</span> <span class=nx>dy</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 坐标超出界限或当前邻居结点为水域，进入下一个循环
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=nx>nx</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>nx</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>)</span> <span class=o>||</span> <span class=nx>ny</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>ny</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>[</span><span class=nx>cur</span><span class=p>.</span><span class=nx>x</span><span class=p>])</span> <span class=o>||</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>nx</span><span class=p>][</span><span class=nx>ny</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>queue</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>queue</span><span class=p>,</span><span class=nx>point</span><span class=p>{</span><span class=nx>nx</span><span class=p>,</span><span class=nx>ny</span><span class=p>})</span>
</span></span><span class=line><span class=cl>            <span class=nx>grid</span><span class=p>[</span><span class=nx>nx</span><span class=p>][</span><span class=nx>ny</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;0&#39;</span> <span class=c1>// 入队时标记已访问，防止重复入队，陷入循环
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=22-最短路径>2.2 最短路径</h3><p>寻找最短路径的伪代码模板如下</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 如果找到返回最短路径
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>BFS</span><span class=p>(</span><span class=nx>root</span><span class=p>,</span> <span class=nx>target</span> <span class=nx>Node</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>create</span> <span class=nx>queue</span>          <span class=c1>// 创建队列，存储所有待处理结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>create</span> <span class=nx>visited</span>        <span class=c1>// 标记已访问过的结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>shortestPath</span> <span class=kt>int</span>  <span class=c1>// 根结点到当前节点的最短路径
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>add</span> <span class=nx>root</span> <span class=nx>to</span> <span class=nx>queue</span>
</span></span><span class=line><span class=cl>    <span class=nx>add</span> <span class=nx>root</span> <span class=nx>to</span> <span class=nx>visited</span>
</span></span><span class=line><span class=cl>    <span class=c1>// BFS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>queue</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>empty</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>shortestPath</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nx>size</span> <span class=p>=</span> <span class=nx>queue</span><span class=p>.</span><span class=nf>length</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span>  <span class=nx>i</span> <span class=p>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>size</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=nx>cur</span> <span class=nx>Node</span> <span class=p>=</span> <span class=nx>the</span> <span class=nx>first</span> <span class=nx>node</span> <span class=nx>in</span> <span class=nx>queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>shortestPath</span> <span class=k>if</span> <span class=nx>cur</span> <span class=nx>is</span> <span class=nx>target</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=nx>curNeighbor</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>the</span> <span class=nx>neighbors</span> <span class=nx>of</span> <span class=nx>cur</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>curNeighbor</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>in</span> <span class=nx>visited</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>add</span> <span class=nx>next</span> <span class=nx>to</span> <span class=nx>queue</span>
</span></span><span class=line><span class=cl>                    <span class=nx>add</span> <span class=nx>next</span> <span class=nx>to</span> <span class=nx>visited</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>remove</span> <span class=nx>the</span> <span class=nx>first</span> <span class=nx>node</span> <span class=nx>from</span> <span class=nx>queue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>          <span class=c1>// 找不到最短路径
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>注：如果确定没有循环（比如树中）或者确实希望将结点多次加入队列，则不需要使用 visited 标记已访问结点。</p><p>这里有一些总结的技巧</p><ol><li>已访问列表可充分利用原题的数组或链表值实现</li><li>已访问列表可使用 map 实现</li><li>使用 map 实现时，值类型为 bool 或 int 可用于不同的场景</li><li>对当前节点的所有邻居节点进行访问，如果是数组，可使用方向数组完成，其它场景则根据具体情况决定</li></ol><h2 id=3-栈>3. 栈</h2><p>如下图，栈是一个后入先出的数据结构，插入（Push）和删除（Pop）都只能在栈顶操作。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-06-02-at-203523.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-06-02-at-203523.png, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-06-02-at-203523.png 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-06-02-at-203523.png 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-06-02-at-203523.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200222_screen-shot-2018-06-02-at-203523.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h3 id=31-栈实现>3.1 栈实现</h3><p>使用动态数组的简单实现如下</p><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>stack</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 入栈
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>value</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 出栈
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 获取栈顶元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Top</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 判空
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=32-内置库>3.2 内置库</h3><p>与对了相同，栈也可以很容易地使用 Go 提供的链表库实现</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>stack</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span> <span class=c1>// 建立队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>stack</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span> <span class=c1>// 入队：添加新元素到末尾
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>stack</span><span class=p>.</span><span class=nf>Back</span><span class=p>().</span><span class=nx>Value</span><span class=p>.(</span><span class=nx>valueType</span><span class=p>)</span> <span class=c1>// 获取队首元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>stack</span><span class=p>.</span><span class=nf>Remove</span><span class=p>(</span><span class=nx>queue</span><span class=p>.</span><span class=nf>Back</span><span class=p>()).(</span><span class=nx>valueType</span><span class=p>)</span> <span class=c1>// 出队：删除队首元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>stack</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=c1>// 队列长度
</span></span></span></code></pre></td></tr></table></div></div><h3 id=33-例子有效括号>3.3 例子：有效括号</h3><p>这是一个最经典也最简单的栈使用的例子，题目描述如下，<a href=https://leetcode-cn.com/problems/valid-parentheses/ target=_blank rel="external nofollow noopener noreferrer">leetcode题目地址</a></p><p>给定一个只包括 &lsquo;(&rsquo;，&rsquo;)&rsquo;，&rsquo;{&rsquo;，&rsquo;}&rsquo;，&rsquo;[&rsquo;，&rsquo;]&rsquo; 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>isValid</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>rune</span><span class=p>]</span><span class=kt>rune</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=sc>&#39;(&#39;</span><span class=p>:</span> <span class=sc>&#39;)&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=sc>&#39;[&#39;</span><span class=p>:</span> <span class=sc>&#39;]&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=sc>&#39;{&#39;</span><span class=p>:</span> <span class=sc>&#39;}&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>stack</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>rune</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>a</span><span class=p>[</span><span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=o>==</span> <span class=nx>v</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=4-栈和dfs>4. 栈和DFS</h2><p>类似的，深度优先搜索（DFS）是栈的一种核心使用场景。DFS有两种实现方式，一种是递归，尽管递归的实现看起来没有使用栈，但实际上使用的是系统提供的隐式栈，也称为调用栈（Call Stack）；另一种就是显式的使用栈。</p><p>DFS 无法像 BFS 一样计算最短路径。</p><h3 id=41-递归隐式栈>4.1 递归（隐式栈）</h3><p>递归的模板如下</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DFS</span><span class=p>(</span><span class=nx>cur</span><span class=p>,</span> <span class=nx>target</span> <span class=nx>Node</span><span class=p>,</span> <span class=nx>visited</span> <span class=kd>map</span><span class=p>[</span><span class=nx>Node</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>create</span> <span class=nx>visited</span> <span class=c1>// 标记已访问结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>true</span> <span class=k>if</span> <span class=nx>cur</span> <span class=nx>is</span> <span class=nx>target</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>next</span> <span class=p>:</span> <span class=nx>each</span> <span class=nx>neighbor</span> <span class=nx>of</span> <span class=nx>cur</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>next</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>in</span> <span class=nx>visited</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>add</span> <span class=nx>next</span> <span class=nx>to</span> <span class=nx>visted</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span> <span class=k>if</span> <span class=nf>DFS</span><span class=p>(</span><span class=nx>next</span><span class=p>,</span> <span class=nx>target</span><span class=p>,</span> <span class=nx>visited</span><span class=p>)</span> <span class=o>==</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>仍以队列中的「岛屿数量」一题为例，DFS 递归解法如下</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>point</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span> <span class=c1>//x,y分别为行号和列号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>numIslands</span><span class=p>(</span><span class=nx>grid</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>res</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>]);</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 连在一起的陆地算一个
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;1&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>res</span><span class=o>++</span>
</span></span><span class=line><span class=cl>				<span class=nf>DFS</span><span class=p>(</span><span class=nx>grid</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DFS</span><span class=p>(</span><span class=nx>grid</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>row</span><span class=p>,</span> <span class=nx>col</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//以“右-&gt;下-&gt;左-&gt;上”顺序循环，dx,dy是每一种转向的坐标变化方式
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>dx</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>dy</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>grid</span><span class=p>[</span><span class=nx>row</span><span class=p>][</span><span class=nx>col</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;0&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>nx</span><span class=p>,</span> <span class=nx>ny</span> <span class=o>:=</span> <span class=nx>row</span><span class=o>+</span><span class=nx>dx</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>col</span><span class=o>+</span><span class=nx>dy</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>nx</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>nx</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>)</span> <span class=o>||</span> <span class=nx>ny</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>ny</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>[</span><span class=nx>row</span><span class=p>])</span> <span class=o>||</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>nx</span><span class=p>][</span><span class=nx>ny</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 当前邻居结点满足条件，标记为已访问，并递归对该结点执行DFS
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>grid</span><span class=p>[</span><span class=nx>nx</span><span class=p>][</span><span class=nx>ny</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;0&#39;</span>
</span></span><span class=line><span class=cl>		<span class=nf>DFS</span><span class=p>(</span><span class=nx>grid</span><span class=p>,</span> <span class=nx>nx</span><span class=p>,</span> <span class=nx>ny</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=42-显式栈>4.2 显式栈</h3><p>显式栈的模板如下</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DFS</span><span class=p>(</span><span class=nx>root</span><span class=p>,</span><span class=nx>target</span> <span class=nx>Node</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>create</span> <span class=nx>stack</span>
</span></span><span class=line><span class=cl>    <span class=nx>create</span> <span class=nx>visited</span>
</span></span><span class=line><span class=cl>    <span class=nx>add</span> <span class=nx>root</span> <span class=nx>to</span> <span class=nx>stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>stack</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>empty</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>cur</span> <span class=nx>Node</span> <span class=p>=</span> <span class=nx>the</span> <span class=nx>top</span> <span class=nx>element</span> <span class=nx>in</span> <span class=nx>stack</span>
</span></span><span class=line><span class=cl>        <span class=nx>remove</span> <span class=nx>cur</span> <span class=nx>from</span> <span class=nx>stack</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span> <span class=k>if</span> <span class=nx>cur</span> <span class=nx>is</span> <span class=nx>target</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>Node</span> <span class=nx>next</span> <span class=p>:</span> <span class=nx>the</span> <span class=nx>neighbors</span> <span class=nx>of</span> <span class=nx>cur</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>next</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>in</span> <span class=nx>visited</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>add</span> <span class=nx>next</span> <span class=nx>to</span> <span class=nx>stack</span>
</span></span><span class=line><span class=cl>                <span class=nx>add</span> <span class=nx>next</span> <span class=nx>to</span> <span class=nx>visited</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>      
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>「岛屿数量」一题的 DFS 显式栈解法如下</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>point</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span><span class=p>,</span><span class=nx>y</span> <span class=kt>int</span> <span class=c1>//x,y分别为行号和列号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>numIslands</span><span class=p>(</span><span class=nx>grid</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>res</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>]);</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;1&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>res</span><span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=nf>DFS</span><span class=p>(</span><span class=nx>grid</span><span class=p>,</span><span class=nx>i</span><span class=p>,</span><span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DFS</span><span class=p>(</span><span class=nx>grid</span> <span class=p>[][]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>row</span><span class=p>,</span><span class=nx>col</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>   
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>point</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span><span class=nx>point</span><span class=p>{</span><span class=nx>row</span><span class=p>,</span><span class=nx>col</span><span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nx>grid</span><span class=p>[</span><span class=nx>row</span><span class=p>][</span><span class=nx>col</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;0&#39;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//以“右-&gt;下-&gt;左-&gt;上”顺序循环，dx,dy是每一种转向的坐标变化方式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>dx</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>dy</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>cur</span> <span class=o>:=</span> <span class=nx>stack</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>stack</span> <span class=p>=</span> <span class=nx>stack</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>stack</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>      
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>nx</span><span class=p>,</span><span class=nx>ny</span> <span class=o>:=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>x</span><span class=o>+</span><span class=nx>dx</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span><span class=nx>cur</span><span class=p>.</span><span class=nx>y</span><span class=o>+</span><span class=nx>dy</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>nx</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>nx</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>)</span> <span class=o>||</span> <span class=nx>ny</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>ny</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>grid</span><span class=p>[</span><span class=nx>row</span><span class=p>])</span> <span class=o>||</span> <span class=nx>grid</span><span class=p>[</span><span class=nx>nx</span><span class=p>][</span><span class=nx>ny</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 满足条件的结点标记为已访问并入栈
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>grid</span><span class=p>[</span><span class=nx>nx</span><span class=p>][</span><span class=nx>ny</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;0&#39;</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>stack</span><span class=p>,</span><span class=nx>point</span><span class=p>{</span><span class=nx>nx</span><span class=p>,</span><span class=nx>ny</span><span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=5-其它>5. 其它</h2><p>最后一部分介绍两种非常常见的问法：用栈实现队列，用队列实现栈</p><h3 id=51-用栈实现队列>5.1 用栈实现队列</h3><p>使用两个栈实现，最普通的思路是，每次出队时，将栈中的元素弹入一个临时栈，然后取出栈底元素，最后将临时栈的元素再放回去。但这样时间复杂度比较高，另一种合适的做法是，设立一个入栈，一个出栈，入队时将元素放入入栈，出队时从出栈的栈顶取元素，如果出栈为空，将此时入栈的所有元素弹入出栈，然后取栈顶元素。这样做可以将时间复杂度缩减到 $O(1)$</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyQueue</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>in</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>out</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Initialize your data structure here. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Constructor</span><span class=p>()</span> <span class=nx>MyQueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>MyQueue</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Push element x to the back of queue. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>in</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>in</span><span class=p>,</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Removes the element from in front of queue and returns that element. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>in</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>this</span><span class=p>.</span><span class=nx>out</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>,</span><span class=nx>this</span><span class=p>.</span><span class=nx>in</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>this</span><span class=p>.</span><span class=nx>in</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>pop</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>out</span> <span class=p>=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pop</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Get the front element. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Peek</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>)</span><span class=o>==</span><span class=mi>0</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>in</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>&gt;=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>this</span><span class=p>.</span><span class=nx>out</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>,</span> <span class=nx>this</span><span class=p>.</span><span class=nx>in</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>this</span><span class=p>.</span><span class=nx>in</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Returns whether the queue is empty. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyQueue</span><span class=p>)</span> <span class=nf>Empty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>in</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>out</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=52-用队列实现栈>5.2 用队列实现栈</h3><p>使用两个队列实现，只能使用笨办法，每次出栈将所有元素放到临时队列，取队尾元素，然后再将临时队列的元素放回去。如果使用链表实现，可以将最后一步简化为交换两个队列的头指针。</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MyStack</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>q</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Initialize your data structure here. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Constructor</span><span class=p>()</span> <span class=nx>MyStack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>MyStack</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Push element x onto stack. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Push</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>q</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>,</span><span class=nx>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Removes the element on top of the stack and returns that element. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Pop</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nf>Empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>this</span><span class=p>.</span><span class=nx>t</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>t</span><span class=p>,</span><span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nx>this</span><span class=p>.</span><span class=nx>q</span> <span class=p>=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>pop</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>q</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nx>t</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>t</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>this</span><span class=p>.</span><span class=nx>q</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>,</span><span class=nx>this</span><span class=p>.</span><span class=nx>t</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>t</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pop</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Get the top element. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Top</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nf>Empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>this</span><span class=p>.</span><span class=nx>t</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>t</span><span class=p>,</span><span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nx>this</span><span class=p>.</span><span class=nx>q</span> <span class=p>=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>pop</span> <span class=o>:=</span> <span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>q</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>t</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>t</span><span class=p>,</span><span class=nx>pop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>this</span><span class=p>.</span><span class=nx>t</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>t</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>this</span><span class=p>.</span><span class=nx>q</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>,</span><span class=nx>this</span><span class=p>.</span><span class=nx>t</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>this</span><span class=p>.</span><span class=nx>t</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>pop</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/** Returns whether the stack is empty. */</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>this</span> <span class=o>*</span><span class=nx>MyStack</span><span class=p>)</span> <span class=nf>Empty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>this</span><span class=p>.</span><span class=nx>q</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2020-06-30 00:00:00">更新于 2020-06-30&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/2020/data-structure-queue-and-stack/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Pocket" data-sharer=pocket data-url=https://shuzang.github.io/2020/data-structure-queue-and-stack/><i class="fa-brands fa-get-pocket fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://shuzang.github.io/2020/data-structure-queue-and-stack/ data-title=数据结构-队列与栈><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ class=post-tag>数据结构与算法</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2020/life-weekly-8/ class=post-nav-item rel=prev title="书藏的生活周刊第 8 期 (20200221)"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>书藏的生活周刊第 8 期 (20200221)</a>
<a href=/2020/data-structure-tree-and-binary-tree/ class=post-nav-item rel=next title=数据结构-二叉树>数据结构-二叉树<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Shuzang 支付宝" data-alt="Shuzang 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Shuzang 微信" data-alt="Shuzang 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">Hava a great day !</div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/>Shuzang</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/shuzang/shuzang.github.io title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/lightgallery/lightgallery.min.js defer></script><script src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/js/theme.min.js defer></script></body></html>