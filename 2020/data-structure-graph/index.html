<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>数据结构-图 - Shuzang's Blog</title><meta name=author content><meta name=author-link content><meta name=description content="链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。 1. 图的定义 用 V(Vertex) 表示顶点的集"><meta name=keywords content="数据结构与算法"><meta itemprop=name content="数据结构-图"><meta itemprop=description content="链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。 1. 图的定义 用 V(Vertex) 表示顶点的集"><meta itemprop=datePublished content="2020-03-16T00:00:00+00:00"><meta itemprop=dateModified content="2020-03-16T00:00:00+00:00"><meta itemprop=wordCount content="6571"><meta itemprop=image content="https://shuzang.github.io/logo.png"><meta itemprop=keywords content="数据结构与算法,"><meta property="og:title" content="数据结构-图"><meta property="og:description" content="链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。 1. 图的定义 用 V(Vertex) 表示顶点的集"><meta property="og:type" content="article"><meta property="og:url" content="https://shuzang.github.io/2020/data-structure-graph/"><meta property="og:image" content="https://shuzang.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-16T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-16T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shuzang.github.io/logo.png"><meta name=twitter:title content="数据结构-图"><meta name=twitter:description content="链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。 1. 图的定义 用 V(Vertex) 表示顶点的集"><meta name=application-name content="Shuzang's Blog"><meta name=apple-mobile-web-app-title content="Shuzang's Blog"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://shuzang.github.io/2020/data-structure-graph/><link rel=prev href=https://shuzang.github.io/2020/data-structure-heap/><link rel=next href=https://shuzang.github.io/2020/what-can-blockchain-do-during-the-covid-19/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.2.0/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.2.0/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"数据结构-图","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2020\/data-structure-graph\/"},"genre":"posts","keywords":"数据结构与算法","wordcount":6571,"url":"https:\/\/shuzang.github.io\/2020\/data-structure-graph\/","datePublished":"2020-03-16T00:00:00+00:00","dateModified":"2020-03-16T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"作者"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-title="Shuzang's Blog" data-alt="Shuzang's Blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collection/><i class="fa-solid fa-bookmark fa-fw fa-sm" aria-hidden=true></i> 集子</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collection/><i class="fa-solid fa-bookmark fa-fw fa-sm" aria-hidden=true></i> 集子</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>数据结构-图</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i></span></span>
<span class=post-category>收录于 <a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 爱编程爱技术的孩子</a></span></div><div class=post-meta-line><span title="发布于 2020-03-16 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2020-03-16>2020-03-16</time></span>&nbsp;<span title="更新于 2020-03-16 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2020-03-16>2020-03-16</time></span>&nbsp;<span title="6571 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 6600 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 14 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-图的定义>1. 图的定义</a></li><li><a href=#2-图的表示>2. 图的表示</a><ul><li><a href=#21-邻接矩阵>2.1 邻接矩阵</a></li><li><a href=#22-邻接表>2.2 邻接表</a></li><li><a href=#23-十字链表>2.3 十字链表</a></li><li><a href=#24-邻接多重表>2.4 邻接多重表</a></li></ul></li><li><a href=#3-图的构建>3. 图的构建</a></li><li><a href=#4-图的遍历>4. 图的遍历</a><ul><li><a href=#41-深度优先遍历>4.1 深度优先遍历</a></li><li><a href=#42-广度优先遍历>4.2 广度优先遍历</a></li></ul></li><li><a href=#5-最短路径>5. 最短路径</a><ul><li><a href=#51-单源最短路径>5.1 单源最短路径</a></li><li><a href=#52-多源最短路径>5.2 多源最短路径</a></li></ul></li><li><a href=#6-拓扑排序>6. 拓扑排序</a></li><li><a href=#7-关键路径>7. 关键路径</a></li><li><a href=#8-最小生成树>8. 最小生成树</a><ul><li><a href=#81-kruskal算法>8.1 Kruskal算法</a></li><li><a href=#82-prim算法>8.2 Prim算法</a></li><li><a href=#83-两种算法比较>8.3 两种算法比较</a></li></ul></li></ul></nav></div></div><div class=content id=content><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2020-03-16，文中内容可能已过时。</div></div></div><p>链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。</p><h2 id=1-图的定义>1. 图的定义</h2><p>用 V(Vertex) 表示顶点的集合，用 E(Edge) 表示边的集合，则图可以看作由一个非空的有限顶点集合 V 和一个有限边的集合 E 组成，记作G(V, E)。其中</p><ul><li>边可以表示为顶点对：(v, w) ∈ E，其中 v, w ∈ V</li><li>无向边使用小括号包含两个顶点来表示，如上一条所示，有向边可以用 &lt;v, w> 表示</li><li>不考虑重边和自回路（这样的图称为简单图，我们只考虑这种图）</li></ul><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0u9K.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0u9K.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0u9K.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0u9K.png?size=large 2x" sizes=auto data-title=一个无向图的例子 data-alt=一个无向图的例子 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>一些概念解释如下</p><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>弧（Arc）</td><td>边的另一种称呼</td></tr><tr><td>无向图（Digraph）</td><td>图中所有的边没有特定的指向</td></tr><tr><td>有向图（Undigraph）</td><td>图中所有的边是有向的</td></tr><tr><td>完全图</td><td>任意两个顶点间都有边相连</td></tr><tr><td>权（Weight）</td><td>与图的边有关的数，可能表示顶点的距离或花费</td></tr><tr><td>顶点的度（Degree)</td><td>对无向图，顶点所连接的边的数量</td></tr><tr><td>顶点的入度（Indegree）</td><td>对有向图，指向顶点的边的数量</td></tr><tr><td>顶点的出度（Outdegree）</td><td>对有向图，从顶点出发的边的数量</td></tr><tr><td>路径（Path）</td><td>从一个顶点到另一个顶点的顶点序列</td></tr><tr><td>路径长度</td><td>路径上边的数目</td></tr><tr><td>连通图</td><td>从一个顶点开始，可以到达图中任意一个其它顶点</td></tr><tr><td>非连通图</td><td>图中存在不可达的顶点</td></tr><tr><td>连通分量</td><td>对非连通图，它的极大连通子图称为连通分量</td></tr><tr><td>网</td><td>带权的连通图</td></tr></tbody></table><p>关于图的操作集有很多，但最基本的如下</p><ul><li>Create()：建立并返回空图</li><li>InsertVertex(Graph G, Vertex V)：将顶点 V 插入图 G</li><li>InsertEdge(Graph G, Edge E)：将边 E 插入图 G</li><li>DFS(Graph G, Vertex V)：从顶点 V 出发深度优先遍历图 G</li><li>BFS(Graph G, Vertex V)：从顶点 V 出发广度优先遍历图 G</li><li>ShortestPath(Graph G, Vertex V, int Dist[])：计算图 G 中顶点 V 到任意其它顶点的最短路径</li><li>MST(Graph G)：计算图的最小生成树</li></ul><h2 id=2-图的表示>2. 图的表示</h2><p>图的表示有<strong>很多种方法</strong>，包括邻接矩阵、邻接表、十字链表和多重邻接表，最常用的是邻接矩阵和邻接表。</p><h3 id=21-邻接矩阵>2.1 邻接矩阵</h3><p>通过邻接矩阵$G[N] [N]$表示图，首先将 N 个顶点从0到 N-1 编号，然后按如下公式填入数值。即如果两个顶点有边连接，填入1，如果没有边，则填入 0
$$
G[N][N] = \begin{cases} 1& 若&lt;v_i,v_j>是G中的边 \\ 0& 否则 \end{cases}
$$
下面是一个无向图的邻接矩阵表示</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd.png?size=large 2x" sizes=auto data-title=图的邻接矩阵表示 data-alt=图的邻接矩阵表示 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>实际编程时，通常使用二维数组的形式存储。对于无向图而言，邻接矩阵是对称的，因此通过只存储下三角矩阵或上三角矩阵的形式，可以节省一半的存储空间（矩阵压缩）。无向图的度是对应行（或列）非0元素的个数。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0U9f.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0U9f.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0U9f.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y0U9f.png?size=large 2x" sizes=auto data-title=下三角邻接矩阵 data-alt=下三角邻接矩阵 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>对于有向图来讲，邻接矩阵并不是对称的，因此不能采用这种方式。有向图对应行非0元素的个数是「出度」，对应列非0元素的个数是「入读」。</p><p>以上我们谈到的都是无权图，如果是有权图，如果两个顶点有边连接，填入边的权值，如果没有边连接，为$\infty$</p><p>如果是稠密图（边很多），使用邻接矩阵比较合适。如果是稀疏图（点很多而边很少），存在大量的无效元素，使用邻接矩阵会浪费大量的存储空间。</p><p>邻接矩阵结构可以定义为</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Graph</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>VNum</span><span class=p>,</span><span class=nx>ENUM</span>      <span class=kt>int</span>     <span class=c1>// 顶点和边的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Vertex</span>    <span class=p>[]</span><span class=kt>int</span>     <span class=c1>// 每个顶点的值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>AdjMatrix</span> <span class=p>[][]</span><span class=kt>int</span> <span class=c1>// 邻接矩阵
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=22-邻接表>2.2 邻接表</h3><p>邻接表适用于稀疏图的情况。将所有顶点用一个指针数组$G[N]$表示，每个元素表示一个节点，其值指向该顶点所有相邻顶点构成的链表（顺序不重要，可以随意），一个有向图的邻接表示例如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUHQU.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUHQU.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUHQU.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUHQU.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUHQU.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUHQU.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>邻接表结构可以定义为</p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ENode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>V</span>           <span class=kt>int</span>         <span class=c1>//顶点编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Weight</span>      <span class=kt>int</span>         <span class=c1>//边的权重(可选，无权图没有这个值)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>NextEdge</span>       <span class=o>*</span><span class=nx>ENode</span>     <span class=c1>//指向下一个邻接点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>VNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span>      <span class=kt>int</span>      <span class=c1>//顶点信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>FirstEdge</span>   <span class=o>*</span><span class=nx>Enode</span>  <span class=c1>//指向第一个邻接点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Graph</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>VNum</span><span class=p>,</span><span class=nx>ENum</span>      <span class=kt>int</span>         <span class=c1>//顶点和边的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>AdjList</span>        <span class=p>[]</span><span class=nx>VNode</span>   <span class=c1>//存顶点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>邻接表方便寻找任一顶点的所有邻接点，可以节省存储空间，但对有向图无法计算顶点的出度，需要构造「逆邻接表」，上面有向图的逆邻接表如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUxF1.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUxF1.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUxF1.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUxF1.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUxF1.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LUxF1.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h3 id=23-十字链表>2.3 十字链表</h3><p>十字链表可以看作将图的邻接表和逆邻接表结合的产物。和邻接表相同，图的顶点信息存在顶点数组中，数组元素有三个域：data域，存放与顶点相关的信息；FirstIn域，指向第一条指向它的弧；FirstOut域，指向一个单链表，单链表中存放所有该结点发出的弧。单链表的每个表结点对应一条弧，每个表结点有5个域：vtail和vhead分别是该弧两个顶点在图中的位置，weight存储弧的权重（可选），vtail指向同一弧尾的下一条弧，vhead指向同一弧头的下一条弧。</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ENode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>vtail</span><span class=p>,</span><span class=nx>vhead</span>              <span class=kt>int</span>         <span class=c1>//弧尾和弧头顶点编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Weight</span>                   <span class=kt>int</span>         <span class=c1>//边的权重(可选，无权图没有这个值)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nexttail</span><span class=p>,</span><span class=nx>nexthead</span>        <span class=o>*</span><span class=nx>ENode</span>     <span class=c1>//指向同弧尾和同弧头的弧结点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>VNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span>              <span class=kt>int</span>      <span class=c1>//顶点信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>FirstIn</span><span class=p>,</span><span class=nx>FirstOut</span>   <span class=o>*</span><span class=nx>Enode</span>  <span class=c1>//指向第一个邻接点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Graph</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>VNum</span><span class=p>,</span><span class=nx>ENum</span>      <span class=kt>int</span>         <span class=c1>//顶点和边的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>AdjList</span>        <span class=p>[]</span><span class=nx>VNode</span>   <span class=c1>//存顶点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>一个十字链表如下图所示，A只有出弧没有入弧，所以第一个指针为nil，第二个指针指向弧&lt;A, B>。弧结点&lt;A, B>没有同弧尾的结点，即除了A没有其它结点指向B，所以第一个指针为nil，但同弧头的还有弧结点&lt;A, C>。这里的同弧头和同弧尾都是相对于弧来说的，因此，对弧结点&lt;A, C>，同弧尾的还有&lt;B, C>，但同弧头的到此为止。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LIyse.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LIyse.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LIyse.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8LIyse.png?size=large 2x" sizes=auto data-title=十字链表 data-alt=十字链表 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>可以看出，基本结构是邻接表结构，只是添加了一个额外的指针域。</p><h3 id=24-邻接多重表>2.4 邻接多重表</h3><p>邻接多重表是邻接表的一种改进，只适用于无向图。在此存储结构中，图的顶点信息存放在顶点数组中，数组元素有两个域：data域，存放与顶点相关的信息；FirstEdge域，指向一个单链表，此单链表存储所有依附于该顶点的边的信息。这些单链表的一个表结点对应一条边，表结点有4个域：vexi和vexj分别存放该边两个顶点在图中的位置；nexti 指向下一条依附于顶点vexi的边对应的表结点，nextj 指向下一条依附于顶点vexj的边对应的表结点。</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ENode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>vexi</span><span class=p>,</span><span class=nx>vexj</span>          <span class=kt>int</span>         <span class=c1>//边的两个顶点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nexti</span><span class=p>,</span><span class=nx>nextj</span>        <span class=o>*</span><span class=nx>ENode</span>     <span class=c1>//两个顶点所依附的下一条边
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>VNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span>              <span class=kt>int</span>      <span class=c1>//顶点信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>FirstEdge</span>          <span class=o>*</span><span class=nx>Enode</span>  <span class=c1>//指向第一条边
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Graph</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>VNum</span><span class=p>,</span><span class=nx>ENum</span>      <span class=kt>int</span>         <span class=c1>//顶点和边的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>AdjList</span>        <span class=p>[]</span><span class=nx>VNode</span>     <span class=c1>//存顶点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>一个示例如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Lq6L8.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Lq6L8.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Lq6L8.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Lq6L8.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Lq6L8.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Lq6L8.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h2 id=3-图的构建>3. 图的构建</h2><p>我们以邻接矩阵形式存储，定义图的结构体如下</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Graph</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>VNum</span>      <span class=kt>int</span>     <span class=c1>// the number of Vertices
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>ENum</span>      <span class=kt>int</span>     <span class=c1>// the numver of Edges
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>AdjMatrix</span> <span class=p>[][]</span><span class=kt>int</span> <span class=c1>// adjacency matrix
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>为了方便测试，不建立 CreateVertex() 和 CreateEdge() 函数，而是直接对结构体进行初始化从而创建图，创建了一个无向图和一个有向图</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>CreateUndirectedGraph</span><span class=p>()</span> <span class=o>*</span><span class=nx>Graph</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Graph</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>ENum</span> <span class=p>=</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>6</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>7</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//为了便于操作和理解，从下标为1开始
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>,</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>7</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>3</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>4</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>5</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>5</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>5</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>5</span><span class=p>][</span><span class=mi>3</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>5</span><span class=p>][</span><span class=mi>6</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>6</span><span class=p>][</span><span class=mi>5</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>g</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 初始化一个图，顶点和边的数量、权值都预设好
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>CreateDirectedGraph</span><span class=p>()</span> <span class=o>*</span><span class=nx>Graph</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Graph</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>ENum</span> <span class=p>=</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//为了便于操作和理解，从下标为1开始
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>,</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>8</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>4</span><span class=p>]</span> <span class=p>=</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>4</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>5</span><span class=p>]</span> <span class=p>=</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>3</span><span class=p>][</span><span class=mi>6</span><span class=p>]</span> <span class=p>=</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>3</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>5</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>6</span><span class=p>],</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>4</span><span class=p>][</span><span class=mi>7</span><span class=p>]</span> <span class=p>=</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>5</span><span class=p>][</span><span class=mi>7</span><span class=p>]</span> <span class=p>=</span> <span class=mi>6</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>7</span><span class=p>][</span><span class=mi>6</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>g</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=4-图的遍历>4. 图的遍历</h2><p>有深度优先（Depth First Search, DFS）和广度优先（Breadth First Search, BFS）两种，前者类似于树的先序遍历，后者类似于树的层次遍历。下面图的遍历算法以下图为例</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd-1585138053043.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd-1585138053043.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd-1585138053043.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8Y03Bd-1585138053043.png?size=large 2x" sizes=auto data-title=图的邻接矩阵表示 data-alt=图的邻接矩阵表示 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h3 id=41-深度优先遍历>4.1 深度优先遍历</h3><p>递归解法的程序实现如下</p><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DepthFirstSearch</span><span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>,</span> <span class=nx>vertex</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>result</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>v</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=nx>k</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>result</span> <span class=p>=</span> <span class=nf>DepthFirstSearch</span><span class=p>(</span><span class=nx>g</span><span class=p>,</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>以结点0为入口，深度优先的遍历结果为[0 1 4 2 5 3]</p><h3 id=42-广度优先遍历>4.2 广度优先遍历</h3><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BreadthFirstSearch</span><span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>,</span> <span class=nx>vertex</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>queue</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>queue</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=nx>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>queue</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>vertex</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>.</span><span class=nf>Remove</span><span class=p>(</span><span class=nx>queue</span><span class=p>.</span><span class=nf>Front</span><span class=p>()).(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>v</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=nx>k</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>				<span class=nx>queue</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>result</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>以结点0为入口，广度优先的遍历结果为[0 1 2 3 4 5]</p><h2 id=5-最短路径>5. 最短路径</h2><p>最短路径问题可以抽象为：在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径，这条路径就是两点之间的最短路径（Shortest Path）。其中，第一个顶点为源点（Source），最后一个顶点为终点（Destination）。</p><p>最短路径问题不是一个单独的问题，而是一系列问题的综合，包括</p><ol><li>单源最短路径问题：从某固定源点出发，求其到所有其它顶点的最短路径<ul><li>（有向）无权图</li><li>（有向）有权图</li></ul></li><li>多源最短路径问题：求任意两顶点间的最短路径</li></ol><p>最短路径使用的示例图如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yn7VA.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yn7VA.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yn7VA.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yn7VA.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yn7VA.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yn7VA.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h3 id=51-单源最短路径>5.1 单源最短路径</h3><p>在理解最短路径算法前有两个问题需要注意</p><ol><li>无向图和有向图都适用，虽然多数示例是有向图</li><li>无权图是有权图的特例（权值为1），因此不单独介绍</li><li>图中不可以存在权值为负的边，否则 Dijkstra(迪杰斯特拉)算法不起作用</li></ol><p>如第3条所述，单源最短路径的典型算法称为 Dijkstra(迪杰斯特拉)算法，算法的基本思想为以起始点为中心层层向外扩展，直到扩展到终点为止。因此，该算法和广度优先搜索有一定的相似性。</p><p>输入上面的示例图，Dijkstra算法的输出为：[0 2 3 1 3 6 5]</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>DijkstraShortestPath</span><span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>,</span> <span class=nx>vertex</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>count</span> <span class=o>:=</span> <span class=mi>1</span>                          <span class=c1>// 已收录的顶点数目，用于控制循环
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>find</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>bool</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>      <span class=c1>//标记已访问过的结点
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>prevVertex</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=c1>//当前节点的前驱结点
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>distance</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>   <span class=c1>//当前结点的最短路径
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>vertex</span><span class=p>][</span><span class=nx>i</span><span class=p>]</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>distance</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>vertex</span><span class=p>][</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=nx>prevVertex</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>vertex</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>distance</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>MAX_INT</span>
</span></span><span class=line><span class=cl>			<span class=nx>prevVertex</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>distance</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>find</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nx>v</span><span class=p>,</span> <span class=nx>d</span> <span class=o>:=</span> <span class=nx>vertex</span><span class=p>,</span> <span class=mi>0</span> <span class=c1>//用来迭代顶点的变量和初始距离
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>count</span> <span class=p>&lt;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>d</span> <span class=p>=</span> <span class=nx>MAX_INT</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>find</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=nx>distance</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>d</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span> <span class=p>=</span> <span class=nx>distance</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>				<span class=nx>v</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>find</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>t</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>find</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=nx>t</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>distance</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span><span class=o>+</span><span class=nx>t</span> <span class=p>&lt;</span> <span class=nx>distance</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>distance</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>distance</span><span class=p>[</span><span class=nx>v</span><span class=p>]</span> <span class=o>+</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl>				<span class=nx>prevVertex</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>distance</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=52-多源最短路径>5.2 多源最短路径</h3><p>多源最短路径使用Floyd算法，这是一个经典的动态规划算法，核心思想是：从任意节点 i 到任意节点 j 的最短路径不外乎2种可能，1是直接从 i 到 j，2是从 i 经过若干个节点 k 到 j。所以，我们假设 Distance(i,j) 为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查 Distance(i,k) + Distance(k,j) &lt; Distance(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，我们便设置Distance(i,j) = Distance(i,k) + Distance(k,j)，这样一来，当我们遍历完所有节点 k，Distance(i,j) 中记录的便是 i 到 j 的最短路径的距离。</p><p>整个过程可以描述为两个步骤</p><ol><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是，更新它。</li></ol><p>程序实现如下</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FloydShortestPath</span><span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>,</span> <span class=nx>vertex</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>D</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>path</span> <span class=p>[][]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>k</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>D</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>D</span><span class=p>,</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=nx>path</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=p>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=p>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>D</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=nx>path</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>k</span> <span class=p>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>k</span> <span class=o>&lt;=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>k</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>i</span> <span class=p>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>D</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>k</span><span class=p>]</span><span class=o>+</span><span class=nx>D</span><span class=p>[</span><span class=nx>k</span><span class=p>][</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>D</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>D</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>D</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>k</span><span class=p>]</span> <span class=o>+</span> <span class=nx>D</span><span class=p>[</span><span class=nx>k</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>				<span class=nx>path</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nx>k</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=6-拓扑排序>6. 拓扑排序</h2><p>如果图中从 v 到 w 有一条有向路径，则 v 一定排在 w 之前。满足此条件的顶点序列称为一个<strong>拓扑序</strong>，获得一个拓扑序的过程就是<strong>拓扑排序</strong>。</p><p>一个最典型的例子是排课表，一个专业很多课程都有先修课，因此排课时必须考虑先修课的存在，以每门课程为结点，若课程间存在先修课关系则有边，这样构成的网络叫做AOV（Activity On Vertex）网，也是拓扑排序使用的网络。</p><p>拓扑排序用一句话描述就是「每次删除入度为0的顶点并输出它」，以下图为例，拓扑排序的结果为：V1,V2,V3,V4,V5。拓扑排序的结果是不唯一的。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yKVYt.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yKVYt.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yKVYt.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8yKVYt.png?size=large 2x" sizes=auto data-title=拓扑排序 data-alt=拓扑排序 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>拓扑排序必定是一个有向无环图（DAG），因此，该算法也可以用于判断一个图是否为有向无环图。程序实现如下，返回的result是拓扑排序结果，ve是关键路径需要用到的事件最早发生时间。</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TopologicalSort</span><span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>)</span> <span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>//拓扑排序的结果数组
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>ve</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>count</span> <span class=o>:=</span> <span class=mi>0</span> <span class=c1>//判断图中是否有环
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//计算各结点的入度并存储
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>indegree</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>j</span> <span class=o>&lt;=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>indegree</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span><span class=o>++</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>queue</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//入度为0的结点入队
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>indegree</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>queue</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>queue</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>vertex</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>.</span><span class=nf>Remove</span><span class=p>(</span><span class=nx>queue</span><span class=p>.</span><span class=nf>Front</span><span class=p>()).(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>v</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>indegree</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span><span class=o>--</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>indegree</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>queue</span><span class=p>.</span><span class=nf>PushBack</span><span class=p>(</span><span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>ve</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span><span class=o>+</span><span class=nx>v</span> <span class=p>&gt;</span> <span class=nx>ve</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>ve</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>ve</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=o>+</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>ve</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span><span class=o>+</span><span class=nx>v</span> <span class=p>&gt;</span> <span class=nx>ve</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>ve</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>ve</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=o>+</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>count</span> <span class=o>!=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;This is a DAG!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>result</span><span class=p>,</span> <span class=nx>ve</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=7-关键路径>7. 关键路径</h2><p>拓扑排序应用在AOV网络上，每个顶点表示一个活动或任务。如果每条边表示一个活动或任务，就是AOE（Activity On Edge）网络，多用在安排一个庞大生产流程的工序上，工序之间有先后关系。</p><p>如下图所示，在AOE网络中，事件 i 发生后，其后继活动 a(i,*) 都可以开始，但只有所有先导活动 a( *,j ) 都结束后，事件 j 才可以发生。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y1p4A.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y1p4A.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y1p4A.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y1p4A.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y1p4A.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y1p4A.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>假设一个工程的 AOE 网如下，最常求的就是 a) 整个工程完工需要多长时间？ b) 哪些活动影响工程进度？或求关键路径。图中的虚线表示事件有先后关系，但是这个活动不存在。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y3Exx.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y3Exx.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y3Exx.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8y3Exx.png?size=large 2x" sizes=auto data-title=AOE网络 data-alt=AOE网络 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>对事件（顶点）i，令最早发生时间为 ve(i)，最晚发生时间为 vl(i)；</p><p>对活动（边）a(i,j)，令最早开始时间为 e(i,j)，最晚开始时间为 l(i,j)。</p><p>那么整个工程的完工时间就是终点的最早发生时间；关键路径就是路径长度最长的路径。求关键路径的算法如下：</p><ol><li>将所有顶点进行拓扑排序；</li><li>计算 ve(j)， $ve(j) = max{ve(<em>) + a(</em>,j)}$ ，其中*为任意前驱事件，有ve(1) = 0；</li><li>计算 vl(i)， $vl(i) = min{vl(<em>) - a(i,</em>)}$ ，其中*为任意后继事件，有vl(n) = ve(n)；</li><li>计算 e(i,j) 和 l(i,j)，$e(i,j) = ve(i)$，$l(i,j) = vl(j)-a(i,j)$</li><li>结论：工程总用时 ve(n)，关键活动是 e(i,j) = l(i,j) 的活动 a(i,j)</li></ol><p>如果只求工程总用时，那么只需要第1，2步。关于两个核心公式可以这样理解：事件 j 在所有前驱活动都完成后发生，所以其最早发生时间为 $ve(j) = max{ve(<em>) + a(</em>,j)}$ ，即取决于最慢的前驱活动。另一方面，事件 i 发生后所有后继活动都可以开始了，所以其最晚发生时间为 $vl(i) = min{vl(<em>) - a(i,</em>)}$，即不耽误最慢的后继活动。</p><p>简单理解的话，就是按照拓扑有序排列顶点，然后从前往后计算事件的最早发生时间得到总时间，再从后往前计算事件的最晚发生时间，最后计算活动的最早和最晚开始时间得到关键活动和关键路径。求上面示例图的关键路径过程如下表</p><table><thead><tr><th>事件</th><th>最早发生时间ve</th><th>最晚发生时间vl</th><th>活动</th><th>最早开始时间e</th><th>最晚开始时间l</th></tr></thead><tbody><tr><td>v1</td><td>0</td><td>0</td><td>a(1,2)</td><td>0</td><td>0</td></tr><tr><td>v2</td><td>6</td><td>6</td><td>a(1,3)</td><td>0</td><td>2</td></tr><tr><td>v3</td><td>4</td><td>6</td><td>a(1,4)</td><td>0</td><td>1</td></tr><tr><td>v4</td><td>5</td><td>6</td><td>a(2,5)</td><td>6</td><td>6</td></tr><tr><td>v5</td><td>7</td><td>7</td><td>a(3,5)</td><td>4</td><td>6</td></tr><tr><td>v6</td><td>7</td><td>7</td><td>a(4,6)</td><td>5</td><td>6</td></tr><tr><td>v7</td><td>12</td><td>13</td><td>a(5,6)</td><td>7</td><td>7</td></tr><tr><td>v8</td><td>11</td><td>11</td><td>a(5,7)</td><td>7</td><td>8</td></tr><tr><td>v9</td><td>15</td><td>15</td><td>a(5,8)</td><td>7</td><td>8</td></tr><tr><td></td><td></td><td></td><td>a(6,8)</td><td>7</td><td>7</td></tr><tr><td></td><td></td><td></td><td>a(7,9)</td><td>12</td><td>13</td></tr><tr><td></td><td></td><td></td><td>a(8,9)</td><td>11</td><td>11</td></tr></tbody></table><p>最终得到工程完工需要时间为15，关键路径是 1,2,5,6,8,9</p><p>程序实现如下</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func CriticalPath(g *Graph) (int, []int) {
</span></span><span class=line><span class=cl>	path, ve := TopologicalSort(g)
</span></span><span class=line><span class=cl>	if len(path) == 1 || path == nil {
</span></span><span class=line><span class=cl>		return 0, nil
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>	vl := make([]int, len(path))
</span></span><span class=line><span class=cl>	for i := 1; i &lt; len(vl); i++ {
</span></span><span class=line><span class=cl>		vl[i] = MAX_INT
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>	vl[len(ve)-1] = ve[len(ve)-1]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	for i := len(vl) - 2; i &gt; 0; i-- {
</span></span><span class=line><span class=cl>		for k, v := range g.AdjMatrix[i] {
</span></span><span class=line><span class=cl>			if v &gt;= 0 &amp;&amp; vl[k]-v &lt; vl[i] {
</span></span><span class=line><span class=cl>				vl[i] = vl[k] - v
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>	result := []int{}
</span></span><span class=line><span class=cl>	for i := 1; i &lt; g.VNum+1; i++ {
</span></span><span class=line><span class=cl>		for j := 1; j &lt; g.VNum+1; j++ {
</span></span><span class=line><span class=cl>			if g.AdjMatrix[i][j] &gt;= 0 {
</span></span><span class=line><span class=cl>				if ve[i] == vl[j]-g.AdjMatrix[i][j] {
</span></span><span class=line><span class=cl>					result = append(result, i)
</span></span><span class=line><span class=cl>				}
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>	result = append(result, path[len(path)-1])
</span></span><span class=line><span class=cl>	return ve[len(ve)-1], result
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h2 id=8-最小生成树>8. 最小生成树</h2><p>生成树指包含全部顶点且树的 V-1 条边全部在图里的树，其中 V 为顶点数目。最小生成树（Minimum Spanning Tree）就是边的权重和最小的生成树。需要注意两点</p><ol><li>向生成树中任加一条边都一定会构成回路</li><li>最小生成树存在等价于图连通</li></ol><p>生成最小生成树最常见的有 Prim 和 Kruskal 两种算法，这两种都是贪心算法。</p><h3 id=81-kruskal算法>8.1 Kruskal算法</h3><p>算法的核心思想用一句话描述就是「不构成环的情况下，每次选取最小的边」，最小边的选取可以使用最小堆，环的判断可以使用并查集。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IP2RI.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IP2RI.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IP2RI.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IP2RI.png?size=large 2x" sizes=auto data-title=Kruskal算法 data-alt=Kruskal算法 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>代码实现如下，最小堆的实现使用了 标准库中的container/heap，usetFind是并查集的查找函数</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>usetFind</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>uset</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>x</span> <span class=o>!=</span> <span class=nx>uset</span><span class=p>[</span><span class=nx>x</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>x</span> <span class=p>=</span> <span class=nx>uset</span><span class=p>[</span><span class=nx>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>KruskalMiniSpanTree</span><span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>total</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>result</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>Edge</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>h</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Heap</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>heap</span><span class=p>.</span><span class=nf>Init</span><span class=p>(</span><span class=nx>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>i</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>heap</span><span class=p>.</span><span class=nf>Push</span><span class=p>(</span><span class=nx>h</span><span class=p>,</span> <span class=nx>Edge</span><span class=p>{</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>i</span><span class=p>][</span><span class=nx>j</span><span class=p>]})</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>uset</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=c1>//用数组表示并查集
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>uset</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>uset</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>h</span><span class=p>.</span><span class=nf>Len</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>e</span> <span class=o>:=</span> <span class=nx>heap</span><span class=p>.</span><span class=nf>Pop</span><span class=p>(</span><span class=nx>h</span><span class=p>).(</span><span class=nx>Edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>usetFind</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>from</span><span class=p>,</span> <span class=nx>uset</span><span class=p>)</span> <span class=o>!=</span> <span class=nf>usetFind</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>to</span><span class=p>,</span> <span class=nx>uset</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>result</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>result</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>uset</span><span class=p>[</span><span class=nx>uset</span><span class=p>[</span><span class=nx>e</span><span class=p>.</span><span class=nx>to</span><span class=p>]]</span> <span class=p>=</span> <span class=nx>uset</span><span class=p>[</span><span class=nx>e</span><span class=p>.</span><span class=nx>from</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=nx>total</span> <span class=o>+=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>weight</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>total</span><span class=p>,</span> <span class=nx>uset</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=82-prim算法>8.2 Prim算法</h3><p>记 V 是联通网的顶点集，U 是求得的生成树的顶点集，TE 是求得的生成树的边集。普利姆算法步骤如下</p><ol><li>开始时，$U={v_0}, TE = \emptyset$</li><li>计算 U 到其余顶点 V-U 的最小代价，将该顶点纳入 U，边纳入TE</li><li>重复第二步直到 U=V</li></ol><p>一个例子如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IFD4H.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IFD4H.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IFD4H.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200316_8IFD4H.png?size=large 2x" sizes=auto data-title=Prim算法 data-alt=Prim算法 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>代码实现如下</p><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>PrimMiniSpanTree</span><span class=p>(</span><span class=nx>g</span> <span class=o>*</span><span class=nx>Graph</span><span class=p>,</span> <span class=nx>start</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>total</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>parent</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>dist</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>parent</span><span class=p>[</span><span class=nx>start</span><span class=p>]</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>dist</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=nx>start</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>start</span><span class=p>][</span><span class=nx>i</span><span class=p>]</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>dist</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>start</span><span class=p>][</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>dist</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>MAX_INT</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>count</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>vertex</span><span class=p>,</span> <span class=nx>mini</span> <span class=o>:=</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>MAX_INT</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>count</span> <span class=p>&lt;</span> <span class=nx>g</span><span class=p>.</span><span class=nx>VNum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mini</span> <span class=p>=</span> <span class=nx>MAX_INT</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>dist</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=nx>mini</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>vertex</span><span class=p>,</span> <span class=nx>mini</span> <span class=p>=</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>total</span> <span class=o>+=</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>dist</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>t</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>g</span><span class=p>.</span><span class=nx>AdjMatrix</span><span class=p>[</span><span class=nx>vertex</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>t</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>t</span> <span class=p>&lt;</span> <span class=nx>dist</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>dist</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl>				<span class=nx>parent</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=nx>vertex</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>total</span><span class=p>,</span> <span class=nx>parent</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=83-两种算法比较>8.3 两种算法比较</h3><p>Kruskal的算法时间复杂度为$O(eloge)$，只和边的数目 e 有关，与顶点个数 n 无关，适用于稀疏图</p><p>Prim算法时间复杂度为$O(n^2)$，只和顶点个数 n 有关，与边的数目 e 无关，适用于稠密图</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2020-03-16 00:00:00">更新于 2020-03-16&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/2020/data-structure-graph/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Pocket" data-sharer=pocket data-url=https://shuzang.github.io/2020/data-structure-graph/><i class="fa-brands fa-get-pocket fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://shuzang.github.io/2020/data-structure-graph/ data-title=数据结构-图><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ class=post-tag>数据结构与算法</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2020/data-structure-heap/ class=post-nav-item rel=prev title=数据结构-堆><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>数据结构-堆</a>
<a href=/2020/what-can-blockchain-do-during-the-covid-19/ class=post-nav-item rel=next title=面对疫情区块链可以做些什么>面对疫情区块链可以做些什么<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/alipay.png data-title=" 支付宝" data-alt=" 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/wechatpay.png data-title=" 微信" data-alt=" 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">Hava a great day !</div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/shuzang/shuzang.github.io title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.6.1/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.2/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.2/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/fuse.js@6.6.2/dist/fuse.min.js defer></script><script src=https://unpkg.com/twemoji@14.0.2/dist/twemoji.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.2/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.2/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.2/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/js/theme.min.js defer></script></body></html>