<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>计算机网络-数据链路层 | Shuzang's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="书藏的个人博客，包括Golang、数据结构、算法的学习记录，各类生活技能的学习，每周五发布一期自己的生活周刊"><link rel=prev href=https://shuzang.github.io/2020/physical-layer/><link rel=next href=https://shuzang.github.io/2020/algorithm-branch-and-bound/><link rel=canonical href=https://shuzang.github.io/2020/data-link-layer/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="计算机网络-数据链路层"><meta name=twitter:description content="两台主机间的数据传输，通常不是直达的，而是分成一段一段的链路。两个相邻节点间如何传输数据，是数据链路层关心的事情。"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"计算机网络-数据链路层","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2020\/data-link-layer\/"},"image":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"计算机基础","wordcount":3536,"url":"https:\/\/shuzang.github.io\/2020\/data-link-layer\/","datePublished":"2020-07-19T20:25:00\x2b08:00","dateModified":"2020-07-19T20:25:00\x2b08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"shuzang","logo":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://shuzang.github.io>Shuzang's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">计算机网络-数据链路层</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2020-07-19>2020-07-19</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 3536 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://shuzang.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/>爱编程爱技术的孩子</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1-帧>1. 帧</a><ul><li><a href=#11-封装成帧>1.1 封装成帧</a></li><li><a href=#12-透明传输>1.2 透明传输</a></li><li><a href=#13-差错检测>1.3 差错检测</a></li></ul></li><li><a href=#2-以太网>2. 以太网</a><ul><li><a href=#21-适配器>2.1 适配器</a></li><li><a href=#22-csmacd>2.2 CSMA/CD</a></li><li><a href=#23-集线器>2.3 集线器</a></li><li><a href=#24-mac层>2.4 MAC层</a></li><li><a href=#25-网桥>2.5 网桥</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#1-帧>1. 帧</a><ul><li><a href=#11-封装成帧>1.1 封装成帧</a></li><li><a href=#12-透明传输>1.2 透明传输</a></li><li><a href=#13-差错检测>1.3 差错检测</a></li></ul></li><li><a href=#2-以太网>2. 以太网</a><ul><li><a href=#21-适配器>2.1 适配器</a></li><li><a href=#22-csmacd>2.2 CSMA/CD</a></li><li><a href=#23-集线器>2.3 集线器</a></li><li><a href=#24-mac层>2.4 MAC层</a></li><li><a href=#25-网桥>2.5 网桥</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>两台主机间的数据传输，通常不是直达的，而是分成一段一段的链路。两个相邻节点间如何传输数据，是数据链路层关心的事情。</p><p>由于物理层已经完成了比特流的传输，数据链路层考虑的就是上一层的事情：如何将网络层交下来的数据报组装成基本传输单位帧，然后将帧发送出去，或者将物理层交上来的比特流划分成帧，取出数据部分后上交给网络层。</p><p>尽管传输媒体和通信手段的差异已经被屏蔽，数据链路层依然要考虑两种不同类型的信道：</p><ol><li>点对点信道：一对一的通信方式；</li><li>广播信道：一对多的广播通信方式，同时与多台主机通信。</li></ol><p>此外，关于传输的基本单位：帧，还要考虑如何对帧进行划分、如何完成差错检测等各种事情。</p><a class=post-dummy-target id=1-帧></a><h2>1. 帧</h2><p>链路层的基本传输单位叫做<strong>帧</strong>，帧是在网络层交付的 IP 数据报的基础上添加帧头帧尾构成的，然后移交物理层，由物理层作为纯粹的比特流传输给目标主机，目标主机物理层收到后，根据首尾标记，对比特流重新划分形成帧，校验后无差错则去除帧头帧尾交付网络层。</p><p>所以数据链路层考虑如何封装成帧，从比特流解析出帧以及进行差错检测，前面两件事是相反的过程。</p><a class=post-dummy-target id=11-封装成帧></a><h3>1.1 封装成帧</h3><p>封装成帧(framing)就是在一段数据（网络层的 IP 数据报）的前后分别添加首部和尾部，这样就构成了一个帧。</p><p>帧所携带的数据长度有一个上限，叫做最大传输单元MTU（Maximum Transfer Unit）。帧首部和尾部的主要作用是进行帧定界（确定帧的界限）以及包括许多控制信息。</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200719_epub_655484_87.jpg alt class=lazyload></figure></p><p>对于点对点协议 PPP（Point-to-Point Protocol）来说，帧格式如下</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200719_epub_655484_98.jfif alt class=lazyload></figure></p><p>首部和尾部分别为四个字段和两个字段。</p><p>首部的第一个字段和尾部的第二个字段都是标志字段F (Flag)，规定为0x7E（十六进制的7E的二进制表示是01111110）。标志字段表示一个帧的开始或结束，也就是定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃</p><p>首部中的地址字段A规定为0xFF（即11111111），控制字段C规定为0x03（即00000011）。至今没有实际的意义。首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是 IP 数据报。若为0xC021,则信息字段是 PPP 链路控制协议 LCP 的数据，而 0x8021 表示这是网络层的控制数据。</p><p>尾部中的第一个字段（2字节）是使用CRC的帧检验序列 FCS。</p><a class=post-dummy-target id=12-透明传输></a><h3>1.2 透明传输</h3><p>透明传输的意思是不管什么样的数据都能通过数据链路层，实现这一点解决的主要是一个问题，即帧的数据部分出现了和帧定界符相同的编码，导致无法正确的划分帧。</p><p>这种情况广泛出现在传输程序或图像等非 ASCII 码串时，解决方法是在数据中出现帧定界符时在前面加一个转义字符 0x7D（即01111101），如果要传输的字段本身就是转义字符，那么将其变成（0x7D, 0x5D）来传输，接收端在将数据送往网络层前会把转义符删掉。这种方法称为字节填充或字符填充。</p><p>上面提到的办法是异步传输时实用的方法，同步传输时采用零比特填充。即在发送端，先扫描整个信息字段，只要发现有5个连续1，则立即填入一个0，从而保证在信息字段中不会出现6个连续1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。</p><a class=post-dummy-target id=13-差错检测></a><h3>1.3 差错检测</h3><p>差错检测是指检测传输的数据中 0 变成 1，1 变成 0 的情况，使用的方法是<a href=https://baike.baidu.com/item/CRC/1453359 target=_blank>循环冗余检验</a>。</p><p>在发送端，先把数据划分为组，假定每组 k个比特。现假定待传送的数据 M = 101001 （k =6）。CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位冗余码，然后构成一个帧发送出去，一共发送(k + n)位。这n 位冗余码可用以下方法得出：在 M 后面添加 n 个0，得到的 k + n 位的数除以收发双方事先商定的长度为 n + 1 位的除数P，得出商是 Q 而余数是 R（n 位，比P少一位），这个余数就是冗余码。</p><p>下图所示的例子中，M = 101001（即k= 6），假定除数P = 1101（即n = 3），经模2除法运算后的结果是：商Q = 110101（这个商并没有什么用处），而余数 R = 001。这个余数 R 就作为冗余码拼接在数据 M 的后面发送出去。这种为了进行检错而添加的冗余码常称为帧检验序列 FCS(Frame Check Sequence)。</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200719_epub_655484_93.jfif alt class=lazyload></figure></p><p>在接收端把接收到的数据以帧为单位进行CRC检验：把收到的每一个帧都除以同样的除数P（模2运算），然后检查得到的余数 R。如果无差错，那么余数应当为 0。</p><p>除数 P 的生成一般使用多项式，如给定多项式 $P(X) = x^3 + x^2 +1$，那么除数 P = 1101</p><p>但链路层的差错检测只检测比特的错误变动，对于 帧丢失、帧重复、帧失序 这些情况不做检测，这些问题由运输层的 TCP 保证。</p><a class=post-dummy-target id=2-以太网></a><h2>2. 以太网</h2><p>对使用广播信道的数据链路层，主要讨论的是局域网，而由于现在局域网中以太网占主流，实际讨论内容是以太网。另外要注意的是，局域网工作的层次跨越了数据链路层和物理层。由于局域网技术中有关数据链路层的内容比较丰富，因此把局域网的内容放在数据链路层中讨论。但这并不表示局域网仅仅和数据链路层有关。</p><a class=post-dummy-target id=21-适配器></a><h3>2.1 适配器</h3><p>两台计算机除了需要物理线路（有线或无线）来连接，还必须有一些规范定义这些数据如何传输，实现这些规范的通常是网络适配器（有硬件和软件两方面的含义）</p><p>计算机与外界局域网的连接主要是通过适配器，就是我们说的网卡。适配器与局域网的通信是通过双绞线以串行方式进行的，而适配器与计算机的通信是通过主板上的 I/O 总线以并行方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。若在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。</p><p>适配器接收和发送各种帧时不使用计算机的CPU。这时CPU可以处理其他任务。当适配器收到有差错的帧时，就把这个帧丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机并交付协议栈中的网络层。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。我们特别要注意，计算机的硬件地址（MAC地址）在适配器的ROM中，而计算机的软件地址（IP地址）则在计算机的存储器中。</p><a class=post-dummy-target id=22-csmacd></a><h3>2.2 CSMA/CD</h3><p>在以太网中所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。以太网采用的协议叫做 <a href=https://baike.baidu.com/item/CSMA%2FCD target=_blank>CSMA/CD</a>，意思是载波监听多点接入/碰撞检测(Carrier SenseMultiple Access with Collision Detection)。</p><a class=post-dummy-target id=23-集线器></a><h3>2.3 集线器</h3><p>集线器工作在物理层，它的每个接口仅仅简单地转发比特——收到1就转发1，收到0就转发0，不进行碰撞检测。若两个接口同时有信号输入（即发生碰撞），那么所有的接口都将收不到正确的帧。</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200719_epub_655484_112.jpg alt=集线器结构示意图 class=lazyload><figcaption class=image-caption>集线器结构示意图</figcaption></figure></p><p>集线器的主要作用是扩展一个以太网的覆盖范围。如下图，使用多个集线器可以构成一个覆盖更大范围的局域网。</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200719_epub_655484_121.jpg alt class=lazyload></figure></p><a class=post-dummy-target id=24-mac层></a><h3>2.4 MAC层</h3><p>数据链路层分为上层LLC（Logical Links Control，逻辑链路控制），和下层的MAC（媒体访问控制），MAC主要负责控制与连接物理层的物理介质。</p><p>IEEE802 标准为局域网规定了一种48位（6字节）的全球地址，这种地址固化在适配器的ROM中，叫做 MAC 地址，除非更换适配器，其它的操作都不会对计算机的 MAC 地址产生影响，因此，MAC 地址实际上可以看作计算机的名字。</p><p>48位的 MAC 地址可组成 $2^{46}$ 个地址，超过 70万亿，足够区分全世界所有的计算机。</p><p>MAC地址的前三字节由 IEEE 的注册管理机构 RA 分配给世界上所有生产适配器的厂家，后三个字节由厂家自行指派，只要没有重复地址即可。</p><p>当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。</p><p>常用的以太网 MAC 帧标准为以太网 V2 标准，帧格式如下</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200719_epub_655484_119.jpg alt class=lazyload></figure></p><p>目的地址和源地址指的都是 MAC 地址，类型指上层使用的协议，比如 IP。以太网 MAC 帧的最小长度为 64字节，因此数据部分最小长度为 64-18 = 46 字节，数据部分最大长度为 1500 字节。</p><a class=post-dummy-target id=25-网桥></a><h3>2.5 网桥</h3><p>集线器工作在物理层，只对数据进行简单转发，网桥工作中数据链路层，会根据 MAC 地址进行针对性转发，这种针对性转发是通过维护一个路由表完成的，路由表中存在网桥接口和MAC地址的对应关系。</p><p>两层交换机的本质就是一种多接口网桥。</p><p>注意，路由器实际上不属于网桥，它包括网络层，和三层交换机一样，是一个三层设备，不是根据 MAC 地址转发，而是根据网络层的 IP 地址转发。</p></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>shuzang</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2020-07-19</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fshuzang.github.io%2f2020%2fdata-link-layer%2f&text=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c-%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fshuzang.github.io%2f2020%2fdata-link-layer%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fshuzang.github.io%2f2020%2fdata-link-layer%2f&title=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c-%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://shuzang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/><i class="fas fa-tag fa-fw"></i>&nbsp;计算机基础</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://shuzang.github.io>Home</a></span></section></div><div class=post-nav><a href=https://shuzang.github.io/2020/physical-layer/ class=prev rel=prev title=计算机网络-物理层><i class="fas fa-angle-left fa-fw"></i>计算机网络-物理层</a>
<a href=https://shuzang.github.io/2020/algorithm-branch-and-bound/ class=next rel=next title=算法-分支限界>算法-分支限界<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shuzang.github.io/about/ target=_blank>shuzang</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-209130979-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>