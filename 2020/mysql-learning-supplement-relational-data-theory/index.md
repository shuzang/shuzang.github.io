# Mysql学习补充-关系数据理论


MySQL 作为关系数据库，关系数据理论是基础，本文进行补充学习，主要包括关系模型、关系代数和范式的相关知识。

<!--more-->

## 1. 关系模型

### 1.1 简介

模型就是描述数据的概念的集合。

数据库的本质作用是存储抽象自现实世界的数据，这一过程可以分为两个阶段

1. 对现实世界进行抽象，强调语义的表达，这一阶段称为**概念模型**，一般使用线条、图形、文字等来进行描述，是用户和数据库设计人员的沟通语言，比如 E-R 图。
2. 用计算机可理解的方式进行二次抽象，强调数据描述的确定性，这一阶段称作**数据模型**，包括遵循的数据结构、对数据的各种操作和数据的约束条件三部分。

关系模型正是当前广泛使用的一种数据模型，使用关系模型的数据库称为关系型数据库，MySQL 正是广为使用的一种关系型数据库。

### 1.2 基本概念

**域**：域是一组具有相同类型值的集合，比如 MAN = {王兵，李平} 就是一个域，WOMAN = {丁梅，吴芳} 也是一个域。

**笛卡尔积**：给定一组域 $D_1,D_2,...,D_n$，它们的笛卡尔积就定义为
$$
D_1 \times D_2 \times ... D_n=\{(d_1,d_2,...,d_n)|d_i \in D_i,i=1,2,...,n\}
$$
以上面的 MAN 和 WOMEN 域为例，$MAN \times WOMEN = \{(王兵,丁梅),(王兵,吴芳),(李平,丁梅),(李平,吴芳)\}$，一个笛卡尔积可以表示为一个二维表，如下

| MAN  | WOMAN |
| ---- | ----- |
| 王兵 | 丁梅  |
| 王兵 | 吴芳  |
| 李平 | 丁梅  |
| 李平 | 吴芳  |

**元组**：笛卡尔积中的每个元素叫做一个元组，也就是二维表中的一行。

**关系**：$D_1 \times D_2 \times ... D_n$ 的子集叫做在域 $D_1,D_2,...,D_n$ 上的一个关系，可以表示为 $R(D_1,D_2,...,D_n)$，n 叫做关系的目/度。关系是关系模型最核心的概念，一个关系数据库就是一组关系的集合，而一个关系就是一张二维表（笛卡尔积所代表的二维表的一个子集），比如，我们假设王兵的妻子是丁梅，李平的妻子是吴芳，则取笛卡尔积的一个子集就可以构造出一个关系 FAMILY

| husband | wife |
| ------- | ---- |
| 王兵    | 丁梅 |
| 李平    | 吴芳 |

关系具有一些规定（性质）

1. 关系中不能存在完全相同的两个元组
2. 关系中元组行的序不重要
3. 关系中列的序不重要

**属性**：关系的每一列都有一个自己的名字，称为属性。这一，上面的关系就可以表示为 $FAMILY = \{husband,wife\}$

**候选码**：能够唯一标识一个元组的最小属性组叫做候选码，在上面的例子中，需要丈夫和妻子两个人的名字才能区分每一对夫妻，因此其候选码为 (husband,wife)，但在其它例子比如学生名单中，学生学号可以唯一标识学生，因此学号可以单独作为候选码。

**主属性**：候选码中的属性叫做主属性。

**非码属性**：不包含在任何候选码中的属性叫做非码属性。

**关系模式**：对关系进一步抽象，表示所有关系的一个通用方法就是关系模式，表达为 $R(U,D,dom,F)$，其中 R 为关系名，U 是组成该关系的属性名集合，D 是属性组 U 中属性来自的域，dom 是属性到域的映射集合，F 为属性间数据的依赖关系集合。通常我们会简写为 $R(U)$，所以才有了上面的 $FAMILY = \{husband,wife\}$ 这种表示。

## 2. 关系代数

一个数据模型，不仅包含表达数据的数据结构，还包含可对数据进行的操作。关系模型中，每个关系看作一个集合，对关系的操作可以就归纳为对集合的操作，这就是本节要介绍的关系代数。

关系代数的运算分为：传统的集合运算和专门的关系运算。

### 2.1 集合运算

就是指求**交集**、**并集**和**差集**，要求运算的两个关系具有相同的目，且相应的属性取自同一个域。

还有一个特别的集合运算叫做**广义笛卡尔积**。假设两个关系 R 和 S 分别为 n 和 m 目，则其广义笛卡尔积是一个 n + m 列的元组的集合。若 R 有 k1 个元组，S 有 k2 个元组，则广义笛卡尔积有 $k1 × k2$ 个元组，记作 $R \times S$。通常我们在描述时一般直接称为笛卡尔积运算。

假设 R 关系如下

| A    | B    | C    |
| ---- | ---- | ---- |
| a1   | b1   | c1   |
| a2   | b2   | c2   |

S 关系如下

| D    | E    |
| ---- | ---- |
| d1   | e1   |
| d2   | e2   |
| d3   | e3   |

则 $R \times S$ 如下

| A    | B    | C    | D    | E    |
| ---- | ---- | ---- | ---- | ---- |
| a1   | b1   | c1   | d1   | e1   |
| a1   | b1   | c1   | d2   | e2   |
| a1   | b1   | c1   | d3   | e3   |
| a2   | b2   | c2   | d1   | e1   |
| a2   | b2   | c2   | d2   | e2   |
| a2   | b2   | c2   | d3   | e3   |

### 2.2 关系运算

**选择**：选择运算是在关系 R 中选择满足给定条件的元组，记作 $\sigma_F(R) = \{t \in R \and F(t) = true\}$，其中 $\sigma$ 为选择运算符，$F$ 为选择条件

选择运算 $\sigma_{A='a1'}(R)$ 的结果为

| A    | B    | C    |
| ---- | ---- | ---- |
| a1   | b1   | c1   |

**投影**：投影运算是在关系 R 中选出若干属性列组成新的关系，记作 $\pi_A(R) = \{t[A]|t \in R\}$，其中 $\pi$ 为投影运算符，$A$ 为选择的属性列名。需要注意的是，投影运算可能缩减元组个数，因为要去重。

投影运算 $\pi_{A,B}(R)$ 的结果为

| A    | B    |
| ---- | ---- |
| a1   | b1   |
| a2   | b2   |

**连接**：连接运算是从两个关系的笛卡尔积中选取属性间满足一定条件的元组，称为θ连接，记作 $R \bowtie S$，$\bowtie$ 下面应该有个θ连接的表达式，比如 $A = B$，当θ为等号时称作**等值连接**。

连接运算可以理解为笛卡尔积和选择两个运算的结合，下面是一个等值连接的例子

![等值连接](https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20180701_%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5.png)

当等值连接中等于号的两端是相同的属性组时，称为自然连接，上图同时也是一个**自然连接**，可以直接表示为 $R \bowtie S$

**左连接**：左连接的意思是左表的记录会全部显示出来，而右表只会显示符合搜索条件的记录，右表记录不足的填充 NULL。

**右连接**：与左连接相反，右表的记录全部显示出来，左表只会显示符合搜索条件的记录，左表记录不足的填充 NULL。

象集：给定一个关系 R(X,Y)，X和Y为属性组，当 t[X]=x时，x在R中的象集为：$Y_x=\{t[Y]|t \in R, t[X]=x\}$

除：给定关系 R(X,Y) 和 S(Y,X)，其中 X,Y,Z 为属性组。R中的Y和S中的Y可以有不同的名字，但必须取自同一个域，R与S除得到一个新关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X分量值x的象集$Y_x$包含S在Y上投影的集合，记作：$R \div S = \{t_r[X]|t_r \in R \land \pi_y(S) \subseteq Y_x \}$

![除运算](https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20180701_%E9%99%A4%E8%BF%90%E7%AE%97.png)

## 3. 约束

数据的约束条件是一组完整性规则的集合，这些规则用来限定数据模型中的数据，使其符合某种特征，比如对学生年龄的限定，奖金必须低于基本工资等。

关系模型的完整性约束主要包括

1. 实体完整性：主码中的属性不可取空值
2. 参照完整性：关系中的某个属性列与另一个关系的主码对应
3. 用户自定义完整性：类似于学生年龄取值这种符合现实特征的
