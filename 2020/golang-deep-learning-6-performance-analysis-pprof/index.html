<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Golang深入学习6-使用pprof进行性能分析 | Shuzang's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="书藏的个人博客，包括Golang、数据结构、算法的学习记录，各类生活技能的学习，每周五发布一期自己的生活周刊"><link rel=prev href=https://shuzang.github.io/2020/golang-deep-learning-5-debug-with-dlv/><link rel=next href=https://shuzang.github.io/2020/golang-deep-learning-7-scheduler-and-garbage-collection/><link rel=canonical href=https://shuzang.github.io/2020/golang-deep-learning-6-performance-analysis-pprof/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang深入学习6-使用pprof进行性能分析"><meta name=twitter:description content="pprof 用来做 Go 程序的性能监控，让我们知道在什么地方耗费了多少 CPU、memory。"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang深入学习6-使用pprof进行性能分析","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2020\/golang-deep-learning-6-performance-analysis-pprof\/"},"image":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Go语法","wordcount":4680,"url":"https:\/\/shuzang.github.io\/2020\/golang-deep-learning-6-performance-analysis-pprof\/","datePublished":"2020-07-27T18:46:00\x2b08:00","dateModified":"2020-07-27T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"shuzang","logo":{"@type":"ImageObject","url":"https:\/\/shuzang.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://shuzang.github.io>Shuzang's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://shuzang.github.io>Shuzang's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://shuzang.github.io/posts>Posts</a><a class=menu-item href=https://shuzang.github.io/tags>Tags</a><a class=menu-item href=https://shuzang.github.io/categories>Categories</a><a class=menu-item href=https://shuzang.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">Golang深入学习6-使用pprof进行性能分析</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2020-07-27>2020-07-27</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 4680 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://shuzang.github.io/categories/golang%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/>Golang学习之路</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1-引入>1. 引入</a></li><li><a href=#2-分析普通程序>2. 分析普通程序</a></li><li><a href=#2-时间与存储优化>2. 时间与存储优化</a></li><li><a href=#3-分析网络程序>3. 分析网络程序</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#1-引入>1. 引入</a></li><li><a href=#2-分析普通程序>2. 分析普通程序</a></li><li><a href=#2-时间与存储优化>2. 时间与存储优化</a></li><li><a href=#3-分析网络程序>3. 分析网络程序</a></li></ul></nav></div></details></div><div class=post-content><p>pprof 用来做 Go 程序的性能监控，让我们知道在什么地方耗费了多少 CPU、memory。</p><p>pprof 关注的方面有：</p><ul><li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li><li>Memory Profile（Heap Profile）：报告程序的内存使用情况</li><li>Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈</li><li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li></ul><a class=post-dummy-target id=1-引入></a><h2>1. 引入</h2><p>pprof 可以从以下两个包中引入：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>import</span> <span class=s>&#34;net/http/pprof&#34;</span>
<span class=kn>import</span> <span class=s>&#34;runtime/pprof&#34;</span>
</code></pre></td></tr></table></div></div><p>其中 net/http/pprof 底层使用 runtime/pprof 包，只是进行了一下封装，并在 http 端口上暴露出来。</p><p>如果我们的服务是一直运行的，如 web 应用，通过简单的导入 <code>import _ "net/http/pprof"</code>，就可以在运行 web 应用后在浏览器 http://localhost:port/debug/pprof 直接看到当前 web 服务的状态，包括 CPU 占用情况和内存使用情况等。</p><p>如果我们的程序不是 web 应用，而是一个服务进程，那么可以导入 <code>net/http/pprof</code> 包，然后主动开启一个 Goroutine 在端口进行监听</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;localhost:6060&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span><span class=p>)</span>
<span class=p>}</span><span class=p>(</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>如果我们的程序只是简单的 Go 程序，那么只能使用 <code>runtime/pprof</code> 包，具体做法是在代码中加入下面这段程序，然后在运行时（go run 或 go build等命令）加入 &ndash;cpuprofile 参数，比如 <code>go run demo.go --cpuprofile=demo.prof</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>cpuprofile</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;cpuprofile&#34;</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=s>&#34;write cpu profile to file&#34;</span><span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>(</span><span class=p>)</span>
    <span class=k>if</span> <span class=o>*</span><span class=nx>cpuprofile</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
        <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=o>*</span><span class=nx>cpuprofile</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=nx>pprof</span><span class=p>.</span><span class=nf>StartCPUProfile</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
        <span class=k>defer</span> <span class=nx>pprof</span><span class=p>.</span><span class=nf>StopCPUProfile</span><span class=p>(</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=o>...</span>
</code></pre></td></tr></table></div></div><p>命令执行完后当前目录会生成 demo.prof 文件，其中记录了 CPU 运行的信息，下一步就可以利用该文件查看相关的信息，使用 go tool pprof 命令来执行，如果要进行可视化，需要安装 <a href=http://www.graphviz.org/ target=_blank>graphviz</a></p><p>win10 下可以使用 chocolatye 或 winget 安装，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-powershell data-lang=powershell><span class=p>&gt;</span> <span class=n>choco</span> <span class=n>install</span> <span class=n>graphviz</span>
<span class=c># 或</span>
<span class=p>&gt;</span> <span class=n>winget</span> <span class=n>install</span> <span class=n>graphviz</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=2-分析普通程序></a><h2>2. 分析普通程序</h2><p>主要参考的文章是 Go Post 中的 <a href=https://blog.go-zh.org/profiling-go-programs target=_blank>Profiling Go Programs</a></p><p>测试代码来自于 <a href=https://github.com/rsc/benchgraffiti/tree/master/havlak>https://github.com/rsc/benchgraffiti/tree/master/havlak</a></p><p>我们使用 go mod 建立了一个测试项目文件夹，第一次使用测试代码中的 havlak1.go 文件，将该文件复制到测试项目根目录。由于其中已经引入了 <code>runtime/pprof</code> 包并包含了如下代码，我们不需要做修改，执行执行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>cpuprofile</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;cpuprofile&#34;</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=s>&#34;write cpu profile to file&#34;</span><span class=p>)</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>(</span><span class=p>)</span>
    <span class=k>if</span> <span class=o>*</span><span class=nx>cpuprofile</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
        <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=o>*</span><span class=nx>cpuprofile</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=nx>pprof</span><span class=p>.</span><span class=nf>StartCPUProfile</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
        <span class=k>defer</span> <span class=nx>pprof</span><span class=p>.</span><span class=nf>StopCPUProfile</span><span class=p>(</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=o>...</span>
</code></pre></td></tr></table></div></div><p>执行时加入 &ndash;cpuprofile=havlak1.prof 参数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go build havlak1.go

$ ./havlak1 --cpuprofile<span class=o>=</span>havlak1.prof
<span class=c1># of loops: 76000 (including 1 artificial root node)</span>

$ ls
go.mod  havlak1.exe  havlak1.go  havlak1.prof
</code></pre></td></tr></table></div></div><p>然后运行 <code>go tool pprof</code> 命令与 profile 交互</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go tool pprof havlak1.exe havlak1.prof
File: havlak1.exe
Type: cpu
Time: Jul 25, <span class=m>2020</span> at 7:23pm <span class=o>(</span>CST<span class=o>)</span>
Duration: 21.52s, Total <span class=nv>samples</span> <span class=o>=</span> 34.77s <span class=o>(</span>161.56%<span class=o>)</span>
Entering interactive mode <span class=o>(</span><span class=nb>type</span> <span class=s2>&#34;help&#34;</span> <span class=k>for</span> commands, <span class=s2>&#34;o&#34;</span> <span class=k>for</span> options<span class=o>)</span>
<span class=o>(</span>pprof<span class=o>)</span>
</code></pre></td></tr></table></div></div><p>最主要的命令是 <code>topN</code> ，用来输出最耗 CPU 的前N个调用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=p>(</span><span class=nx>pprof</span><span class=p>)</span> <span class=nx>top10</span>
<span class=nx>Showing</span> <span class=nx>nodes</span> <span class=nx>accounting</span> <span class=k>for</span> <span class=mi>21340</span><span class=nx>ms</span><span class=p>,</span> <span class=mf>61.37</span><span class=o>%</span> <span class=nx>of</span> <span class=mi>34770</span><span class=nx>ms</span> <span class=nx>total</span>
<span class=nx>Dropped</span> <span class=mi>168</span> <span class=nf>nodes</span> <span class=p>(</span><span class=nx>cum</span> <span class=o>&lt;=</span> <span class=mf>173.85</span><span class=nx>ms</span><span class=p>)</span>
<span class=nx>Showing</span> <span class=nx>top</span> <span class=mi>10</span> <span class=nx>nodes</span> <span class=nx>out</span> <span class=nx>of</span> <span class=mi>89</span>
      <span class=nx>flat</span>  <span class=nx>flat</span><span class=o>%</span>   <span class=nx>sum</span><span class=o>%</span>        <span class=nx>cum</span>   <span class=nx>cum</span><span class=o>%</span>
    <span class=mi>5340</span><span class=nx>ms</span> <span class=mf>15.36</span><span class=o>%</span> <span class=mf>15.36</span><span class=o>%</span>    <span class=mi>12320</span><span class=nx>ms</span> <span class=mf>35.43</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>scanobject</span>
    <span class=mi>3190</span><span class=nx>ms</span>  <span class=mf>9.17</span><span class=o>%</span> <span class=mf>24.53</span><span class=o>%</span>     <span class=mi>3650</span><span class=nx>ms</span> <span class=mf>10.50</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>mapaccess1_fast64</span>
    <span class=mi>2650</span><span class=nx>ms</span>  <span class=mf>7.62</span><span class=o>%</span> <span class=mf>32.15</span><span class=o>%</span>    <span class=mi>16670</span><span class=nx>ms</span> <span class=mf>47.94</span><span class=o>%</span>  <span class=nx>main</span><span class=p>.</span><span class=nx>FindLoops</span>
    <span class=mi>2240</span><span class=nx>ms</span>  <span class=mf>6.44</span><span class=o>%</span> <span class=mf>38.60</span><span class=o>%</span>     <span class=mi>3320</span><span class=nx>ms</span>  <span class=mf>9.55</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>findObject</span>
    <span class=mi>1800</span><span class=nx>ms</span>  <span class=mf>5.18</span><span class=o>%</span> <span class=mf>43.77</span><span class=o>%</span>     <span class=mi>2920</span><span class=nx>ms</span>  <span class=mf>8.40</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>greyobject</span>
    <span class=mi>1490</span><span class=nx>ms</span>  <span class=mf>4.29</span><span class=o>%</span> <span class=mf>48.06</span><span class=o>%</span>     <span class=mi>6540</span><span class=nx>ms</span> <span class=mf>18.81</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>mallocgc</span>
    <span class=mi>1480</span><span class=nx>ms</span>  <span class=mf>4.26</span><span class=o>%</span> <span class=mf>52.32</span><span class=o>%</span>     <span class=mi>4230</span><span class=nx>ms</span> <span class=mf>12.17</span><span class=o>%</span>  <span class=nx>main</span><span class=p>.</span><span class=nx>DFS</span>
    <span class=mi>1230</span><span class=nx>ms</span>  <span class=mf>3.54</span><span class=o>%</span> <span class=mf>55.85</span><span class=o>%</span>     <span class=mi>3510</span><span class=nx>ms</span> <span class=mf>10.09</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>mapassign_fast64ptr</span>
    <span class=mi>1000</span><span class=nx>ms</span>  <span class=mf>2.88</span><span class=o>%</span> <span class=mf>58.73</span><span class=o>%</span>     <span class=mi>1450</span><span class=nx>ms</span>  <span class=mf>4.17</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>heapBitsSetType</span>
     <span class=mi>920</span><span class=nx>ms</span>  <span class=mf>2.65</span><span class=o>%</span> <span class=mf>61.37</span><span class=o>%</span>     <span class=mi>1050</span><span class=nx>ms</span>  <span class=mf>3.02</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nf>spanOf</span> <span class=p>(</span><span class=nx>inline</span><span class=p>)</span>
<span class=p>(</span><span class=nx>pprof</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><ul><li>flat、flat% 表示函数在 CPU上运行的时间及百分比</li><li>sum% 表示列表中自己包括前面的函数CPU使用比例的累积，比如第三行 main.FindLoops 显示的 32.15% 其实就等于前面三个调用的比例之和 15.36% + 9.17% + 7.62% = 32.15%</li><li>cum、cum% 表示该函数及其子函数运行所占的时间总和及比例总和，应该大于等于自己执行所占的时间和比例，也就是最前面两列</li></ul><p>添加 -cum 参数可以按照 cum 来排序</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=p>(</span><span class=nx>pprof</span><span class=p>)</span> <span class=nx>top5</span> <span class=o>-</span><span class=nx>cum</span>
<span class=nx>Showing</span> <span class=nx>nodes</span> <span class=nx>accounting</span> <span class=k>for</span> <span class=mf>2.67</span><span class=nx>s</span><span class=p>,</span> <span class=mf>7.68</span><span class=o>%</span> <span class=nx>of</span> <span class=mf>34.77</span><span class=nx>s</span> <span class=nx>total</span>
<span class=nx>Dropped</span> <span class=mi>168</span> <span class=nf>nodes</span> <span class=p>(</span><span class=nx>cum</span> <span class=o>&lt;=</span> <span class=mf>0.17</span><span class=nx>s</span><span class=p>)</span>
<span class=nx>Showing</span> <span class=nx>top</span> <span class=mi>5</span> <span class=nx>nodes</span> <span class=nx>out</span> <span class=nx>of</span> <span class=mi>89</span>
      <span class=nx>flat</span>  <span class=nx>flat</span><span class=o>%</span>   <span class=nx>sum</span><span class=o>%</span>        <span class=nx>cum</span>   <span class=nx>cum</span><span class=o>%</span>
         <span class=mi>0</span>     <span class=mi>0</span><span class=o>%</span>     <span class=mi>0</span><span class=o>%</span>     <span class=mf>16.79</span><span class=nx>s</span> <span class=mf>48.29</span><span class=o>%</span>  <span class=nx>main</span><span class=p>.</span><span class=nx>main</span>
         <span class=mi>0</span>     <span class=mi>0</span><span class=o>%</span>     <span class=mi>0</span><span class=o>%</span>     <span class=mf>16.79</span><span class=nx>s</span> <span class=mf>48.29</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nx>main</span>
         <span class=mi>0</span>     <span class=mi>0</span><span class=o>%</span>     <span class=mi>0</span><span class=o>%</span>     <span class=mf>16.67</span><span class=nx>s</span> <span class=mf>47.94</span><span class=o>%</span>  <span class=nx>main</span><span class=p>.</span><span class=nf>FindHavlakLoops</span> <span class=p>(</span><span class=nx>inline</span><span class=p>)</span>
     <span class=mf>2.65</span><span class=nx>s</span>  <span class=mf>7.62</span><span class=o>%</span>  <span class=mf>7.62</span><span class=o>%</span>     <span class=mf>16.67</span><span class=nx>s</span> <span class=mf>47.94</span><span class=o>%</span>  <span class=nx>main</span><span class=p>.</span><span class=nx>FindLoops</span>
     <span class=mf>0.02</span><span class=nx>s</span> <span class=mf>0.058</span><span class=o>%</span>  <span class=mf>7.68</span><span class=o>%</span>     <span class=mf>15.16</span><span class=nx>s</span> <span class=mf>43.60</span><span class=o>%</span>  <span class=nx>runtime</span><span class=p>.</span><span class=nf>systemstack</span>
<span class=p>(</span><span class=nx>pprof</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>实际上 main.FindLoops 和 main.main 的总和应当为 100%，但是 pprof 不会统计所有的调用，递归调用层次过深的一些执行会被忽略。</p><p>另外，使用 <code>web</code> 命令可以生成调用关系图，是一个 svg 文件，可视化的方式可以帮助我们更好的理解，该命令需要 graphviz 工具的支持，这也是为什么前面要安装它</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=o>(</span>pprof<span class=o>)</span> web
</code></pre></td></tr></table></div></div><p>执行该命令后图片会自动打开</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/Go_20200727_pprof002.png alt class=lazyload></figure></p><p>图片中每个方框都代表一个函数，方框的大小根据 CPU 占用比例确定，箭头表示调用关系，从上到下调用层次逐渐加深，表示调用的线条上出现的数字表示调用次数，递归调用自身会有一个自己指向自己的箭头。</p><p>从图中看到 mapaccess 占用比例较大，我们可以只显示与它相关的调用，从而使图片逻辑更清晰。可以看到 mapaccess1 主要由 main.FindLoops 和 main.DFS 调用。</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/Go_20200727_pprof003.png alt class=lazyload></figure></p><p>我们还可以通过指定函数进入某个函数的细节，DFS逻辑比较简单，以它为例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=o>(</span>pprof<span class=o>)</span> web DFS
</code></pre></td></tr></table></div></div><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/Go_20200727_pprof004.png alt class=lazyload></figure></p><p>也可以使用命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=o>(</span>pprof<span class=o>)</span> list DFS
Total: 34.77s
<span class=nv>ROUTINE</span> <span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span> main.DFS in F:<span class=se>\G</span>o-web<span class=se>\h</span>avlak1.go
     1.48s      8.38s <span class=o>(</span>flat, cum<span class=o>)</span> 24.10% of Total
         .          .    233:   <span class=k>return</span> <span class=nb>false</span>
         .          .    234:<span class=o>}</span>
         .          .    235:
         .          .    236:// DFS - Depth-First-Search and node numbering.
         .          .    237://
      30ms       30ms    238:func DFS<span class=o>(</span>currentNode *BasicBlock, nodes <span class=o>[</span><span class=o>]</span>*UnionFindNode, number map<span class=o>[</span>*BasicBlock<span class=o>]</span>int, last <span class=o>[</span><span class=o>]</span>int, current int<span class=o>)</span> int <span class=o>{</span>
      20ms      240ms    239:   nodes<span class=o>[</span>current<span class=o>]</span>.Init<span class=o>(</span>currentNode, current<span class=o>)</span>
      20ms      340ms    240:   number<span class=o>[</span>currentNode<span class=o>]</span> <span class=o>=</span> current
         .          .    241:
         .          .    242:   lastid :<span class=o>=</span> current
     1.02s      1.02s    243:   <span class=k>for</span> _, target :<span class=o>=</span> range currentNode.OutEdges <span class=o>{</span>
     190ms      1.73s    244:           <span class=k>if</span> number<span class=o>[</span>target<span class=o>]</span> <span class=o>=</span><span class=o>=</span> unvisited <span class=o>{</span>
      80ms      4.23s    245:                   <span class=nv>lastid</span> <span class=o>=</span> DFS<span class=o>(</span>target, nodes, number, last, lastid+1<span class=o>)</span>
         .          .    246:           <span class=o>}</span>
         .          .    247:   <span class=o>}</span>
      80ms      750ms    248:   last<span class=o>[</span>number<span class=o>[</span>currentNode<span class=o>]</span><span class=o>]</span> <span class=o>=</span> lastid
      40ms       40ms    249:   <span class=k>return</span> lastid
         .          .    250:<span class=o>}</span>
         .          .    251:
         .          .    252:// FindLoops
         .          .    253://
         .          .    254:// Find loops and build loop forest using Havlak<span class=err>&#39;</span>s algorithm, which
<span class=o>(</span>pprof<span class=o>)</span>
</code></pre></td></tr></table></div></div><p>前两列分别是 flat 和 cum，也就是该行执行占用的时间和该行及该行调用的函数执行占用的总时间，第三列是源码行数。所以我们看到第 245 行由于出现了 DFS 这个递归函数，总占用时间为 4.23s，是最多的。除了该行之外，占用最多的就是第239、240、248三行，主要原因是映射的使用占用了大量时间，所以我们在使用中应尽可能使用数组和切片，而减少使用映射。</p><a class=post-dummy-target id=2-时间与存储优化></a><h2>2. 时间与存储优化</h2><p>将 DFS 函数参数中的 number 由映射更改为切片，可以将运行时间减少两倍，我们使用测试文件列表中的 havlak2.go，执行同样的测试过程可以验证这一点，原先的 DFS cum 是 4230ms，现在已经只有 830ms。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go build havlak2.go

$ ./havlak2 --cpuprofile<span class=o>=</span>havlak2.prof
<span class=c1># of loops: 76000 (including 1 artificial root node)</span>

$ go tool pprof havlak2.exe havlak2.prof
File: havlak2.exe
Type: cpu
Time: Jul 25, <span class=m>2020</span> at 8:51pm <span class=o>(</span>CST<span class=o>)</span>
Duration: 12.36s, Total <span class=nv>samples</span> <span class=o>=</span> 22.91s <span class=o>(</span>185.34%<span class=o>)</span>
Entering interactive mode <span class=o>(</span><span class=nb>type</span> <span class=s2>&#34;help&#34;</span> <span class=k>for</span> commands, <span class=s2>&#34;o&#34;</span> <span class=k>for</span> options<span class=o>)</span>
<span class=o>(</span>pprof<span class=o>)</span> top10
Showing nodes accounting <span class=k>for</span> 14360ms, 62.68% of 22910ms total
Dropped <span class=m>132</span> nodes <span class=o>(</span>cum &lt;<span class=o>=</span> 114.55ms<span class=o>)</span>
Showing top <span class=m>10</span> nodes out of <span class=m>85</span>
      flat  flat%   sum%        cum   cum%
    4130ms 18.03% 18.03%     9810ms 42.82%  runtime.scanobject
    1850ms  8.08% 26.10%     2570ms 11.22%  runtime.findObject
    1800ms  7.86% 33.96%    11070ms 48.32%  main.FindLoops
    1530ms  6.68% 40.64%     2510ms 10.96%  runtime.greyobject
    1450ms  6.33% 46.97%     5940ms 25.93%  runtime.mallocgc
     950ms  4.15% 51.11%     1290ms  5.63%  runtime.heapBitsSetType
     680ms  2.97% 54.08%      830ms  3.62%  main.DFS
     670ms  2.92% 57.01%      670ms  2.92%  runtime.memclrNoHeapPointers
     670ms  2.92% 59.93%      670ms  2.92%  runtime.nextFreeFast
     630ms  2.75% 62.68%      630ms  2.75%  runtime.arenaIndex <span class=o>(</span>partial-inline<span class=o>)</span> 
</code></pre></td></tr></table></div></div><p>附： <a href=https://github.com/rsc/benchgraffiti/commit/58ac27bcac3ffb553c29d0b3fb64745c91c95948 target=_blank>diff between havlak1 and havlak2</a></p><p>现在，DFS 不再是时间瓶颈，取而代之的是内存分配与垃圾回收，上面的结果中 runtime.mallocgc 占了一大部分。为了找出为什么垃圾回收时间占用这么多，我们来分析内存占用，这时候使用 memprofile ，不再是 cpuprofile。首先在主函数中替换如下部分</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>memprofile</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;memprofile&#34;</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=s>&#34;write memory profile to this file&#34;</span><span class=p>)</span>
<span class=o>...</span>

    <span class=nf>FindHavlakLoops</span><span class=p>(</span><span class=nx>cfgraph</span><span class=p>,</span> <span class=nx>lsgraph</span><span class=p>)</span>
    <span class=k>if</span> <span class=o>*</span><span class=nx>memprofile</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
        <span class=nx>f</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=o>*</span><span class=nx>memprofile</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
        <span class=p>}</span>
        <span class=nx>pprof</span><span class=p>.</span><span class=nf>WriteHeapProfile</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
        <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>(</span><span class=p>)</span>
        <span class=k>return</span>
    <span class=p>}</span>
</code></pre></td></tr></table></div></div><p>然后使用 &ndash;memprofile 标志编译源码，此时使用测试文件列表中的 havlak3</p><p>附：<a href=https://github.com/rsc/benchgraffiti/commit/b78dac106bea1eb3be6bb3ca5dba57c130268232 target=_blank>diff from havlak2</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go build havlak3.go

$ ./havlak3 --memprofile<span class=o>=</span>havlak3.mprof

$ go tool pprof havlak3.exe havlak3.mprof
$ go tool pprof havlak3.exe havlak3.mprof
File: havlak3.exe
Type: inuse_space
Time: Jul 25, <span class=m>2020</span> at 9:07pm <span class=o>(</span>CST<span class=o>)</span>
Entering interactive mode <span class=o>(</span><span class=nb>type</span> <span class=s2>&#34;help&#34;</span> <span class=k>for</span> commands, <span class=s2>&#34;o&#34;</span> <span class=k>for</span> options<span class=o>)</span>
<span class=o>(</span>pprof<span class=o>)</span> top5
Showing nodes accounting <span class=k>for</span> 53.39MB, 100% of 53.39MB total
Showing top <span class=m>5</span> nodes out of <span class=m>13</span>
      flat  flat%   sum%        cum   cum%
   33.10MB 62.00% 62.00%    33.10MB 62.00%  main.FindLoops
   11.50MB 21.54% 83.54%    11.50MB 21.54%  main.NewBasicBlock <span class=o>(</span>inline<span class=o>)</span>
    4.50MB  8.43% 91.96%     4.50MB  8.43%  main.<span class=o>(</span>*BasicBlock<span class=o>)</span>.AddInEdge
    2.29MB  4.29% 96.25%    13.79MB 25.83%  main.<span class=o>(</span>*CFG<span class=o>)</span>.CreateNode
       2MB  3.75%   100%        2MB  3.75%  main.<span class=o>(</span>*BasicBlock<span class=o>)</span>.AddOutEdge
<span class=o>(</span>pprof<span class=o>)</span>
</code></pre></td></tr></table></div></div><p>flat 和 cum 已经从时间占用变成了存储占用，可以看到 main.FindLoops 占用最多，达到了 62.00%，使用 <code>list</code> 命令查看具体情况</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=o>(</span>pprof<span class=o>)</span> list FindLoops
Total: 53.39MB
<span class=nv>ROUTINE</span> <span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span> main.FindLoops in F:<span class=se>\G</span>o-web<span class=se>\h</span>avlak3.go
   33.10MB    33.10MB <span class=o>(</span>flat, cum<span class=o>)</span> 62.00% of Total
         .          .    261:           <span class=k>return</span>
         .          .    262:   <span class=o>}</span>
         .          .    263:
         .          .    264:   size :<span class=o>=</span> cfgraph.NumNodes<span class=o>(</span><span class=o>)</span>
         .          .    265:
    1.97MB     1.97MB    266:   nonBackPreds :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>map<span class=o>[</span>int<span class=o>]</span>bool, size<span class=o>)</span>
    5.77MB     5.77MB    267:   backPreds :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span><span class=o>[</span><span class=o>]</span>int, size<span class=o>)</span>
         .          .    268:
    1.97MB     1.97MB    269:   number :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size<span class=o>)</span>
    1.97MB     1.97MB    270:   header :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
    1.97MB     1.97MB    271:   types :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
    1.97MB     1.97MB    272:   last :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
    1.97MB     1.97MB    273:   nodes :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>*UnionFindNode, size, size<span class=o>)</span>        
         .          .    274:
         .          .    275:   <span class=k>for</span> i :<span class=o>=</span> 0<span class=p>;</span> i &lt; size<span class=p>;</span> i++ <span class=o>{</span>
      11MB       11MB    276:           nodes<span class=o>[</span>i<span class=o>]</span> <span class=o>=</span> new<span class=o>(</span>UnionFindNode<span class=o>)</span>
         .          .    277:   <span class=o>}</span>
         .          .    278:
         .          .    279:   // Step a:
         .          .    280:   //   - initialize all nodes as unvisited.
         .          .    281:   //   - depth-first traversal and numbering.        
         .          .    282:   //   - unreached BB<span class=err>&#39;</span>s are marked as dead.
         .          .    283:   //
         .          .    284:   <span class=k>for</span> i, bb :<span class=o>=</span> range cfgraph.Blocks <span class=o>{</span>
         .          .    285:           number<span class=o>[</span>bb.Name<span class=o>]</span> <span class=o>=</span> unvisited
    4.50MB     4.50MB    286:           nonBackPreds<span class=o>[</span>i<span class=o>]</span> <span class=o>=</span> make<span class=o>(</span>map<span class=o>[</span>int<span class=o>]</span>bool<span class=o>)</span>       
         .          .    287:   <span class=o>}</span>
         .          .    288:
         .          .    289:   DFS<span class=o>(</span>cfgraph.Start, nodes, number, last, 0<span class=o>)</span>
         .          .    290:
         .          .    291:   // Step b:
<span class=o>(</span>pprof<span class=o>)</span>
</code></pre></td></tr></table></div></div><p>瓶颈依然在于 UnionFindNode 结构体的初始化和映射。</p><p>另外，如果我们执行 <code>go tool pprof</code> 加入 <code>--inuse_objects</code> ，看到的不是内存使用而是调用计数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go tool pprof --inuse_objects havlak3.exe havlak3.mprof
File: havlak3.exe
Type: inuse_objects
Time: Jul 25, <span class=m>2020</span> at 9:07pm <span class=o>(</span>CST<span class=o>)</span>
Entering interactive mode <span class=o>(</span><span class=nb>type</span> <span class=s2>&#34;help&#34;</span> <span class=k>for</span> commands, <span class=s2>&#34;o&#34;</span> <span class=k>for</span> options<span class=o>)</span>
<span class=o>(</span>pprof<span class=o>)</span> list FindLoops
Total: <span class=m>1171490</span>
<span class=nv>ROUTINE</span> <span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span> main.FindLoops in F:<span class=se>\G</span>o-web<span class=se>\h</span>avlak3.go
    <span class=m>458774</span>     <span class=m>458774</span> <span class=o>(</span>flat, cum<span class=o>)</span> 39.16% of Total
         .          .    261:           <span class=k>return</span>
         .          .    262:   <span class=o>}</span>
         .          .    263:
         .          .    264:   size :<span class=o>=</span> cfgraph.NumNodes<span class=o>(</span><span class=o>)</span>
         .          .    265:
         <span class=m>1</span>          <span class=m>1</span>    266:   nonBackPreds :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>map<span class=o>[</span>int<span class=o>]</span>bool, size<span class=o>)</span>
         <span class=m>1</span>          <span class=m>1</span>    267:   backPreds :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span><span class=o>[</span><span class=o>]</span>int, size<span class=o>)</span>
         .          .    268:
         <span class=m>1</span>          <span class=m>1</span>    269:   number :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size<span class=o>)</span>
         <span class=m>1</span>          <span class=m>1</span>    270:   header :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
         <span class=m>1</span>          <span class=m>1</span>    271:   types :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
         <span class=m>1</span>          <span class=m>1</span>    272:   last :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
         <span class=m>1</span>          <span class=m>1</span>    273:   nodes :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>*UnionFindNode, size, size<span class=o>)</span>
         .          .    274:
         .          .    275:   <span class=k>for</span> i :<span class=o>=</span> 0<span class=p>;</span> i &lt; size<span class=p>;</span> i++ <span class=o>{</span>
    <span class=m>360459</span>     <span class=m>360459</span>    276:           nodes<span class=o>[</span>i<span class=o>]</span> <span class=o>=</span> new<span class=o>(</span>UnionFindNode<span class=o>)</span>
         .          .    277:   <span class=o>}</span>
         .          .    278:
         .          .    279:   // Step a:
         .          .    280:   //   - initialize all nodes as unvisited.
         .          .    281:   //   - depth-first traversal and numbering.
         .          .    282:   //   - unreached BB<span class=err>&#39;</span>s are marked as dead.
         .          .    283:   //
         .          .    284:   <span class=k>for</span> i, bb :<span class=o>=</span> range cfgraph.Blocks <span class=o>{</span>
         .          .    285:           number<span class=o>[</span>bb.Name<span class=o>]</span> <span class=o>=</span> unvisited
     <span class=m>98308</span>      <span class=m>98308</span>    286:           nonBackPreds<span class=o>[</span>i<span class=o>]</span> <span class=o>=</span> make<span class=o>(</span>map<span class=o>[</span>int<span class=o>]</span>bool<span class=o>)</span>
         .          .    287:   <span class=o>}</span>
         .          .    288:
         .          .    289:   DFS<span class=o>(</span>cfgraph.Start, nodes, number, last, 0<span class=o>)</span>
         .          .    290:
         .          .    291:   // Step b:
<span class=o>(</span>pprof<span class=o>)</span>
</code></pre></td></tr></table></div></div><p>这里依然是解决映射使用带来的影响，主要方式是将映射换成切片，这里使用测试文件列表中的 havlak4，可以看到总耗时又少了一点点。</p><p>附：<a href=https://github.com/rsc/benchgraffiti/commit/245d899f7b1a33b0c8148a4cd147cb3de5228c8a target=_blank>diff from havlak3</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go build havlak4.go

$ ./havlak4 --cpuprofile<span class=o>=</span>havlak4.prof
<span class=c1># of loops: 76000 (including 1 artificial root node)</span>

$ go tool pprof havlak4.exe havlak4.prof
File: havlak4.exe
Type: cpu
Time: Jul 25, <span class=m>2020</span> at 9:25pm <span class=o>(</span>CST<span class=o>)</span>
Duration: 7.35s, Total <span class=nv>samples</span> <span class=o>=</span> 13.03s <span class=o>(</span>177.21%<span class=o>)</span>
Entering interactive mode <span class=o>(</span><span class=nb>type</span> <span class=s2>&#34;help&#34;</span> <span class=k>for</span> commands, <span class=s2>&#34;o&#34;</span> <span class=k>for</span> options<span class=o>)</span>
<span class=o>(</span>pprof<span class=o>)</span> top10
Showing nodes accounting <span class=k>for</span> 8930ms, 68.53% of 13030ms total
Dropped <span class=m>104</span> nodes <span class=o>(</span>cum &lt;<span class=o>=</span> 65.15ms<span class=o>)</span>
Showing top <span class=m>10</span> nodes out of <span class=m>84</span>
      flat  flat%   sum%        cum   cum%
    2660ms 20.41% 20.41%     6190ms 47.51%  runtime.scanobject
    1450ms 11.13% 31.54%     5860ms 44.97%  main.FindLoops
    1110ms  8.52% 40.06%     1590ms 12.20%  runtime.findObject
     900ms  6.91% 46.97%     1580ms 12.13%  runtime.greyobject
     810ms  6.22% 53.18%     3300ms 25.33%  runtime.mallocgc
     620ms  4.76% 57.94%      820ms  6.29%  main.DFS
     390ms  2.99% 60.94%      500ms  3.84%  runtime.heapBitsSetType
     380ms  2.92% 63.85%      510ms  3.91%  runtime.spanOf <span class=o>(</span>inline<span class=o>)</span>
     310ms  2.38% 66.23%      310ms  2.38%  runtime.arenaIndex <span class=o>(</span>partial-inline<span class=o>)</span>    
     300ms  2.30% 68.53%      300ms  2.30%  runtime.memclrNoHeapPointers
<span class=o>(</span>pprof<span class=o>)</span> 
</code></pre></td></tr></table></div></div><p>现在，垃圾回收（runtime.mallocgc）占用 53.18%，我们来查看对它的调用</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/pprof005.png alt class=lazyload></figure></p><p>因为时间占比比较小的调用很多，看不出什么，我们可以在 <code>go tool pprof</code> 中添加 <code>--nodefraction=0.1</code> 参数过滤占用低于 10% 的调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go tool pprof --nodefraction<span class=o>=</span>0.1 havlak4.exe havlak4.prof
File: havlak4.exe
Type: cpu
Time: Jul 25, <span class=m>2020</span> at 9:25pm <span class=o>(</span>CST<span class=o>)</span>
Duration: 7.35s, Total <span class=nv>samples</span> <span class=o>=</span> 13.03s <span class=o>(</span>177.21%<span class=o>)</span>
Entering interactive mode <span class=o>(</span><span class=nb>type</span> <span class=s2>&#34;help&#34;</span> <span class=k>for</span> commands, <span class=s2>&#34;o&#34;</span> <span class=k>for</span> options<span class=o>)</span>
<span class=o>(</span>pprof<span class=o>)</span> web mallocgc
</code></pre></td></tr></table></div></div><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/Go_20200727_pprof006.png alt class=lazyload></figure></p><p>这就非常清楚了，FindLoops 是最主要的占用，然后我们查看它</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=o>(</span>pprof<span class=o>)</span> list FindLoops
Total: 13.03s
<span class=nv>ROUTINE</span> <span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span><span class=o>=</span> main.FindLoops in F:<span class=se>\G</span>o-web<span class=se>\h</span>avlak4.go
     1.45s      5.86s <span class=o>(</span>flat, cum<span class=o>)</span> 44.97% of Total
         .          .    270:           <span class=k>return</span>
         .          .    271:   <span class=o>}</span>
         .          .    272:
         .          .    273:   size :<span class=o>=</span> cfgraph.NumNodes<span class=o>(</span><span class=o>)</span>
         .          .    274:
         .       90ms    275:   nonBackPreds :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span><span class=o>[</span><span class=o>]</span>int, size<span class=o>)</span>
         .      210ms    276:   backPreds :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span><span class=o>[</span><span class=o>]</span>int, size<span class=o>)</span>
         .          .    277:
         .      250ms    278:   number :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size<span class=o>)</span>
         .      140ms    279:   header :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
         .       80ms    280:   types :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
         .       60ms    281:   last :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>int, size, size<span class=o>)</span>
         .       70ms    282:   nodes :<span class=o>=</span> make<span class=o>(</span><span class=o>[</span><span class=o>]</span>*UnionFindNode, size, size<span class=o>)</span>        
         .          .    283:
         .          .    284:   <span class=k>for</span> i :<span class=o>=</span> 0<span class=p>;</span> i &lt; size<span class=p>;</span> i++ <span class=o>{</span>
      10ms      590ms    285:           nodes<span class=o>[</span>i<span class=o>]</span> <span class=o>=</span> new<span class=o>(</span>UnionFindNode<span class=o>)</span>
         .          .    286:   <span class=o>}</span>
         .          .    287:
...
</code></pre></td></tr></table></div></div><p>每次 FindLoops 被调用，都会进行一系列的初始化工作，为了处理这些内存分配，垃圾回收器的占用才会那么高。所以我们要意识到，语言自带垃圾回收不意味着不需要再关心内存分配问题，这里解决该问题的方法是使用缓存，以便每次不需要重新分配和回收内存。</p><p>添加一个全局的结构 cache</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>cache</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>size</span> <span class=kt>int</span>
    <span class=nx>nonBackPreds</span> <span class=p>[</span><span class=p>]</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span>
    <span class=nx>backPreds</span> <span class=p>[</span><span class=p>]</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span>
    <span class=nx>number</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span>
    <span class=nx>header</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span>
    <span class=nx>types</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span>
    <span class=nx>last</span> <span class=p>[</span><span class=p>]</span><span class=kt>int</span>
    <span class=nx>nodes</span> <span class=p>[</span><span class=p>]</span><span class=o>*</span><span class=nx>UnionFindNode</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>然后在 FindLoops 中每次访问它而不是重新分配（这种方式并不是一种很好的方式，但是确实能在此程序中提升时间）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=k>if</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>size</span> <span class=p>&lt;</span> <span class=nx>size</span> <span class=p>{</span>
    <span class=nx>cache</span><span class=p>.</span><span class=nx>size</span> <span class=p>=</span> <span class=nx>size</span>
    <span class=nx>cache</span><span class=p>.</span><span class=nx>nonBackPreds</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
    <span class=nx>cache</span><span class=p>.</span><span class=nx>backPreds</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
    <span class=nx>cache</span><span class=p>.</span><span class=nx>number</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
    <span class=nx>cache</span><span class=p>.</span><span class=nx>header</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
    <span class=nx>cache</span><span class=p>.</span><span class=nx>types</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
    <span class=nx>cache</span><span class=p>.</span><span class=nx>last</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
    <span class=nx>cache</span><span class=p>.</span><span class=nx>nodes</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=p>[</span><span class=p>]</span><span class=o>*</span><span class=nx>UnionFindNode</span><span class=p>,</span> <span class=nx>size</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>nodes</span> <span class=p>{</span>
        <span class=nx>cache</span><span class=p>.</span><span class=nx>nodes</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>UnionFindNode</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=nx>nonBackPreds</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>nonBackPreds</span><span class=p>[</span><span class=p>:</span><span class=nx>size</span><span class=p>]</span>
<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nonBackPreds</span> <span class=p>{</span>
    <span class=nx>nonBackPreds</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>nonBackPreds</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=p>[</span><span class=p>:</span><span class=mi>0</span><span class=p>]</span>
<span class=p>}</span>
<span class=nx>backPreds</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>backPreds</span><span class=p>[</span><span class=p>:</span><span class=nx>size</span><span class=p>]</span>
<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nonBackPreds</span> <span class=p>{</span>
    <span class=nx>backPreds</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>backPreds</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=p>[</span><span class=p>:</span><span class=mi>0</span><span class=p>]</span>
<span class=p>}</span>
<span class=nx>number</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>number</span><span class=p>[</span><span class=p>:</span><span class=nx>size</span><span class=p>]</span>
<span class=nx>header</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>header</span><span class=p>[</span><span class=p>:</span><span class=nx>size</span><span class=p>]</span>
<span class=nx>types</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>types</span><span class=p>[</span><span class=p>:</span><span class=nx>size</span><span class=p>]</span>
<span class=nx>last</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>last</span><span class=p>[</span><span class=p>:</span><span class=nx>size</span><span class=p>]</span>
<span class=nx>nodes</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>nodes</span><span class=p>[</span><span class=p>:</span><span class=nx>size</span><span class=p>]</span>
</code></pre></td></tr></table></div></div><p>这一更改实现在了 havlak5 中，我们从测试文件列表中找到该文件并使用，发现时间占用已经减少到了 10s 以下</p><p>附：<a href=https://github.com/rsc/benchgraffiti/commit/2d41d6d16286b8146a3f697dd4074deac60d12a4 target=_blank>diff from havlak4</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ go build havlak5.go

$ ./havlak5.exe --cpuprofile<span class=o>=</span>havlak5.prof
<span class=c1># of loops: 76000 (including 1 artificial root node)</span>

$ go tool pprof havlak5.exe havlak5.prof
File: havlak5.exe
Type: cpu
Time: Jul 25, <span class=m>2020</span> at 9:46pm <span class=o>(</span>CST<span class=o>)</span>
Duration: 4.89s, Total <span class=nv>samples</span> <span class=o>=</span> 7.34s <span class=o>(</span>150.01%<span class=o>)</span>
Entering interactive mode <span class=o>(</span><span class=nb>type</span> <span class=s2>&#34;help&#34;</span> <span class=k>for</span> commands, <span class=s2>&#34;o&#34;</span> <span class=k>for</span> options<span class=o>)</span>
<span class=o>(</span>pprof<span class=o>)</span>
</code></pre></td></tr></table></div></div><p>还有很多的工作可以进行从而使程序更快，但都不需要 pprof 的协助，最终的版本 havlak6 可以减少到 2.29s 和 351M存储占用。</p><p>当然，最简单的方式是使用 go test 工具，Go 提供的测试机制可以很容易的提供 CPU 和存储的占用分析。</p><a class=post-dummy-target id=3-分析网络程序></a><h2>3. 分析网络程序</h2><p>就像我们一开始说的，分析一个网络程序更加的简单，只需要导入 <code>net/http/pprof</code> 包即可，不需要在程序中使用，只需要添加这一条导入语句。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kn>import</span> <span class=nx>_</span> <span class=s>&#34;net/http/pprof&#34;</span>
</code></pre></td></tr></table></div></div><p>导入该包会添加一些 /debug/pprof/ URL 下面的一些处理器函数，之后简单的运行 go tool pprof 然后添加服务器 URL就会实时的检查配置文件。</p><p>以我们之前写的一个文件上传下载应用为例，端口使用 8090，添加导入语句后，打开浏览器 http://localhost:8090/debug/pprof/，显示如下</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/Go_20200727_Snipaste_2020-07-25_22-01-39.png alt class=lazyload></figure></p><p>或者在命令行使用 <code>go tool pprof</code> 命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>go tool pprof http://localhost:8090/debug/pprof/profile   <span class=c1># 30-second CPU profile</span>
go tool pprof http://localhost:8090/debug/pprof/heap      <span class=c1># heap profile</span>
go tool pprof http://localhost:8090/debug/pprof/block     <span class=c1># goroutine blocking profile</span>
</code></pre></td></tr></table></div></div><p>进入 pprof 命令行界面后就和前面的使用没有区别了，这几个文件简单介绍如下</p><ul><li><code>/debug/pprof/profile</code>：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载</li><li><code>/debug/pprof/heap</code>： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件</li><li><code>/debug/pprof/block</code>：block Profiling 的路径</li></ul><p>最后，上面的导入形式是基于我们使用默认的 http.DefaultServeMux 的情况，如果使用了其它的包，比如 Mux，需要手动添加路由规则</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>r</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Index</span><span class=p>)</span>
<span class=nx>r</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/cmdline&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Cmdline</span><span class=p>)</span>
<span class=nx>r</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/profile&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Profile</span><span class=p>)</span>
<span class=nx>r</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/symbol&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Symbol</span><span class=p>)</span>
<span class=nx>r</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/debug/pprof/trace&#34;</span><span class=p>,</span> <span class=nx>pprof</span><span class=p>.</span><span class=nx>Trace</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>之后的使用就没有区别了。</p></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>shuzang</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2020-07-27</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fshuzang.github.io%2f2020%2fgolang-deep-learning-6-performance-analysis-pprof%2f&text=Golang%e6%b7%b1%e5%85%a5%e5%ad%a6%e4%b9%a06-%e4%bd%bf%e7%94%a8pprof%e8%bf%9b%e8%a1%8c%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fshuzang.github.io%2f2020%2fgolang-deep-learning-6-performance-analysis-pprof%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fshuzang.github.io%2f2020%2fgolang-deep-learning-6-performance-analysis-pprof%2f&title=Golang%e6%b7%b1%e5%85%a5%e5%ad%a6%e4%b9%a06-%e4%bd%bf%e7%94%a8pprof%e8%bf%9b%e8%a1%8c%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://shuzang.github.io/tags/go%E8%AF%AD%E6%B3%95/><i class="fas fa-tag fa-fw"></i>&nbsp;Go语法</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://shuzang.github.io>Home</a></span></section></div><div class=post-nav><a href=https://shuzang.github.io/2020/golang-deep-learning-5-debug-with-dlv/ class=prev rel=prev title=Golang深入学习5-使用dlv调试程序><i class="fas fa-angle-left fa-fw"></i>Golang深入学习5-使用dlv调试程序</a>
<a href=https://shuzang.github.io/2020/golang-deep-learning-7-scheduler-and-garbage-collection/ class=next rel=next title=Golang深入学习7-调度器与垃圾回收>Golang深入学习7-调度器与垃圾回收<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://shuzang.github.io/about/ target=_blank>shuzang</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span></a>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-209130979-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>