<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>算法-递归 - Shuzang's Blog</title><meta name=author content><meta name=author-link content><meta name=description content="首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。

递归是一种编程技巧，一种解决问题的思维方式；
分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）；
贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。
"><meta name=keywords content="数据结构与算法"><meta itemprop=name content="算法-递归"><meta itemprop=description content="首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。

递归是一种编程技巧，一种解决问题的思维方式；
分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）；
贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。
"><meta itemprop=datePublished content="2020-04-12T00:00:00+00:00"><meta itemprop=dateModified content="2020-07-05T00:00:00+00:00"><meta itemprop=wordCount content="2960"><meta itemprop=image content="https://shuzang.github.io/logo.png"><meta itemprop=keywords content="数据结构与算法,"><meta property="og:title" content="算法-递归"><meta property="og:description" content="首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。

递归是一种编程技巧，一种解决问题的思维方式；
分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）；
贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。
"><meta property="og:type" content="article"><meta property="og:url" content="https://shuzang.github.io/2020/algorithm-recursive/"><meta property="og:image" content="https://shuzang.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-12T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-05T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shuzang.github.io/logo.png"><meta name=twitter:title content="算法-递归"><meta name=twitter:description content="首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。

递归是一种编程技巧，一种解决问题的思维方式；
分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）；
贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。
"><meta name=application-name content="Shuzang's Blog"><meta name=apple-mobile-web-app-title content="Shuzang's Blog"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://shuzang.github.io/2020/algorithm-recursive/><link rel=prev href=https://shuzang.github.io/2020/about-personalized-advertising/><link rel=next href=https://shuzang.github.io/2020/algorithm-divide-and-conquer/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.2.0/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.2.0/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"算法-递归","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2020\/algorithm-recursive\/"},"genre":"posts","keywords":"数据结构与算法","wordcount":2960,"url":"https:\/\/shuzang.github.io\/2020\/algorithm-recursive\/","datePublished":"2020-04-12T00:00:00+00:00","dateModified":"2020-07-05T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"作者"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-title="Shuzang's Blog" data-alt="Shuzang's Blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collection/><i class="fa-solid fa-bookmark fa-fw fa-sm" aria-hidden=true></i> 集子</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/avatar.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/collection/><i class="fa-solid fa-bookmark fa-fw fa-sm" aria-hidden=true></i> 集子</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>算法-递归</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i></span></span>
<span class=post-category>收录于 <a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 爱编程爱技术的孩子</a></span></div><div class=post-meta-line><span title="发布于 2020-04-12 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2020-04-12>2020-04-12</time></span>&nbsp;<span title="更新于 2020-07-05 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2020-07-05>2020-07-05</time></span>&nbsp;<span title="2960 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 3000 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 6 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-递归原理>1. 递归原理</a></li><li><a href=#2-记忆化技术>2. 记忆化技术</a></li><li><a href=#3-复杂度分析>3. 复杂度分析</a><ul><li><a href=#31-时间复杂度>3.1 时间复杂度</a></li><li><a href=#32-空间复杂度>3.2 空间复杂度</a></li></ul></li><li><a href=#4-尾递归>4. 尾递归</a></li><li><a href=#5-原则>5. 原则</a></li></ul></nav></div></div><div class=content id=content><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2020-07-05，文中内容可能已过时。</div></div></div><p>首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。</p><ol><li>递归是一种编程技巧，一种解决问题的思维方式；</li><li>分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）；</li><li>贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。</li></ol><h2 id=1-递归原理>1. 递归原理</h2><p>递归的基本思想是<strong>某个函数直接或者间接地调用自身</strong>，核心在于将原问题拆解为性质相同但规模更小的子问题，函数不断地调用自身来解决子问题，直到分无可分，也就是到了无需递归就可以解决的地步，原问题就顺利解决掉了。</p><p>因此我们在思考递归问题时应明确两点</p><ol><li>明确递推关系，也就是原问题如何拆分到更小的子问题</li><li>明确结束条件，也就是最小的问题如何不使用递归来解决</li></ol><p>我们将递归的基本思路概述为一个模板如下</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>func</span> <span class=nf>Recursive</span><span class=p>(</span><span class=err>传入数值</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=err>结束条件</span> 
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=err>最小子问题解</span>
</span></span><span class=line><span class=cl>  <span class=n>Recursive</span><span class=p>(</span><span class=err>缩小规模</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>利用递归结果进行计算</span><span class=p>[</span><span class=err>可选</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>下面以一个简单的问题「以相反的顺序打印字符串」来进行说明。我们将函数定义为 <code>printReverse(str[0…n-1])</code>，其中<code>str[0]</code> 表示字符串的第一个字符，然后进行分析</p><ol><li>分解子问题。原问题可以拆解为先以相反的顺序打印子字符串 <code>str[1…n-1]</code>，然后打印第一个字符 <code>str[0]</code></li><li>结束条件。结束条件为如果当前字符串为空，直接返回。</li></ol><p>最终得到的代码如下</p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printReverse</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printReverse</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%c&#34;</span><span class=p>,</span><span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>需要我们牢记的一个结论是：凡是可计算函数都是一般递归函数，这就是著名的丘奇-图灵论点。</p><p>继续以「反转链表」为例进行说明，虽然迭代的方法更优，但这里我们只介绍递归的思路。</p><ol><li>结束条件是当前节点为 nil 或者当前节点的下一个节点为 nil，这两种情况不需要反转</li><li>子问题就是反转当前节点后面的部分</li><li>递归后要做的事情就是如何将当前节点添加到后面的反转的链表的末尾</li></ol><p>因此最后得到的代码如下</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>reverseList</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>ListNode</span><span class=p>)</span> <span class=o>*</span><span class=nx>ListNode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>head</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>head</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>     
</span></span><span class=line><span class=cl>    <span class=nx>tmp</span> <span class=o>:=</span> <span class=nf>reverseList</span><span class=p>(</span><span class=nx>head</span><span class=p>.</span><span class=nx>Next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>head</span>
</span></span><span class=line><span class=cl>    <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>tmp</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>这里最后的处理过程可以这样理解，假设列表为：
$$
n_1 → … → n_{k-1} → n_k → n_{k+1} → … → n_m → Ø
$$
若从节点 $n_{k+1}$ 到 $n_m$ 已经被反转，而我们正处于 $n_k$。
$$
n_1 → … → n_{k-1} → n_k → n_{k+1} ← … ← n_m
$$
我们希望 $n_{k+1}$ 的下一个节点指向 $n_k$, 那么只需要调整 $n_k$ 的指针即可，因为此时后面的链表末尾已经是节点 $n_{k+1}$ 了。所以执行</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>nk</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=nx>nk</span>
</span></span><span class=line><span class=cl><span class=nx>nk</span><span class=p>.</span><span class=nx>Next</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>// 处理边界条件 n1，否则产生循环
</span></span></span></code></pre></td></tr></table></div></div><p>还应该明白代码最后返回的 <code>tmp</code> 不是当前处理节点的下一个节点，而是后面已反转链表的头结点，这个头结点的指针是一级一级递归传回来的。</p><p>写递归最重要的一点是： <strong>明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。</strong> 如果跳进一层又一层的递归函数里思考，就会陷入无穷无尽的细节，人脑不是为了做这个的，递归本身就是在简化思维。比如上面的「反转链表」例子，我们确认了子问题具有与原问题相同的性质，因此 <code>reverseList(head.Next)</code> 可以翻转链表后面的部分，我们需要相信这一点，而不是跟随递归进入一层层的调用栈。</p><h2 id=2-记忆化技术>2. 记忆化技术</h2><p>递归的过程可能出现大量重复的计算，以斐波那契数列为例，如果我们定义函数 <code>F(n)</code> 表示在索引 <code>n</code> 处的斐波那契数，那么你可以推导出如下的递推关系：</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>F(n) = F(n - 1) + F(n - 2)</span></span></code></pre></td></tr></table></div></div><p>下面的树显示了在计算 <code>F(4)</code> 时发生的所有重复计算（按颜色分组）。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>为了消除上述情况中的重复计算，采用的一种方法是将中间结果存储在缓存中，以便随时重用，而不需要重新计算。这种方式叫做记忆化。</p><p>记忆化与动态规划的 DP 数组非常相似，但用在递归过程中，一般作为全局变量声明，或者由父函数通过参数进行传递。斐波那契树计算的记忆化方法举例如下</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>cache</span> <span class=p>=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fib</span><span class=p>(</span><span class=nx>N</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>N</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>N</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>memoize</span><span class=p>(</span><span class=nx>N</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>memoize</span><span class=p>(</span><span class=nx>N</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>[</span><span class=nx>N</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>cache</span><span class=p>[</span><span class=nx>N</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>cache</span><span class=p>[</span><span class=nx>N</span><span class=p>]</span> <span class=p>=</span> <span class=nf>memoize</span><span class=p>(</span><span class=nx>N</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=nf>memoize</span><span class=p>(</span><span class=nx>N</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>memoize</span><span class=p>(</span><span class=nx>N</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=3-复杂度分析>3. 复杂度分析</h2><h3 id=31-时间复杂度>3.1 时间复杂度</h3><p>给出一个递归算法，其时间复杂度$O(T)$ 通常是<strong>递归调用的数量</strong>（记作 R） 和计算的时间复杂度的乘积（表示为 $O(s)$）的乘积：
$$
O(T) = R * O(s)
$$
以反转字符串为例，由于每次将问题缩减为除第一个字符外的子串，因此函数一共被递归调用 n 次，n 为字符串长度。每次递归调用完毕后，仅仅将第一个字符输出，该操作的时间复杂度为 $O(1)$，因此总体时间复杂度为 $n * O(1) = O(n)$</p><p>对于递推关系涉及多个递归调用的情况，比如斐波那契数，其递推关系被定义为 <code>f(n) = f(n-1) + f(n-2)</code>，最好使用执行树来分析时间复杂度。<strong>执行树</strong>是一棵用于表示递归函数执行流程的树，树中每个节点都表示递归函数的调用，因此树的节点总数就对应递归调用的数量。</p><p>递归函数的执行树将形成 <code>n 叉树</code>，其中 <code>n</code> 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_fibonacci.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>如果构成了一棵 n 层的完全二叉树，那么节点总数就是 $2^n - 1$，因此时间复杂度计算中的递归调用数量就是 $O(2^n)$，算上最后的结果处理 $O(1)$，总的时间复杂度为 $O(2^n)$</p><p>但是如果我们使用了记忆化技术，从 1 到 n 每个值对应的斐波那契数计算只会发生一次，因此递归调用的数量变为 $O(n)$，最终的时间复杂度为 $O(n) * O(1) = O (n)$</p><h3 id=32-空间复杂度>3.2 空间复杂度</h3><p>空间复杂度考虑两部分：递归相关空间和非递归相关空间。</p><p>递归相关空间指由递归直接引起的内存开销，即用于跟踪递归函数调用的堆栈，为了完成函数调用，系统会在栈中分配空间来保存三个重要信息</p><ol><li>函数调用的返回地址</li><li>传递给函数调用的参数</li><li>函数调用的局部变量</li></ol><p>该空间在函数调用时产生，在调用完成后释放，但对于递归，栈空间将逐渐累积直到结束条件。递归函数中如果没有额外的空间消耗，则递归调用引起的栈空间消耗是递归空间复杂度的主要来源。</p><p>仍以反转字符串为例，函数处理逻辑中只有打印首字符会使用常数级空间，递归调用 n 次一共会产生 n 级的栈空间，因此最终的空间复杂度为 $O(n)$。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_stack.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_stack.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_stack.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_stack.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_stack.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_stack.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>由于为程序提供的栈空间通常是有限的，在递归调用层级过多时，可能会发生堆栈溢出的情况，此时无法分配新的栈空间进行下一步的递归调用，因此导致程序执行失败。所以在涉及递归算法时，应仔细评估在输入规模扩大时是否存在堆栈溢出的可能性。</p><p>非递归相关空间指与递归过程没有直接关系的内存空间，比如上面讨论中提到的打印首字符使用的空间，除此外还可能包括如全局变量等其它的空间使用，比如在利用记忆化优化递归时使用的全局数组，会占用 O(n) 的空间复杂度。</p><p>注意，这里递归相关空间与非递归相关空间不是相乘的关系。</p><h2 id=4-尾递归>4. 尾递归</h2><p>尾递归是递归函数的一种特殊情况，其中递归调用是递归函数的最后一条指令，并且其返回值不是表达式的一部分。举个例子</p><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 非尾递归
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>helper</span><span class=p>(</span><span class=nx>start</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>ls</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>start</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>ls</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>ls</span><span class=p>[</span><span class=nx>start</span><span class=p>]</span> <span class=o>+</span> <span class=nf>helper</span><span class=p>(</span><span class=nx>start</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>ls</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 尾递归
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>helper</span><span class=p>(</span><span class=nx>start</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>ls</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>acc</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>start</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>ls</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>acc</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>helper</span><span class=p>(</span><span class=nx>start</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=nx>ls</span><span class=p>,</span><span class=nx>acc</span><span class=o>+</span><span class=nx>ls</span><span class=p>[</span><span class=nx>start</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>说的更通俗一点就是，调用语句是函数最后一条语句，且返回值不会被用作其它计算。</p><p>尾递归的好处是避免递归调用期间栈空间的累积，因为每一层的返回不做处理直接返回，相当于不需要这一步直接返回元素调用。此时我们无需保存每一层递归的环境，这导致了从最高层级到结束条件我们始终重用一个栈空间。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_tail.png srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_tail.png?size=small, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_tail.png?size=medium 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_tail.png?size=large 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_tail.png data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200412_card_recursion_tail.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>尾递归当然也可以作为非尾递归函数来执行，此时不会重用栈空间，仍然会逐级累积，不过通常编译器会识别尾递归模式进行优化，但这需要编程语言的支持，C、C++支持尾递归优化，Java、Python，我当前使用的 Go 都不支持尾递归优化。</p><h2 id=5-原则>5. 原则</h2><p>递归的作用非常强大，但可能出现堆栈溢出，因此，可能的情况下，尽量使用记忆化技术节省调用次数，使用尾递归节省栈空间。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2020-07-05 00:00:00">更新于 2020-07-05&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/2020/algorithm-recursive/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Pocket" data-sharer=pocket data-url=https://shuzang.github.io/2020/algorithm-recursive/><i class="fa-brands fa-get-pocket fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://shuzang.github.io/2020/algorithm-recursive/ data-title=算法-递归><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/ class=post-tag>数据结构与算法</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2020/about-personalized-advertising/ class=post-nav-item rel=prev title=关于个性化广告><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>关于个性化广告</a>
<a href=/2020/algorithm-divide-and-conquer/ class=post-nav-item rel=next title=算法-分治>算法-分治<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/alipay.png data-title=" 支付宝" data-alt=" 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/wechatpay.png data-title=" 微信" data-alt=" 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">Hava a great day !</div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2025</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/shuzang/shuzang.github.io title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.6.1/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.2/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.2/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/fuse.js@6.6.2/dist/fuse.min.js defer></script><script src=https://unpkg.com/twemoji@14.0.2/dist/twemoji.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.6.1/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.2/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.2/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.2/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.2/dist/contrib/mhchem.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/js/theme.min.js defer></script></body></html>