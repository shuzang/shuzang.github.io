<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>计算机网络-TCP和UDP协议 - Shuzang's Blog</title><meta name=author content="Shuzang"><meta name=author-link content><meta name=description content="本篇介绍计算机网络运输层的的 TCP 和 UDP 协议，主要是过一遍，加深理解，以及方便以后查看，毕竟不是每次都带着书。"><meta name=keywords content="计算机基础"><meta itemprop=name content="计算机网络-TCP和UDP协议"><meta itemprop=description content="本篇介绍计算机网络运输层的的 TCP 和 UDP 协议，主要是过一遍，加深理解，以及方便以后查看，毕竟不是每次都带着书。"><meta itemprop=datePublished content="2018-08-07T21:16:00+08:00"><meta itemprop=dateModified content="2020-08-20T00:00:00+00:00"><meta itemprop=wordCount content="12144"><meta itemprop=image content="https://shuzang.github.io/logo.png"><meta itemprop=keywords content="计算机基础,"><meta property="og:title" content="计算机网络-TCP和UDP协议"><meta property="og:description" content="本篇介绍计算机网络运输层的的 TCP 和 UDP 协议，主要是过一遍，加深理解，以及方便以后查看，毕竟不是每次都带着书。"><meta property="og:type" content="article"><meta property="og:url" content="https://shuzang.github.io/2018/transmission-control-protocol-and-user-datagram-protocol/"><meta property="og:image" content="https://shuzang.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-07T21:16:00+08:00"><meta property="article:modified_time" content="2020-08-20T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shuzang.github.io/logo.png"><meta name=twitter:title content="计算机网络-TCP和UDP协议"><meta name=twitter:description content="本篇介绍计算机网络运输层的的 TCP 和 UDP 协议，主要是过一遍，加深理解，以及方便以后查看，毕竟不是每次都带着书。"><meta name=application-name content="Shuzang's Blog"><meta name=apple-mobile-web-app-title content="Shuzang's Blog"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://shuzang.github.io/2018/transmission-control-protocol-and-user-datagram-protocol/><link rel=prev href=https://shuzang.github.io/2018/data-link-layer/><link rel=next href=https://shuzang.github.io/2018/http-and-https/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"计算机网络-TCP和UDP协议","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/shuzang.github.io\/2018\/transmission-control-protocol-and-user-datagram-protocol\/"},"genre":"posts","keywords":"计算机基础","wordcount":12144,"url":"https:\/\/shuzang.github.io\/2018\/transmission-control-protocol-and-user-datagram-protocol\/","datePublished":"2018-08-07T21:16:00+08:00","dateModified":"2020-08-20T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Shuzang"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=/images/avatar.png srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes=auto data-title="Shuzang's Blog" data-alt="Shuzang's Blog" class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Shuzang's Blog"><img loading=lazy src=/images/avatar.png srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes=auto data-title=/images/avatar.png data-alt=/images/avatar.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Shuzang's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>计算机网络-TCP和UDP协议</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><img loading=lazy src=/images/avatar.png srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x" sizes=auto data-title=Shuzang data-alt=Shuzang class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;Shuzang</span></span>
<span class=post-category>收录于 <a href=/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 爱编程爱技术的孩子</a></span></div><div class=post-meta-line><span title="发布于 2018-08-07 21:16:00"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2018-08-07>2018-08-07</time></span>&nbsp;<span title="更新于 2020-08-20 00:00:00"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2020-08-20>2020-08-20</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 12144 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 25 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-运输层>1. 运输层</a></li><li><a href=#2-udp>2. UDP</a></li><li><a href=#3-tcp>3. TCP</a><ul><li><a href=#31-超时重传>3.1 超时重传</a></li><li><a href=#32-滑动窗口>3.2 滑动窗口</a></li><li><a href=#33-tcp-报文>3.3 TCP 报文</a></li><li><a href=#34-流量控制>3.4 流量控制</a></li><li><a href=#35-拥塞控制>3.5 拥塞控制</a><ul><li><a href=#慢开始>慢开始</a></li><li><a href=#拥塞避免>拥塞避免</a></li><li><a href=#快重传>快重传</a></li><li><a href=#快恢复>快恢复</a></li></ul></li><li><a href=#36-tcp连接>3.6 TCP连接</a><ul><li><a href=#连接建立>连接建立</a></li><li><a href=#连接释放>连接释放</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2020-08-20，文中内容可能已过时。</div></div></div><p>本篇介绍计算机网络运输层的的 TCP 和 UDP 协议，主要是过一遍，加深理解，以及方便以后查看，毕竟不是每次都带着书。</p><h2 id=1-运输层>1. 运输层</h2><p>五层体系结构中，运输层是从上往下的第二层，主要是 TCP 和 UDP 两个协议。</p><p>运输层的作用是为相互通信的应用进程提供逻辑通信，因此，运输层的端点是主机中的进程。而网络层为主机间提供通信，因此端点则是网络中的主机。数据在网络中传输时，路由器转发分组都只会用到下三层的功能，与运输层无关，因此，运输层仅在主机的协议栈中起作用。下面的图片比较清楚的说明了这一点</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_240.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_240.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_240.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_240.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_240.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_240.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>根据应用程序的不同需求，运输层有两种不同的协议，即<strong>用户数据报协议 UDP</strong>（User Datagram Protocol）和<strong>传输控制协议 TCP</strong>（Transmission Control Protocol）。这两种协议是我们在运输层需掌握的主要内容，它们在整体的协议栈中的位置如下所示</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_242.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_242.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_242.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_242.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_242.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_242.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>网络层的端点是主机，采用 IP 来标识，运输层的端点是应用进程，使用协议端口号（protocol port number）标识，通常简称为<strong>端口</strong>。不同的操作系统实现端口的方法可能是不同的，但其作用是相同的。传输层协议定义一个端口号为 16 位，仅在本地主机具有实际意义，目的是标识各应用进程与传输层交互的接口，因此不同的主机间相同的端口号没有关联。</p><p>16 位的端口号允许 65535 个不同的端口号。服务端使用的端口主要分为两类。一类叫做熟知端口或系统端口，数值为 0~1023，这些端口号被指派给了固定的某类应用，其它的应用不得使用。另一类叫做登记端口号，数值为 1024~49151，主要为没有熟知端口号的应用使用，但也有进行登记防止重复。常用的熟知端口号如下</p><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>SNMP</th><th>SNMP(trap)</th></tr></thead><tbody><tr><td>熟知端口号</td><td>21</td><td>23</td><td>25</td><td>53</td><td>69</td><td>80</td><td>161</td><td>162</td></tr></tbody></table><p>客户端使用的端口号数值为 49152~65535，仅在客户进程运行时才动态选择，存在周期较短，又叫做短暂端口号。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以将数据发送给客户进程，通信结束后，该客户端端口就被释放。</p><p>最后要注意的是，对所传输的数据单元，TCP叫做报文段，UDP叫做用户数据报。</p><h2 id=2-udp>2. UDP</h2><p>UDP 仅在 IP 的基础上增加了很少的功能，关于 UDP 的特点介绍如下</p><ol><li><p>UDP 是<strong>无连接</strong>的。无连接的含义是发送数据前不需要建立连接，发送结束后不需要释放连接；</p></li><li><p>UDP <strong>尽最大努力交付</strong>。尽最大努力的意思是不保证可靠；</p></li><li><p>UDP 是<strong>面向报文</strong>的。发送方的 UDP 对应用程序交下来的报文，添加首部后直接交付 IP 层，不做合并或拆分处理，一次发送一个报文，接收方的 UDP 对 IP 层交上来的报文，去除首部后直接交付应用进程，一次接受一个报文。简单的逻辑图如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_246.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_246.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_246.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_246.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_246.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_246.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p></li><li><p>UDP 支持一对一、一对多、多对一和多对多的交互通信；</p></li><li><p>UDP 首部只有 8 个字节，比 TCP 的20 个字节小的多；</p></li><li><p>UDP 没有拥塞控制，这意味着网络上的拥塞不会影响源主机的发送速率，这种特性使其适合于一些实时的应用，如 IP电话、实时视频会议等，这些应用允许一定的数据丢失，却不允许太大的时延。</p></li></ol><p>UDP 的数据报非常简单，除了 8 个字节的首部，剩下的全是数据部分，首部格式如下图所示</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_247.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_247.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_247.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_247.jpg 2x" sizes=auto data-title=UDP的首部和伪首部 data-alt=UDP的首部和伪首部 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>首部共分四个字段，每个字段两个字节，具体解释如下</p><ol><li><p>源端口：源端口号，需要对方回复时使用，不需要时置全 0；</p></li><li><p>目的端口：目的端口号，接收端交付报文必须的；</p></li><li><p>长度：这里的长度是 UDP 整个报文的长度，最小为 UDP 首部 8 个字节</p></li><li><p>校验和：UDP 校验和的计算包括整个 UDP 数据报，除此之外和 IP 首部校验和计算很相似。发送端首先将校验和字段置0，然后在 UDP 首部前加 12 个字节的伪首部，再按 16 位进行划分，最后一行不足16位补 0，写成一串竖式，进行求和计算，对和取反码，从而得到校验和。过程如下图所示</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_249.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_249.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_249.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_249.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_249.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_249.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>将得到的结果填入校验和字段，并发送出去，接收方收到报文后，添加 12 个字节的伪首部然后继续 16 位划分求和，结果取反码后应该为 1，否则就表明有差错，接收方就会丢弃该报文。</p></li></ol><p>最后要注意的是，UDP 在 IP 报文中的协议字段为 17.</p><h2 id=3-tcp>3. TCP</h2><p>TCP 协议要复杂很多，我们仍然先介绍其特点</p><ol><li><p>TCP 是<strong>面向连接</strong>的，使用前必须先建立连接，使用后释放连接；</p></li><li><p>TCP <strong>保证可靠</strong>，可靠的含义是通过 TCP 传输的数据无差错、不丢失、不重复、按序到达；</p></li><li><p>TCP 是<strong>面向字节流</strong>的，其含义是 TCP 将应用层交下来的数据看作一连串无结构的字节流，而不是看作一个整体，TCP 不知道所传输的字节流的含义，也不保证接收与交付的数据具有对应大小的关系，仅保证接收方收到的字节流和发送方发出的字节流完全一致，这里的完全一致指的是字节的顺序一致和每个字节的内容没有差错。当然，接收方的应用是一定有能力识别这一连串字节流的含义，这就是应用层的功能了。整个过程可以用下图简单的说明，虽然图中仅仅涉及几个字节，但实际上每个 TCP 报文涉及成百上千字节是很常见的。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_250.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_250.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_250.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_250.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_250.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_250.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p></li><li><p>TCP 仅支持一对一的通信，不同于 UDP，TCP 连接是点对点的；</p></li><li><p>TCP 提供全双工通信，通信双方的应用进程在任何时候都能发送数据。事实上，TCP 连接的两端都设有发送缓存和接收缓存，发送时应用将数据交给发送缓存后就不管了，由 TCP 在合适的时候将数据发出去，接收时把收到的数据放入缓存，上层的应用在合适的时候读取缓存中的数据。</p></li></ol><p>TCP 连接的端点叫做套接字（socket），其实就是 IP 地址和端口号的拼接，尽管 socket 在其它地方还有很多含义，但在这里就这么简单。</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>套接字 socket = (IP地址：端口号)</span></span></code></pre></td></tr></table></div></div><h3 id=31-超时重传>3.1 超时重传</h3><p>TCP 可靠传输主要靠下面几个机制保证</p><ol><li>确认应答和序列号</li><li>超时重传</li><li>校验和</li><li>流量控制</li><li>拥塞控制</li></ol><p>流量控制和拥塞控制需要理解 TCP 报文，放在后面介绍，校验和在 TCP报文中介绍，现在先介绍前两个机制。</p><p>首先，理想的情况下，也就是信道不出差错，接收的速度永远跟得上发送的速度，此时数据的发送和接收遵循简单的<strong>停等协议</strong>。由于全双工通信的双方既是发送方也是接收方，下面为了讨论方便，仅考虑 A 发送数据而 B 接收数据，而且将一个 TCP 报文包含的数据称为一个分组。</p><p>停等协议的过程如下所示，简单地讲，就是发送方发送分组，接收方接收后返回确认，发送方收到确认后再发送下一个分组，如此循环。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_255.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_255.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_255.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_255.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_255.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_255.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>但我们知道现实是不可能出现这种理想情况的，我们必须考虑数据可能出差错，可能丢失，可能不按序到达等许多情况。因此必须采取一定的措施避免这些情况的出现或出现时进行纠正。</p><p>首先是发送方<strong>发送的数据出现差错</strong>。差错可以通过校验和的计算检测出来，当检测的差错后，接收方只做一件事，就是丢弃该分组（不通知发送方分组出错），可靠传输的保证是，A 在发送数据后设置了一个超时计时器，如果计时器到期前收到了确认，就撤销该计时器，而此时由于 B 丢弃了分组且没有返回确认，计时器到期后 A 仍然无法收到确认，就会重传前面发送过的分组。这一过程在上图中同样有所说明。</p><p>超时重传机制的设定还会同时引入另外两个机制：</p><ol><li>A 发送完分组后，必须暂时保留已发送的分组的副本（为发生超市重传时使用），只有在收到确认后才能清除保留的副本；</li><li>发送的分组和返回的确认分组都必须进行编号，这样才能明确是哪个发送出去的分组收到了确认，哪个没有收到确认。而由于 TCP 是面向字节流的，编号实际上也是针对字节的，也就是说每个字节一个编号。</li></ol><p>因此我们可以看到，确认应答、序列号、超市重传实际上是协同工作的，一起来保证 TCP 连接的可靠。最后还要注意的一点是，超时计时器的重传时间应当稍微比分组传输的平均往返时间多一点点，从而确保正常网络情况下足已收到确认。</p><p>其次是发送方<strong>发送的分组丢失</strong>，丢失的后果是 B 收不到任何数据，同样也不会发送确认，之后触发的超时重传就和出现差错完全相同了。</p><p>再然后是<strong>确认丢失</strong>，确认丢失指的是 B 所发送的对分组 $M_1$ 的确认丢失了，此时 A 无法收到确认，依然会触发超时重传，但接下来我们就会注意到 B 再次收到了同样的分组，面对同样的分组 B 所作的事情是：丢弃整个重复的分组，然后向 A 发送确认，丢弃是因为分组已经在缓冲区存在，重新发送确认是因为先前的确认 A 没有收到。整个过程如下图所示</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_258.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_258.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_258.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_258.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_258.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_258.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>最后一种情况是确认重复。我们考虑一种可能，那就是 B 对分组 $M_1$ 的确认并不是丢失了，而是由于种种原因迟到了，当 A 收到该确认的时候，已经触发了超时重传重新发送了分组，此时 B 所作的事没有区别，依然是丢弃分组然后回复确认，A 所做的事情则是对收到的第二个确认分组进行丢弃。如上图 (b) 所示。</p><p>这些机制保证了 A 总能收到对所有发出的分组的确认，如果 A 不断重传而一直收不到确认，那么只能说明一件事，那就是信道质量太差。添加了这一系列机制的协议就叫做 <strong>自动重传请求 ARQ</strong>（Automatic Repeat reQuest）。</p><h3 id=32-滑动窗口>3.2 滑动窗口</h3><p>无论是停等还是 ARQ，信道的利用率都比较低，主要是因为只有在收到上一个分组的确认后才会发送下一个分组，优化的办法就是使用流水线传输，即发送方连续发送多个分组，不必等待上一个分组的确认，从而使信道上一直有数据在传送。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_259.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_259.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_259.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_259.jpg 2x" sizes=auto data-title=停等的时间利用 data-alt=停等的时间利用 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_261.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_261.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_261.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_261.jpg 2x" sizes=auto data-title=流水线传输 data-alt=流水线传输 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>当使用流水线传输时，就需要连续 ARQ 协议和滑动窗口协议。这里先介绍连续 ARQ 协议，滑动窗口之后介绍。</p><p>如下图所示，发送方维持一个发送窗口，其含义是位于发送窗口内的5个字节可以连续的发出去，不必等待对方的确认。一般我们在讨论时，默认理解为下面图中箭头所示的时间流动方向，向前就指向着时间增大的方向，向后就是向着时间减少的方向。字节的发送是按照序号从小到大的方向。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_262.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_262.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_262.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_262.jpg 2x" sizes=auto data-title=连续ARQ协议的工作原理 data-alt=连续ARQ协议的工作原理 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>连续 ARQ 协议规定，发送方每收到一个确认，发送窗口就向前移动一格，上图中发送方收到了对第1个字节的确认，因此发送窗口向前移动了1个字节，现在可以发送第6个字节了。另外，由于发送和接收都是面向字节流的，一次发送接收很可能涉及很多字节，所以接收方一般采用<strong>累积确认</strong>的方式，也就是说，接收方不必对收到的每个字节都发送确认，而是只对按序到达的最后一个字节发送确认，这一动作就表示到该字节为止前面所有的字节都正确收到了。</p><p>累积确认尽管提高了传输效率，减少了网络中的数据，但可能会造成回退 N 问题（Go-back-N）。该问题描述如下，加入发送方发送了 5 个字节，第 3 个字节丢失了，此时接收方只能对前两个字节发送确认，发送方无法知道后面 3 个字节的下落，此时尽管第 4 和第 5 个字节接收方都已经收到了，发送方还是需要对第 3 个字节开始的数据都重传一次，回退 N 的含义就是退回来重传已发送过的 N 个数据。所以在信道质量不好时，连续 ARQ 具有较大的副作用。</p><h3 id=33-tcp-报文>3.3 TCP 报文</h3><p>TCP 是面向字节流的，但意思仅限于逐字节编号，交付网络层的实际上是报文段。TCP 报文段首部有 20 个字节是固定的，后面还可以添加 40 个字节，首部最大 60 字节，再往后就是 TCP 的数据部分。TCP 报文格式如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_263.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_263.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_263.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_263.jpg 2x" sizes=auto data-title=TCP报文段首部格式 data-alt=TCP报文段首部格式 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><ul><li><p><strong>源端口</strong>和<strong>目的端口</strong>：含义同 UDP</p></li><li><p><strong>序号</strong>：所传输的数据的第一个字节的编号，也就是本报文段数据部分的第一个字节，序号一共四个字节，意味着可编号范围为 $[0, 2^{32}-1]$</p></li><li><p><strong>确认号</strong>：期望收到的对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发过来的报文段，序号字段值为 501，数据部分共 200字节，所以 B 收到的最后一个字节序号为 700，那么 B 期望收到的 A 的下一个报文段的第一个字节序号就是 701，所以在确认报文中将 确认号字段置为 701。</p><p>总之，要明白：若 确认号 = N，就说明到序号 N-1 为止的所有数据都正确收到了。</p></li><li><p><strong>数据偏移</strong>：占4位，指 TCP 报文段数据部分距离报文段起始处有多远，简单来说就是 TCP 首部长度。单位是 4 字节，因此最大值为 15 * 4 = 60 字节，这就是 TCP 首部最大长度。</p></li><li><p><strong>保留</strong>：共6位，当前没有使用，全部置0。</p></li><li><p><strong>控制位</strong>：共6位，每位的作用不一样，如下</p><ul><li><strong>紧急URG</strong> (URGent) ：当URG = 1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（Control + C）。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了许多时间。当URG置1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针(UrgentPointer)字段配合使用。</li><li><strong>确认ACK</strong> (ACKnowlegment) ：仅当ACK = 1时确认号字段才有效。当ACK = 0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li><li><strong>推送 PSH</strong> (PuSH)：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送(push)操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH = 1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付</li><li><strong>复位RST</strong> (ReSeT)：当RST = 1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。</li><li><strong>同步SYN</strong> (SYNchronization)： 在连接建立时用来同步序号。当SYN = 1而ACK = 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN = 1和ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。关于连接的建立和释放，在本章的5.9节还要进行详细讨论。</li><li><strong>终止FIN</strong> (FINis，意思是“完”、“终”) ：用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li></ul></li><li><p><strong>窗口</strong>：16位，指的是发送本报文段的一方的接收窗口，目的是告诉对方自己还能收多少数据。例如，设确认号是701，窗口字段是1000。这就表明，从701号算起，发送此报文段的一方还有接收1000个字节数据（字节序号是701～1700）的接收缓存空间。</p></li><li><p><strong>校验和</strong>：TCP 校验和的计算方式和 UDP 相同。</p></li><li><p><strong>紧急指针</strong>：占2字节。紧急指针仅在URG = 1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。</p></li><li><p><strong>选项</strong>：长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节。</p></li></ul><h3 id=34-流量控制>3.4 流量控制</h3><p>流量控制主要依靠滑动窗口，为了方便说明，假定数据传输只在一个方向进行，即 A 发送数据，B 给出确认。</p><p>首先，假定 A 收到了 B 发来的确认报文段，其中窗口是20（字节），确认号是31（即期望收到的B发送的下一个序号是31），根据这两个值，A 构造自己的发送窗口如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_266.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_266.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_266.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_266.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_266.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_266.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>此时 A 可以将序号 31 起连续 20 个字节都发送出去，但在未收到确认前都必须保留，以便超时重传使用。因此，发送窗口中的数据表示允许发送的数据，后沿后面的数据表示已收到确认的数据，前沿前面的数据表示不允许发送的数据。如果没有收到新的确认，后沿不可移动，收到新的确认后，后沿向前移动，而如果收到的确认中对方通知的窗口缩小了，使得发送窗口前沿正好不动，那么前沿也不动，否则前沿根据通知的窗口大小向前移动。当然，前沿也可以向后收缩，但 TCP 强烈不赞成这么做。</p><p>TCP 的流量控制指的是通过窗口和确认号来调整发送速率，让发送方的发送不要太快，从而使接收方来得及接收。</p><p>除此之外，流量控制还包括两个问题。</p><p>第一个问题是由于发送方应用层交付过慢造成的，假如发送方应用层每次交付1个字节，那么就需要加上 20 个字节的 TCP 首部，再加上 20 字节的 IP 首部，然后发送出去，每次为了1字节的数据，要多发送远大于数据部分的 40 个字节，效率非常低。应对这种情况主要使用 Nagle 算法，算法如下：若发送方应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来，当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组成一个报文发送出去，同时继续对随后到达的数据进行缓存，只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用地网络带宽。Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。</p><p>另一个问题叫做糊涂窗口综合症（silly window syndrome），是由于接收方接收过慢造成的。设想一种情况：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节（这样就使接收缓存空间仅腾出1个字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报是40字节长）。接着，发送方又发来1个字节的数据（请注意，发送方发送的IP数据报是41字节长）。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><p>TCP 的流量控制主要指的就是滑动窗口的控制和这两个问题。</p><h3 id=35-拥塞控制>3.5 拥塞控制</h3><p>流量控制往往指点对点通信量的控制，要做的是抑制发送端发送数据的速率，以便接收端来得及接收。拥塞控制要做的则是防止过量的数据注入网络，它与流量控制的相似之处在于，某些拥塞控制算法是通过向发送端发送控制报文，令其放慢发送速率完成的，手段与流量控制相似。TCP 的拥塞控制主要是指通过某种手段判断网络是否出现拥塞，然后对发送速率进行调整。</p><p>当前进行拥塞控制主要是四种算法：<strong>慢开始</strong>（slow-start）、<strong>拥塞避免</strong>（congestion avoidance）、<strong>快重传</strong>（fast retransmit）和<strong>快恢复</strong>（fast recovery）。</p><p>这四种算法都与一个<strong>拥塞窗口</strong> cwnd（congestion window）的状态变量有关，拥塞窗口由发送方维持，其大小取决于网络的拥塞程度，并且在动态地变化，发送方会让自己的发送窗口等于拥塞窗口大小。只要发送方没有按时收到应当到达的确认报文，就猜测网络可能出现了拥塞，此时就将拥塞窗口减小，从而减少发送到网络中的数据，如果按时收到确认，就证明网络没有出现拥塞，拥塞窗口就再增大一些。四种拥塞控制算法实际上就是在控制拥塞窗口的变化。</p><h4 id=慢开始>慢开始</h4><p>慢开始的思路是这样的，当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因此先将拥塞窗口设置为一个最大报文段的数值，每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值，这样从小到大逐步增加拥塞窗口大小，从而使数据注入到网络的速率更加合理。</p><p>举个例子，假设在一开始发送方先设置cwnd = 1，发送第一个报文段M1，接收方收到后确认M1。发送方收到对M1的确认后，把cwnd从1增大到2，于是发送方接着发送M2和M3两个报文段。接收方收到后发回对M2和M3的确认。发送方每收到一个对新报文段的确认（重传的不算在内）就使发送方的拥塞窗口加1，因此发送方在收到两个确认后，cwnd就从2增大到4，并可发送M4～M7共4个报文段（见图5-24）。因此使用慢开始算法后，每经过一个传输轮次(transmission round)，拥塞窗口cwnd就加倍。这里的传输轮次指的是一次往返时间。简单的图示如下</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_281.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_281.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_281.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_281.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_281.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_281.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd = 1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要“慢得多”。这对防止网络出现拥塞是一个非常有力的措施。</p><h4 id=拥塞避免>拥塞避免</h4><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh状态变量。慢开始门限ssthresh的用法如下：</p><ul><li>当cwnd &lt; ssthresh时，使用上述的慢开始算法。</li><li>当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul><p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样，拥塞窗口cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><h4 id=快重传>快重传</h4><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。</p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。在下图所示的例子中，接收方收到了M1和M2后都分别发出了确认。现假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段（按照顺序的M3还没有收到）。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对 M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送M5和M6。接收方收到后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待为M3设置的重传计时器到期。由于发送方能尽早重传未被确认的报文段。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_285.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_285.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_285.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_285.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_285.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_285.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h4 id=快恢复>快恢复</h4><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ol><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重的拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ol><h3 id=36-tcp连接>3.6 TCP连接</h3><p>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，而被动等待连接建立的应用进程叫做服务器(server)。</p><h4 id=连接建立>连接建立</h4><p>TCP 连接建立的过程如下图所示，假定主机 A 运行的是 TCP 客户程序，而 B 运行 TCP 服务器程序。最初两端的TCP 进程都处于 CLOSED（关闭）状态。图中在主机下面的方框分别是 TCP 进程所处的状态。请注意，A 主动打开连接，而 B 被动打开连接。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_294.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_294.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_294.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/epub_655484_294.jpg 2x" sizes=auto data-title=三次握手建立连接 data-alt=三次握手建立连接 style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>B 被动打开连接的意思不是在连接建立前 B 不做任何事，相反，B 的 TCP 服务器进程需要先创建传输控制块 TCB，准备接受客户进程的连接请求。然后使服务器进程处于 LISTEN（收听）状态，等待客户的连接请求。</p><p>A 的 TCP 客户进程也是首先创建传输控制模块 TCB，然后在需要建立连接时向 B 发出连接请求报文段，这是建立连接的第一条报文，这时首部中的同步位 SYN = 1，同时选择一个初始序号 seq= x。TCP规定，SYN 报文段（即SYN = 1的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p><p>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入 SYN-RCVD（同步收到）状态。</p><p>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置1，确认号 ack = y + 1，而自己的序号seq = x + 1。TCP 的标准规定，这一个报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p><p>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。</p><p>整个连接建立的过程涉及三个报文的发送接收，因此叫做三次握手(three-way handshake)。</p><p>面试时经常问的，也是比较关键的一个问题是第三次确认报文的作用，这里明确：<strong>A 发送第三次确认的原因是防止已失效的连接请求报文段突然又传送到了 B，从而产生错误。</strong></p><p>所谓“已失效的连接请求报文段”是这样产生的。假设 A 发出一个连接请求，但因连接请求报文丢失而未收到确认。于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。如果 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用三次握手，那么只要 B 发出确认，新的连接就建立了。</p><p>此时由于 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。第三次的确认报文可以防止上述现象的发生。例如在刚才的情况下，A 不会向 B 的确认发出确认。B 由于收不到确认，就知道 A 并没有要求建立连接。</p><h4 id=连接释放>连接释放</h4><p>数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置1，其序号 seq = u，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意，TCP规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。</p><p><img loading=lazy src=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_297.jpg srcset="https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_297.jpg, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_297.jpg 1.5x, https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_297.jpg 2x" sizes=auto data-title=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_297.jpg data-alt=https://picped-1301226557.cos.ap-beijing.myqcloud.com/BC_20200707_epub_655484_297.jpg style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>B 收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加1。然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭(half-close)状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一些时间。</p><p>A 收到来自 B 的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待 B 发出的连接释放报文段。</p><p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 w（在半关闭状态B可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK（最后确认）状态，等待 A 的确认。</p><p>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack = w + 1，而自己的序号是 seq = u + 1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。然后进入到 TIME-WAIT（时间等待）状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做最长报文段寿命(Maximum Segment Lifetime)，RFC 793建议设为2分钟。但这完全是从工程上来考虑，对于现在的网络，MSL = 2分钟可能太长了一些。因此 TCP 允许不同的实现可根据具体情况使用更小的 MSL 值。因此，从 A 进入到 TIME-WAIT 状态后，要经过4分钟才能进入到 CLOSED 状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接</p><p>为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间呢？这有两个理由。</p><p>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK状态的 B 收不到对已发送的 FIN+ ACK 报文段的确认。B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 CLOSED 状态。</p><p>第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p><p>B 只要收到了 A 发出的确认，就进入 CLOSED 状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的TCP 连接。我们注意到，B 结束 TCP 连接的时间要比 A 早一些。</p><p>上述的 TCP 连接释放过程叫做四次握手。</p><p>除时间等待计时器外，TCP还设有一个保活计时器(keepalive timer)。设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75分钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2020-08-20 00:00:00">更新于 2020-08-20&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/2018/transmission-control-protocol-and-user-datagram-protocol/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Pocket" data-sharer=pocket data-url=https://shuzang.github.io/2018/transmission-control-protocol-and-user-datagram-protocol/><i class="fa-brands fa-get-pocket fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://shuzang.github.io/2018/transmission-control-protocol-and-user-datagram-protocol/ data-title=计算机网络-TCP和UDP协议><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/ class=post-tag>计算机基础</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/2018/data-link-layer/ class=post-nav-item rel=prev title=计算机网络-数据链路层><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>计算机网络-数据链路层</a>
<a href=/2018/http-and-https/ class=post-nav-item rel=next title=计算机网络-HTTP与HTTPS协议>计算机网络-HTTP与HTTPS协议<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-reward><div class=comment></div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward>赞赏</label><div class=reward-ways data-mode=static><div><img loading=lazy src=/images/alipay.png srcset="/images/alipay.png, /images/alipay.png 1.5x, /images/alipay.png 2x" sizes=auto data-title="Shuzang 支付宝" data-alt="Shuzang 支付宝" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>支付宝</span></div><div><img loading=lazy src=/images/wechatpay.png srcset="/images/wechatpay.png, /images/wechatpay.png 1.5x, /images/wechatpay.png 2x" sizes=auto data-title="Shuzang 微信" data-alt="Shuzang 微信" style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span>微信</span></div></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.117.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.2.18"><img class=fixit-icon src=/fixit.min.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/>Shuzang</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><a href=https://github.com/shuzang/shuzang.github.io title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/pace/themes/blue/pace-theme-minimal.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/twemoji/twemoji.min.js defer></script><script src=/lib/lightgallery/lightgallery.min.js defer></script><script src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/js/theme.min.js defer></script></body></html>